<?xml version="1.0" standalone="no"?>
<!DOCTYPE chapter SYSTEM "minidocbook.dtd">

<!--
  $Id$
-->

<chapter id="intro-to-tdf">
	<title>Introduction to &tdf;</title>

	<para>Having discussed many of the problems involved
		with writing portable programs, we now eventually turn to &tdf;.
		Firstly a brief technical overview is given, indicating those
		features of &tdf; which facilitate the separation of program
		from &api;.
		Secondly the &tdf; compilation scheme is described. It is shown how
		the features of &tdf; are exploited to aid in the separation of
		target independent and target dependent code which we have
		indicated as characterising portable programs. Finally, the
		various constituents of this scheme are considered individually,
		and their particular roles are described in more detail.</para>

	<section id="S23">
		<title>Features of &tdf;</title>

		<para>It is not the purpose of this paper
			to explain the exact specification of &tdf; - this is described
			elsewhere (see [6] and [4]) - but rather to show how its general
			design features make it suitable as an aid to writing portable
			programs.</para>

		<para>&tdf; is an abstraction of high-level languages - it contains
			such things as <code>exps</code> (abstractions of expressions and
			statements), <code>shapes</code> (abstractions of types) and
			<code>tags</code> (abstractions of variable identifiers). In
			general form it is an abstract syntax tree which is flattened and
			encoded as a series of bits, called a <code>capsule</code>. This
			fairly high level of definition (for a compiler intermediate
			language) means that &tdf; is architecture neutral in the sense
			that it makes no assumptions about the underlying processor
			architecture.</para>

		<para>The translation of a capsule to and from the corresponding
			syntax tree is totally unambiguous, also &tdf; has a "universal"
			semantic interpretation as defined in the &tdf; specification.</para>

		<section>
			<title>Capsule Structure</title>

			<para>A &tdf;
				capsule consists of a number of units of various types. These are
				embedded in a general linkage scheme <xref linkend="tdf_link"/>.
				Each unit contains a number of variable objects of various sorts (for
				example, tags and tokens) which are potentially visible to other
				units. Within the unit body each variable object is identified by
				a unique number. The linking is via a set of variable objects
				which are global to the entire capsule. These may in turn be
				associated with external names. For example, in
				<xref linkend="tdf_link"/>, the
				fourth variable of the first unit is identified with the first
				variable of the third unit, and both are associated with the
				fourth external name (indicated).</para>

			<figure id="tdf_link">
				<title>&tdf; Capsule Structure</title>
				<graphic fileref="images/tdf_link.svg"/>
			</figure>

			<para>This capsule structure means that the combination of a number of
				capsules to form a single capsule is a very natural operation.
				The actual units are copied unchanged into the resultant capsule
				- it is only the surrounding linking information that needs
				changing. Many criteria could be used to determine how this
				linking is to be organised, but the simplest is to link two
				objects if and only if they have the same external name. This is
				the scheme that the current &tdf; linker has implemented.
				Furthermore such operations as changing an external name or
				removing it altogether ("hiding") are very simple under this
				linking scheme.</para>
		</section>

		<section id="S25">
			<title>Tokens</title>

			<para>So, the combination of program at this high level is straightforward. But
				&tdf; also provides another mechanism which allows for the
				combination of program at the syntax tree level, namely
				<code>tokens</code>. Virtually any node of the &tdf; tree may be a
				token: a place holder which stands for a subtree. Before the &tdf;
				can be decoded fully the definition of this token must be
				provided. The token definition is then macro substituted for the
				token in the decoding process to form the complete tree (see
				<xref linkend="token"/>).</para>

			<figure id="token">
				<title>&tdf; Tokens</title>
				<graphic fileref="images/token.svg"/>
			</figure>

			<para>Tokens may also take arguments (see <xref linkend="token_args"/>).
				The actual argument values (from the main tree) are substituted
				for the formal parameters in the token definition.</para>

			<figure id="token_args">
				<title>&tdf; Tokens (with arguments)</title>
				<graphic fileref="images/token_args.svg"/>
			</figure>

			<para>As mentioned above, tokens are one of the types of variable
				objects which are potentially visible to external units. This
				means that a token does not have to be defined in the same unit
				as it is used in. Nor do these units have originally to have come
				from the same capsule, provided they have been linked before they
				need to be fully decoded. Tokens therefore provide a mechanism
				for the low-level separation and combination of code.</para>
		</section>
	</section>

	<section id="S26">
		<title>&tdf; Compilation Phases</title>

		<para>We have seen how one of the
			great strengths of &tdf; is the fact that it facilitates the
			separation and combination of program. We now demonstrate how
			this is applied in the &tdf; compilation strategy. This section is
			designed only to give an outline of this scheme. The various
			constituent phases are discussed in more detail later.</para>

		<para>Again we start with the simplest case, where the program
			contains no target dependent code. The strategy is illustrated in
			<xref linkend="tdf_scheme"/>, which should be compared with the
			traditional compilation
			strategy shown in <xref linkend="trad_scheme"/>. The general layout of
			the diagrams is
			the same. The left halves of the diagrams refers to the program
			itself, and the right halves to the corresponding &api;. The top
			halves refer to machine independent material, and the bottom
			halves to what happens on each target machine. Thus, as before,
			the portable program appears in the top left of the diagram, and
			the corresponding &api; in the top right.</para>

		<para>The first thing to note is that, whereas previously all the
			compilation took place on the target machines, here the
			compilation has been split into a target independent (C to &tdf;)
			part, called <code>production</code>, and a target dependent
			(&tdf; to target) part, called <code>installation</code> . One
			of the synonyms for &tdf; is &andf;, Architecture Neutral
			Distribution Format, and we require that the production is
			precisely that - architecture neutral - so that precisely the
			same &tdf; is installed on all the target machines.</para>

		<para>This architecture neutrality necessitates a separation of
			code. For example, in the "Hello world" example discussed in
			sections 2.1.1 and 2.1.2, the &api; specifies that there shall be a
			type <code>FILE</code> and an object <code>stdout</code> of type
			<code>FILE *</code>, but the implementations of these may be
			different on all the target machines. Thus we need to be able to
			abstract out the code for <code>FILE</code> and
			<code>stdout</code> from the &tdf; output by the producer, and
			provide the appropriate (target dependent) definitions for these
			objects in the installation phase.</para>

		<figure id="tdf_scheme">
			<title>&tdf; Compilation Phases</title>
			<graphic fileref="images/tdf_scheme.svg"/>
		</figure>

		<section id="S27">
			<title>&api; Description (Top Right)</title>

			<para>The method used for this separation is the token
				mechanism. Firstly the syntactic element of the &api; is described
				in the form of a set of target independent headers. Whereas the
				target dependent, system headers contain the actual
				implementation of the &api; on a particular machine, the target
				independent headers express to the producer what is actually in
				the &api;, and which may therefore be assumed to be common to all
				compliant target machines. For example, in the target independent
				headers for the &ansi; standard, there will be a file
				<code>stdio.h</code> containing the lines:</para>

			<programlisting language="c">#pragma token TYPE FILE # ansi.stdio.FILE
#pragma token EXP rvalue : FILE * : stdout # ansi.stdio.stdout
#pragma token FUNC int ( const char *, FILE * ) : fputs # ansi.stdio.fputs</programlisting>

			<para>These <code>#pragma token</code> directives are extensions to
				the C syntax which enable the expression of abstract syntax
				information to the producer. The directives above tell the producer
				that there exists a type called <code>FILE</code>, an expression
				<code>stdout</code> which is an rvalue (that is, a non-assignable
				value) of type <code>FILE *</code>, and a procedure
				<code>fputs</code> with prototype:</para>

			<programlisting language="c">int fputs ( const char *, FILE * ) ;</programlisting>

			<para>and that it should leave their values unresolved by means of
				tokens (for more details on the <code>#pragma token</code>
				directive see [3]). Note how the information in the target
				independent header precisely reflects the syntactic information in
				the &ansi; &api;.</para>

			<para>The names <code>ansi.stdio.FILE</code> etc. give the external
				names for these tokens, those which will be visible at the
				outermost layer of the capsule; they are intended to be unique
				(this is discussed below). It is worth making the distinction
				between the internal names and these external token names. The
				former are the names used to represent the objects within C, and
				the latter the names used within &tdf; to represent the tokens
				corresponding to these objects.</para>

			<para>See the &orientation.doc; for details of how the
				target-independent &api; headers and the corresponding
				&tdf; libraries are generated.</para>
		</section>

		<section id="S28">
			<title>Production (Top Left)</title>

			<para>Now the producer can compile the program using
				these target independent headers. As will be seen from the "Hello
				world" example, these headers contain sufficient information to
				check that the program is syntactically correct. The produced,
				target independent, &tdf; will contain tokens corresponding to the
				various uses of <code>stdout</code>, <code>fputs</code> and so
				on, but these tokens will be left undefined. In fact there will
				be other undefined tokens in the &tdf;. The basic C types,
				<code>int</code> and <code>char</code> are used in the program,
				and their implementations may vary between target machines. Thus
				these types must also be represented by tokens. However these
				tokens are implicit in the producer rather than explicit in the
				target independent headers.</para>

			<para>Note also that because the information in the target
				independent headers describes abstractly the contents of the &api;
				and not some particular implementation of it, the producer is in
				effect checking the program against the &api; itself.</para>
		</section>

		<section id="S29">
			<title>&api; Implementation (Bottom Right)</title>

			<para>Before the &tdf; output by the producer can be
				decoded fully it needs to have had the definitions of the tokens
				it has left undefined provided. These definitions will be
				potentially different on all target machines and reflect the
				implementation of the &api; on that machine.</para>

			<para>The syntactic details of the implementation are to be found in
				the system headers. The process of defining the tokens describing
				the &api; (called &tdf; library building) consists of comparing the
				implementation of the &api; as given in the system headers with the
				abstract description of the tokens comprising the &api; given in
				the target independent headers. The token definitions thus
				produced are stored as &tdf; libraries, which are just archives of
				&tdf; capsules.</para>

			<para>For example, in the example implementation of
				<code>stdio.h</code> given in section 2.1.2, the token
				<code>ansi.stdio.FILE</code> will be defined as the &tdf; compound
				shape corresponding to the structure defining the type
				<code>FILE</code> (recall the distinction between internal and
				external names). <code>__iob</code> will be an undefined tag
				whose shape is an array of 60 copies of the shape given by the
				token <code>ansi.stdio.FILE</code>, and the token
				<code>ansi.stdio.stdout</code> will be defined to be the &tdf;
				expression corresponding to a pointer to the second element of
				this array. Finally the token <code>ansi.stdio.fputs</code> is
				defined to be the effect of applying the procedure given by the
				undefined tag <code>fputs</code>. (In fact, this picture has been
				slightly simplified for the sake of clarity. See the section on
				C to &tdf; mappings in section 3.3.2.)</para>

			<para>These token definitions are created using exactly the same
				C to &tdf; translation program as is used in the producer phase.
				This program knows nothing about the distinction between target
				independent and target dependent &tdf;, it merely translates the C
				it is given (whether from a program or a system header) into &tdf;.
				It is the compilation process itself which enables the separation
				of target independent and target dependent &tdf;.</para>

			<para>In addition to the tokens made explicit in the &api;, the
				implicit tokens built into the producer must also have their
				definitions inserted into the &tdf; libraries. The method of
				definition of these tokens is slightly different. The definitions
				are automatically deduced by, for example, looking in the target
				machine's <code>limits.h</code> header to find the local values
				of <code>CHAR_MIN</code> and <code>CHAR_MAX</code> , and deducing
				the definition of the token corresponding to the C type
				<code>char</code> from this. It will be the <code>variety</code>
				(the &tdf; abstraction of integer types) consisting of all integers
				between these values.
				These tokens comprise a producer-specific
				&ldquo;Language Programing Interface&rdquo;,
				and are implemented as &lpi; &tdf; libraries (not illustrated)
				which are linked in alongside the &api; &tdf; libraries.</para>

			<para>Note that what we are doing in the main library build is
				checking the actual implementation of the &api; against the
				abstract syntactic description. Any variations of the syntactic
				aspects of the implementation from the &api; will therefore show
				up. Thus library building is an effective way of checking the
				syntactic conformance of a system to an &api;. Checking the
				semantic conformance is far more difficult - we shall return to
				this issue later.</para>
		</section>

		<section id="S30">
			<title>Installation (Bottom Left)</title>

			<para>The installation phase is now straightforward. The
				target independent &tdf; representing the program contains various
				undefined tokens (corresponding to objects in the &api;), and the
				definitions for these tokens on the particular target machine
				(reflecting the &api; implementation) are to be found in the local
				&tdf; libraries. It is a natural matter to link these to form a
				complete, target dependent, &tdf; capsule. The rest of the
				installation consists of a straightforward translation phase (&tdf;
				to target) to produce a binary object file, and linking with
				the system libraries to form a final executable. Linking with the
				system libraries will resolve any tags left undefined in the &tdf;.</para>
		</section>

		<section id="S31">
			<title>Illustrated Example</title>

			<para>In order to help clarify exactly what is happening where,
				<xref linkend="eg_scheme"/>
				shows a simple example superimposed on the &tdf; compilation
				diagram.
				Selected relevant contents of TDF capsules are notated using
				<code>tnc -p</code> syntax.
				Specifics of the <code>libc</code> implementation are omitted
				for brevity and are indicated by an ellipsis.</para>

			<figure id="eg_scheme">
				<title>Example Compilation</title>
				<graphic fileref="images/eg_scheme.svg"/>
			</figure>

			<para>The program to be translated is simply:</para>

			<programlisting language="c">#include &lt;stdio.h&gt;
FILE f ;</programlisting>

			<para>and the &api; is as above, so that <code>FILE</code> is an
				abstract type. This &api; is described as target independent headers
				containing the <code>#pragma token</code> statements given above.
				The producer combines the program with the target independent
				headers to produce a target independent capsule which defines a
				tag <code>f</code> whose shape is given by the token representing
				<code>FILE</code>, but leaves this token undefined. In the &api;
				implementation, the local definition of the type <code>FILE</code>
				from the system headers is translated into the definition of this
				token by the library building process. Finally in the installation,
				the target independent capsule is combined with the local token
				definition library to form a target dependent capsule in which all
				the tokens used are also defined. This is then installed further as
				described above.</para>
		</section>
	</section>

	<section id="S32">
		<title>Aspects of the &tdf; System</title>

		<para>Let us now consider in
			more detail some of the components of the &tdf; system and how they
			fit into the compilation scheme.</para>

		<section id="S33">
			<title>The C to &tdf; Producer</title>

			<para>Above it was emphasised how the design of the
				compilation strategy aids the representation of program in a
				target independent manner, but this is not enough in itself. The
				C to &tdf; producer must represent everything symbolically; it
				cannot make assumptions about the target machine. For example,
				the line of C containing the initialisation:</para>

			<programlisting language="c">int a = 1 + 1 ;</programlisting>

			<para>is translated into &tdf; representing precisely that, 1 + 1,
				not 2, because it does not know the representation of
				<code>int</code> on the target machine. The installer does know
				this, and so is able to replace 1 + 1 by 2 (provided this is
				actually true).</para>

			<para>As another example, in the structure:</para>

			<programlisting language="c">struct tag {
	int a ;
	double b ;
} ;</programlisting>

			<para>the producer does not know the actual value in bits of the
				offset of the second field from the start of the structure - it
				depends on the sizes of <code>int</code> and <code>double</code>
				and the alignment rules on the target machine. Instead it
				represents it symbolically (it is the size of <code>int</code>
				rounded up to a multiple of the alignment of <code>double</code>).
				This level of abstraction makes the tokenisation required by the
				target independent &api; headers is very natural. If we only knew that
				there existed a structure <code>struct tag</code> with a field
				<code>b</code> of type <code>double</code> then it is perfectly
				simple to use a token to represent the (unknown) offset of this
				field from the start of the structure rather than using the
				calculated (known) value. Similarly, when it comes to defining this
				token in the library building phase (recall that this is done by
				the same C to &tdf; translation program as the production) it is a
				simple matter to define the token to be the calculated value.</para>

			<para>Furthermore, because all the producer's operations are
				performed at this very abstract level, it is a simple matter to
				put in extra portability checks. For example, it would be a
				relatively simple task to put most of the functionality of
				<code>lint</code> (excluding intermodular checking) or
				<code>gcc</code>'s <option>-Wall</option> option into the producer, and
				moreover have these checks applied to an abstract machine rather
				than a particular target machine. Indeed a number of these checks
				have already been implemented.</para>

			<para>These extra checks are switched on and off by using
				<code>#pragma</code> statements. (For more details on the
				<code>#pragma</code> syntax and which portability checks are
				currently supported by the producer see [3].) For example, &ansi; C
				states that any undeclared function is assumed to return
				<code>int</code>, whereas for strict portability checking it is
				more useful to have undeclared functions marked as an error
				(indeed for strict &api; checking this is essential). This is done
				by inserting the line:</para>

			<programlisting language="c">#pragma no implicit definitions</programlisting>

			<para>either at the start of each file to be checked or, more
				simply, in a start-up file - a file which can be
				<code>#include</code>'d at the start of each source file by means
				of a command line option.</para>

			<para>Because these checks can be turned off as well as on it is
				possible to relax as well as strengthen portability checking.
				Thus if a program is only intended to work on 32-bit machines, it
				is possible to switch off certain portability checks. The whole
				ethos underlying the producer is that these portability
				assumptions should be made explicit, so that the appropriate
				level of checking can be done.</para>

			<para>As has been previously mentioned, the use of a single
				front-end to any compiler not only virtually eliminates the
				problems of differing code interpretation and compiler quirks,
				but also reduces the exposure to compiler bugs. Of course, this
				also applies to the &tdf; compiler, which has a single front-end
				(the producer) and multiple back-ends (the installers). As
				regards the syntax and semantics of the C language, the producer
				is by default a strictly &ansi; C compliant compiler. (Addition to
				the October 1993 revision : Alas, this is no longer true; however
				strict &ansi; can be specified by means of a simple command line
				option (see [1]). The decision whether to make the default strict
				and allow people to relax it, or to make the default lenient and
				allow people to strengthen it, is essentially a political one. It
				does not really matter in technical terms provided the user is
				made aware of exactly what each compilation mode means in terms
				of syntax, semantics and portability checking.) However it is
				possible to change its behaviour (again by means of
				<code>#pragma</code> statements) to implement many of the
				features found in "traditional" or "K&amp;R" C. Hence it is
				possible to precisely determine how the producer will interpret
				the C code it is given by explicitly describing the C dialect it
				is written in in terms of these <code>#pragma</code>
				statements.</para>
		</section>

		<section id="S34">
			<title>C to &tdf; Mappings</title>

			<para>The nature of the C to &tdf; transformation implemented by the
				producer is worth considering, although not all the features
				described in this section are fully implemented in the current
				(October 1993) producer. Although it is only indirectly related
				to questions of portability, this mapping does illustrate some of
				the problems the producer has in trying to represent program in
				an architecture neutral manner.</para>

			<para>Once the initial difficulty of overcoming the syntactic and
				semantic differences between the various C dialects is overcome,
				the C to &tdf; mapping is quite straightforward. In a hierarchy
				from high level to low level languages C and &tdf; are not that
				dissimilar - both come towards the bottom of what may
				legitimately be regarded as high level languages. Thus the
				constructs in C map easily onto the constructs of &tdf; (there are
				a few exceptions, for example coercing integers to pointers,
				which are discussed in [3]). Eccentricities of the C language
				specification such as doing all integer arithmetic in the
				promoted integer type are translated explicitly into &tdf;. So to
				add two <code>char</code>'s, they are promoted to
				<code>int</code>'s, added together as <code>int</code>'s, and the
				result is converted back to a <code>char</code>. These rules are
				not built directly into &tdf; because of the desire to support
				languages other than C (and even other C dialects).</para>

			<para>A number of issues arise when tokens are introduced. Consider
				for example the type <code>size_t</code> from the &ansi; standard.
				This is a target dependent integer type, so bearing in mind what
				was said above it is natural for the producer to use a tokenised
				variety (the &tdf; representation of integer types) to stand for
				<code>size_t</code>. This is done by a <code>#pragma token</code>
				statement of the form:</para>

			<programlisting language="c">#pragma token VARIETY size_t # ansi.stddef.size_t</programlisting>

			<para>But if we want to do arithmetic on <code>size_t</code>'s we
				need to know the integer type corresponding to the integral
				promotion of <code>size_t</code> . But this is again target
				dependent, so it makes sense to have another tokenised variety
				representing the integral promotion of <code>size_t</code>. Thus
				the simple token directive above maps to (at least) two &tdf; tokens,
				the type itself and its integral promotion.</para>

			<para>As another example, suppose that we have a target dependent C
				type, <code>type</code> say, and we define a procedure which
				takes an argument of type <code>type</code>. In both the
				procedure body and at any call of the procedure the &tdf; we need
				to produce to describe how C passes this argument will depend on
				<code>type</code>. This is because C does not treat all procedure
				argument types uniformly. Most types are passed by value, but
				array types are passed by address. But whether or not
				<code>type</code> is an array type is target dependent, so we
				need to use tokens to abstract out the argument passing
				mechanism. For example, we could implement the mechanism using
				four tokens : one for the type <code>type</code> (which will be a
				tokenised shape), one for the type an argument of type
				<code>type</code> is passed as, <code>arg_type</code> say, (which
				will be another tokenised shape), and two for converting values
				of type <code>type</code> to and from the corresponding values of
				type <code>arg_type</code> (these will be tokens which take one
				exp argument and give an exp). For most types,
				<code>arg_type</code> will be the same as <code>type</code> and
				the conversion tokens will be identities, but for array types,
				<code>arg_type</code> will be a pointer to <code>type</code> and
				the conversion tokens will be "address of" and "contents of".</para>

			<para>So there is not the simple one to one correspondence between
				<code>#pragma token</code> directives and &tdf; tokens one might
				expect. Each such directive maps onto a family of &tdf; tokens, and
				this mapping in a sense encapsulates the C language
				specification. Of course in the &tdf; library building process the
				definitions of all these tokens are deduced automatically from
				the local values.</para>
		</section>

		<section id="S35">
			<title>&tdf; Linking</title>

			<para>We now move
				from considering the components of the producer to those of the
				installer. The first phase of the installation - linking in the
				&tdf; libraries containing the token definitions describing the
				local implementation of the &api; - is performed by a general
				utility program, the &tdf; linker (or builder). This is a very
				simple program which is used to combine a number of &tdf; capsules
				and libraries into a single capsule. As has been emphasised
				previously, the capsule structure means that this is a very
				natural operation, but, as will be seen from the previous
				discussion (particularly section 2.2.3), such combinatorial
				phases are very prone to namespace problems.</para>

			<para>In &tdf; tags, tokens and other externally named objects occupy
				separate namespaces, and there are no constructs which can cut
				across these namespaces in the way that the C macros do. There
				still remains the problem that the only way to know that two
				tokens, say, in different capsules are actually the same is if
				they have the same name. This, as we have already seen in the
				case of system linking, can cause objects to be identified
				wrongly.</para>

			<para>In the main &tdf; linking phase - linking in the token
				definitions at the start of the installation - we are primarily
				linking on token names, these tokens being those arising from the
				use of the target independent headers. Potential namespace
				problems are virtually eliminated by the use of unique external
				names for the tokens in these headers (such as
				<code>ansi.stdio.FILE</code> in the example above). This means
				that there is a genuine one to one correspondence between tokens
				and token names. Of course this relies on the external token
				names given in the headers being genuinely unique. In fact, as is
				explained below, these names are normally automatically
				generated, and uniqueness of names within a given &api; is checked.
				Also incorporating the &api; name into the token name helps to
				ensure uniqueness across &api;s. However the token namespace does
				require careful management. (Note that the user does not normally
				have access to the token namespace; all variable and procedure
				names map into the tag namespace.)</para>

			<para>We can illustrate the "clean" nature of &tdf; linking by
				considering the <code>st_atime</code> example given in section
				2.2.3. Recall that in the traditional compilation scheme the
				problem arose, not because of the program or the &api;
				implementation, but because of the way they were combined by the
				pre-processor. In the &tdf; scheme the target independent version
				of <code>sys/stat.h</code> will be included. Thus the procedure
				name <code>st_atime</code> and the field selector
				<code>st_atime</code> will be seen to belong to genuinely
				different namespaces - there are no macros to disrupt this. The
				former will be translated into a &tdf; tag with external name
				<code>st_atime</code>, whereas the latter is translated into a
				token with external name
				<code>posix.stat.struct_stat.st_atime</code> , say. In the &tdf;
				library reflecting the &api; implementation, the token
				<code>posix.stat.struct_stat.st_atime</code> will be defined
				precisely as the system header intended, as the offset
				corresponding to the C field selector
				<code>st_atim.st__sec</code>. The fact that this token is defined
				using a macro rather than a conventional direct field selector is
				not important to the library building process. Now the
				combination of the program with the &api; implementation in this
				case is straightforward - not only are the procedure name and the
				field selector name in the &tdf; now different, but they also lie
				in distinct namespaces. This shows how the separation of the &api;
				implementation from the main program is cleaner in the &tdf;
				compilation scheme than in the traditional scheme.</para>

			<para>&tdf; linking also opens up new ways of combining code which may
				solve some other namespace problems. For example, in the
				<code>open</code> example in section 2.2.3, the name
				<code>open</code> is meant to be internal to the program. It is
				the fact that it is not treated as such which leads to the
				problem. If the program consisted of a single source file then we
				could make <code>open</code> a <code>static</code> procedure, so
				that its name does not appear in the external namespace. But if
				the program consists of several source files the external name is
				necessary for intra-program linking. The &tdf; linker allows this
				intra-program linking to be separated from the main system
				linking. In the &tdf; compilation scheme described above each
				source file is translated into a separate &tdf; capsule, which is
				installed separately to a binary object file. It is only the
				system linking which finally combines the various components into
				a single program. An alternative scheme would be to use the &tdf;
				linker to combine all the &tdf; capsules into a single capsule in
				the production phase and install that. Because all the
				intra-program linking has already taken place, the external names
				required for it can be "hidden" - that is to say, removed from
				the tag namespace. Only tag names which are used but not defined
				(and so are not internal to the program) and <code>main</code>
				should not be hidden. In effect this linking phase has made all
				the internal names in the program (except <code>main</code>)
				<code>static</code>.</para>

			<para>In fact this type of complete program linking is not always
				feasible. For very large programs the resulting &tdf; capsule can
				to be too large for the installer to cope with (it is the system
				assembler which tends to cause the most problems). Instead it may
				be better to use a more judiciously chosen partial linking and
				hiding scheme.</para>
		</section>

		<section id="S36">
			<title>The &tdf; Installers</title>

			<para>The &tdf; installer on a given machine typically consists
				of four phases: &tdf; linking, which has already been discussed,
				translating &tdf; to assembly source code, translating assembly
				source code to a binary object file, and linking binary object
				files with the system libraries to form the final executable. The
				latter two phases are currently implemented by the system
				assembler and linker, and so are identical to the traditional
				compilation scheme.</para>

			<para>It is the &tdf; to assembly code translator which is the main
				part of the installer. Although not strictly related to the
				question of portability, the nature of the translator is worth
				considering. Like the producer (and the assembler), it is a
				transformational, as opposed to a combinatorial, compilation
				phase. But whereas the transformation from C to &tdf; is
				"difficult" because of the syntax and semantics of C and the need
				to represent everything in an architecture neutral manner, the
				transformation from &tdf; to assembly code is much easier because
				of the unambiguous syntax and uniform semantics of &tdf;, and
				because now we know the details of the target machine, it is no
				longer necessary to work at such an abstract level.</para>

			<para>The whole construction of the current generation of &tdf;
				translators is based on the concept of compilation as
				transformation. They represent the &tdf; they read in as a syntax
				tree, virtually identical to the syntax tree comprising the &tdf;.
				The translation process then consists of continually applying
				transformations to this tree - in effect &tdf; to &tdf;
				transformations - gradually optimising it and changing it to a
				form where the translation into assembly source code is a simple
				transcription process (see [7]).</para>

			<para>Even such operations as constant evaluation - replacing 1 + 1
				by 2 in the example above - may be regarded as &tdf; to &tdf;
				transformations. But so may more complex optimisations such as
				taking constants out of a loop, common sub-expression
				elimination, strength reduction and so on. Some of these
				transformations are universally applicable, others can only be
				applied on certain classes of machines. This transformational
				approach results in high quality code generation (see [5]) while
				minimising the risk of transformational errors. Moreover the
				sharing of so much code - up to 70% - between all the &tdf;
				translators, like the introduction of a common front-end, further
				reduces the exposure to compiler bugs.</para>

			<para>Much of the machine ABI information is built into the
				translator in a very simple way. For example, to evaluate the
				offset of the field <code>b</code> in the structure <code>struct
				tag</code> above, the producer has already done all the hard
				work, providing a formula for the offset in terms of the sizes
				and alignments of the basic C types. The translator merely
				provides these values and the offset is automatically evaluated
				by the constant evaluation transformations. Other aspects of the
				ABI, for example the procedure argument and result passing
				conventions, require more detailed attention.</para>

			<para>One interesting range of optimisations implemented by many of
				the current translators consists of the inlining of certain
				standard procedure calls. For example, <code>strlen ( "hello"
				)</code> is replaced by 5. As it stands this optimisation appears
				to run the risk of corrupting the programmer's namespace - what
				if <code>strlen</code> was a user-defined procedure rather than
				the standard library routine (cf. the <code>open</code> example
				in section 2.2.3)? This risk only materialises however if we
				actually use the procedure name to spot this optimisation. In
				code compiled from the target independent headers all calls to
				the library routine <code>strlen</code> will be implemented by
				means of a uniquely named token, <code>ansi.string.strlen</code>
				say. It is by recognising this token name as the token is
				expanded that the translators are able to ensure that this is
				really the library routine <code>strlen</code>.</para>

			<para>Another example of an inlined procedure of this type is
				<code>alloca</code>. Many other compilers inline
				<code>alloca</code>, or rather they inline
				<code>__builtin_alloca</code> and rely on the programmer to
				identify <code>alloca</code> with <code>__builtin_alloca</code>.
				This gets round the potential namespace problems by getting the
				programmer to confirm that <code>alloca</code> in the program
				really is the library routine <code>alloca</code>. By the use of
				tokens this information is automatically provided to the &tdf;
				translators.</para>
		</section>
	</section>

	<section id="S37">
		<title>&tdf; and &api;s</title>

		<para>What the discussion above has
			emphasised is that the ability to describe &api;s abstractly as
			target independent headers underpins the entire &tdf; approach to
			portability. We now consider this in more detail.</para>

		<section id="S38">
			<title>&api; Description</title>

			<para>The
				process of transforming an &api; specification into its description
				in terms of <code>#pragma token</code> directives is a
				time-consuming but often fascinating task. In this section we
				discuss some of the issues arising from the process of describing
				an &api; in this way.</para>

			<section id="S39">
				<title>The Description Process</title>

				<para>As may be observed from the example given in
					section 3.2.1, the <code>#pragma token</code> syntax is not
					necessarily intuitively obvious. It is designed to be a low-level
					description of tokens which is capable of expressing many complex
					token specifications. Most &api;s are however specified in C-like
					terms, so an alternative syntax, closer to C, has been developed
					in order to facilitate their description. This is then
					transformed into the corresponding <code>#pragma token</code>
					directives by a specification tool called <code>tspec</code> (see
					[2]), which also applies a number of checks to the input and
					generates the unique token names. For example, the description
					leading to the example above was:</para>

				<programlisting language="tspec">+TYPE FILE ;
+EXP FILE *stdout ;
+FUNC int fputs ( const char *, FILE * ) ;</programlisting>

				<para>Note how close this is to the English language specification
					of the &api; given previously. (There are a number of open issues
					relating to <code>tspec</code> and the <code>#pragma token</code>
					syntax, mainly concerned with determining the type of syntactic
					statements that it is desired to make about the &api;s being
					described. The current scheme is adequate for those &api;s so far
					considered, but it may need to be extended in future.)</para>

				<para><code>tspec</code> is not capable of expressing the full power
					of the <code>#pragma token</code> syntax. Whereas this makes it
					easier to use in most cases, for describing the normal C-like
					objects such as types, expressions and procedures, it cannot
					express complex token descriptions. Instead it is necessary to
					express these directly in the <code>#pragma token</code> syntax.
					However this is only rarely required : the constructs
					<code>offsetof</code>, <code>va_start</code> and
					<code>va_arg</code> from &ansi; are the only examples so far
					encountered during the &api; description programme at DRA. For
					example, <code>va_arg</code> takes an assignable expression of
					type <code>va_list</code> and a type <code>t</code> and returns
					an expression of type <code>t</code>. Clearly, this cannot be
					expressed abstractly in C-like terms; so the <code>#pragma
					token</code> description:</para>

				<programlisting language="c">#pragma token PROC ( EXP lvalue : va_list : e, TYPE t )\
	EXP rvalue : t : va_arg # ansi.stdarg.va_arg</programlisting>

				<para>must be used instead.</para>

				<para>Most of the process of describing an &api; consists of going
					through its English language specification transcribing the
					object specifications it gives into the <code>tspec</code> syntax
					(if the specification is given in a machine readable form this
					process can be partially automated). The interesting part
					consists of trying to interpret what is written and reading
					between the lines as to what is meant. It is important to try to
					represent exactly what is in the specification rather than being
					influenced by one's knowledge of a particular implementation,
					otherwise the &api; checking phase of the compilation will not be
					checking against what is actually in the &api; but against a
					particular way of implementing it.</para>

				<para>There is a continuing &api; description programme at DRA. The
					current status (October 1993) is that &ansi; (X3.159), &posix;
					(1003.1), XPG3 (X/Open Portability Guide 3) and SVID (System V
					Interface Definition, 3rd Edition) have been described and
					extensively tested. &posix;2 (1003.2), XPG4, AES (Revision A), X11
					(Release 5) and Motif (Version 1.1) have been described, but not
					yet extensively tested.</para>

				<para>There may be some syntactic information in the paper &api;
					specifications which <code>tspec</code> (and the <code>#pragma
					token</code> syntax) is not yet capable of expressing. In
					particular, some &api;s go into very careful management of
					namespaces within the &api;, explicitly spelling out exactly what
					should, and should not, appear in the namespaces as each header
					is included (see the appendix on namespaces and &api;s below). What
					is actually being done here is to regard each header as an
					independent sub-&api;. There is not however a sufficiently
					developed "&api; calculus" to allow such relationships to be easily
					expressed.</para>
			</section>

			<section id="S40">
				<title>Resolving Conflicts</title>

				<para>Another consideration during the description
					process is to try to integrate the various &api; descriptions. For
					example, &posix; extends &ansi;, so it makes sense to have the target
					independent &posix; headers include the corresponding &ansi; headers
					and just add the new objects introduced by &posix;. This does
					present problems with &api;s which are basically compatible but
					have a small number of incompatibilities, whether deliberate or
					accidental. As an example of an "accidental" incompatibility,
					XPG3 is an extension of &posix;, but whereas &posix; declares
					<code>malloc</code> by means of the prototype:</para>

				<programlisting language="c">void *malloc(size_t);</programlisting>

				<para>XPG3 declares it by means of the traditional procedure
					declaration:</para>

				<programlisting language="c">void *malloc(s)
size_t s;</programlisting>

				<para>These are surely intended to express the same thing, but in
					the first case the argument is passed as a <code>size_t</code> and
					in the second it is firstly promoted to the integer promotion of
					<code>size_t</code>. On most machines these are compatible, either
					because of the particular implementation of <code>size_t</code>, or
					because the procedure calling conventions make them compatible.
					However in general they are incompatible, so the target independent
					headers either have to reflect this or have to read between the
					lines and assume that the incompatibility was accidental and ignore
					it.</para>

				<para>As an example of a deliberate incompatibility, both XPG3 and
					SVID3 declare a structure <code>struct msqid_ds</code> in
					<code>sys/msg.h</code> which has fields <code>msg_qnum</code> and
					<code>msg_qbytes</code>. The difference is that whereas XPG3
					declares these fields to have type <code>unsigned short</code>,
					SVID3 declares them to have type <code>unsigned long</code>.
					However for most purposes the precise types of these fields is
					not important, so the &api;s can be unified by making the types of
					these fields target dependent. That is to say, tokenised integer
					types <code>__msg_q_t</code> and <code>__msg_l_t</code> are
					introduced. On XPG3-compliant machines these will both be defined
					to be <code>unsigned short</code>, and on SVID3-compliant
					machines they will both be <code>unsigned long</code>. So,
					although strict XPG3 and strict SVID3 are incompatible, the two
					extension &api;s created by adding these types are compatible. In
					the rare case when the precise type of these fields is important,
					the strict &api;s can be recovered by defining the field types to
					be <code>unsigned short</code> or <code>unsigned long</code> at
					produce-time rather than at install-time. (XPG4 uses a similar
					technique to resolve this incompatibility. But whereas the XPG4
					types need to be defined explicitly, the tokenised types are
					defined implicitly according to whatever the field types are on a
					particular machine.)</para>

				<para>This example shows how introducing extra abstractions can
					resolve potential conflicts between &api;s. But it may also be used
					to resolve conflicts between the &api; specification and the &api;
					implementations. For example, &posix; specifies that the structure
					<code>struct flock</code> defined in <code>fcntl.h</code> shall
					have a field <code>l_pid</code> of type <code>pid_t</code>.
					However on at least two of the &posix; implementations examined at
					DRA, <code>pid_t</code> was implemented as an <code>int</code>,
					but the <code>l_pid</code> field of <code>struct flock</code> was
					implemented as a <code>short</code> (this showed up in the &tdf;
					library building process). The immediate reaction might be that
					these system have not implemented &posix; correctly, so they should
					be cast into the outer darkness. However for the vast majority of
					applications, even those which use the <code>l_pid</code> field,
					its precise type is not important. So the decision was taken to
					introduce a tokenised integer type, <code>__flock_pid_t</code>,
					to stand for the type of the <code>l_pid</code> field. So
					although the implementations do not conform to strict &posix;, they
					do to this slightly more relaxed extension. Of course, one could
					enforce strict &posix; by defining <code>__flock_pid_t</code> to be
					<code>pid_t</code> at produce-time, but the given implementations
					would not conform to this stricter &api;.</para>

				<para>Both the previous two examples are really concerned with the
					question of determining the correct level of abstraction in &api;
					specification. Abstraction is inclusive and allows for &api;
					evolution, whereas specialisation is exclusive and may lead to
					dead-end &api;s. The SVID3 method of allowing for longer messages
					than XPG3 - changing the <code>msg_qnum</code> and
					<code>msg_qbytes</code> fields of <code>struct msqid_ds</code>
					from <code>unsigned short</code> to <code>unsigned long</code> -
					is an over-specialisation which leads to an unnecessary conflict
					with XPG3. The XPG4 method of achieving exactly the same end -
					abstracting the types of these fields - is, by contrast, a smooth
					evolutionary path.</para>
			</section>

			<section id="S41">
				<title>The Benefits of &api; Description</title>

				<para>The description process is potentially of
					great benefit to bodies involved in &api; specification. While the
					specification itself stays on paper the only real existence of
					the &api; is through its implementations. Giving the specification
					a concrete form means not only does it start to be seen as an
					object in its own right, rather than some fuzzy document
					underlying the real implementations, but also any omissions,
					insufficient specifications (where what is written down does not
					reflect what the writer actually meant) or built-in assumptions
					are more apparent. It may also be able to help show up the kind
					of over-specialisation discussed above. The concrete
					representation also becomes an object which both applications and
					implementations can be automatically checked against. As has been
					mentioned previously, the production phase of the compilation
					involves checking the program against the abstract &api;
					description, and the library building phase checks the syntactic
					aspect of the implementation against it.</para>
					
				<para>The implementation checking aspect is considered below. Let us
					here consider the program checking aspect by re-examining the
					examples given in section 2.2.4.1. The <code>SIGKILL</code>
					example is straightforward; <code>SIGKILL</code> will appear in
					the &posix; version of <code>signal.h</code> but not the &ansi;
					version, so if the program is compiled with the target
					independent &ansi; headers it will be reported as being undefined.
					In a sense this is nothing to do with the <code>#pragma
					token</code> syntax, but with the organisation of the target
					independent headers. The other examples do however rely on the
					fact that the <code>#pragma token</code> syntax can express
					syntactic information in a way which is not possible directly
					from C. Thus the target independent headers express exactly the
					fact that <code>time_t</code> is an arithmetic type, about which
					nothing else is known. Thus <code>( t &amp; 1 )</code> is not
					type correct for a <code>time_t t</code> because the binary
					<code>&amp;</code> operator does not apply to all arithmetic
					types. Similarly, for the type <code>div_t</code> the target
					independent headers express the information that there exists a
					structure type <code>div_t</code> and field selectors
					<code>quot</code> and <code>rem</code> of <code>div_t</code> of
					type <code>int</code>, but nothing about the order of these
					fields or the existence of other fields. Thus any attempt to
					initialise a <code>div_t</code> will fail because the
					correspondence between the values in the initialisation and the
					fields of the structure is unknown. The <code>struct
					dirent</code> example is entirely analogous, except that here the
					declarations of the structure type <code>struct dirent</code> and
					the field selector <code>d_name</code> appear in both the &posix;
					and XPG3 versions of <code>dirent.h</code>, whereas the field
					selector <code>d_ino</code> appears only in the XPG3 version.</para>
			</section>
		</section>
					
		<section id="S42">
			<title>&tdf; Library Building</title>

			<para>As we have said, two of the primary problems with writing portable
				programs are dealing with &api; implementation errors on the target
				machines - objects not being defined, or being defined in the
				wrong place, or being implemented incorrectly - and namespace
				problems - particularly those introduced by the system headers.
				The most interesting contrast between the traditional compilation
				scheme (<xref linkend="trad_scheme"/>) and the &tdf; scheme
				(<xref linkend="tdf_scheme"/>) is that in the former
				the program comes directly into contact with the "real world" of
				messy system headers and incorrectly implemented &api;s, whereas in
				the latter there is an "ideal world" layer interposed. This
				consists of the target independent headers, which describe all
				the syntactic features of the &api; where they are meant to be, and
				with no extraneous material to clutter up the namespaces (like
				<code>index</code> and the macro <code>st_atime</code> in the
				examples given in section 2.2.3), and the &tdf; libraries, which
				can be combined "cleanly" with the program without any namespace
				problems. All the unpleasantness has been shifted to the
				interface between this "ideal world" and the "real world"; that
				is to say, the &tdf; library building.</para>
				
			<para>The importance of this change may be summarised by observing
				that previously all the unpleasantnesses happened in the left
				hand side of the diagram (the program half), whereas in the &tdf;
				scheme they are in the right hand side (the &api; half). So &api;
				implementation problems are seen to be a genuinely separate issue
				from the main business of writing programs; the ball is firmly in
				the &api; implementor's court rather than the programmer's. Also
				the problems need to be solved once per &api; rather than once per
				program.</para>
				
			<para>It might be said that this has not advanced us very far
				towards actually dealing with the implementation errors. The &api;
				implementation still contains errors whoever's responsibility it
				is. But the &tdf; library building process gives the &api;
				implementor a second chance. Many of the syntactic implementation
				problems will be shown up as the library builder compares the
				implementation against the abstract &api; description, and it may
				be possible to build corrections into the &tdf; libraries so that
				the libraries reflect, not the actual implementation, but some
				improved version of it.</para>
				
			<para>To show how this might be done, we reconsider the examples of
				&api; implementation errors given in section 2.2.4.2. As before we
				may divide our discussion between system header problems and
				system library problems. Recall however the important
				distinction, that whereas previously the programmer was trying to
				deal with these problems in a way which would work on all
				machines (top left of the compilation diagrams), now the person
				building the &tdf; libraries is trying to deal with implementation
				problems for a particular &api; on a particular machine (bottom
				right).</para>
					
			<section id="S43">
				<title>System Header Problems</title>

				<para>Values which are defined in the wrong place,
					such as <code>SEEK_SET</code> in the example given, present no
					difficulties. The library builder will look where it expects to
					find them and report that they are undefined. To define these
					values it is merely a matter of telling the library builder where
					they are actually defined (in <code>unistd.h</code> rather than
					<code>stdio.h</code>).</para>
					
				<para>Similarly, values which are undefined are also reported. If
					these values can be deduced from other information, then it is a
					simple matter to tell the library builder to use these deduced
					values. For example, if <code>EXIT_SUCCESS</code> and
					<code>EXIT_FAILURE</code> are undefined, it is probably possible
					to deduce their values from experimentation or experience (or
					guesswork).</para>
					
				<para>Wrongly defined values are more difficult. Firstly they are
					not necessarily detected by the library builder because they are
					semantic rather than syntactic errors. Secondly, whereas it is
					easy to tell the library builder to use a corrected value rather
					than the value given in the implementation, this mechanism needs
					to be used with circumspection. The system libraries are provided
					pre-compiled, and they have been compiled using the system
					headers. If we define these values differently in the &tdf;
					libraries we are effectively changing the system headers, and
					there is a risk of destroying the interface with the system
					libraries. For example, changing a structure is not a good idea,
					because different parts of the program - the main body and the
					parts linked in from the system libraries - will have different
					ideas of the size and layout of this structure. (See the
					<code>struct flock</code> example in section 3.4.1.2 for a
					potential method of resolving such implementation problems.)</para>
					
				<para>In the two cases given above - <code>DBL_MAX</code> and
					<code>size_t</code> - the necessary changes are probably "safe".
					<code>DBL_MAX</code> is not a special value in any library
					routines, and changing <code>size_t</code> from <code>int</code>
					to <code>unsigned int</code> does not affect its size, alignment
					or procedure passing rules (at least not on the target machines
					we have in mind) and so should not disrupt the interface with the
					system library.</para>
			</section>
					
			<section id="S44">
				<title>System Library Problems</title>

				<para>Errors in the system libraries will not be
					detected by the &tdf; library builder because they are semantic
					errors, whereas the library building process is only checking
					syntax. The only realistic ways of detecting semantic problems is
					by means of test suites, such as the Plum-Hall or CVSA library
					tests for &ansi; and VSX for XPG3, or by detailed knowledge of
					particular &api; implementations born of personal experience.
					However it may be possible to build workarounds for problems
					identified in these tests into the &tdf; libraries.</para>
					
				<para>For example, the problem with <code>realloc</code> discussed
					in section 2.2.4.4 could be worked around by defining the token
					representing <code>realloc</code> to be the equivalent of:</para>
					
				<programlisting language="c">#define realloc ( p, s ) ( void *q = ( p ) ? ( realloc ) ( q, s ) : malloc ( s ) )</programlisting>
					
				<para>(where the C syntax has been extended to allow variables to
					be introduced inside expressions) or:</para>
					
				<programlisting language="c">static void *__realloc ( void *p, size_t s )
{
	if ( p == NULL )
		return ( malloc ( s ) ) ;
	return ( ( realloc ) ( p, s ) ) ;
}

#define realloc ( p, s ) __realloc ( p, s )</programlisting>

				<para>Alternatively, the token definition could be encoded directly
					into &tdf; (not via C), using the &tdf; notation compiler (see [9]).</para>
			</section>
					
			<section id="S45">
				<title>&tdf; Library Builders</title>

				<para>The discussion above shows how the &tdf; libraries
					are an extra layer which lies on top of the existing system &api;
					implementation, and how this extra layer can be exploited to
					provide corrections and workarounds to various implementation
					problems. The expertise of particular &api; implementation problems
					on particular machines can be captured once and for all in the
					&tdf; libraries, rather than being spread piecemeal over all the
					programs which use that &api; implementation. But being able to
					encapsulate this expertise in this way makes it a marketable
					quantity. One could envisage a market in &tdf; libraries: ranging
					from libraries closely reflecting the actual &api; implementation
					to top of the range libraries with many corrections and
					workarounds built in.</para>
					
				<para>All of this has tended to paint the system vendors as the
					villains of the piece for not providing correct &api;
					implementations, but this is not entirely fair. The reason why
					&api; implementation errors may persist over many operating system
					releases is that system vendors have as many porting problems as
					anyone else - preparing a new operating system release is in
					effect a huge porting exercise - and are understandably reluctant
					to change anything which basically works. The use of &tdf;
					libraries could be a low-risk strategy for system vendors to
					allow users the benefits of &api; conformance without changing the
					underlying operating system.</para>
					
				<para>Of course, if the system vendor's porting problems could be
					reduced, they would have more confidence to make their underlying
					systems more &api; conformant, and thereby help reduce the normal
					programmer's porting problems. So whereas using the &tdf; libraries
					might be a short-term workaround for &api; implementation problems,
					the rest of the &tdf; porting system might help towards a long-term
					solution.</para>
					
				<para>Another interesting possibility arises. As we said above, many
					&api;s, for example &posix; and &bsd;, offer equivalent functionality
					by different methods. It may be possible to use the &tdf; library
					building process to express one in terms of the other. For
					example, in the <code>struct dirent</code> example10 in section
					2.3.3, the only differences between &posix; and &bsd; were that the
					&bsd; version was defined in a different header and that the
					structure was called <code>struct direct</code>. But this
					presents no problems to the &tdf; library builder : it is perfectly
					simple to tell it to look in <code>sys/dir.h</code> instead of
					<code>dirent.h</code> , and to identify <code>struct
					direct</code> with <code>struct dirent</code>. So it may be
					possible to build a partial &posix; lookalike on &bsd; systems by
					using the &tdf; library mechanism.</para>
			</section>
		</section>
	</section>

	<section id="S46">
		<title>&tdf; and Conditional Compilation</title>

		<para>So far our
			discussion of the &tdf; approach to portability has been confined
			to the simplest case, where the program itself contains no target
			dependent code. We now turn to programs which contain conditional
			compilation. As we have seen, many of the reasons why it is
			necessary to introduce conditional compilation into the
			traditional compilation process either do not arise or are seen
			to be distinct phases in the &tdf; compilation process. The use of
			a single front-end (the producer) virtually eliminates problems
			of compiler limitations and differing interpretations and reduces
			compiler bug problems, so it is not necessary to introduce
			conditionally compiled workarounds for these. Also &api;
			implementation problems, another prime reason for introducing
			conditional compilation in the traditional scheme, are seen to be
			isolated in the &tdf; library building process, thereby allowing
			the programmer to work in an idealised world one step removed
			from the real &api; implementations. However the most important
			reason for introducing conditional compilation is where things,
			for reasons of efficiency or whatever, are genuinely different on
			different machines. It is this we now consider.</para>

		<section id="S47">
			<title>User-Defined &api;s</title>

			<para>The things which are done genuinely differently on different machines
				have previously been characterised as comprising the user-defined
				component of the &api;. So the real issue in this case is how to
				use the &tdf; &api; description and representation methods within
				one's own programs. A very simple worked example is given below
				(in section 3.5.2), for more detailed examples see [8].</para>
		
			<para>For the <code>MSB</code> example given in section 2.3 we
				firstly have to decide what the user-defined &api; is. To fully
				reflect exactly what the target dependent code is, we could
				define the &api;, in <code>tspec</code> terms, to be:</para>
		
			<programlisting language="tspec">+MACRO unsigned char MSB ( unsigned int a ) ;</programlisting>
		
			<para>where the macro <code>MSB</code> gives the most significant
				byte of its argument, <code>a</code>. Let us say that the
				corresponding <code>#pragma token</code> statement is put into the
				header <code>msb.h</code>. Then the program can be recast into the
				form:</para>

			<programlisting language="c">#include &lt;stdio.h&gt;
#include "msb.h"

unsigned int x = 100000000 ;

int main ()
{
	printf ( "%u\n", MSB ( x ) ) ;
	return ( 0 ) ;
}</programlisting>

			<para>The producer will compile this into a target independent &tdf;
				capsule which uses a token to represent the use of
				<code>MSB</code>, but leaves this token undefined. The only
				question that remains is how this token is defined on the target
				machine; that is, how the user-defined &api; is implemented. On each
				target machine a &tdf; library containing the local definition of the
				token representing <code>MSB</code> needs to be built. There are
				two basic possibilities. Firstly the person performing the
				installation could build the library directly, by compiling a
				program of the form:</para>
			
			<programlisting language="c">#pragma implement interface "msb.h"
#include "config.h"

#ifndef SLOW_SHIFT
#define MSB ( a ) ( ( unsigned char ) ( a &gt;&gt; 24 ) )
#else
#ifdef BIG_ENDIAN
#define MSB ( a ) *( ( unsigned char * ) &amp;( a ) )
#else
#define MSB ( a ) *( ( unsigned char * ) &amp;( a ) + 3 )
#endif
#endif</programlisting>

			<para>with the appropriate <code>config.h</code> to choose the
				correct local implementation of the interface described in
				<code>msb.h</code>. Alternatively the programmer could provide
				three alternative &tdf; libraries corresponding to the three
				implementations, and let the person installing the program choose
				between these. The two approaches are essentially equivalent, they
				just provide for making the choice of the implementation of the
				user-defined component of the &api; in different ways. An interesting
				alternative approach would be to provide a short program which does
				the selection between the provided &api; implementations
				automatically. This approach might be particularly effective in
				deciding which implementation offers the best performance on a
				particular target machine.</para>
		</section>

		<section>
		<title>3.5.2. User Defined Tokens - Example</title>

			<para>As an example of how to define a simple token
				consider the following example. We have a simple program which
				prints <quote>hello</quote> in some language, the language being target
				dependent. Our first task is choose an &api;. We choose &ansi; C
				extended by a tokenised object <code>hello</code> of type
				<code>char *</code> which gives the message to be printed. This
				object will be an rvalue (i.e. it cannot be assigned to). For
				convenience this token is declared in a header file,
				<code>tokens.h</code> say. This particular case is simple enough
				to encode by hand; it takes the form:</para>
				
			<programlisting language="c">#pragma token EXP rvalue : char * : hello #
#pragma interface hello</programlisting>
				
			<para>consisting of a <code>#pragma token</code> directive
				describing the object to be tokenised, and a <code>#pragma
				interface</code> directive to show that this is the only object in
				the &api;. An alternative would be to generate <code>tokens.h</code>
				from a <code>tspec</code> specification of the form:</para>
				
			<programlisting language="tspec">+EXP char *hello ;</programlisting>
				
			<para>The next task is to write the program conforming to this &api;.
				This may take the form of a single source file,
				<code>hello.c</code>, containing the lines:</para>
				
			<programlisting language="c">#include &lt;stdio.h&gt;
#include "tokens.h"

int main ()
{
	printf ( "%s\n", hello ) ;
	return ( 0 ) ;
}</programlisting>

			<para>The production process may be specified by means of a <code>
				Makefile</code>. This uses the &tdf; C compiler, <code>tcc</code>,
				which is an interface to the &tdf; system which is designed to be
				like <code>cc</code>, but with extra options to handle the extra
				functionality offered by the &tdf; system (see [1]).</para>

			<programlisting language="make">produce : hello.j

hello.j : hello.c tokens.h
	tcc -Fj hello.c</programlisting>

			<para>The production is run by typing <code>make produce</code>.
				The &ansi; &api; is the default, and so does not need to be specified
				to <code>tcc</code>. The program <code>hello.c</code> is compiled
				to a target independent capsule, <code>hello.j</code>. This will
				use a token to represent <code>hello</code>, but it will be left
				undefined.</para>

			<para>On each target machine we need to create a token library
				giving the local definitions of the objects in the &api;. We shall
				assume that the library corresponding to the &ansi; C &api; has
				already been constructed, so that we only need to define the
				token representing <code>hello</code>. This is done by means of a
				short C program, <code>tokens.c</code>, which implements the
				tokens declared in <code>tokens.h</code>. This might take the
				form:</para>

			<programlisting language="c">#pragma implement interface "tokens.h"
#define hello "bonjour"</programlisting>

			<para>to define <code>hello</code> to be "bonjour". On a different
				machine, the definition of <code>hello</code> could be given as
				<quote>hello</quote>, <quote>guten Tag</quote>, <quote>zdrastvuyte</quote>
				(excuse my transliteration) or
				whatever (including complex expressions as well as simple strings).
				Note the use of <code>#pragma implement interface</code> to
				indicate that we are now implementing the &api; described in
				<code>tokens.h</code>, as opposed to the use of
				<code>#include</code> earlier when we were just using the &api;.</para>

			<para>The installation process may be specified by adding the
				following lines to the <code>Makefile</code>:</para>

			<programlisting language="make">install : hello

hello : hello.j tokens.tl
	tcc -o hello -J. -jtokens hello.j

tokens.tl : tokens.j
	tcc -Ymakelib -o tokens.tl tokens.j

tokens.j : tokens.c tokens.h
	tcc -Fj -not_ansi tokens.c</programlisting>

			<para>The complete installation process is run by typing <code>make
				install</code>. Firstly the file <code>tokens.c</code> is compiled
				to give the &tdf; capsule <code>tokens.j</code> containing the
				definition of <code>hello</code>. The <option>-not_ansi</option> flag is
				needed because <code>tokens.c</code> does not contain any real C
				(declarations or definitions), which is not allowed in &ansi; C. The
				next step is to turn the capsule <code>tokens.j</code> into a &tdf;
				library, <code>tokens.tl</code>, using the <option>-Ymakelib</option> option
				to <code>tcc</code> (with older versions of <code>tcc</code> it may
				be necessary to change this option to <option>-Ymakelib -M -Fj</option>).
				This completes the &api; implementation.</para>

			<para>The final step is installation. The target independent &tdf;,
				<code>hello.j</code>, is linked with the &tdf; libraries
				<code>tokens.tl</code> and <code>ansi.tl</code> (which is built
				into <code>tcc</code> as default) to form a target dependent &tdf;
				capsule with all the necessary token definitions, which is then
				translated to a binary object file and linked with the system
				libraries. All of this is under the control of
				<code>tcc</code>.</para>

			<para>Note the four stages of the compilation : &api; specification,
				production, &api; implementation and installation, corresponding to
				the four regions of the compilation diagram (<xref linkend="tdf_scheme"/>).</para>
		</section>

		<section>
			<title>3.5.3. Conditional Compilation within &tdf;</title>

			<para>Although tokens are the main method used to deal with
				target dependencies, &tdf; does have built-in conditional
				compilation constructs. For most &tdf; sorts <code>X</code> (for
				example, exp, shape or variety) there is a construct
				<code>X_cond</code> which takes an exp and two <code>X</code>'s
				and gives an <code>X</code>. The exp argument will evaluate to an
				integer constant at install time. If this is true (nonzero), the
				result of the construct is the first <code>X</code> argument and
				the second is ignored; otherwise the result is the second
				<code>X</code> argument and the first is ignored. By ignored we
				mean completely ignored - the argument is stepped over and not
				decoded. In particular any tokens in the definition of this
				argument are not expanded, so it does not matter if they are
				undefined.</para>

			<para>These conditional compilation constructs are used by the
				C to &tdf; producer to translate certain statements
				containing:</para>

			<programlisting language="c">#if condition</programlisting>

			<para>where <code>condition</code> is a target dependent value.
				Thus, because it is not known which branch will be taken at produce
				time, the decision is postponed to install time. If
				<code>condition</code> is a target independent value then the
				branch to be taken is known at produce time, so the producer only
				translates this branch. Thus, for example, code surrounded by
				<code>#if 0</code> ... <code>#endif</code> will be ignored by the
				producer.</para>
				
			<para>Not all such <code>#if</code> statements can be translated
				into &tdf; <code>X_cond</code> constructs. The two branches of the
				<code>#if</code> statement are translated into the two
				<code>X</code> arguments of the <code>X_cond</code> construct;
				that is, into sub-trees of the &tdf; syntax tree. This can only be
				done if each of the two branches is syntactically complete.</para>
				
			<para>The producer interprets <code>#ifdef</code> (and
				<code>#ifndef</code>) constructs to mean, is this macro is
				defined (or undefined) at produce time? Given the nature of
				pre-processing in C this is in fact the only sensible
				interpretation. But if such constructs are being used to control
				conditional compilation, what is actually intended is, is this
				macro defined at install time? This distinction is necessitated
				by the splitting of the &tdf; compilation into production and
				installation - it does not exist in the traditional compilation
				scheme. For example, in the mips example in section 2.3, whether
				or not <code>mips</code> is defined is intended to be an
				installer property, rather than what it is interpreted as, a
				producer property. The choice of the conditional compilation path
				may be put off to install time by, for example, changing
				<code>#ifdef mips</code> to <code>#if is_mips</code> where
				<code>is_mips</code> is a tokenised integer which is either 1 (on
				those machines on which <code>mips</code> would be defined) or 0
				(otherwise). In fact in view of what was said above about
				syntactic completeness, it might be better to recast the program
				as:</para>
				
			<programlisting language="c">#include &lt;stdio.h&gt;
#include "user_api.h" /* For the spec of is_mips */

int main ()
{
	if ( is_mips ) {
		fputs ( "This machine is a mips\n", stdout ) ;
	}
	return ( 0 ) ;
}</programlisting>

			<para>because the branches of an <code>if</code> statement, unlike
				those of an <code>#if</code> statement, have to be syntactically
				complete is any case. The installer will optimise out the
				unnecessary test and any unreached code, so the use of <code>if (
				condition )</code> is guaranteed to produce as efficient code as
				<code>#if condition</code>.</para>
				
			<para>In order to help detect such "installer macro" problems the
				producer has a mode for detecting them. All <code>#ifdef</code>
				and <code>#ifndef</code> constructs in which the compilation path
				to be taken is potentially target dependent are reported (see [3]
				and [8]).</para>
				
			<para>The existence of conditional compilation within &tdf; also gives
				flexibility in how to approach expressing target dependent code.
				Instead of a "full" abstraction of the user-defined &api; as target
				dependent types, values and functions, it can be abstracted as a
				set of binary tokens (like <code>is_mips</code> in the example
				above) which are used to control conditional compilation. This
				latter approach can be used to quickly adapt existing programs to
				a &tdf;-portable form since it is closer to the "traditional"
				approach of scattering the program with <code>#ifdef</code>'s and
				<code>#ifndef</code>'s to implement target dependent code.
				However the definition of a user-defined &api; gives a better
				separation of target independent and target dependent code, and
				the effort to define such as &api; may often be justified. When
				writing a new program from scratch the &api; rather than the
				conditional compilation approach is recommended.</para>
				
			<para>The latter approach of a fully abstracted user-defined &api; may
				be more time consuming in the short run, but this may well be
				offset by the increased ease of porting. Also there is no reason
				why a user-defined &api;, once specified, should not serve more
				than one program. Similar programs are likely to require the same
				abstractions of target dependent constructs. Because the &api; is a
				concrete object, it can be reused in this way in a very simple
				fashion. One could envisage libraries of private &api;s being built
				up in this way.</para>
		</section>
				
		<section id="S50">
			<title>Alternative Program Versions</title>

			<para>Consider again the program described in section
				2.3.4 which has optional features for displaying its output
				graphically depending on the boolean value
				<code>HAVE_X_WINDOWS</code>. By making
				<code>HAVE_X_WINDOWS</code> part of the user-defined &api; as a
				tokenised integer and using:</para>
				
			<programlisting language="c">#if HAVE_X_WINDOWS</programlisting>
				
			<para>to conditionally compile the X Windows code, the choice of
				whether or not to use this version of the program is postponed to
				install time. If both &posix; and X Windows are implemented on the
				target machine the installation is straightforward.
				<code>HAVE_X_WINDOWS</code> is defined to be true, and the
				installation proceeds as normal. The case where only &posix; is
				implemented appears to present problems. The &tdf; representing the
				program will contain undefined tokens representing objects from
				both the &posix; and X Windows &api;s. Surely it is necessary to define
				these tokens (i.e. implement both &api;s) in order to install the
				&tdf;. But because of the use of conditional compilation, all the
				applications of X Windows tokens will be inside <code>X_cond</code>
				constructs on the branch corresponding to
				<code>HAVE_X_WINDOWS</code> being true. If it is actually false
				then these branches are stepped over and completely ignored. Thus
				it does not matter that these tokens are undefined. Hence the
				conditional compilation constructs within &tdf; give the same
				flexibility in the &api; implementation is this case as do those in
				C.</para>
		</section>
	</section>
</chapter>

