@use all

(*
 * Copyright 2015, The TenDRA Project.
 *
 * See doc/copyright/ for the full copyright terms.
 *
 * This is OCaml binding for TDF Specification.
 *
 * For each TDF SORT (with name 'xxx') there is OCaml type named s_xxx.
 * For each TDF constructor named 'yyy' there is C_yyy variant in OCaml.
 *
 *)

(* AUTOMATICALLY GENERATED BY %ZX VERSION %ZV FROM TDF %VA.%VB *)

open Tdf_types

class reader file = object (self)
(**  This class contains state and methods to read TDF **)

val my_in_channel = open_in file
(** Input channel to read from **)

val mutable last_byte = 0
(** Value of last read byte **)
val mutable have_bits = 0
(** Number of bits to read from last_byte **)
val mutable offset = 0
(** Value of index of last read byte **)

val mutable external_linkage = []
(** capsules external_linkage list **)

val mutable prop_names = []
(** List of PROPS name to read **)

val mutable prop_name = ""
(** Current PROPS name to read **)

val mutable major_version = 0
(** Version read from capsule **)
val mutable minor_version = 0
(** Version read from capsule **)
val mutable header = ""
(** TDF header read from capsule **)

(* Debug purpose methods *)
method get_offset = offset
method get_last_byte = last_byte
method get_have_bits = have_bits
method set_prop_names x = prop_names <- x
method set_prop_name x = prop_name <- x
method set_external_linkage x = external_linkage <- x

method read_byte () =
(** Read one byte from input stream **)
  let buffer = "x" in
  offset <- offset + 1;
  let read = input my_in_channel buffer 0 1 in
  if read = 1 then int_of_char buffer.[0]
  else failwith "Unexpected end of file"

method read_bits size =
(** Read [size] bits from input stream. If [size] <0 skip to end of byte **)
  let rec read_some_bits need_bits value =
     if have_bits = 0 then
     begin
        last_byte <- self#read_byte ();
        have_bits <- 8
     end;
     let bits = min have_bits need_bits in
     begin
        have_bits <- have_bits - bits;
        let result = (value lsl bits) + (last_byte lsr have_bits) in
        last_byte <- last_byte - ((last_byte lsr have_bits) lsl have_bits);
        if need_bits = bits then
           result
        else
           read_some_bits (size - bits) result
     end;
  in
  if size < 0 then
    read_some_bits have_bits 0
  else
    read_some_bits size 0

method read_tdfint () =
   let rec read_digit value =
     let next = self#read_bits 4 in
     if next < 8 then
        read_digit (value * 8 + next)
     else
        value * 8 + next - 8
   in
     read_digit 0

method read_tdfbool () =
  let next = self#read_bits 1 in
  next = 1

method read_tdfstring () =
  let bits  = self#read_tdfint () in
  let rec read_char left value =
    if left = 0 then
      value
    else
      let next = char_of_int (self#read_bits bits) in
      read_char (left - 1) (value ^ String.make 1 next) 
  in
  let count = self#read_tdfint () in
  read_char count ""

method read_tdfident () =
  let bits  = self#read_tdfint () in
  let rec read_char left value =
    if left = 0 then
      value
    else
      let next = char_of_int (self#read_bits bits) in
      read_char (left - 1) (value ^ String.make 1 next) 
  in
  let count = self#read_tdfint () in
  ignore (self#read_bits (-1));  (* Align input stream *)
  read_char count ""

method read_extendable bits =
  let rec read_next offset =
    let value = self#read_bits bits in
    if value = 0 then
      read_next (offset + (1 lsl bits) - 1)
    else
      offset + value
  in read_next 0

method read_bitstream () =
(** Parsing of bitsream is not supporder. Just skip it **)
  let bits  = self#read_tdfint () in
  let () = for j = 1 to bits do
    ignore (self#read_bits 1)
  done in
    Ignore_bitstream

method read_bytestream () =
(** Parse bytestream as PROPS **)
  ignore (self#read_tdfint ());  (* Read byte counter *)
  ignore (self#read_bits (-1));  (* Align input stream *)
  let result = match prop_name with
 | "tld" -> C_tld_props (self#read_tld_props ())
@loop sort
@if sort.unit
 | "%SU" -> C_%SN (self#read_%SN ())
@endif
@end
 | _ -> failwith ("Unknown unit name: " ^ prop_name)
  in
    ignore (self#read_bits (-1));  (* Align input stream *)
    result

method read_tld_props () =
  let version  = self#read_tdfint () in
  let rec read_list left value =
    if left = 0 then
      value
    else
      let item = self#read_tdfint () in
      read_list (left - 1) (value @ [item])
  in
  let rec read_list_of_list left value =
    if left = [] then
      value
    else
      let count = match List.hd left with C_make_extern_link x ->
          List.length x in
      let item = read_list count [] in
      read_list_of_list (List.tl left) (value @ [item])
  in
    C_make_tld
      (version,
       read_list_of_list external_linkage [])

@loop sort
@if !sort.builtin
method read_%SN () =
@endif
@if sort.dummy
@loop sort.cons
@if sort.eq.group
  prop_name <- List.hd prop_names;
  prop_names <- List.tl prop_names;
@endif
@loop cons.param
@if param.align
  ignore (self#read_bits (-1));  (* Align input stream *)
@endif
  let p_%PN = self#read_%PSN () in
@if param.eq.prop_names
  prop_names <- p_prop_names;
@endif
@if param.eq.external_linkage
  external_linkage <- p_external_linkage;
@endif
@end
  C_%CN (
@loop cons.param
@if param.last
    p_%PN)
@else
    p_%PN,
@endif
@end
@end
@else
@if sort.slist
  let rec read_list left value =
    if left = 0 then
      value
    else
      let item = self#read_%SSN () in
      read_list (left - 1) (value @ [item])
  in read_list (self#read_tdfint()) []
@else
@if sort.list
  let () = ignore (self#read_bits 1) in
  let rec read_list left value =
    if left = 0 then
      value
    else
      let item = self#read_%SSN () in
      read_list (left - 1) (value @ [item])
  in read_list (self#read_tdfint()) []
@else
@if sort.option
  let have = self#read_tdfbool () in
  if have then
    Some (self#read_%SSN ())
  else
    None
@else
@if sort.basic
@if sort.extends
  let bits = self#read_extendable %SB in
@else
  let bits = self#read_bits %SB in
@endif
  match bits with
@loop sort.cons
  | %CE ->
@loop cons.param
@if param.align
    ignore (self#read_bits (-1));  (* Align input stream *)
@endif
    let p_%PN = self#read_%PSN () in
@end
@if cons.params
    C_%CN (
@loop cons.param
@if param.last
      p_%PN)
@else
      p_%PN,
@endif
@end
@else
    C_%CN
@endif
@end
  | _ -> failwith "unknown %SN"
@endif
@endif
@endif
@endif
@endif
@end

method read_from_file () =
  (* read whole file from input stream *)
  assert ('T' = char_of_int (self#read_byte ()));
  assert ('D' = char_of_int (self#read_byte ()));
  assert ('F' = char_of_int (self#read_byte ()));
  let c = char_of_int (self#read_byte ()) in
  major_version <- self#read_tdfint ();
  minor_version <- self#read_tdfint ();
  header <- "TDF" ^ String.make 1 c;
  self#read_capsule ()

end
;;

let read file =
  let reader = new reader file in
  reader#read_from_file ()
;;

