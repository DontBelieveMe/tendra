<?xml version="1.0" standalone="no"?>
<!DOCTYPE book SYSTEM "minidocbook.dtd">

<!--
  $Id$
-->

<book>
	<bookinfo>
		<title>Validation of TenDRA Capability to Implement a Set of Commands for
			the Linux Operating System</title>

		<authorgroup>
			<author>
				<firstname>Fran&ccedil;ois</firstname>
				<surname>de Ferri&egrave;re</surname>
				<affiliation>
					<orgname>Open Software Foundation Research Institute</orgname>
				</affiliation>
			</author>

			<author>
				<firstname>Fred</firstname>
				<surname>Roy</surname>
				<affiliation>
					<orgname>Open Software Foundation Research Institute</orgname>
				</affiliation>
			</author>
		</authorgroup>

		<authorgroup>
			<othercredit class="copyeditor">
				<firstname>Katherine</firstname>
				<surname>Flavel</surname>
				<affiliation><orgname>The TenDRA Project</orgname></affiliation>
			</othercredit>

			<othercredit class="copyeditor">
				<firstname>Jeroen</firstname>
				<surname>Ruigrok van der Werven</surname>
				<affiliation><orgname>The TenDRA Project</orgname></affiliation>
			</othercredit>
		</authorgroup>

		<pubdate>1996</pubdate>

		<copyright>
			<year>1996</year>
			<holder>DERA</holder>
		</copyright>

<!-- TODO:
		<para>Last Modified: 04:46pm , July 30, 1996</para>
-->

<!-- TODO:
		<abstract>
			<para>This report describes work done under contract to the Defence
				Research Agency (DRA) of the U.K.	It is an extension of an earlier
				contract to assess the capability of the DRA TenDRA technology to
				express a fully portable operating system implementation.</para>
		</abstract>
-->
	</bookinfo>

	<preface>
		<title>Executive Summary</title>

		<para>During a first phase of the project the main goal was to examine
			the extent to which the TenDRA technology could be used to compile a
			complete operating sytem. This experiment was carried out on the
			Unixware operating system on an Intel 486 platform. Although Unix
			sources are known to be compiler dependent, it was found that most of
			the code could be compiled with no, or minor, modifications.	Details
			of the results can be found in a report.</para>
			<!-- TODO: <biblioref linkend="Ferri&egrave;re95-2">report</biblioref> -->

		<para>The goal of this second phase of the project was
			to study the feasibility of producing Unix commands in architecture
			neutral (ANDF) format which could be readily ported to different
			hardware platforms running the same operating system.	The target
			system chosen for this second phase was Linux, which was available on
			both the Intel and DEC Alpha platforms (although the latter was
			incomplete at the beginning of the project).</para>
			
		<para>The experiment carried out during this second phase was very
			successful.	A significant amount of complex code was converted to the
			architecture neutral ANDF format, and the portability of this code was
			demonstrated. However, due to time constraints, the number of commands
			ported to both platforms was more limited than had been hoped.	The
			project also provided some interesting lessons about the strengths and
			limitations of the ANDF/TenDRA technology and about API issues. This is
			the final report on work undertaken on the Linux operating system on
			the Intel/i386 and Digital/Alpha platforms.</para>
	</preface>

	<chapter>
		<title>Objectives and Description</title>

		<section>
			<title>Objectives</title>
			
			<para>In previous work, we performed validation, performance and
				robustness testing of the TenDRA technology to ensure its capability
				to implement and fully bootstrap a UNIX-like operating system. We also
				provided an assessment of the capability of TenDRA technology to
				express a fully portable operating system implementation. This work
				was very successful, and the results are reported in a
				summary report.
				<!-- TODO: <biblioref linkend="Ferri&egrave;re95-2">summary report</biblioref> -->
			</para>

			<para>However, though we originally planned to conduct this first
				experiment on two different architectures, an Intel/486 and a
				Sun/Sparc platforms running UnixWare, it was completed only for the
				Intel/486 platform.	After discussions with DRA, it was then decided
				to focus the second part of the project on the Unix commands, and to
				switch from the UnixWare to the Linux operating system. The
				motivations for a revised plan were:</para>

			<itemizedlist>
				<listitem>
					<para>OSF is developing a Linux server for the Intel/486 and
						PowerPC platforms, and we would like to deliver the set of
						associated commands in ANDF format. In the event, native Linux
						commands for PowerPC became available in the meantime.</para>
				</listitem>
				
				<listitem>
					<para>Repeating on the Sparc platform the work already done on the
						i486 platform would bring little added-value, while requiring a
						significant amount of work.	The major benefit of the work on a
						second platform would be to demonstrate that a set of commands along
						with its API can be defined in ANDF format and then installed on two
						different platforms.</para>
				</listitem>
			</itemizedlist>

			<para>Thus, the objective of the second part of the project is the
				production in ANDF format of Linux commands, and their installation on
				two platforms. This will demonstrate the ability of the TenDRA
				technology to produce a set of architecture neutral commands and, at
				completion of the project, will provide a set of freely distributable
				commands in ANDF format.</para>

			<para>The project, which lasted 9 months, started on July 1995, and was
				finished at the end of March 1996.</para>

			<para>This report summarizes all the work done under the contract for
				this second part of the project.</para>
		</section>
	
		<section>
			<title>General description</title>
			
			<para>The commands, one part of a Unix system, are based on some
				standard APIs, XPG3 for example, plus some extensions, which together
				form the interface shared with the libraries against which they are
				built. The commands should not have any assembly code, unlike the
				other parts of a Unix system.</para>
			
			<para>As for other software OSF already ported to ANDF, the port of the
				Linux commands is done in three steps:</para>
			
			<itemizedlist>
				<listitem>
					<para>The NAT-NAT step, which consists in rebuilding the commands
				 		 with the native compilation chain, to ensure that they can be
						regenerated from their source files.</para>
				</listitem>
				
				<listitem>
					<para>The DRA-NAT step, for which the TenDRA technology is used as
						a replacement of the native compilation chain to build the commands,
						using the native system header files, as for a classical compilation
						chain. This part involves dealing with discrepancies between the
						native and the TenDRA code generators.</para>
				</listitem>

				<listitem>
					<para>The DRA-DRA step, which will consist in using the TenDRA
						technology as a portability tool. The API shared by the commands and
						libraries is defined, and used to produce the commands in
						architecture independent ANDF code. This code will be installed and
						validated on the selected machines.</para>
				</listitem>
			</itemizedlist>
			
			<para>We initially planned to conduct the experiment on the Intel/i386
				and IBM/PowerPc platforms, both running the Linux operating system.
				However, the Linux system for the IBM/PowerPC platform was still under
				development at the time we needed it, in December 1995. So we decided
				to replace it by a Digital/Alpha platform, the only other platform for
				which a Linux port was sufficiently advanced at that time.	However,
				it is a 64-bit platform, so this switch was more of a challenge,
				because of the fundamental change in data sizes. It provided
				additional tests of the TenDRA portability attributes.</para>
		</section>
	</chapter>

  <chapter id="phases">
    <title>Description of Project phases</title>

    <para>In this section we specify the tasks which have been performed under
      this project.</para>

    <para>The set of commands which were ported to ANDF was split into two
      subsets:</para>

    <itemizedlist>
      <listitem>
		<para>The <emphasis>level 1</emphasis> subset corresponds to the level achieved
        with UnixWare at the end of the first project (about 100 commands out
        of 600).  These commands conform to a standard interface (Posix or
        XPG) with some simple extensions. They do not use extensions which are
        difficult to port from one system to another.  This set includes about
        150 Linux commands.</para>
	</listitem>
      
      <listitem>
		<para>The <emphasis>level 2</emphasis> subset corresponds to the maximum which can
        be reasonably achieved for a given system. While we could expect about
        twice as many commands as for level 1, we only compiled about 75 more
        commands.</para>
	</listitem>
    </itemizedlist>

    <section>
      <title>Phase 1: level 1 commands on Intel/i386</title>
      
      <para>The objective is to produce a &ldquo;level 1&rdquo; set of Linux commands in
        ANDF format for the Intel platform. This requires the production of
        the associated API, also in ANDF format (token library).</para>

      <para>The major tasks for this phase are:</para>

      <section>
        <title>T1. Linux installation.</title>
        
        <orderedlist>
          <listitem><para>Install the Linux system.</para></listitem>
          
          <listitem><para>Install a compilation environment.</para></listitem>
          
          <listitem><para>Install the Linux source code.</para></listitem>
        </orderedlist>
        
        <para>Prerequisite: Linux system for
          Intel.</para>

        <para>Delivery: System running.</para>
      </section>
        
      <section>
        <title>T2. TenDRA installation.</title>
          
        <orderedlist>
          <listitem><para>Install the TenDRA technology for Linux.</para></listitem>
        </orderedlist>
        
        <para>Prerequisite:TenDRA technology &amp;
          T1.</para>
        
        <para>Delivery: TenDRA installed.</para>
      </section>
          
      <section>
        <title>T3. Level 1 commands port.</title>
        
        <orderedlist>
          <listitem><para>Define the level 1 set of Linux commands.</para></listitem>
          
          <listitem><para>Compile the level 1 commands in NAT-NAT mode.</para></listitem>
          
          <listitem><para>Compile the level 1 commands in DRA-NAT mode.</para></listitem>
        </orderedlist>
        
        <para>Prerequisite: Linux source code, T1 &amp;
          T2.</para>

        <para>Delivery: Level 1 commands compiled with
          TenDRA in native mode.</para>
      </section>

      <section>
        <title>T4. Level 1 commands API definition.</title>
        
        <orderedlist>
          <listitem><para>Define the non-explicit API used by this set of commands.
            Machine dependent code issues will be addressed
            specifically.</para></listitem>
        </orderedlist>
        
        <para>Prerequisite: Linux source code.</para>

        <para>Delivery: Set of ANDF header files for this
          level 1 API.</para>
      </section>
        
      <section>
        <title>T5. ANDFization of Level 1 commands.</title>
        
        <orderedlist>
          <listitem><para>Produce the level 1 commands with the TenDRA technology,
            using the ANDF definition of the API defined in the previous
            task.</para></listitem>
        </orderedlist>
        
        <para>Prerequisite: Linux source code, T2 &amp;
          T4.</para>

        <para>Delivery: Level 1 commands in ANDF
          format.</para>
      </section>

      <section>
        <title>T6. Level 1 commands API installation.</title>
        
        <orderedlist>
          <listitem><para>Build the token library for the level 1 commands
            API.</para></listitem>
        </orderedlist>

        <para>Prerequisite: T2 &amp; T4.</para>

        <para>Delivery: Token library for this level 1
          API.</para>
      </section>

      <section>
        <title>T7. Level 1 commands installation and validation.</title>
        
        <orderedlist>
          <listitem><para>Install the commands in ANDF format produced in task T5.
          </para></listitem>

          <listitem><para>Validate the commands using adhoc tests.</para></listitem>

          <listitem><para>Write a report that describes the results obtained and
            the problems encountered.</para></listitem>
        </orderedlist>

        <para>Prerequisite: T2, T5 &amp; T6.</para>

        <para>Delivery: Report on level 1 commands on
          Intel.</para>
      </section>
    </section>

    <section>
      <title>Phase 2: level 1 commands on Digital/Alpha</title>
      
      <para>The objective is to validate that the commands produced during the
        first phase can be easily ported to the Alpha platform.</para>
      
      <para>The major tasks, during this phase, are:</para>

      <section>
        <title>T8. Linux installation.</title>

        <orderedlist>
          <listitem><para>Install the Linux system.</para></listitem>

          <listitem><para>Install a compilation environment, including header files
            and libraries.</para></listitem>
        </orderedlist>
        
        <para>Prerequisite: Linux system for
          Alpha.</para>
        
        <para>Delivery: System running.</para>
      </section>

      <section>
        <title>T9. TenDRA installation.</title>
        
        <orderedlist>
          <listitem><para>Adapt the TenDRA technology for Linux on the
            Alpha.</para></listitem>

          <listitem><para>Install the TenDRA technology.</para></listitem>
        </orderedlist>
        
        <para>Prerequisite: TenDRA technology &amp;
          T8.</para>
        
        <para>Delivery: TenDRA installed.</para>
      </section>

      <section>
        <title> T10. Level 1 commands API installation.</title>
        
        <orderedlist>
          <listitem><para>Build the token library for the level 1 commands
            API.</para></listitem>
        </orderedlist>
        
        <para>Prerequisite: T4 &amp; T9.</para>

        <para>Delivery: Token library for this level 1
          API.</para>
      </section>

      <section>
        <title> T11. Level 1 commands installation and validation.</title>
        
        <orderedlist>
          <listitem><para>NAT-NAT and DRA-NAT check.</para></listitem>
          
          <listitem><para>Install the commands in ANDF format produced in task
            T5.</para></listitem>
          
          <listitem><para>Validate the commands using adhoc tests.</para></listitem>
          
          <listitem><para>Write a report that describes the results obtained and
            the problems encountered.</para></listitem>
        </orderedlist>
        
        <para>Prerequisite: T5, T9 &amp; T10.</para>

        <para>Delivery: Report on level 1 commands on
          Alpha.</para>
      </section>
    </section>

    <section>
      <title>Phase 3: level 2 commands on Intel/i386 and Digital/Alpha</title>

      <para>The objective during this phase is to validate further the ANDF
        tools by trying to extend the ANDF commands to a broader set that will
        include some &ldquo;difficult&rdquo; cases.</para>
      
      <para>The major tasks are:</para>


      <section>
        <title>T12. Level 2 commands port.</title>
    
        <orderedlist>
          <listitem><para>Define the level 2 set of Linux commands, by extension of
            the level 1 set.</para></listitem>
          
          <listitem><para>Compile the level 2 commands in NAT-NAT mode on
            Intel.</para></listitem>
          
          <listitem><para>Compile the level 2 commands in NAT-NAT mode on
            Alpha.</para></listitem>
          
          <listitem><para>Compile the level 2 commands in DRA-NAT mode on
            Intel.</para></listitem>
          
          <listitem><para>Compile the level 2 commands in DRA-NAT mode on
            Alpha.</para></listitem>
        </orderedlist>
    
        <para>Prerequisite: Linux source code, T1, T2, T8
          &amp; T9.</para>
    
        <para>Delivery: Level 2 commands compiled with
          TenDRA in native mode.</para>
      </section>
    
      <section>
        <title>T13. Level 2 commands API definition.</title>
    
        <orderedlist>
          <listitem><para>Extend the level 1 API to include the interfaces used by
            the level 2 commands.</para></listitem>
        </orderedlist>
    
        <para>Prerequisite: Linux source code &amp; T4.</para>
    
        <para>Delivery: Set of ANDF header files for this level 2 API.</para>
      </section>
    
      <section>
        <title>T14. Level 2 commands ANDFization.</title>
    
        <orderedlist>
          <listitem><para>Produce the level 2 commands with the TenDRA technology,
            using the ANDF definition of the API defined in the previous
            task.</para></listitem>
        </orderedlist>
    
        <para>Prerequisite: Linux source code, T2, T9 &amp; T13.</para>
        
        <para>Delivery: Level 2 commands in ANDF format.</para>
      </section>

      <section>
        <title>T15. Level 2 commands API installation.</title>

        <orderedlist>
          <listitem><para>Build the token library for the level 2 commands API on
            Intel.</para></listitem>
          
          <listitem><para>Build the token library for the level 2 commands API on
            Alpha.</para></listitem>
        </orderedlist>

        <para>Prerequisite: T2, T9 &amp; T13.</para>

        <para>Delivery: Token library for this level 2 API.</para>
      </section>

      <section>
        <title>T16. Level 2 commands installation and validation.</title>

        <orderedlist>
          <listitem><para>Install the commands in ANDF format produced in task T14
            on Intel.</para></listitem>

          <listitem><para>Install the commands in ANDF format produced in task T14
            on Alpha.</para></listitem>
          
          <listitem><para>Validate the commands using adhoc tests.</para></listitem>

          <listitem><para>Write an intermediate report and a final
            report.</para></listitem>
        </orderedlist>
          
          <para>Prerequisite: T2, T9, T14 &amp; T15.</para>

          <para>Delivery: Intermediate report on level 2 commands, and
            final report.</para>
      </section>
    </section>
  </chapter>

  <chapter>
    <title>Project environment</title>

    <section>
      <title>LINUX operating system</title>

      <para>Linux is a free Unix-like operating system, first developed by
        Linus Torvalds on an Intel platform; &ldquo;official&rdquo; releases exist since
        October 1991.</para>

		<para>It has now been ported to Digital/Alpha and ports to other
			machines, including PowerPC andPowerMAC, are under way.</para>

  <section>
  <title>Linux on Intel/i386</title>

  <para>There are many distributions of Linux for the Intel
  platform; we installed the Slackware distribution, based on the Linux 1.1
  version.</para>

  <para>We downloaded it from the ftp site: <ulink
  url="ftp://sunsite.unc.edu/pub/Linux/distributions/slackware">sunsite.unc.edu:/pub/Linux/distributions/slackware</ulink></para>

  <para>The version we installed was Linux 1.1.59, available since
  October 1994. Since then, newer versions have been released, but we stuck to
  this version throughout the project since it worked well, and because all the
  packages it included were easily available in source form (see below).</para>
  </section>

  <section>
  <title>Source code for Linux commands used by the project</title>

  <para>We downloaded the source code of the Linux commands from
  the ftp site: <ulink url="ftp://sunsite.unc.edu/pub/Linux/distributions/slackware/source">sunsite.unc.edu:/pub/Linux/distributions/slackware/source</ulink>.</para>

  <para>This means that the versions of commands available on our
  development machine for Linux/i386 were matching the source code we used as base
  for the project, except in a few cases for which the source code had been
  revised.</para>
  </section>

  <section>
  <title>Linux on Digital/Alpha</title>

  <para>For the Alpha platform, Linux is available from the BLADE
  distribution, and more recently from the Red Hat distribution.</para>

  <para>A 32-bit version of Linux/Alpha was first released in
  January 1995; then a 64-bit version was available in November 1995, which
  included most of the capabilities provided by the Linux/Intel system. We
  downloaded the BLADE_0.3 release, consisting of more than thirty floppy images,
  from the ftp site: <ulink url="ftp://ftp.digital.com/pub/DEC/Linux-Alpha">ftp.digital.com:/pub/DEC/Linux-Alpha</ulink></para>

  <para>Since December 1995, another Linux/Alpha distribution has
  become available from the RedHat company; it is built from the same components,
  but newer versions, as the BLADE release.</para>

  <para>An interesting feature of the current Linux/Alpha ports, is
  that they provide rather extensive binary compatibility with Digital Unix. This
  compatibility has been used to cross-build on Digital Unix for Linux/Alpha, and
  also for a few features which were not available in the Linux/Alpha BLADE
  release.</para>
</section>

  </section>

  <section>
  <title>Hardware platforms and environment</title>

  <para>The Intel platform was an Intel/i486 PC machine, with
      most disk space available through NFS.</para>

  <para>The Digital/Alpha platform was built specifically for
  this project, around a Digital AXPpci 33 motherboard. In fact, at the
  time we set-up the machine, the Linux/Alpha ports were only running on a few
  Alpha-based machines.</para>

  <para>A Linux kernel had to be rebuilt for this machine in order
  to add support for the 3COM Ethernet board we used, and for the NFS-client
  capability. Most disk space was thus available through an NFS file system,
  shared with the Intel platform.</para>
  </section>

  <section>
  <title>TenDRA technology</title>

  <para>We started the project on an Intel platform with a snapshot of the
    TenDRA technology from April 1995, which included support for the
    Linux/Intel platform. This snapshot was based on the ANDF 3.1
    specification.</para>

  <para>We switched to the November 1995 TenDRA snapshot, based on ANDF 4.0,
    when we setup the second platform, in order to use the tools for the
    Digital Unix/Alpha platform. Because of the high degree of compatibility
    between Digital Unix and Linux on Alpha, we could use the TenDRA
    technology on a DigitalUnix/Alpha platform to cross-build executables for
    the Linux/Alpha platform.</para>

  <para>The ANDF 4.0 intermediate file format is not upward compatible with
    the ANDF 3.1 one, which required that we rebuild the intermediate ANDF
    files for the Linux commands we had already built.</para>

  <para>ANDF 4.0 contains increased capability, though not required by this
    project, and forms the basis for the X/Open preliminary
    specification XANDF.</para>
</section>
</chapter>

  <chapter>
    <title>Descriptions and Results of Project phases</title>

  <para>In the next paragraphs, we describe the way we accomplished
  the various tasks of the project and we summarize their results.</para>

  <section>
    <title>Linux installation</title>

  <para>At the beginning of the project, we installed the Linux operating
    system release 1.1 on an Intel/i386 machine. In December 1995, after a few
    months of work on the Intel/i386 platform, we installed Linux on the
    second platform for the project, which is a Dec/Alpha. Linux was first
    released on this platform at the beginning of 1995.</para>

  <section>
  <title>Linux/i386 installation (including the source code for commands)</title>

  <para>A machine with Linux 1.1.59 from the Slackware
  distribution, including the native compilation chain and libraries from GNU, was
  setup for the project.</para>
  <para>The Linux system is available on several anonymous ftp
  sites. The one we used was at  sunsite.unc.edu, where a distribution of the
  sources and binaries of the Intel/Linux commands from Slackware was available
  under the /pub/Linux/distributions/slackware directory. Note that the current
  Slackware distribution at the time of writing of this report is based on Linux
  3.0.</para>

  <para>In the Slackware Linux distribution for Intel/ix86, the
      delivery of the source code for commands is split into a large number of
      <firstterm>packages</firstterm>. The contents of each source package must be compiled
      and installed individually. For example, the &awk; command,
      actually &gawk;, belongs to the <code>bin</code> package which contains
      56 commands, while the &bc; command belongs to the <code>bc</code>
      package which contains only this one command.  Consequently, we did not
      download the whole set of sources for the Linux commands, but selected a
      few packages containing the sources of the commands we intended to build
      first. We also had a look at the Caldera Linux source distribution, and
      it appeared to be organized in the same way.</para> <para>
      A Slackware Linux package for source code distribution is
      made of a compressed tar files (usually only one), optional patch
      file(s), and a shell script. The execution of this shell script installs
      the source files from the tar file(s), applies patches if necessary,
      optionally performs a self-configuration step, runs the makefile(s) for
      the compilation, and finally generates a binary package which holds the
      resulting executables. This procedure has been adapted to fit the
      NAT-NAT, DRA-NAT and DRA-DRA development steps on two platforms, as
      described in the section <ulink url="linux_re.htm#4846">Setting up the
      build environment</ulink>.</para>

  <para>Note that each package has a private version number. Thus
  packages can be maintained and released independently. Moreover, some packages
  (e.g. the <code>bin</code> package) are a collection of several &ldquo;subpackages&rdquo;, each
  of which has its own version number.</para>
  </section>
  <section>
  <title>Linux/Alpha installation</title>
  <para>The Linux Operating System port to the Digital Alpha architecture
    started two years ago. The first user-installable distribution was
    available in January 95, from the BLADE distribution, and was a 32-bit
    version. Then came a 64-bit version which was made compatible with Digital
    Unix with respect to basic C language types:</para>

  <table>
<col align="center"/>
<col align="center"/>
<thead>
	<tr><th>Type</th>
	<th>Size</th></tr>
</thead>
<tbody>
    <tr>
      <td><code>int</code></td>
      <td>32-bit</td>
    </tr>
    
    <tr>
      <td><code>long</code></td>
      <td>64-bit</td>
    </tr>
    
    <tr>
      <td>pointer</td>
      <td>64-bit</td>
    </tr>
</tbody>
  </table>

  <para>While it is still under development, Linux/Alpha is now robust and
    includes most of the capabilities provided by the Linux/Intel
    system.</para>

  <para>The BLADE distribution was the first available distribution for
    Linux/Alpha. For the project, we retrieved the November 95 BLADE_0.3
    release, based on the Linux 1.3 development kernel, at the following
    site:</para>

  <para><ulink url="ftp://ftp.digital.com/pub/DEC/Linux-Alpha">ftp.digital.com:/pub/DEC/Linux-Alpha</ulink></para>

  <para>This release consists of more than thirty 3.5'' floppy images (not
    including X-Window). The source code for the commands is not a part of
    this distribution. Since then, several new versions for the boot firmware,
    kernel, compiler and libraries have been released, but, as we encountered
    minor problems only with BLADE_0.3, we did not upgrade our system.</para>

  <para>Since December 95, another distribution of Linux for Dec/Alpha is also
    available from the RedHat company; the current version is:</para>

  <para><ulink url="ftp://ftp.redhat.com/pub/redhat/redhat-2.1/axp">ftp.redhat.com:/pub/redhat/redhat-2.1/axp</ulink></para>

  <para>This distribution includes all the source packages for the components
    it is made from, along with some fixes and additions, in both binary and
    source forms. It is possible to unpack a RedHat Linux/Alpha 2.1 set while
    not running the RedHat Linux, but, as a proprietary packaging format is
    used, one should install the packaging tools (&rpm;) first.</para>

  <para>At the time we setup the machine, Linux/Alpha was operational only on
  a few variants of Digital Alpha-based systems. So, we selected an entry
  level and rather inexpensive board, the Digital AXPpci 33
  Alpha PC motherboard, around which we built a machine. Our Linux/Alpha system
  currently comprises the following:</para>

  <itemizedlist>
    <listitem><para>an 8-slot enclosure with 200W power supply and fan</para></listitem>

    <listitem><para>Digital AXPpci 33 motherboard, Windows NT (ARC) firmware, PS/2
      style keyboard interface, 233 Mhz Alpha processor</para></listitem>
    <listitem><para>2x16MB, 36-bit, 70ns SIMMs</para></listitem>
    <listitem><para>256 KB, 20ns cache [optional part]</para></listitem>
    <listitem><para>a Number 9 GXE VGA display adapter (ISA)</para></listitem>
    <listitem><para>a dumb VGA display</para></listitem>
    <listitem><para>a PS/2 style keyboard</para></listitem>
    <listitem><para>a 3.5''/1440K floppy disk drive</para></listitem>
    <listitem><para>a SCSI-2 hard disk (a DECpc 2.0GB disk from Digital)</para></listitem>
    <listitem><para>a 3COM Ethernet Link-II (aka 3c503) controller (ISA).</para></listitem>
  </itemizedlist>

  <para>We installed the BLADE_0.3 distribution on our machine, including the
    C compilation chain and libraries. In order to use the 3COM Ethernet
    board, we had to rebuild the kernel. We used almost all of the default
    kernel build parameters, except for the Ethernet adapter, for the settings
    for the TGA graphics support (switched to &ldquo;no&rdquo;) and for the NFS-client
    feature (selected). Note that a kernel rebuild takes more than half an
    hour on our system.</para>

  <para>A very interesting feature of the current releases of
    Linux/Alpha is that they provide an almost perfect binary compatibility
    with Digital Unix. This was of great help to us, as will be described
    later.</para>

  <para>Among the various updates to the Linux/Alpha boot
    loader, kernel, C compiler and libraries, commands, ..., which have been
    made by the Linux-Alpha development teams, we have used only a
    few:</para>

  <itemizedlist>
    <listitem>
		<para>upgrade of the <command>sed</command> command: some sed scripts
	      used for modifying the system headers when building the APIs with TenDRA
	      caused the original <command>sed</command> command to abort.</para>
	</listitem>

    <listitem>
		<para>upgrade of a few system headers, extracted from the azstarnet
	      <filename>inc-and-libs-0.38.tar.gz</filename> file.</para>
	</listitem>
  </itemizedlist>

  <para>These two updates were downloaded from the site</para>
  
  <para><ulink url="ftp://ftp.azstartnet.com/pub/linux/axp">
    ftp.azstartnet.com:/pub/linux/axp</ulink></para>
  
  <para>We encountered a few problems with the BLADE_0.3
    release on the AXPpci Alpha board:</para>


  <itemizedlist>
    <listitem><para>The floppy disk driver sometimes entered a time-out, as
      indicated by a console message.</para></listitem>

    <listitem><para>Some shell scripts failed until a #!/bin/sh line, or equivalent,
      was inserted. According to a member of the Linux/Alpha development team,
      it is caused by the kernel command loader, and was fixed in new kernel
      releases. We worked-around this problem by patching a number of shell
      script files included with various source packages we were building on
      Linux/Alpha: we realized too late that it would have been preferable to
      upgrade the kernel.</para></listitem>

    <listitem><para>Linux/Alpha failed to mount an NFS file system served by a HP-UX
      release 8 machine. Fortunately, this problem disappeared when using a
      server running Solaris or HP-UX release 9: we had to move our
      development tree to such a host.</para></listitem>

    <listitem><para>As mentioned above, the sets of source files were shared through
      NFS between a Linux/Intel, a Digital Unix and a Linux/Alpha platform.
      Occasionally, Linux/Alpha lost access to a file that had been updated
      recently by another NFS client: the error message &ldquo;Stale NFS file
      handle&rdquo; was displayed.  Unmounting/remounting the NFS file system
      usually cured such problems.</para></listitem>

    <listitem><para>During kernel rebuilds, the compilation of at least one file
      failed because of lack of memory: in the makefiles for kernel rebuild,
      the gcc compiler is called with the <code>-pipe</code> option, which speeds up the
      build but is not safe when compiling large source files. We wrote a
      small shell script which redoes a compilation without the <code>-pipe</code>
      option. (This problem was fixed by a subsequent kernel release:
      <filename>tcpip.c</filename> was split into several parts...)</para></listitem>
  </itemizedlist>
</section>
  </section>

  <section>
  <title>TenDRA installation</title>

  <para>We first installed the TenDRA technology on the Linux/i386
  platform, from the April 1995 snapshot. Later, we installed the November 1995
  release, the first to include support for the Dec/Alpha machine, in order to
  start work on the Linux/Alpha platform. However, because this snapshot was not
  upward compatible with the previous TenDRA release, we also had to install it on
  the Linux/i386 platform. We did not upgrade to the February 1996 snapshot,
  though it is compatible with the previous one. We only used it in a few cases
  when we had a bug in a command and wanted to make sure that it was not due to a
  problem already fixed in TenDRA.</para>

  <section>
  <title>TenDRA installation on Intel/i386</title>
  <para>The TenDRA snapshot from April 1995, based on TDF 3.1,
  included support for the Linux/i386 platform. So, the installation on our
  machine was straightforward. We only had to recompile the tcc driver, and to
  modify some environment and startup files to fine tune the level of checking.</para>
  <para>When we started to work on the second platform, we had to
  install the November 1995 snapshot of the TenDRA technology (see below). This
  was DRA's first snapshot based on TDF 4.0, and it included significant changes
  to the installation procedure. We had some difficulties to install this
  snapshot, due to a few bugs in the new installation procedures, but once
  installed the technology appeared to work well.</para>
  </section>

  <section id="installonalpha">
  <title>TenDRA installation on DEC/Alpha</title>
  <para>The TenDRA snapshot from November 1995 was the first
  snapshot with support for the Dec/Alpha platform, but was not upward compatible
  with the one installed on the Intel platform (TenDRA 4.0 versus TenDRA 3.1). So,
  the TenDRA snapshot from November 1995 was installed on both the Intel/i386 and
  the Dec/Alpha platforms.</para>

  <para>DRA provide support for the DigitalUnix/Alpha platform, not
  for the Linux/Alpha one. However, we benefited from the compatibility between
  Digital Unix and Linux to solve this problem. We made three different
  installations of the TenDRA technology for Alpha, among which the 2nd was fully
  operational for Linux/Alpha:</para>


	<itemizedlist>
		<listitem>
			<para>First installation on native Digital Unix/alpha.</para>
		</listitem>

		<listitem>
			<para>Second installation, still on Digital Unix, but for cross-development for
				Linux/Alpha (termed &ldquo;lin_alpha_cross&rdquo;).</para>
		</listitem>

		<listitem>
			<para>Third installation on Linux/Alpha (termed &ldquo;lin_alpha&rdquo;).</para>
		</listitem>
	</itemizedlist>

  <para>The first installation was straightforward and worked very
  well. The main purpose was to ensure that the TenDRA technology worked correctly
  on Dec/Alpha.</para>

  <para>For the second installation, we created a new target
  platform termed &ldquo;lin_alpha_cross&rdquo;. Most of the &ldquo;lin_alpha_cross&rdquo; files are
  shared with Digital Unix, using symbolic links to directories or files, since
  only a few files differ between the two targets. The main purpose of these
  changes was to use Linux/Alpha system header files when compiling, instead of
  the Digital Unix system header files, and Linux/Alpha libraries and startup
  files when link-editing. For example, we changed three files inside the <code>&lt;target_platform&gt;/private/env</code>
  directory named <filename>default</filename>, <filename>system</filename> and <filename>tcc_diag</filename>. For the
  same reason, we created a specific &ldquo;lin_alpha_cross&rdquo; subdirectory in lib/system
  to hold some replacement system header files when cross-compiling with the <code>-Ysystem</code>
  option (i.e. in DRA-NAT mode). The target dependent directories and files used
  when (cross-)building APIs for Linux/Alpha, e.g. located under the <filename>src/apis/libs</filename>
  directory, were also made specific.</para>

  <para>Using this installation, we could cross-compile and
  cross-link on Digital Unix for Linux, without any problem. The binary
  compatibility between Linux/Alpha and Digital Unix was thus a key factor of
  success.</para>

  <para>The third TenDRA installation for Linux/Alpha was readily
  derived from the previous one. We benefited again from the binary compatibility
  with Digital Unix: we ran the TenDRA compilation chain, built for Digital Unix,
  on top of Linux/Alpha, without the necessity to port it or recompile it.
  However, to do so, we had to copy and install the shared library tools of
  Digital Unix on Linux/Alpha because TenDRA uses shared libraries, for which
  there is currently no support in Linux/Alpha. The Digital Unix shared libraries
  mechanism works fine under Linux! This trick could have be avoided if we had
  re-linked the TenDRA tools under Digital Unix using its statically-linked
  libraries.</para>

  <para>In order to use the Linux/Alpha native assembler and
  link-editor instead of those from Digital Unix, we wrote a front-end shell
  script to the TenDRA installer (trans). This shell script calls the actual trans
  tool with an option to output a source assembly file instead of the &ldquo;binary
  assembly&rdquo; files used by the Digital Unix as1 tool. Similarly, we wrote a
  front-end shell script which emulates the call made by tcc to as1 by a call to
  the Linux as tool. We give below the changes to the settings in &lt;lin_alpha&gt;/private/env/default
  for the third installation:</para>

  <programlisting language="env">+TRANS "/..../linux/1.3.45/alpha/private/bin/trans.sh"
+AS1   "/..../linux/1.3.45/alpha/private/bin/as1.sh"
+AS    "/usr/bin/as -nocpp" # seems unused
+LD    "/usr/bin/ld -G8 -O1"</programlisting>

  <para>However, despite these modifications, the port of the TenDRA
  installer to Linux/Alpha could not be completed. In some cases, the TenDRA
  installer appeared to generate assembly instructions that are not recognized by
  the Linux/Alpha assembler. For example, the following lines could not be
  assembled properly by Linux/Alpha:</para>

  <screen>.extern __ctype_ 8
	Error: Rest of line ignored. First ignored character is '8'

stq $fp, 8($sp)
	Warning: Illegal operands

bis $17,$17,$fp
	Warning: Illegal operands

.frame $fp, 360, $26, 0
	Error: bad absolute expression; zero assumed</screen>

  <para>We now understand it is not surprising that we were unable
  to use the TenDRA installer for Digital Unix/Alpha on Linux/Alpha. ANDF
  installer output needs to be tailored for different target operating systems
  according to the assembler and/or link editor interfaces supported by the target
  operating system. In our case we attempted to use the assembler interface, and
  the errors and warnings above are examples where this interface differs between
  Digital Unix/Alpha and Linux/Alpha. Debugger support and even some details of
  the procedure calling conventions may also need to be taken into account when
  tailoring an ANDF installer to a different operating system.</para>

  <para>Since we had already set up a cross-development TenDRA
  environment for Linux/Alpha, hosted by Digital Unix, we continued to use it and
  discontinued use of the &ldquo;lin_alpha&rdquo; installation. We actually installed TenDRA
  on an NFS file server (used by the Linux/ i386, the Digital Unix and the
  Linux/Alpha platforms).</para>
</section>
</section>

<section>
  <title>Build environment with TenDRA</title>

  <section>
  <title>Definition of the set of Linux commands</title>

  <para>The definition of the set of commands has not been done once
  for all. It has been done on the Intel/i386 platform, during the first part of
  the project, in two steps, level1 and level2, as described in <xref linkend="phases"/>.
  Each step has been performed as an incremental process.
  Each time new commands were selected, a
  whole cycle of API definition (<xref linkend="apidef"/>),
  command ANDFization (<xref linkend="andfization"/>), API
  installation (<xref linkend="apiinstallation"/>) and command
  installation and validation (<xref linkend="installandvalid"/>) was
  performed.</para>

  <para>During the first phase of the project, a number of commands
  have been compiled in DRA-DRA mode on the Unixware platform (see &unix-validation.doc;).
  We started by locating these commands in the
  packages from the Slackware Linux source distribution for Intel/ix86. Since
  these commands were among the simplest ones to ANDFize on Unixware, they were
  good candidates to start with. Provided that a full binary installation was made
  on our Linux/i386 platform, a command could be located in a package by searching
  for its name in the list of packages under the <filename>/var/adm/packages</filename>
  directory. This directory contains one text file per installed package, which
  records the names of the commands it contains (actually the relative
  installation path from / is provided for each command). When the name of the
  package which holds a command has been found, we just had to connect to the ftp
  site, find the directory of the same name in the Slackware source distribution,
  and download the files under this directory.</para>

  <para>Among the 103 Unixware commands ANDfized during the previous
  phase of this project, we found 59 commands with similar name in Linux,
  scattered among 11 packages: <code>bc</code>, <code>bin</code>,
	<code>bsdgames</code>, <code>diff</code>, <code>find</code>, <code>grep</code>, <code>gzip</code>,
  <code>sh_utils</code>, <code>txtutils</code> and <code>util</code>.
	Moreover, these packages also contained
  some additional commands which appeared to be good candidates for easy
  ANDFization. However, we excluded a few of them which were compiled but not
  delivered in the binary package, or which seemed too dependent on the target
  platform (e.g. the
  <code>fdformat</code> command which formats floppy disks). We also selected four
  additional packages, <code>tar, cpio, xlock</code> and <code>xgames</code>, in order to
  complete the <code>level 1</code> set of commands.</para>

  <para>The definition of the <code>level 2</code> set of commands was
  more difficult than for <code>level 1</code>, because we had to reject a number of
  commands, for various reasons discussed below.</para>

  <para>First, we tried to include in the <code>level 2</code> set of
  commands more commands from X11, as we successfully experimented the ANDFization
  of a few of them for<code> level 1</code>. However it appeared that this was not so
  easy: the sources for these commands had not been packaged by Slackware, but
  were provided inside a huge collection of sources named <code>Xfree86</code> (from
  the Xfree86 Project, Inc.), itself derived from the X Consortium X11R6 code. An
  attempt to perform the first step of the build of Xfree86 on Linux/i386, which
  consisted in producing Makefiles from Imakefiles, failed. With some rewriting,
  we managed to produce a Makefile for a simple Xfree86 command, <code>xclock</code>,
  and successfully compiled it. However, we did not spend much time on
  understanding the installation procedures of Xfree86, and, since it would have
  taken us too much time per command to rewrite every Makefile, we set aside
  Xfree86.</para>

  <para>Then we excluded one package, <code>groff</code>, because it was
  mostly coded in C++. We found also that some native Linux header files, used in
  several packages, offer BSD compatibility but in a way that could not be
  straightforwardly adapted to TenDRA. This issue is discussed in <xref linkend="apidef"/>.</para>

  <para>We have included in the <code>level 2 </code>set of commands some
  commands which represent quite large amounts of source code: <code>m4, elvis</code>
  (a <code>vi</code> clone), <code>joe</code> (another editor), <code>less</code>, <code>perl</code>
  and <code>elm</code>. The ultimate step of this experiment would have been to build
  &ldquo;monsters&rdquo; such as <code>bash</code> and <code>emacs</code>.</para>

  <para>Finally, we evaluated the number of commands distributed
  with a Linux system, and we found about 700 executable binary files in the
  /usr/bin, /bin, /usr/X11/bin, /usr/openwin/bin, /usr/games, /sbin and /usr/sbin
  directories. We examined some of these commands in the Slackware packages, and
  concluded that there could be candidates for ANDFization. But we were limited by
  time constraints to include such commands. Also, we did not port to the 2nd
  platform, nor validate, all the commands operational on the 1st platform. Here
  again, time is the main reason why we did not complete the port. We estimate
  that an additional 1.5 engineer-month would have been sufficient to complete the
  task, apart from some commands which may have been difficult to port.</para>

  <para>The <code>level1 </code>and <code>level2</code> set of commands
  include 236 commands: these commands were installed and validated on Linux/i386
  (cf. section 4.7 on this point).</para>

  <para>In the list below, the commands in <emphasis>bold</emphasis> (149) have
  been installed and validated on both Linux/i386 and Linux/Alpha, as opposed to
  the commands listed in plain characters, which are available on the first
  platform only.</para>

  <para>The few (13) commands listed in <replaceable>italic</replaceable> were ported
  to both platforms, but their validation failed, or was not completed, on the
  second platform.</para>

  <para>Finally, in the &ldquo;p/m&rdquo; statements, p is the
  best-case number of commands we ported, while m is the maximum number of them
  with respect to a given Slackware Linux package.</para>


<table>
<col align="center"/>
<col align="center"/>
<col align="left"/>
<thead>
<tr>
<th>Package</th>
<th>Total</th>
<th>Commands ported</th>
</tr>
</thead>

<tbody>
  <tr> <td>aaa_base</td> <td>9/9</td> <td>fromdos, funzip, mtools, todos,
  unzip, unzipsfx, zip, zipnote, zipsplit.</td> </tr>
  <tr> <td>ash</td> <td>1/1</td> <td>ash.</td> </tr>
  <tr> <td>bc</td> <td>1/1</td> <td><emphasis>bc</emphasis>.</td> </tr>
  <tr> <td>bin</td> <td>48/56</td> <td>at, <emphasis>bban, bpe, chgrp, chmod, chown</emphasis>,
  compress, <emphasis>cp</emphasis>, crond, crontab, <emphasis>ctags, dd, df,</emphasis> dircolors, <emphasis>du</emphasis>,
  ed, <emphasis>elvis, elvprsv, elvrec</emphasis>, file, fiz, <emphasis>fmt</emphasis>, <replaceable>gawk</replaceable>, <emphasis>ginstall</emphasis>,
  indent, <emphasis>ln, ls, man, mkdir, mkfifo, mknod, mv, patch, ref, rm, rmdir</emphasis>,
  sed, <emphasis>shar, sysvbanner, time, touch, tput</emphasis>, unarj, <emphasis>unshar, uudecode,
  uuencode, which</emphasis>, zoo.</td> </tr>
  <tr> <td>bsdgames</td> <td>13/36</td> <td>bcd, caesar, factor, fish, monop,
  morse, number, paranoia, ppt, primes, rain, worm, worms.</td> </tr>
  <tr> <td>byacc</td> <td>1/1</td> <td><emphasis>byacc</emphasis>.</td> </tr>
  <tr> <td>cpio</td> <td>2/2</td> <td><replaceable>cpio, mt-GNU</replaceable>.</td> </tr>
  <tr> <td>diff</td> <td>4/4</td> <td><emphasis>cmp, diff, diff3, sdiff</emphasis>.</td> </tr>
  <tr> <td>elm</td> <td>9/9</td> <td><replaceable>answer</replaceable>, <emphasis>elm</emphasis>, <replaceable>elmalias</replaceable>,
  <emphasis>fastmail, filter, frm,</emphasis><replaceable> newalias, newmail</replaceable>, <emphasis>readmsg</emphasis>. 
  </td> </tr>
  <tr> <td>find</td> <td>6/6</td> <td><emphasis>bigram, code, find, frcode, locate, xargs</emphasis>.</td> </tr>
  <tr> <td>flex</td> <td>1/1</td> <td><emphasis>flex</emphasis>.</td> </tr>
  <tr> <td>getty</td> <td>2/2</td> <td>getty, uugetty.</td> </tr>
  <tr> <td>grep</td> <td>1/1</td> <td><emphasis>grep</emphasis>.</td> </tr>
  <tr> <td>gzip</td> <td>1/1</td> <td><emphasis>gzip</emphasis>.</td> </tr>
  <tr> <td>ispell</td> <td>6/6</td> <td><emphasis>buildash, icombine, ijoin, ispell, sq, unsq</emphasis>. 
  </td> </tr>
  <tr> <td>joe</td> <td>2/2</td> <td>joe, termidx.</td> </tr>
  <tr> <td>less</td> <td>2/2</td> <td><emphasis>less, lesskey</emphasis>.</td> </tr>
  <tr> <td>m4</td> <td>2/2</td> <td><emphasis> ansi2knr, m4</emphasis>.</td> </tr>
  <tr> <td>perl</td> <td>4/4</td> <td><replaceable> a2p, perl4.036, sperl4.036, tperl4.036</replaceable>.</td> </tr>
  <tr> <td>ps</td> <td>11/12</td> <td>free, fuser, killall, ps, pstree,
  psupdate, tload, uptime, vmstat, w.procps, w.bassman.</td> </tr>
  <tr> <td>rcs</td> <td>8/8</td> <td><emphasis>ci, co, ident, merge, rcs, rcsdiff, rcsmerge, rlog</emphasis>. 
  </td> </tr>
  <tr> <td>sh_utils</td> <td>24/24</td> <td><emphasis> basename, date, dirname,
  echo, env, expr, id, logname, nice, pathchk, printenv, printf, pwd, sleep, stty,
  su, tee, test, tty, uname, users, who, whoami, yes</emphasis>.</td> </tr>
  <tr> <td>sudo</td> <td>2/2</td> <td>sudo.bin, visudo.</td> </tr>
  <tr> <td>tar</td> <td>3/3</td> <td><emphasis>tar</emphasis>, <replaceable>rmt</replaceable>, testpad.</td> </tr>
  <tr> <td>tcpip</td> <td>7/31 (from the net-tools subset)</td> <td>arp,
  ifconfig, plipconfig, rarp, route, netstat, slattach. 
  </td> </tr>
  <tr> <td>txtutils</td> <td>22/22</td> <td><emphasis>cat, cksum, comm, csplit,
  cut, expand, fold, head, join, nl, od, paste, pr, sort, split, sum, tac, tail,
  tr, unexpand, uniq, wc</emphasis>.</td> </tr>
  <tr> <td>util</td> <td>35/57</td> <td>agetty, <emphasis>arch, banner, chfn,
  chroot, chsh, col, colcrt, colrm, column, ddate, frag, hexdump, hostname, ipcrm,
  ipcs, last, login, mesg, more, newgrp, passwd, rdev</emphasis>, readprofile, <emphasis>renice,
  rev, setsid, sln</emphasis>, strings, swapon, <emphasis>ul, vipw, wall</emphasis>, <replaceable>zdump</replaceable>,
  <emphasis>zic</emphasis>.</td> </tr>
  <tr> <td>xgames</td> <td>8/13</td> <td>maze, xcolormap, spider, xtetris,
  xlander, xminesweep, xroach, xvier.</td> </tr>
  <tr> <td>xlock</td> <td>1/1</td> <td>xlock.</td> </tr>
</tbody>
</table>
  
  </section>
  <section>
  <title>Setting up the build environment</title>

  <para>The environments for the NAT-NAT, DRA-NAT and DRA-DRA builds
  have been setup using similar to those used during the Unixware port.</para>


  
  <itemizedlist>
  <listitem><para>One single reference source tree, then a dedicated work tree per (build,
  target platform). For the 1st target (Linux/i386), each work tree holds symbolic
  links to the <code>source</code> tree, while binaries are built inside a <code>work</code>
  tree as plain files. In addition, a procedure is used to replace a link to the
  source tree by a link to a <code>patch</code> tree when a source file has to be
  modified during the port to TenDRA. This is very similar to the environment we
  had on Unixware. The major difference is that each package has its own set of
  <code>source/work/patch</code> file trees. This is more modular but requires more
  manipulations.</para>
  </listitem>
  <listitem><para>For the 2nd target (Linux/Alpha): we usually created only a work tree for
  the DRA-DRA build. It initially contained source files only, which are
  symbolic links to their equivalent in the DRA-DRA/i386 work tree. By &ldquo;source
  files&rdquo; we mean here the Makefiles and the &andf; - <filename>.j</filename> - files
  having been generated from the original .c files by the TenDRA producer, during
  the DRA-DRA build for Linux/i386.</para>
  </listitem>
  <listitem><para>A shell script used as a pseudo cc (e.g. pseudo gcc) during the DRA-NAT and
  DRA-DRA builds. This avoids the necessity to modify most of the original
  makefiles when building the commands. The pseudo <code>cc</code> used during the
  build for the 2nd platform substitutes the (usually unique) <replaceable>input_file</replaceable><filename>.c</filename>
  by <replaceable>input_file</replaceable><filename>.j</filename>.</para>
  </listitem></itemizedlist>

  <para>One specific feature of the sources and build procedures of
  the Linux commands is that they have often been designed to support a variety of
  target platforms and UNIX variants at source level. Thus, when building a
  command for the first time, there is usually a preliminary self-configuration
  step which examines the system header files, and produces a local header file
  (or a customized Makefile) which summarizes the target system peculiarities by
  means of #define (or -D) statements. We ran such self-configuration scripts
  before creating the NAT-NAT, DRA-NAT and DRA-DRA work trees: this assumes that
  our second platform for porting (Linux/Alpha) is to provide similar APIs to the
  1st one (Linux/i386). Eventually, we had to revise the settings chose by the
  self-configuration.</para>
  
  </section>
  <section>
  <title>NAT-NAT/i386 and DRA-NAT/i386 build problems</title>
  <para>These two builds of the commands were only performed on the
  Linux/i386 platform, as a sanity check and cleanup of the source code.</para>
  <para>We faced only one problem during the NAT-NAT/i386 build of a
  few commands.</para>


  
  <itemizedlist>
  <listitem><para>Some header files (e.g. <code>linux/autoconf.h</code>) were not found when
  attempting to compile some administrative commands. To gain access to such
  headers, the preliminary step of a kernel rebuild can be done; alternatively,
  one could manually establish the proper symbolic links for <code>/usr/include/linux
  </code>and
  <code>/usr/include/asm</code>: they should point to their equivalent inside the<code>/usr/src/linux/include
  </code>directory.</para>
  </listitem></itemizedlist>
  <para>We faced a limited number of problems during the
  DRA-NAT/i386 builds of the commands. We list these problems below:</para>


  
  <itemizedlist>
  <listitem><para>The link-edit of some commands failed because one symbol was undefined:
  <code>_alloca</code>. In the native compiler (gcc), <code>_alloca</code> is implemented as
  a built-in function. In the TenDRA compiler, this can also be the case, provided
  that the header file <code>alloca.h</code> is explicitly included. So we modified the
  relevant source files to include this header file.</para>
  </listitem>
  <listitem><para>The source code for some commands appeared to use, through the inclusion of
  a system header file or under <code>#ifdef i386</code> conditional instruction, some
  assembly code. The related commands were thus excluded from our set of commands,
  except for a few of them for which we found a C variant to the assembly code.</para>
  </listitem>
  <listitem><para>Re-declaration of an array, for which the dimension was computed using
  <code>sizeof</code>. The following code sums-up the problem:</para>
  
  <programlisting language="c">extern int lnum[sizeof(short)];
int lnum[sizeof(short)]; /* bis */</programlisting>   
  </listitem></itemizedlist>

  <para>We sent a Change Request, <code>array_sizeof(262)</code>,
  concerning this problem, which applied to the apr-95 and nov-95 TenDRA releases.
  It has now been fixed.</para>


  
  <itemizedlist>
  <listitem><para>Name conflict between a function and its arguments. The following code
  sums-up the problem:</para>

  <programlisting language="c">char *fields(fields)
char *fields;
{ return fields; }</programlisting> 
  </listitem></itemizedlist>

  <para>We sent a Change Request, <code>func_var(262)</code>, concerning
  this problem, which applies to the apr-95 and nov-95 TenDRA releases. It has now
  been fixed.</para>


  
  <itemizedlist>
  <listitem><para>Use of custom options of the native compiler (gcc), e.g.
  <code>-fpcc_struct_return</code></para>

	<para>This option was used in the Makefile for the
  getty package. The gcc man page says that this option provides intercallability
  with modules (e.g. library modules) compiled with a pcc compiler. We concluded
  that this was not relevant when compiling for a Linux target platform, since gcc
  is used to compile the libraries, and we ignored it. Similarly, we ignored, i.e.
  filtered out in our pseudo-gcc for DRA-NAT/DRA-DRA builds, many other gcc
  options such as <code>-fomit-frame-pointer, -pipe, -g</code>
	while we adapted to TenDRA style some others, such as <code>-static</code>
	(for gcc) to <code>-Wl,-static</code> (for tcc).</para>
  </listitem></itemizedlist>
  
</section>
  </section>

  <section id="apidef">
  <title>Definition of the API for the commands</title>

  <para>We started the experiment with an xpg3 API, and decided to
  put all other symbols we needed in an extension API. However, after a few
  compilations of Linux commands, it became clear that most of the symbols we were
  adding to the extension API were in fact part of some other standard APIs, such
  as svid3.</para>

  <para>So, we redefined our base API to be a merge between the
  xpg3, svid3, gcc and bsd_extn APIs delivered with TenDRA, limiting the extension
  API to symbols specific to the Linux commands interface. In fact, some of the
  symbols in the extension API are defined in the standard cose API, but since
  this API is very partially supported by Linux, and sometimes conflicts with
  definitions provided in other APIs, it was not worth including it in the base
  API.</para>

  <para>For the<code> level 2</code> set of commands, we downloaded some
  packages using a BSD-like interface, and we tried to include the symbol
  definitions for these commands in our extension API. However, this appeared to
  be very difficult, since we found that the Linux implementation of some BSD
  interfaces redefines symbols from the POSIX API, in an incompatible way. This is
  reflected in the Linux header files by conditional definitions, selected with
  the _BSD_SOURCE macro for example, or by replacement header files, such as
  bsd/signal.h instead of signal.h. The incompatible definitions we found were for
  the <code>jmp_buf</code> type, the <code>setjmp()</code>, <code>getpgrp()</code>, <code>wait()</code>,
  <code>waitpid()</code>, <code>wait3()</code> and
  <code>wait4()</code> functions, and finally the<code> signal()</code> function redefined
  as <code>bsd_signal()</code>.</para>

  <para>This problem could have been resolved by removing from our
  base API the conflicting symbols, and creating a <code>conflict_posix</code> and a
  <code>conflict_bsd</code> extension APIs with these symbols. The compilation of the
  commands based on a BSD-like API would have used the <code>conflict_bsd</code> API,
  in addition to the base and regular extension APIs, and would have been
  link-edited with the
  <code>libbsd</code> library provided by Linux. Since this would have taken a lot of
  time, we preferred not to modify our API and we set aside these commands, unless
  we found a simple work-around: selecting at build-time, or recoding to, a POSIX
  adherence for them (refer to next section).</para>

  <para>Finally, in order to compile some X11 commands, a separate
  API including the <code>x5_lib</code>, <code>x5_t</code>, <code>x5_mu</code>,<code> x5_aw</code> and<code>x5_mit</code>
  standard APIs, has been created. Since Linux is based on X11R6, an extension API
  has also been created, which includes the few symbols we had to define for the
  X11 commands we built.</para>

  <para>We found one inconsistency between the Linux header files
  and the standard API provided with TenDRA for the &lt;sys/socket.h&gt; header
  file, defined in the bsd_ext API: we had to change almost every use of <code>caddr_t</code>
  to <code>struct sockaddr *</code>. We also found a few inconsistencies between the
  Linux/i386 and Linux/Alpha header files, which have been resolved by some
  corrections to the Linux native header files, in the API definition, and in the
  source code for one command (<code>more</code>).</para>
  
  </section>

  <section id="andfization">
  <title>ANDFization of the commands</title>

  <para>We encountered different kinds of problems when compiling
  with TenDRA the set of commands on the Linux/i386 platform. Among these
  problems, only one was related to a bug in the TenDRA technology, the others
  were either related to ANDF constraints, or to more general portability issues.</para>
  
  <section>
  <title>Dealing with ANDF constraints</title>
  <para>We list below problems we encountered while ANDFizing Linux
    commands, which are related to the use of the TenDRA technology as a 
  replacement to a classic compiler. We start with the only bug found in TenDRA during 
  this process, then we roughly follow the order in which the various issues were
  encountered.</para>

  <itemizedlist>
    <listitem>
      <para>Redefinition of an API token as a macro</para>
      
      <para>In the code below, <code>alarm</code> is defined as a macro, but it is 
        also a token in our API:</para>

      <programlisting language="c">#include &lt;unistd.h&gt; /* for alarm() */
extern int debug() ;
#define D_RUN 1
#define alarm(d) alarm(d); debug(D_RUN, "alarm set: %s:%u",\
    __FILE__, __LINE__)
long xx() { return alarm((long)5); }</programlisting>

      <para>This code is indeed illegal, but tdfc entered an infinite loop.
        The problem was reported to DRA as <code>loop_tdfc_alarm(276)</code>, and
        has now been fixed.</para>
    </listitem>

    <listitem>
      <para>Added missing startup macros</para>

		<para>When the TenDRA
        compiler (tcc) was used, a number of startup flags, defined with the
        native compiler (gcc), were missing.  The <code>linux</code>,
        <code>__linux__</code>, <code>unix</code> and _<code>_X11_P_HEADERS</code> flags, plus a
        number of flags defined in the native <code>features.h</code> header file,
        such as <code>_POSIX_SOURCE</code>, were added in a startup file for tcc.
      </para>
    </listitem>

  <listitem><para>Added missing function prototypes and fixed type
    mismatches</para><para>We used a tcc option to warn about missing function
    prototypes, and we fixed them by either including the appropriate header
    files or adding their prototype for locally defined functions. We added
    casting on some calls to library functions.  Then, every remaining
    undeclared symbol was added to the extension API. <emphasis>Note than more
    than half of the changes we made in the source code for Linux commands
    consisted in adding such prototypes.</emphasis>
    </para></listitem>

<listitem>
  <para>Resolved one conflict with an API symbol</para>

  <para>The function <code>mkdir()</code>, local to the file <code>mtools</code>, has been
    renamed to avoid a conflict with the API symbol defined in
    &lt;sys/stat.h&gt;.</para></listitem>

  <listitem>
	<para>Illegal use of target-dependent condition</para>
				<para>In the code below,
    INT_MAX is a target dependent token, which cannot be used to conditionally
    define a preprocessor macro:</para>

  <programlisting language="c">	#if (INT_MAX &lt;= 65535)
  	#define longdiff(a, b) /* (definition 1 for the macro) */
  	#else
  	#define longdiff(a, b) /* (definition 2 for the macro) */
  	#endif</programlisting> 

  <para>We fixed it by replacing the macro definition by a static functions:</para>

  <programlisting language="c">static int longdiff(time_t a, time_t b) {
#if (INT_MAX &lt;= 65535)
  	/* ... (definition 1 for the function) */
#else
  	/* ... (definition 2 for the function) */
#endif
}</programlisting>

      <para>This constraint arises from the way ANDF is used to achieve
        portability between targets which may have different values for
        INT_MAX. The constraint is that a target-dependent #if is permitted
        only where a statement is permissible, and both alternatives must be
        legal statement lists.</para>
      
      <para>This constraint unfortunately prevents target-dependent macro
        definitions in the style shown above. DRA is currently considering
        whether the constraint may be eased in a subsequent version of TenDRA
        to permit certain well-formed cases such as this.</para>
    </listitem>

    <listitem>
      <para>POSIX.1 or SVID interfaces versus BSD interfaces</para>
      
      <para>Three functions of the <code>bin</code> package, <command>time</command>
        and <command>crontab</command>, and <command>ash</command> (a simple
        shell), were configured to use some BSD interfaces which had not been
        included into our API, as discussed in <xref linkend="apidef"/>.</para>

      <para>For the <command>time</command> command, we found that the support
        for POSIX interfaces was provided in the source code, so we used it.
      </para>
  
      <para>Similarly, prior to building <command>ash</command>, we modified
        the related configuration file and Makefile, in order to elect
        svid3-like interfaces instead of the default bsd ones.</para>

  <para>For the <command>crontab</command> command, we fixed the problem by
    removing in the source code some (simple) calls to the BSD
    <function>wait4()</function> function, and by using the XPG3
    <function>waitpid()</function> function instead.</para></listitem>

  <listitem><para>For a few commands which use the <code>curses</code> interface, e.g.
    <code>bpe</code>, we chose the svid3 variant instead of the BSD one (they are
    both supported by Linux). Makefiles for building these commands with
    TenDRA have been changed to use the <code>libncurses</code> library instead of
    the <code>libcurses</code> library at link-edit time. Note that the sources for
    the <code>elvis</code> editor (from the <code>bin</code> package) embed a small custom
    version of the <code>curses</code> interface.</para></listitem>

  <listitem><para>For some commands, the initial self-configuration step performed
    prior to entering the actual build defines the path for another command,
    because the latter is called by the first one by means of
    <function>exec()</function> or <function>system()</function>.  While Linux
    provides the &lt;paths.h&gt; header file for this purpose, we found some
    files which do not include this header file, and others which need to call
    a command for which there is no path definition in the regular header. An
    example of such a situation is <command>elm</command>, which calls an
    editor (e.g. <command>vi</command>).  When we detected such situations, we
    either modified the source code to include and use &lt;paths.h&gt;, or we
    added a definition inside the alternate &lt;paths.h&gt; specified in our
    extension API.</para></listitem>

  <listitem><para>Pointer/Integer conversion</para>
				<para>The TenDRA compiler can be
    configured to issue a warning on every pointer/integer conversion. This is
    done with the pragma instruction:</para>
				<para><code>#pragma TenDRA conversion
    analysis (int-pointer) warning</code></para>
				<para>However, due to the very large
    number of occurrences of these warnings, we had to cancel this mode, and
    decided to postpone their analysis until after the validation
    step.</para>
				<para>For example, we encountered uses of -1 (minus one) to give a
    special meaning to a pointer value, while only 0 (NULL) is accepted for
    this purpose. (Note: 64-bit issues are discussed later in this section.)</para>
    </listitem>

  <listitem><para>Underspecified type in svid3 API</para>
	<para>We found one command which
  makes the assumption that the daddr_t type, defined in the svid3 API, is an
  arithmetic type. The source code casts a daddr_t value into an int, while
  daddr_t is defined in the API as: </para>

  <programlisting language="tspec">+TYPE daddr_t;</programlisting>

  <para>We fixed this problem by stating that daddr_t is indeed an arithmetic type,
  which is correct for both Linux/i386 and Linux/Alpha. We initially modified
  the reference svid3 API, but later we did it more cleanly, moving the
  daddr_t definition to our extension API prior to changing it to:</para>

  <programlisting language="tspec">+TYPE (int) daddr_t;</programlisting>

  <para>Also, prior to fixing this in the API, we found that casting an integer
  value to a daddr_t type was not rejected by the TenDRA compiler, while it is
  obviously illegal. A bug report has been sent to DRA, and this has now been
  fixed.</para>
  </listitem>

  <listitem><para>Recoding of a source file dealing with target platform byte ordering
  issues.</para>
	<para>A source file used a local BYTEORDER macro, set-up during the
  initial self-configuration step of the build of the command, to support
  different byte ordering. However, Linux already provides for this purpose a
  __BYTE_ODER macro, defined in the &lt;bytesex.h&gt; header file. So, we added
  the __BYTE_ORDER symbol to our API, and replaced all the occurrences of the
  BYTEORDER macro by references to the __BYTE_ODER API macro. We also had to
  rewrite some code, because with TenDRA some instructions are illegal after a
  target dependent condition.</para></listitem>

  <listitem><para>The termio and termios interfaces are both provided with Linux,
  and share the same set of macros to define indexes in the<code> c_cc </code>array
  from either the termio or termios structures. On Linux/i386, these indexes
  are the same for the two structures, while on Linux/Alpha they differ.
  TenDRA provides a way to support different variants of a same object, using
  version numbers, and this should have solved our problem. However, since we
  never used this feature before, we did not spend time to see how we could
  use it in our API. Instead, we made a temporary fix, consisting in renaming
  the constants in the termio interface. For two of the commands we ported,
  <code>more</code> and <code>ispell</code>, which use the termio interface, we changed
  their sources to reference the new macros.</para>
  </listitem>
</itemizedlist>
  </section>

  <section>
  <title>Undocumented dependencies to the OS / the underlying hardware</title>
  <para>Some commands are platform dependent, and are not
    easily (sometimes: not at all) portable from one platform to another.
    However, the Linux/i386 and Linux/Alpha OS's are very similar;
    furthermore, some hardware architectures built around the DEC Alpha chip
    are not much different from the Intel-based PC: for example, our
    Linux/Alpha platform includes ISA adapters for graphics and Ethernet. In
    such a favorable situation, the Linux/i386 <code>ifconfig</code> command (from
    the<code> tcpip/net-tools</code> subset), which displays hardware information on
    the network interfaces such as their (ISA) &ldquo;Base address&rdquo;, could
    probably have been easily ported to Linux/Alpha (/AXP pci). Also, the perl
    command, which includes optional support for undocumented system calls,
    may or may not be portable between two Linux platforms, depending on the
    system calls they implement.</para>

  <para>On the other hand, changing the format for binary
  files, e.g. switching from a classic Linux <code>a.out</code> format to the
  Digital Unix &ldquo;Extended COFF&rdquo;, may require changes in some common commands
  such as <code>strings</code> or <code>file</code>. When using a classic compiler, some
  (or even all in a favorable case) of these changes may be hidden inside the
  system header files, e.g. &lt;a.out.h&gt;, but the TenDRA compilation chain,
  when used in DRA-DRA mode, is often more rigid.</para>

  </section>

  <section>
  <title>Upgrade to TenDRA 4.0</title>

  <para>When we had ANDFized the whole set of commands, we
    upgraded to TenDRA 4.0 in order to work on the Linux/Alpha platform (see
	<xref linkend="installonalpha"/>).
    However, we had to ANDFize again the set of commands with the new TenDRA
    version, since it was not upward compatible with the previous one. In
    fact, we only re-ANDFized the commands we tried to install on the
    Dec/Alpha platform, at the time we needed them. We did not encounter any
    problem when doing this.</para>
  </section>

  <section>
  <title>Holes in source code portability (64-bit vs 32-bit issues)</title>

  <para>During the installation and validation of these
    commands on the second platform, we found a number of bugs related to
    portability problems, which are out of the scope of TenDRA. All these bugs
    were due to code assuming 32-bit platforms, which break on 64-bit
    platforms. Some of the bugs we found were already fixed in early
    Linux/Alpha releases, such as the Blade release, others were still there.
    We fixed the source of the commands, re-andfized them, and installed and
    validated these commands again on the two platforms. We give below the
    portability issues we encountered:</para>

  <itemizedlist>
    <listitem>
	<para>Wrong <code>int &lt;-&gt; pointer</code> conversion</para>
	<para>On Linux/Alpha
      (and Digital Unix/Alpha), a pointer type is 8-bytes wide, so it cannot
      fit in an <code>int</code> type, which is only 4-bytes wide. Fortunately, the
      <code>long</code> type on Linux/Alpha is, as usual, as large as a pointer, and
      thus can be used as a replacement for an <code>int</code>, each time an
      explicit pointer&lt;-&gt;integer is used. This is a common type of the
      portability fixes we had to make in the source code for Linux commands,
      subsequent to encountering a Linux/Alpha-only problem at validation
      time.</para></listitem>
    
  <listitem>
	<para>Incorrect assumptions on sizes of <code>int</code>, <code>long</code> and
  <code>size_t</code></para>

	<para>Although in many cases int and long types are equivalent,
  we give below three examples of code we found where it makes a difference:</para>

  <programlisting language="c">/* #1 */ { int i; printf("i value is: %ld\n", i); }
/* #2 */ extern char *malloc(int);
/* #3 */ { long l ; printf("%08lx", l); }</programlisting>

      <para>All three work perfectly on Linux/i386, while they cause, or could
      cause, damage under Linux/Alpha.</para>

	<para>In the first two lines the
      function, printf or malloc, will read respectively a long on the stack,
      which are 8 bytes wide, while only 4 bytes for an int would have been
      pushed. Note that the correct prototype for malloc is char
      *malloc(size_t), and that size_t is equivalent to long on Linux/Alpha. We
      fixed the error on such printf statements with a cast to long for an
      argument, and the error on malloc by replacing its local-and-wrong
      declaration by the inclusion of the &lt;stdlib.h&gt; header
      file.</para>

		<para>In the third case, the instruction was used to print a
      fixed number of digits.  However, a long, 8-bytes on an Alpha platform,
      may hold a value that prints up to 16 digits, thus putting unexpected
      digits in the output. In the code where we found the problem, the fix
      was to truncate the value to a 4-byte value.</para>
	  </listitem>
  </itemizedlist>

  
</section>
  </section>

  <section id="apiinstallation">
  <title>Installation of the API for the commands</title>

  <section>
  <title>Installation of the API on Linux/i386</title>

  <para>The API is made of two parts, a base API, which is a
    merge between xpg3, svid3, gcc and bsd_extn APIs, and an extension API,
    which completes the interface required for the commands (see <xref linkend="apidef"/>).</para>

  <para>The base API was installed on the Linux/i386 platform,
  without any problem. However, we left some tokens undefined when some parts of
  the API were not part of the actual Linux API. Then, the extension API was
  installed, as we extended it to cover more and more commands. These
  installations required a few patches to the system header files, some of which
  were already provided with the TenDRA snapshot. These installations went very
  well, with only a few problems, listed in a following paragraph. Then, when we
  moved to a new TenDRA snapshot to the Linux/Alpha platform, we re-installed the
  API, without any problem.</para>

  <para>We made a small number of modifications to the API during
  the port of the commands on the Linux/Alpha platform. However, each modification
  we made required re-installation of some parts of the API.</para>
  </section>

  <section>
  <title>Installation of the API on Linux/Alpha</title>

  <para>As for the Linux/i386 platform, we had to apply some patches
  to the system header files in order to install the API. A number of these
  patches were actually identical to the patches we made on the Linux/i386 header
  files. So, instead of copying and editing, by hand, these files again, we chose
  to implement these patches by means of <code>sed</code> scripts, which could be
  applied to both Linux/i386 and Linux/Alpha header files. Most of these scripts
  are now common to the two platforms, although a few of them are specific to one.
  These
  <code>sed</code> scripts not only facilitate corrections to the system header files,
  but would also be useful if we need to upgrade from one Linux version to
  another.</para>

  <para>The Linux/Alpha system header files do not differ much from
  the Linux/i386 ones. However, since the Linux/Alpha port was derived from a more
  recent Linux/i386 version (Linux 1.3) than the one we used (Linux 1.1), we could
  not clearly distinguish between the changes which come from standard Linux
  evolutions and those which have been introduced during the port of Linux to
  Digital Alpha. One important modification was that some definitions found on
  Linux/i386 in some &lt;linux/*&gt; or &lt;sys/*&gt; header files have now been
  moved into &lt;asm/*&gt; header files. We had to take such changes into account
  when adapting the Linux/i386 modifications to Linux/Alpha.</para>

  <para>Finally, we did not port to Linux/Alpha the extension API to
  the TenDRA x5/* APIs. This would have required installation of X11 on our
  Linux/Alpha box, which consists of 28 additional floppy images! This part of the
  API was only required for 9 commands from our set of commands, which we did not
  install on Linux/Alpha.</para>
  
  </section>
  <section>
  <title>API installation problems</title>
  <para>We list below the problems we found when building the API on
  the Linux/i386 or the Linux/Alpha platforms, and the solution we adopted.</para>


  
  <itemizedlist>
  <listitem><para>A macro, <code>makedev</code>, added to our extension API, was defined in the
  Linux/i386<code>sys/sysmacros.h </code>header file. This file contains the lines:</para>

  <programlisting language="c">#define major(dev) ...
#define minor(dev) ...
#define makedev(major,minor) ...</programlisting>

	<para>The identifiers <code>major</code> and <code>minor</code> used to name the formal
  parameters of the <code>makedev</code> macro are also the name of two macros defined
  in this header file, which we included in our API. The clash on the names is
  reported as an error by tdfc when building the API. We did not check whether
  this was a TenDRA bug or not, but we bypassed the problem by using an alternate
  version of <code>sys/sysmacros.h</code>, in which the formal parameters of the <code>makedev</code>
  macro have been renamed. </para>
  </listitem>

  <listitem>
	<para>The &lt;bytesex.h&gt; header file contained the following lines:</para>

  <programlisting language="c">#undef __BYTE_ORDER
#define __BYTE_ORDER 1234</programlisting>

	<para>The<code> #undef</code> line prevents tcc from finding the definition of the
  __BYTE_ORDER constant. This is a constraint that applies only when building API
  token libraries. It is a necessary consequence of using C macro definitions to
  obtain ANDF token definitions. We bypassed this behaviour by commenting out the
  #undef line in a replacement header file.</para>
  </listitem>

  <listitem><para>The Linux/Alpha header files do not follow the standard APIs in some cases.
  For example, the Linux/Alpha &lt;sys/stat.h&gt; header file defines the field
  <code>st_dev</code> from the <code>stat</code> structure as <code>unsigned int</code> instead of
  <code>dev_t</code> as defined in XPG/3. Since <code>dev_t</code> is equivalent to <code>unsigned int</code> on
  Linux/Alpha, we were able to modify the system header file to use the correct
  type.</para></listitem>

  <listitem><para>The Linux/Alpha header files sometimes use an <code>int</code> type, in places where a
  <code>long</code> type is used on Linux/i386. In such cases, we decided to patch the
  Linux/i386 header files to use an <code>int</code> type, since <code>long</code> and <code>int</code> are
  equivalent on a 32-bit platform.</para></listitem>

  <listitem><para>The reverse situation, where Linux/i386 uses an <code>int</code> and Linux/Alpha uses
  a <code>long</code>, has also been found. In this case, we preferred to modify the API to
  accept both types, using the tspec <code>+TYPE (int) ...</code> notation.</para></listitem>

  <listitem><para>On the Linux/i386 platform, we extended the API with some symbols from the &lt;termio.h&gt;
  header file. The &lt;termio.h&gt; system header file has changed between
  Linux/i386 and Linux/Alpha, and some definition were incompatible with the
  extension API. We eventually found a solution, which involved a fix to the Linux
  header files.</para></listitem>

  <listitem><para>The Linux system supports two variants of the <code>curses</code> library, one
  defined by the &lt;curses.h&gt; header file for a BSD API, and the other defined
  by the &lt;ncurses.h&gt; header file for a svid3 API. We used the latter to
  build the API, since we do not support the BSD API.</para></listitem>

  <listitem><para>The TenDRA svid3 API defines the constant RLIM_INFINITY, from the
  sys/resource.h header file, as follow:</para>

  <programlisting language="tspec">+CONST int RLIM_INFINITY;</programlisting>

	<para>However, this constant is used to assign variables of type <code>rlimit_t</code>,
  which is, on Dec/Alpha, defined as a long, thus 8-bytes wide. So the problem
  was: while this constant was defined with the value 0x7fffffffffffffffL, it was
  actually truncated to fit within a (32-bit) int. We fixed this bug by replacing
  the definition of RLIM_INFINITY by:</para>

  <programlisting language="tspec">+CONST rlimit_t RLIM_INFINITY;</programlisting> 
  </listitem></itemizedlist>
  
</section>
  </section>
  <section id="installandvalid">
  <title>Installation and validation of the commands</title>

  <para>On the Linux/i386 platform, we used the TenDRA compiler to
  produce the ANDF files, and then translate them into binary executable files, in
  the same invocation of the compiler. A tcc option was used to preserve the
  intermediate ANDF files.</para>
  <para>On the Linux/Alpha platform, we used the ANDF files produced
  on the Linux/i386 platform, and translated them into binary executable files.
  For this platform, we ran the TenDRA compiler on a Dec/Alpha platform as a
  cross-compiler for the Linux/Alpha platform (see <xref linkend="installonalpha"/>).</para>

  <para>In order to validate the commands we built, we used several
  different methods, depending on the commands.</para>

  <para>We found that a very limited number of commands were
  packaged with some rather extensive self-validation tests, that we used to
  validate such commands.</para>

  <para>We tested some other commands interactively (e.g. <code>elvis</code>,
  <code>bpe</code>, <code>ispell</code>, <code>elm</code>, ...). However, for most commands we
  had to write small tests. Even a basic test requires several shell script lines:
  it took us several weeks to write tests for &gt;200 commands then to run them.</para>

  <para>Finally, a small number of commands, actually 10, was not
  tested: <code>getty/uugetty</code>, <code>sudo.bin/visudo</code>, <code>readprofile</code>,
  <code>swapon</code>, <code>mt-GNU</code>, <code>rmt</code>,
  <code>plipconfig</code> and <code>slattach</code>. As none of these commands were actually
  installed on the 2nd platform, there is no real penalty.</para>

  <para>On the Linux/i386 platform, 236 commands were installed,
  then validated. Conversely, on Linux/Alpha, we installed and validated only a
  subset of these commands: about 150, as previously mentioned. While we found
  only a few problems during the validation on Linux/i386, we faced a number of
  validation failures on Linux/Alpha, thus requiring much more investigation. Some
  of these problems were due to bugs in the TenDRA technology, and have all been
  fixed by now. Most of the others have already been discussed in previous
  sections.</para>

  <para>We list below miscellaneous problems, encountered at
  validation time on either the 1st or the 2nd platforms, which are not really
  related to TenDRA, nor do they depend on portability issues in the original
  source code.</para>
  
  <section>
  <title>Miscellaneous problems encountered at validation</title>

  
  <itemizedlist>
  <listitem><para>For two commands, <code>sln</code> and <code>stty</code>, we found different
  behaviour due to an undetected missing symbol in our API. For example, the <code>sln</code>
  command is written such that, depending on weather the S_ISLINK symbol is
  defined or not, it generates a symbolic link or a hard link. The missing symbol
  was defined in our API to fix the problem.</para></listitem>

  <listitem><para>The <code>more</code> command on Linux/Alpha, of which the source code uses the
  non-POSIX <code>termio</code> interface, waits for 4 input characters before
  processing them. The reason is that in Linux/Alpha (as in Digital Unix) some of
  the <code>termio.c_cc[]</code> control characters overlap with some others, depending
  on the input mode being used (i.e. either the &ldquo;canonical&rdquo; mode or the
  &ldquo;half-cooked&rdquo; mode). So such control characters, which are the ones at VMIN and
  VTIME indexes, must always be updated when switching from one input mode to the
  other: we changed the source code for the <code>more</code> command accordingly.</para></listitem>

  <listitem><para>We found two bugs in the Linux/Alpha libc library, in the <code>getegid</code>
  and <code>times</code> functions. The 1st one was already known and fixed in a later
  release, while the 2nd one was not (we received a fix for it a few days later,
  from a member of the Linux/Alpha project).</para></listitem>

  <listitem><para>The <code>csplit</code> command, from the txtutils package, defines the <code>memchr()
  </code>function, also defined in the libc library. The validation of this command
  failed on Alpha, until we removed this local recoding for <code>memchr()</code> and
  used the regular library entry point instead.</para></listitem>

  <listitem><para>The environment on Linux/Alpha for using the <code>zic</code> command was not
  correct, since that command is not available in the Linux/Alpha BLADE_0.3
  distribution.</para></listitem>

  <listitem><para>The environment on Linux/Alpha for running the <code>bpe</code> command was not
  correct, since we had used the (available) <code>ncurses</code> library when
  link-editing this command: at run-time the related <code>terminfo</code> data base
  was lacking. We simply had to replicate on Linux/Alpha the Linux/i386 terminfo
  files to cure this problem.</para></listitem></itemizedlist>
  
  </section>
  
  <section>
  <title>Recent upgrades of our original source code for Linux commands</title>

  <para>We initially found on the net a limited number of patches
  for the commands in source form; such patches had been made during the port of
  Linux to Digital Alpha. For example, the following patch for the source code for
  the col command was found on <code>ftp.azstarnet.com</code>, but it is not a example
  of interest since we had preventively fixed it, i.e. during the initial
  ANDFization of the col command: </para>

  <para>util-linux-2.5/text-utils/col.c:</para>
  <programlisting language="diff">+ #include &lt;malloc.h&gt;</programlisting>

        <para>Conversely, neither the BLADE_0.3 nor the BLADE_0.2
          distributions include source code for commands; we discovered very
          recently that such code was available (on <code>ftp.digital.com</code>)
          for the very first, 32-bit Linux/Alpha distribution. Nevertheless,
          for three commands we used source code from the RedHat 2.1/beta
          and 2.1 Linux/Alpha distributions. This allowed us to fix
          incorrect behavior of the <code>zic</code> command; we also experimented
          without success (due to lack of time) some partial upgrades of the
          source code for <code>zdump</code> and <code>cpio</code>.</para>
      </section>
    </section>
  </chapter>

  <chapter>
    <title>Statistics</title>

    <section>
      <title>Statistics for Linux APIs</title>

  <para>All the files required to create an API are located inside
  a special sub-tree of the TenDRA [4.x] distribution named<code> src/apis/</code>.
  First, the new API must be specified, in a dedicated language (the TenDRA <code>tspec</code>
  tool is provided to translate such API specification into a target-independent
  intermediate format). An API specification is split into files, each of which
  usually corresponding to a system header file available on the target
  platform(s); e.g.: <code>stdio.h, sys/types.h</code>, etc.</para>

  <para>Secondly, there is often the need for slight changes within
  some of the system header files of a given target, in order to build (to
  install) the new API on it; such changes are either hard-coded inside a
  replacement version for the relevant headers, or automatically performed using
  scripts of text processing commands; the <code>sed</code> tool, along with <code>sed</code>
  scripts, are used to deal with common APIs (for UNIX-like systems) included in
  current TenDRA distributions. We think that the second method is more flexible;
  for example, the text processing commands to apply on the system header files in
  order to build successfully our custom APIs for Linux were in most cases the
  same among Linux/i386 and Linux/Alpha targets, so we have written a single set
  of sed scripts suitable for both of these platforms.</para>

  <para><!-- TODO: <xref linkend="apisforlinux"/> -->The following table gives an
  idea of the amount of work required to specify and to build the APIs used by the
  ~230 Linux commands which were ported to ANDF. Two types of data are reported:
  &ldquo;number of files&rdquo; and &ldquo;number of lines&rdquo;. The files are modules holding lines of
  either API specification or of sed commands. We excluded from our statistics the
  comment lines for both, because the ratio of comments versus actual <code>tspec/sed
  </code>constructs was unusually high.</para>

  <para>We recall that our Base API for Linux was derived from
  existing &ldquo;standard&rdquo; APIs, i.e. mainly from XPG3 and SVID3, which themselves
  use parts of POSIX. Consequently, the number of tspec <code>lines</code> for this API
  which is shown below does not reflect the actual amount of lines of
  specification having been used: most of the specifications we wrote are similar
  to C language <code>#include</code> statements (&tspec; <code>+IMPLEMENT</code> or <code>+USE</code>
  constructs).</para>

  <para>In our &ldquo;Extension API 1&rdquo;, we have not uncommonly rewritten
  specifications which had an equivalent (either identical or similar) within the
  reference SVID3 API or SPEC1070 API.</para>

  <para>We recall also that we did not start from scratch when
  making the changes in Linux system headers in order to build our APIs, either
  for Linux/i386 or Linux/Alpha targets: the TenDRA Snapshot we started from
  (April 95) provided 11 <code>sed</code> scripts for this purpose, that were
  sufficient to build most of the XPG3 API for the Linux/i386 target.</para>

  <para>The number of <code>files</code> given for &ldquo;Changes in system
  headers&rdquo; is the one for the 1st target, Linux/i386 (1.0): as already mentioned,
  the build of APIs for the 2nd target, Linux/Alpha (1.3), uses the same set of
  sed scripts. This means that the number of <code>lines</code> corresponds to the <code>sed</code>
  commands which apply either to a Linux/Intel system header, to a Linux/Alpha
  header or to both.</para>


  <table>
  <title>APIs for Linux / ~230 commands</title>

<col align="left"/>
<col align="center"/>
<col align="center"/>
<col align="center"/>
<col align="center"/>

<thead>
  <tr>
  <th/>
  <th>Base API, specs</th>
  <th>Extension API1, specs</th>
  <th>Extension API2 (X11), specs</th>
  <th>Changes in system headers (build)</th></tr>
</thead>
<tbody>
  <tr>
  <td>files</td>
  <td>65 (.h)</td>
  <td>66 (.h)</td>
  <td>3 (.h)</td>
  <td>48 (sed scripts)</td></tr>
  <tr>
  <td>lines (excl. comments)</td>
  <td>1381</td>
  <td>684</td>
  <td>18</td>
  <td>254</td></tr>
</tbody>
	</table>
  
  
  
  
  </section>
  <section>
  <title>Statistics concerning changes in the original source code</title>

  <para><!-- TODO: <xref linkend="i386andalphaports"/> -->The following table lists the
  packages we installed and validated on both platforms. The first column
  gives the (Slackware Linux) name of the package, and the second gives the
  number of source files we dealt with during the ANDFization. The following
  column gives the number of files - actual source or Makefile - patched
  during either the initial ANDFization (keeping the i386 as target), or the
  port to the 2nd target (Alpha). The two last columns show the number of
  files specifically (re)patched during the port to Alpha, and finally the
  number of patched Makefiles (that for the overall project).</para>


  <table>
  <title>Packages ported to Linux/i386 and Linux/Alpha</title>

<col align="left"/>
<col align="center"/>
<col align="center"/>
<col align="center"/>
<col align="center"/>

<thead>
  <tr>
  <th>Packages</th>
  <th>Source files</th>
  <th>Patches <code>Total</code></th>
  <th>Patches <code>Alpha port</code></th>
  <th>Patches <code>Makefiles</code></th></tr>
</thead>

<tbody>
  <tr>
  <td>bin</td>
  <td>455 <footnote>
  <para>Contents of the bin package were partially ANDFized: 48 commands out of
  56. Also, a subset only of these ANDFized commands was actually ported to
  Linux/Alpha: 37 (out of 48). So, the &ldquo;number of source files&rdquo; shown excludes
  source code for non-ANDFized commands. Conversely, the &ldquo;number of patches,
  Alpha&rdquo; would be greater if all the ANDFized commands had been ported to the
  second target.</para></footnote> </td>
  <td>86</td>
  <td>19</td>
  <td>6</td></tr>
  <tr>
  <td>sh_util</td>
  <td>72</td>
  <td>14</td>
  <td>3</td>
  <td>0</td></tr>
  <tr>
  <td>txtutils</td>
  <td>50</td>
  <td>8</td>
  <td>2</td>
  <td>1</td></tr>
  <tr>
  <td>util</td>
  <td>71 <footnote>
  <para>Contents of the Slackware Linux util package were partially ANDFized: 35
  commands out of 57. Among these, only 30 were actually ported to Linux/Alpha.</para>
	</footnote></td>
  <td>51</td>
  <td>22</td>
  <td>3</td></tr>
  <tr>
  <td>diff</td>
  <td>32</td>
  <td>10</td>
  <td>3</td>
  <td>0</td></tr>
  <tr>
  <td>gzip</td>
  <td>36</td>
  <td>4</td>
  <td>1</td>
  <td>1</td></tr>
  <tr>
  <td>grep</td>
  <td>16</td>
  <td>7</td>
  <td>4</td>
  <td>1</td></tr>
  <tr>
  <td>find</td>
  <td>57</td>
  <td>12</td>
  <td>2</td>
  <td>0</td></tr>
  <tr>
  <td>bc</td>
  <td>20</td>
  <td>2</td>
  <td>0</td>
  <td>0</td></tr>
  <tr>
  <td>tar</td>
  <td>37</td>
  <td>10</td>
  <td>2</td>
  <td>1</td></tr>
  <tr>
  <td>rcs</td>
  <td>28</td>
  <td>6</td>
  <td>0</td>
  <td>0</td></tr>
  <tr>
  <td>byacc</td>
  <td>20</td>
  <td>8</td>
  <td>0</td>
  <td>0</td></tr>
  <tr>
  <td>m4</td>
  <td>34</td>
  <td>1</td>
  <td>0</td>
  <td>0</td></tr>
  <tr>
  <td>less</td>
  <td>44</td>
  <td>2</td>
  <td>0</td>
  <td>0</td></tr>
  <tr>
  <td>flex</td>
  <td>46</td>
  <td>3</td>
  <td>0</td>
  <td>0</td></tr>
  <tr>
  <td>ispell</td>
  <td>40</td>
  <td>21</td>
  <td>15</td>
  <td>1</td></tr>
  <tr>
  <td>elm</td>
  <td>170</td>
  <td>27</td>
  <td>4</td>
  <td>0</td></tr>
</tbody>
<tbody>
  <tr>
  <td>Total</td>
  <td>1233</td>
  <td>272 (22%)</td>
  <td>77</td>
  <td>14</td></tr></tbody></table>

  <para><!-- TODO: <xref linkend="i386ports"/>-->The following table lists the
  packages we installed and validated on the Linux/i386 platform only. Similar
  information, except for the number of patches for the Linux/Alpha platform, is
  given.</para>

  <table>
<col align="left"/>
<col align="center"/>
<col align="center"/>
<col align="center"/>

<thead>
  <tr>
  <th>Packages</th>
  <th>Source files</th>
  <th>Patches <code>(i386 only)</code></th>
  <th>Patches <code>Makefiles</code></th></tr>
</thead>
<tbody>
  <tr>
  <td>aaa_base</td>
  <td>122</td>
  <td>22</td>
  <td>2</td></tr>
  <tr>
  <td>ash</td>
  <td>49</td>
  <td>15</td>
  <td>1</td></tr>
  <tr>
  <td>bsdgames</td>
  <td>47 <footnote><para>The bsdgames package was partially ported to ANDF</para></footnote></td>
  <td>35</td>
  <td>11</td></tr>
  <tr>
  <td>cpio</td>
  <td>44</td>
  <td>22</td>
  <td>1</td></tr>
  <tr>
  <td>getty</td>
  <td>18</td>
  <td>6</td>
  <td>1</td></tr>
  <tr>
  <td>joe</td>
  <td>87</td>
  <td>26</td>
  <td>0</td></tr>
  <tr>
  <td>perl</td>
  <td>86</td>
  <td>10</td>
  <td>1</td></tr>
  <tr>
  <td>ps</td>
  <td>35</td>
  <td>6</td>
  <td>1</td></tr>
  <tr>
  <td>sudo</td>
  <td>9</td>
  <td>6</td>
  <td>0</td></tr>
  <tr>
  <td>tcpip/net-tools</td>
  <td>26 <footnote><para>In the tcpip package, only the Net-tools subset was ported.</para></footnote></td>
  <td>12</td>
  <td>0</td></tr>
  <tr>
  <td>xgames</td>
  <td>105</td>
  <td>28</td>
  <td>3</td></tr>
  <tr>
  <td>xlock</td>
  <td>37</td>
  <td>4</td>
  <td>1</td></tr>
</tbody>
<tbody>
  <tr>
  <td>Total</td>
  <td>665</td>
  <td>175</td>
  <td>22</td></tr>
</tbody>
	</table>

		<para>From the data shown in the table above <!-- TODO: <xref linkend="i386andalphaports"/> -->,
			we can say that about 80% of the original source files did not require
			any change when ported to ANDF. We find also that we encountered, during the
			initial ANDFization and the validation on the 1st platform, more than 70% of the
			files requiring changes. In other words, we had missed approximately 30% of
			required changes. Note that in our project both of the platforms were running
			the same UNIX-like variant (Linux), so the last ratio could be greater in a less
			favorable case. Finally, since the Intel/i386 and Digital/Alpha feature
			different sizes for pointer type (and <code>long</code> type), while the byte ordering is
			the same, there is probably still incorrect code lying inside our ANDF files for
			Linux commands.</para>
		</section>
	</chapter>

	<chapter>
		<title>Conclusion</title>

		<para>During this second part of the project, we greatly benefited from
			the experience acquired during the first part &unix-validation.doc;.
			The build environment we used and
			the way we integrated the TenDRA technology were directly derived from
			the work on the Unixware platform. Also, the initial set of Linux
			commands we could reasonably port was derived from the commands we had
			already ANDFized for Unixware.</para>

		<para>We finally ported and validated about 230 commands
			on the Linux/i386 platform, but we could port only about 150 of them to
			the Linux/Alpha platform. The main reason for not porting the 80
			remaining commands on Linux/Alpha was that we were short of time.
			Although we are below the target of 300 commands to be ported to both
			platforms, we believe that the experiment was a success. A significant
			amount of sometimes complex code was ANDFized, and the portability of
			this code was demonstrated. The main reasons that the initial objective
			was not attained were:</para>

		<itemizedlist>
			<listitem>
				<para>The switch to the second platform was delayed.  Initially, we
					had planned to use the microkernel based version of Linux on PowerPC,
					but this was not available in time.</para>
			</listitem>

			<listitem>
				<para>Setting up the Alpha/Linux system took a considerable amount of
					time. This was mainly due to the fact that Linux has not been ported to
					&ldquo;off-the-shelf&rdquo; hardware, and the system had to be assembled from
					components (mother board, power supply, disks, etc.).</para>
			</listitem>

			<listitem>
				<para>In the Linux/Alpha distribution we installed, a number of
					commands were missing, and others were still not fully validated. This
					meant that, porting commands from Intel to Alpha, we found several
					portability bugs which were not fixed, and sometimes not even known, in
					the Alpha command sources. Finding fixes or asking for help on the
					Linux/Alpha mailing list slowed down our work.</para>
			</listitem>
		</itemizedlist>

		<para>In the course of the project, Linux has evolved from Linux 1.1 to 1.3,
			and Linux commands were distributed on Alpha. However, we stuck to the
			Linux 1.1 commands, and we only used the Linux/Alpha distribution to
			install the system and to find fixes when we had problems with some
			commands.</para>

		<para>Actually, many of the portability problems we found are now fixed on
			Linux/Alpha, and it would be much easier to port these commands now than
			it was a few months ago. However, the first source delivery of commands
			for Linux/Alpha was only available in December 95, and using this new set
			of commands would have required to re-do on the Intel platform the work
			(ANDFization, installation and validation) which was already done.
			Moreover, this first delivery was still not extensively validated and
			contained a number of bugs.</para>

		<para>This project demonstrated that it is possible to build an API for a
			-rather large- set of commands. Moreover, this API is mostly based on
			standard APIs, xpg3, svid3, with a relatively small number of additions
			(e.g. a more complete bsd API than the TenDRA bsd_extn). However,
			installation of the standard APIs (Posix, Xpg3,...) with TenDRA has shown
			that Linux does not fully conform to these standards. In fact, the best
			support is for the bsd API, since a large number of commands come from bsd
			sources.</para>

		<para>We used a 3-step approach in porting to ANDF, first compiling with the
			native compiler, second, using the TenDRA compiler with the native header
			files, and finally using TenDRA with abstract headers files and token
			libraries. Although we used the second step to find portability errors
			detected by the TenDRA compiler, this could be done in the third step.
			However, the third step which consists in making the source code compatible
			with the abstract API, is not so easy, and thus we found it easier to
			resolve portability checks in a separate step.</para>

		<para>Most of the modifications we made to the source code for
			the commands came from missing function declarations and other trivial
			unportable coding, e.g. wrong assumptions on int and pointer sizes.</para>

		<para>The TenDRA technology has proven capable of handling the differences
			between the two platforms. Although the same operating system runs on both
			platforms, these hardware platforms are sufficiently different to create
			difficulties. Standard APIs were successfully installed on both platforms,
			and the specific API developed for the commands could be designed to support
			the two different implementations. However, defining and installing an API
			is not an easy process and requires some <emphasis>sometimes extended</emphasis> knowledge of
			the TenDRA technology. We also detected a very small number of bugs in the
			TenDRA technology, in particular for the Dec/Alpha installer which has only
			been recently distributed by DRA.</para>
	</chapter>


	<appendix>
		<title>Errors in the TenDRA compiler</title>

		<para>The problems are classified according to their status
			at the end of March 1996. They were encountered on the April 95 or
			November 95 releases of TenDRA, and have all been fixed now.</para>
  
		<itemizedlist>
			<listitem>
				<para>CR95_359.FB::shift_to_sign</para>
				<para>Error on an arithmetic shift left.</para>
				<para>Fixed
					in November 95.</para>
			</listitem>

			<listitem>
				<para>261 - array_sizeof</para>
				<para>Error when declaring twice an array with sizeof(int)
					as dimension.</para>
				<para>Fixed in tdfc:4.58</para>
			</listitem>

			<listitem>
				<para>262 - func_var</para>
				<para>Name conflict between a function and its arguments.</para>
				<para>Fixed
					in TenDRA February 96.</para>
			</listitem>

			<listitem>
				<para>276 - loop_tdfc_alarm</para>
				<para>Tdfc loops when attempting to redefine as macro a
					tokenized function.</para>
				<para>Fixed in tdfc 4:58</para>
			</listitem>

			<listitem>
				<para>220 - fstp_esi</para>
				<para>invalid assembler instruction <code>fstp %esi</code></para>
				<para>Fixed in
					TenDRA November 95.</para>
			</listitem>

			<listitem>
				<para>225 - func_return_struct</para>
				<para>Intercallability with a gcc-compiled library
					function which returns an 8-bytes structure. Bypassed with thw tcc option
					-Wt,-G1.</para>
				<para>Fixed in TenDRA November 95.</para>
			</listitem>

			<listitem>
				<para>335 - alpha_long_too_big</para>
				<para>Use of a literal integer constant larger than
					232.</para>
				<para>Bypassed. Added a <code>L</code> suffix to such a value.</para>
			</listitem>

			<listitem>
				<para>337 - Error in Alpha installer</para>
				<para>Error message &ldquo;internal error:
					Change_variety out of range&rdquo;.</para>
				<para>Fixed in TenDRA February 96.</para>
			</listitem>

			<listitem>
				<para>338 - Error in SVID3 API (RLIM_INFINITY)</para>
				<para>Illegal type for the API
					definition <code>+CONST int RLIM_INFINITY ;</code></para>
				<para>Fixed in the next major TenDRA
					release.</para>
			</listitem>

			<listitem>
				<para>343 - Error in Linux installer (/tmp full)</para>
				<para>The translation on
					Linux/Alpha of a file required more than 80MB in /tmp</para>
				<para>Fixed in the TenDRA
					February 96.</para>
			</listitem>

			<listitem>
				<para>344 - SVID3 API (daddr_t)</para>
				<para>Casting an integer value to an unspecified
					type was not rejected.</para>
				<para>Fixed in tdfc:4.98</para>
			</listitem>
		</itemizedlist>
	</appendix>

<!-- TODO:
	<bibliography>
		<title>Bibliography</title>

		<biblioentry xreflabel="Ferri&egrave;re95-1">
			<authorgroup>
				<author>
					<firstname>Fran&ccedil;ois</firstname>
					<surname>de Ferri&egrave;re</surname>
				</author>
				<author>
					<firstname>Jacques</firstname>
					<surname>Febvre</surname>
				</author>
			</authorgroup>
			<copyright>
				<year>1995</year>
				<holder>Open Systems Research Institute</holder>
			</copyright>
			<title>Revised Plan for Validation of TenDRA Capability to Implement a
			Unix-like Operating System</title> June 1995
		</biblioentry>

		<biblioentry xreflabel="Ferri&egrave;re95-2">
			<authorgroup>
				<author>
					<firstname>Fran&ccedil;ois</firstname>
					<surname>de Ferri&egrave;re</surname>
				</author>

				<author>
					<firstname>Fred</firstname>
					<surname>Roy</surname>
				</author>
			</authorgroup>
			<copyright>
				<year>1995</year>
				<holder>Open Systems Research Institute</holder>
			</copyright>
			<para><title>Validation of TenDRA Capability to Implement a UNIX-like
				Operating System</title>June 1995</para>
		</biblioentry>
	</bibliography>
-->

</book>
