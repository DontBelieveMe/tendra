<?xml version="1.0" standalone="no"?>
<!DOCTYPE article SYSTEM "minidocbook.dtd">

<article xmlns:dt="http://xml.water-powered.com/doctools">
	<!--
		TODO: update diagrams for new $PREFIX variables; give <replaceable>$PREFIX_LIB</replaceable> etc instead of actual paths
	-->

	<articleinfo>
		<title>Orientation Guide</title>

		<author>
			<firstname>Katherine</firstname>
			<surname>Flavel</surname>
			<affiliation><orgname>The TenDRA Project</orgname></affiliation>
		</author>

		<copyright>
			<year>2012</year>
			<year>2008</year>

			<holder>The TenDRA Project</holder>
		</copyright>

		<revhistory>
			<revision role="dev">
				<date>2012-04-13</date>
				<authorinitials>kate</authorinitials>
				<revdescription>
					<para>Reworked existing vector images for consistency
						between documents.</para>
				</revdescription>
			</revision>
		</revhistory>
	</articleinfo>

	<section>
		<title>Introduction</title>

		<para>TenDRA is a relatively complex system. This document attempts
			to orientate the reader amongst the maze of file types, and to
			help show how it all fits together. The focus here is primarily
			on what files live where, and how they are involved; the details
			of each stage are not discussed at length.</para>

		<para>A few examples are given, and it is recommended that you follow
			along and experiment with various alterations whilst reading.
			This is not a comprehensive guide; it only covers the areas which
			seemed to be most relevant.</para>
	</section>

	<section>
		<title>A tour of <code>$PREFIX</code></title>

		<para>The <code>tendra.base.mk</code> makefile provides several related
			<code>$PREFIX_*</code> variables which are used to specify various
			locations on the filesystem for installation. Each of these
			corresponds to different uses:</para>

		<!-- TODO: link to appropiate manpages or dev guides for each item -->
		<table>
			<col align="left"/>
			<col align="left"/>
			<col align="left"/>

			<thead>
				<tr>
					<th>Variable</th>
					<th>Default</th>
					<th>Filetypes</th>
					<th>Description</th>
				</tr>
			</thead>

			<tbody>
				<tr>
					<td><code>PREFIX</code></td>
					<td><filename>/usr/local</filename></td>
					<td role="na" align="center">&ndash;</td>
					<td>A convenience to specify the base for everything.</td>
				</tr>

				<tr>
					<td><code>PREFIX_BIN</code></td>
					<td><filename><replaceable>${PREFIX}</replaceable>/bin</filename></td>
					<td>Executables</td>
					<td>User-facing binaries</td>
				</tr>

				<!-- TODO: maybe put PREFIX_INCLUDE in the same table cell -->
				<tr>
					<td><code>PREFIX_LIB</code></td>
					<td><filename><replaceable>${PREFIX}</replaceable>/lib</filename></td>
					<td><filename>.so</filename>, <filename>.a</filename></td>
					<td rowspan="2">User-facing libraries and their
						corresponding headers.
						These are used by users in their own code.</td>
				</tr>

				<tr>
					<td><code>PREFIX_INCLUDE</code></td>
					<td><filename><replaceable>${PREFIX}</replaceable>/include</filename></td>
					<td><filename>.h</filename></td>
				</tr>

				<tr>
					<td><code>PREFIX_LIBEXEC</code></td>
					<td><filename><replaceable>${PREFIX}</replaceable>/libexec</filename></td>
					<td>Executables</td>
					<td>Internal binaries, used by &tcc;.
						This should not be in <code>$PATH</code>.</td>
				</tr>

				<tr>
					<td><code>PREFIX_SHARE</code></td>
					<td><filename><replaceable>${PREFIX}</replaceable>/share</filename></td>
					<td>Plaintext</td>
					<td>A convenience to specify the base for
						platform-independent resources.</td>
				</tr>

				<tr>
					<td><code>PREFIX_MAN</code></td>
					<td><filename><replaceable>${PREFIX}</replaceable>/man</filename></td>
					<td><command>roff</command></td>
					<td>User-facing manpages, consumed by &man;.</td>
				</tr>

				<tr>
					<td><code>PREFIX_TSPEC</code></td>
					<td><filename><replaceable>${PREFIX_SHARE}</replaceable>/tspec</filename></td>
					<td><filename>.c</filename>, <filename>.h</filename></td>
					<td>&tspec;-generated abstract &api; implementations.
						These get combined with the system headers and compiled
						to produce concrete &api; implementations, output to
						<code>PREFIX_API</code>.</td>
				</tr>

				<tr>
					<td><code>PREFIX_STARTUP</code></td>
					<td><filename><replaceable>${PREFIX_LIB}</replaceable>/tcc/startup</filename></td>
					<td><filename>.pf</filename>, <filename>.h</filename>, environments</td> <!-- TODO: due to become .env -->
					<td>&tcc; portability tables and strictness profiles.
						These are platform-independent.</td>
				</tr>

				<tr>
					<td><code>PREFIX_ENV</code></td>
					<td><filename><replaceable>${PREFIX_LIB}</replaceable>/tcc/env</filename></td>
					<td>environments</td> <!-- TODO: due to become .env -->
					<td>&tcc; environments.
						These are platform-specific.</td>
				</tr>

				<tr>
					<td><code>PREFIX_LPI</code></td>
					<td><filename><replaceable>${PREFIX_LIB}</replaceable>/tcc/lpi</filename></td>
					<td><filename>.tl</filename></td>
					<td>&tdf; implementations of &lpi; tokens
						(e.g. <filename>c.tl</filename>, the C language types, etc).
						These are platform-specific.</td>
				</tr>

				<tr>
					<td><code>PREFIX_API</code></td>
					<td><filename><replaceable>${PREFIX_LIB}</replaceable>/tcc/api</filename></td>
					<td><filename>.tl</filename></td>
					<td>&tdf; implementations of &api; tokens
						(e.g. <filename>c89.tl</filename>, the &ansi; C89 &api;).
						These are platform-specific.</td>
				</tr>

				<tr>
					<td><code>PREFIX_SYS</code></td>
					<td><filename><replaceable>${PREFIX_LIB}</replaceable>/tcc/sys</filename></td>
					<td><filename>.a</filename>, <filename>.o</filename>, etc</td>
					<td>System interface miscellany (e.g. <filename>crt*.o</filename>).
						These are platform-specific.</td>
				</tr>

				<tr>
					<td><code>PREFIX_TMP</code></td>
					<td><filename>/tmp</filename></td>
					<td><filename>tcc-<replaceable>XXXXXX</replaceable>/</filename></td>
					<td>Temporary workspace for &tcc;.</td>
				</tr>
			</tbody>
		</table>

		<para>During a build these may be overridden individually, but they
			default to values based on <code>$PREFIX</code>, and so overriding
			just that suffices for most situations.
			The best choices for these paths depends on the filesystem layout
			for each particular system.</para>

<!--
TODO: "here's a fairly typical layout" example
-->
	</section>

	<section>
		<title>Dependencies</title>

<!-- TODO:
bootstrap build
bootstrap execution
bootstrap-rebuild build
bootstrap-rebuild execution (i.e. normal execution)
developer-regeneration

TODO: explain goal of each stage (e.g. goal for bootstrap: to produce just enough to compile the rest of the system - required because parts are written in tcc-specific languages)

Several things to show here:
	- build dependencies; what needs to be present in order to compile something
	- runtime dependncies; what needs to be present in order to run something, after it is built
	- developer regeneration dependencies; 

TODO: consider showing as three large graphs; build, runtime and regeneration - for the entire system
 -->

		<para>TenDRA is comprised of a suite of related tools, each packaged
			separately.
			The dependencies required for building these are:</para>

		<figure>
			<title>Build dependencies</title>

			<graphic fileref="images/dep-build.svg"/>
		</figure>

		<para>Note that <quote><code>cc</code></quote> here represents the
			system compiler, which may or may not itself be an installation
			of TenDRA.</para>

		<para>The runtime dependencies are:</para>

		<figure>
			<title>Runtime dependencies</title>

			<graphic fileref="images/dep-run.svg"/>
		</figure>

		<para>These runtime dependencies require the respective tools to be
			installed under <code>$PREFIX</code> in order to be used. However,
			once installed, they know where to find their own resources, and
			so need not be deployed into the system's <code>$PATH</code>,
			or set up using &ldconfig;, etc. In other words, TenDRA may be
			installed to some temporary <code>$PREFIX</code> and run from
			there. The installation does not require root.</para>

		<para>Finally, as is typical with compilers, some of the tools are
			written using themselves; these have generated code which
			occasionally needs to be rebuilt by developers. The dependencies
			for rebuilding are:</para>

		<figure>
			<title>Developer regeneration dependencies</title>

			<graphic fileref="images/dep-regen.svg"/>
		</figure>

		<para>These dependencies are not relevant to package managers or
			system adminstrators building TenDRA; they are of interest to
			TenDRA's developers only.</para>
	</section>

	<section>
		<title>Bootstrap</title>

		<para>The goal of bootstrapping is to produce the bare minimum required
			for the system to be able to build itself. This is neccessary
			because the system compiler alone is unable to build the whole of
			TenDRA, as many parts are written using TenDRA-specific mechanisms.
			For example, the &api; implementations which &tspec; produces are
			encoded using the <code>#pragma</code> token definition
			syntax<!-- TODO: link --> which is only meaningful to the &tdfc2;
			producer.</para>

		<para>The phases of bootstrapping TenDRA are simply:</para>

		<orderedlist>
			<listitem>Use the system compiler to build just the TenDRA tools
				required to be able to recompile itself, and the rest of the
				TenDRA system. This stage may be omitted if the system
				compiler is itself TenDRA (when upgrading, for
				example).</listitem>

			<listitem>Use the bootstrapped minimal TenDRA compiler to build
				everything required for final use.</listitem>
		</orderedlist>

		<para>This is simpler than for many older systems, which often take
			into account system compilers that only implement a subset of
			standard C. Such a situation is unlikely to occur now, and so the
			bootstrap process is simplified by being able to rely on code
			which is written in standard C.</para>

		<section>
			<title>Building the bootstrap compiler</title>

			<para>The dependencies which must be satisfied using the system
				compiler are as illustrated below. Note that relatively few
				projects are required; many tools are omitted (&disp;, for
				example) because they are not required for the next stage
				of rebuilding.</para>

			<figure>
				<title>Build dependencies for bootstrap</title>

				<graphic fileref="images/dep-bootstrap-build.svg"/>
			</figure>

			<para>Bootstrapping is of course traditional for compilers; it is
				a natural step for any general purpose compiler to make
				minimal use of the system compiler, and then proceed to
				rebuild using itself.</para>

			<para>The runtime dependencies for using this minimal bootstrap
				compiler are the same as the dependencies for those same tools
				in general use, as illustrated in <!-- TODO: link to dep-run.svg-->
				.</para>
		</section>

		<section>
			<title>Rebuilding using the bootstrap compiler</title>

			<para>TODO</para>
		</section>
	</section>

	<section>
		<title>Building &api;s</title>

		<para>The &api; checking is one of the more interesting areas of
			TenDRA. An overview of the process of building &api;s is
			given in <xref linkend="apibuilding"/>.
			This diagram expands on the top-right and bottom-right
			quadrants of the &tdf; compilation phases described in
			&tdf-portability.doc;.</para>

		<figure id="apibuilding">
			<title>Files Involved for Building &api;s</title>

			<graphic fileref="images/apibuilding.svg"/>
		</figure>

		<para>An &api; consists of abstract specifications of a set of
			&api;s<footnote>
				<para><dt:source path="/tendra/src/lib/apis/"/></para>
			</footnote> which represent a similar level of abstraction that their
			respective standards represent. For example, <code>size_t</code>
			for the C89 &api; is defined to be an unsigned arithmetic
			type, but exactly which type is left to the implementation.
			See <dt:doc name="tspecguide"/> for details on specifying
			&api;s.</para>

		<para>These abstract specifications are converted by &tspec; into
			&api; Source and &api; Includes. The &api; Includes contain
			<code>#pragma token</code> statements which create tokens that
			correspond to the various things the &api; defines. Details of these
			are documented in the <code>tdfc2</code> guide. These are used
			later on, during compilation of users' programs.</para>

		<para>The generated &api; Source from &tspec; contains implementations of
			just the symbols present in each header for an &api; (as opposed to
			all the extensions your system probably provides), guarded by
			preprocessor conditions. These guards are of a standard form; for
			example, <code>ssize_t.c</code> from the <code>posix1</code>
			&api;:</para>

<programlisting language="C">
/* AUTOMATICALLY GENERATED BY tspec 2.8 */
#ifndef __WRONG_POSIX1
#ifndef __WRONG_POSIX1_SYS_TYPES_H_SSIZE_T
#if #include ( sys/types.h )
#define __BUILDING_TDF_POSIX1_SYS_TYPES_H_SSIZE_T
#include &lt;sys/types.h&gt;
#endif
#endif

#ifndef __BUILDING_TDF_POSIX1_SYS_TYPES_H_SSIZE_T
#pragma TenDRA no token definition allow
#endif
#pragma implement interface &lt;../shared/posix1.api/ssize_t.h&gt;
#endif</programlisting>

		<para>In the &api; specifications fed to &tspec;, <code>ssize_t</code>
			is a subset; the <code>__WRONG_POSIX1_SYS_TYPES_H_SSIZE_T</code>
			guard above is provided so that it may be excluded if your
			system does not have a compliant implementation of
			<code>ssize_t</code>.</para>

		<para>Non-compliance for a particular machine is indicated by
			setting <code>__WRONG_*</code> macros in the start-up files for
			that machine. Hence for &ultrix;, which (apparently) has a
			<code>ssize_t</code> incompatible to the <code>posix1</code>
			&api;'s, <dt:source href="/tendra/src/lib/machines/ultrix/mips/startup/posix1.h">the Startup header for &ultrix;</dt:source> defines <code>__WRONG_POSIX1_SYS_TYPES_H_SSIZE_T</code> and hence <code>ssize_t</code> is omitted when
			compiling the &tspec; &api; Source into the &api; &tdf; Tokens.
			See &porting.doc; for a worked example of making use of
			these macros.</para>

		<para>The compiled &api; &tdf; Tokens are linked together into
			<code>.tl</code> libraries; each library represents an
			&api;. As explained above, the contents of these libraries
			are the intersection of the sets of the things defined in
			that particular &api; and what your system provides.</para>
	</section>

	<section>
		<title>Production of TDF</title>

		<para>Based on the files installed, the process of compilation is
			outlined in <xref linkend="production"/>. These steps may be
			seen by executing <code>tcc -dry</code>.</para>

		<figure id="production">
			<title>Files involved during production</title>

			<graphic fileref="images/production.svg"/>
		</figure>

		<para>C is used as an example here, though similar things
			apply for any other producer. The main difference would be in
			&api; checking.</para>

		<para>It is important to note that during compilation the system
			headers are not used at all. Instead, the various prototypes and
			such which would be bought in by <code>#include</code> statements
			are prepended from the &api; Includes. These can be seen by running
			<code>tcc -E</code>:</para>

<programlisting language="C">
clarion% tcc -Yc89 -E hello.c
#line 1 "hello.c"
...
#line 13 "<replaceable>$PREFIX_TSPEC</replaceable>/TenDRA/include/shared/c89.api/size_t.h"
...
#pragma token VARIETY unsigned size_t # size_t
#pragma token VARIETY __size_t # __size_t
#pragma promote size_t : __size_t

#pragma no_def size_t __size_t

...
#line 25 "<replaceable>$PREFIX_TSPEC</replaceable>/TenDRA/include/c89.api/stdio.h"
#pragma token EXP rvalue : FILE * : stdin # c89.stdio.stdin
#pragma token EXP rvalue : FILE * : stdout # c89.stdio.stdout
#pragma token EXP rvalue : FILE * : stderr # c89.stdio.stderr
...
#pragma token FUNC int ( __local_printf_string, ... ) : printf # c89.stdio.printf

#line 3 "hello.c"
int main(void) {
        printf("hello, world\n");
        return 0;
}</programlisting>

		<para>Here I've omitted most of the things <code>&lt;stdio.h&gt;</code>
			defines, just to keep the example small.</para>

		<para>Note that the contents of the &tspec; &api; Includes are
			portable; they ought to be the same for any system (this should
			be the case, since they were generated from the &tspec; &api;
			Specification sources, which did not involve anything
			system-specific). Therefore since these are included verbatim for
			a given &api; at the top of a users' C program, we can infer that
			the &tdf; capsule produced (<code>foo.j</code>is itself portable.
			This is what TenDRA is all about: producing a portable binary.
			The steps following (namely the call to &trans; and beyond) may
			therefore be on a different system than the one on which
			<code>hello.j</code> was produced, even though that system may
			have a different implementation of the &api;s used.
			As long as the target system provides the same subset in its
			<code>$api.tl</code>, the code will link and execute as expected.
			For details on this, see <dt:doc name="tdfandportability"/>.</para>
	</section>

	<section>
		<title>Installation of TDF</title>

		<para>The final step of linking also brings in any system-specific
			libraries which may be required (such as <code>crt0.o</code>),
			and of course any user-specified libraries, if given.
			These are illustrated representatively and their exact details
			differ per platform.</para>

		<figure id="installation">
			<title>Files involved during installation</title>

			<graphic fileref="images/installation.svg"/>
		</figure>
	</section>

</article>

