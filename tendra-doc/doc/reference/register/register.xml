<?xml version="1.0" standalone="no"?>
<!DOCTYPE book SYSTEM "minidocbook.dtd">

<!--
	$Id$
-->

<book>
	<bookinfo>
		<title>The &tdf; Token Register</title>

		<authorgroup>
			<othercredit class="copyeditor">
				<firstname>Katherine</firstname>
				<surname>Flavel</surname>
				<affiliation><orgname>The TenDRA Project</orgname></affiliation>
			</othercredit>
			<corpauthor>DERA</corpauthor>
		</authorgroup>

		<pubdate>January 1998</pubdate>
		<!-- TODO: <pubdate>2007</pubdate> -->

		<copyright>
			<year>2007</year>
			<holder>The TenDRA Project</holder>
		</copyright>

		<copyright>
			<!-- Crown Copyright (c) 1998 -->
			<year>1998</year>
			<holder>DERA</holder>
		</copyright>
	</bookinfo>

	<chapter>
		<title>Introduction</title>

		<section>
			<title>Background</title>

			<para>&tdf; is an interface used for architecture neutral and programming
				language neutral representation of program. It is used both within
				portable language specific compilation systems, and for architecture
				neutral distribution of compiled programs. For full details see
				&tdf-spec.doc;.</para>

			<para>&tdf; tokens offer a general encapsulation and expansion mechanism which
				allows any implementation detail to be delayed to the most appropriate
				stage of program translation. This provides a means for encapsulating
				any target dependencies in a neutral form, with specific implementations
				defined through standard &tdf; features. This raises a natural opportunity
				for well understood sets of &tdf; tokens to be included along with &tdf;
				itself as interface between &tdf; tools.</para>

			<para>This first revision includes additional tokens for accessing variable
				parameter lists (see <xref linkend="accessingvalist"/>), and a C mapping
				token to support the optional type <code>long long int</code>.</para>
		</section>

		<section>
			<title>Token Register Objectives</title>

			<para>As &tdf; tokens may be used to represent any piece of &tdf;, they may
				be used to supplement any &tdf; interface between software tools. However,
				that raises the issue of control authority for such an interface.
				In many cases, the interfaces may be considered to &ldquo;belong&rdquo; to a particular
				tool. In other cases, the names and specifications of tokens need
				to be recorded for common use.</para>

			<para>This token register is used to record the names and specifications
				of tokens which may need to be assumed by more than one software tool.
				It also defines a naming scheme which should be used consistently
				to avoid ambiguity between tokens.</para>

			<para>Five classes of tokens are identified:</para>

			<variablelist>
				<varlistentry>
					<term><link linkend="targetdep">Target dependency tokens</link></term>

					<listitem>
						<para>concerned with describing
							target architecture or translator detail;</para>
					</listitem>
				</varlistentry>

				<varlistentry>
					<term><link linkend="basicmappingtoks">Basic mapping tokens</link></term>

					<listitem>
						<para>relating general language features to
							architecture detail;</para>
					</listitem>
				</varlistentry>

				<varlistentry>
					<term><link linkend="tdfinterfacetoks">TDF interface tokens</link></term>

					<listitem>
						<para>These may be required
							to complete the specification of some &tdf; constructs;</para>
					</listitem>
				</varlistentry>

				<varlistentry>
					<term><link linkend="lpis">Language Programming Interfaces</link> (&lpi;)</term>

					<listitem>
						<para>These may be specific to a particular producer;</para>
					</listitem>
				</varlistentry>

				<varlistentry>
					<term><link linkend="apis">Application Programming Interfaces</link> (&api;)</term>

					<listitem>
						<para>corresponding to libraries' interfaces.</para>
					</listitem>
				</varlistentry>
			</variablelist>

			<para>These classes are discussed separately, in <xref linkend="targetdep"/>
				to <xref linkend="apis"/> below.</para>
		</section>
	</chapter>

	<chapter id="namingscheme">
		<title>Naming scheme</title>

		<para>A flat name space will suffice for &tdf; token names if producer writers
			adopt the simple constraints described here. &tdf; has separate provision
			for a hierarchic unique naming scheme, but that was intended for a
			specific purpose that has not yet been realised.</para>

		<para>External names for program or application specific tokens should be
			confined to &ldquo;simple names&rdquo;, which we define to mean that they consist
			only of letters, digits and underscore, the characters allowed in
			C identifiers. Normally there will be very few such external names,
			as tokens internal to a single capsule do not require to be named.
			All other token names will consist of some controlled prefix followed
			by a simple name, with the prefix identifying the control authority.</para>

		<para>For &api; tokens, the prefix will consist of a sequence of simple names,
			each followed by a dot, where the first simple name is the name of
			the &api; as listed or referred to in <xref linkend="apis"/>.</para>

		<para>The prefix for producer specific and target dependency tokens will
			begin and end with characters that distinguish them from the above
			cases. However, common tools such as <!-- TODO application tags -->DISP, TNC and PL-&tdf; assume that
			token names contain only letters, digits, underscore, dot, and/or
			twiddle<!-- TODO tilde? -->.</para>

		<para>The following prefixes are currently reserved:</para>

		<table>
			<col align="center"/>
			<col align="left"/>

			<thead>
				<tr>
					<th>Prefix</th>
					<th>Reservation</th>
				</tr>
			</thead>

			<tbody>
				<tr>
					<td><code>~</code></td>
					<td>&tdf; interface tokens as specified in
						<xref linkend="tdfinterfacetoks"/> below, and also &lpi; tokens
						specific to <acronym>DRA</acronym>'s C producer.</td>
					<!-- TODO split into ~ and ~c. respectively? - kate -->
				</tr>

				<tr>
					<td><code>.~</code></td>
					<td>Registered target dependency tokens as specified
						in <xref linkend="targetdep"/> below, and basic mapping tokens specified
						in section <xref linkend="basicmappingtoks"/>.</td>
				</tr>

				<tr>
					<td><code>~c.</code></td>
					<td>&lpi; tokens specific to <acronym>DRA</acronym>'s C++ producer,
						other than those it shares with the C producer.</td>
				</tr>

				<tr>
					<td><code>.Et~</code></td>
					<td>&lpi; tokens specific to Etnoteam's Fortran77 producer.</td>
				</tr>
			</tbody>
		</table>
	</chapter>

	<chapter id="targetdep">
		<title>Target dependency tokens</title>

		<para>Target dependency tokens provide a common interface to simple constructs
			where the required detail for any specific architecture can be expressed
			within &tdf;, but the detail will be architecture specific. Every installer
			should have associated with it, a capsule containing the installer
			specific definitions of all the tokens specificed within
			<xref linkend="targetdep"/>.</para>

		<para>Some of these tokens provide information about the integer and floating
			point variety representations supported by an installer, in a form
			that may be used by &tdf; analysis tools for architecture specific analysis,
			or by library generation tools when generating an architecture specific
			version of a library. Other target dependency tokens provide commonly
			required conversion routines.</para>

		<para>It is recommended that these tokens should not be used directly within
			application programs. They are designed for use within &lpi; definitions,
			which can provide a more appropriate interface for applications.</para>

		<section>
			<title>Integer variety representations</title>

			<para>Since &tdf; specifies integer representations to be twos-complement,
				the number of bits required to store an integer variety representation
				fully specifies that representation. The minimum or maximum signed
				or unsigned integer that can be represented within any variety representation
				can easily be determined from the number of bits.</para>

			<section>
				<title><code>.~rep_var_width</code></title>

				<programlisting language="tdf">
<code>w</code>:	NAT
	-&gt; NAT</programlisting>

				<para>If <code>w </code>lies within the range of <code>VARIETY</code> sizes supported
					by the associated installer, <code>rep_var_width</code>(<code>w</code>) will be
					the number of bits required to store values of <code>VARIETY</code>
					<code>var_width</code>(<code>b</code>,<code>w</code>), for any <code>BOOL</code> <code>b</code>.</para>

				<para>If <code>w </code>is outside the range of <code>VARIETY</code> sizes supported
					by the associated installer, <code>rep_var_width</code>(<code>w</code>) will be
					0.</para>

			</section>

			<section>
				<title><code>.~rep_atomic_width</code></title>

				<programlisting language="tdf">
	-&gt; NAT</programlisting>

				<para><code>.~rep_atomic_width</code> will be the number of bits required to store
					values of some <code>VARIETY</code> <code>v </code>such that <code>assign</code>
					and <code>assign_with_mode</code> are atomic operations if the value assigned
					has <code>SHAPE</code> <code>integer</code>(<code>v</code>). The &tdf; specification
					guarantees existence of such a number.</para>
			</section>

			<section id="floatreps">
				<title>Floating variety representations</title>

				<para>Floating point representations are much more diverse than integers,
					but we may assume that each installer will support a finite set of
					distinct representations. For convenience in distinguishing between
					these representations within architecture specific &tdf;, the set of
					distinct representations supported by any specific installer are stated
					to be ordered into a sequence of non-decreasing memory size. An analysis
					tool can easily count through this sequence to determine the properties
					of all supported representations, starting at 1 and using <code>.~rep_fv_width
					</code> to test for the sequence end.</para>

			<section>
				<title><code>.~rep_fv</code></title>

				<programlisting language="tdf">
<code>n</code>:	NAT
	-&gt; FLOATING_VARIETY</programlisting>

				<para><code>.~rep_fv</code>(<code>n</code>) will be the <code>FLOATING_VARIETY</code>
					whose representation is the <code>n</code>th of the sequence of supported
					floating point representations.
					<code>n</code> will lie within this range.</para>
			</section>

			<section>
				<title><code>.~rep_fv_width</code></title>

				<programlisting language="tdf">
<code>n</code>:	NAT
	-&gt; NAT</programlisting>

				<para>If <code>n</code> lies within the sequence range of supported floating point
					representations, <code>.~rep_fv_width</code>(<code>n</code>) will be the number
					of bits required to store values of <code>FLOATING_VARIETY</code>
					<code>.~rep_fv</code>(<code>n</code>).</para>

				<para>If <code>n</code> is outside the sequence range of supported floating point
					representations, <code>.~rep_fv_width</code>(<code>n</code>) will be 0.</para>
			</section>

			<section>
				<title><code>.~rep_fv_radix</code></title>

				<programlisting language="tdf">
<code>n</code>:	NAT
	-&gt; NAT</programlisting>

				<para><code>.~rep_fv_radix</code>(<code>n</code>) will be the radix used in the representation
					of values of <code>FLOATING_VARIETY</code> <code>.~rep_fv</code>(<code>n</code>).</para>

				<para><code>n</code> will lie within the sequence range of supported floating
					point representations.</para>
			</section>

			<section>
				<title><code>.~rep_fv_mantissa</code></title>

				<programlisting language="tdf">
<code>n</code>:	NAT
	-&gt; NAT</programlisting>

				<para><code>.~rep_fv_mantissa</code>(<code>n</code>) will be the number of base
					<code>.~rep_fv_radix</code>(<code>n</code>) digits in the mantissa representation
					of values of <code>FLOATING_VARIETY</code> <code>.~rep_fv</code>(<code>n</code>).</para>

				<para><code>n</code> will lie within the sequence range of supported floating
					point representations.</para>
			</section>

			<section>
				<title><code>.~rep_fv_min_exp</code></title>

				<programlisting language="tdf">
<code>n</code>:	NAT
	-&gt; NAT</programlisting>

				<para><code>.~rep_fv_min_exp</code>(<code>n</code>) will be the maximum integer
					<code>m</code> such that (<code>.~rep_fv_radix</code>(<code>n</code>))<code>-m</code>
					is exactly representable (though not necessarily normalised) by the
					<code>FLOATING_VARIETY</code> <code>.~rep_fv</code>(<code>n</code>).</para>

				<para><code>n</code> will lie within the sequence range of supported floating
					point representations.</para>
			</section>

			<section>
				<title><code>.~rep_fv_max_exp</code></title>

				<programlisting language="tdf">
<code>n</code>:	NAT
	-&gt; NAT</programlisting>

				<para><code>.~rep_fv_max_exp</code>(<code>n</code>) will be the maximum integer
					<code>m</code> such that (<code>.~rep_fv_radix</code>(<code>n</code>))<code>m</code>
					is exactly representable by the <code>FLOATING_VARIETY</code> <code>.~rep_fv</code>(
					<code>n</code>).</para>

				<para><code>n</code> will lie within the sequence range of supported floating
					point representations.</para>
			</section>

			<section>
				<title><code>.~rep_fv_epsilon</code></title>

				<programlisting language="tdf">
<code>n</code>:	NAT
	-&gt; EXP FLOATING .~rep_fv(<code>n</code>)</programlisting>

				<para><code>.~rep_fv_epsilon</code>(<code>n</code>) will be the smallest strictly positive
					real <code>x </code>such that (1.0 + <code>x</code>) is exactly representable
					by the <code>FLOATING_VARIETY</code> <code>.~rep_fv(n)</code>.</para>

				<para><code>n</code> will lie within the sequence range of supported floating
					point representations.</para>
			</section>

			<section>
				<title><code>.~rep_fv_min_val</code></title>

				<programlisting language="tdf">
<code>n</code>:	NAT
	-&gt; EXP FLOATING .~rep_fv(<code>n</code>)</programlisting>

				<para><code>.~rep_fv_min_val</code>(<code>n</code>) will be the smallest strictly positive
					real number that is exactly representable (though not necessarily
					normalised)) by the <code>FLOATING_VARIETY</code> <code>.~rep_fv(n)</code>.</para>

				<para><code>n</code> will lie within the sequence range of supported floating
					point representations.</para>
			</section>

			<section>
				<title><code>.~rep_fv_max_val</code></title>

				<programlisting language="tdf">
<code>n</code>:	NAT
	-&gt; EXP FLOATING .~rep_fv(<code>n</code>)</programlisting>

				<para><code>.~rep_fv_max_val</code>(<code>n</code>) will be the largest real number
					that is exactly representable by the <code>FLOATING_VARIETY</code>
					<code>.~rep_fv(n)</code>.</para>

				<para><code>n</code> will lie within the sequence range of supported floating
					point representations.</para>
			</section>
		</section>

		<section>
			<title>Non-numeric representations</title>

			<section>
				<title><code>.~ptr_width</code></title>

				<programlisting language="tdf">
	-&gt; NAT</programlisting>

				<para><code>.~ptr_width</code> will be the minimum <code>.~rep_var_width</code>(<code>w</code>)
					for any <code>w </code>such that any pointer to any alignment may be converted
					to an integer of <code>VARIETY</code> <code>var_width</code>(<code>b</code>,<code>w</code>),
					for some <code>BOOL</code> <code>b</code>, and back again without loss of
					information, using the conversions <code>.~ptr_to_int</code> and <code>.~int_to_ptr</code>
					(q.v.).</para>
			</section>

			<section>
				<title><code>.~best_div</code></title>

				<programlisting language="tdf">
	-&gt; NAT</programlisting>

				<para><code>.~best_div</code> is 1 or 2 to indicate preference for class 1 or
					class 2 division and modulus (as defined in the &tdf; Specification).
					This token would be used in situations where either class is valid
					but must be used consistently.</para>
			</section>

			<section>
				<title><code>.~little_endian</code></title>

				<programlisting language="tdf">
	-&gt; BOOL</programlisting>

				<para><code>.~little_endian</code> is a property of the relationship between different
					variety representations and arrays. If an array of a smaller variety
					can be mapped onto a larger variety, and <code>.~little_endian</code>
					is true, then smaller indices of the smaller variety array map onto
					smaller ranges of the larger variety. If <code>.~little_endian</code>
					is false, no such assertion can be made.</para>
			</section>
		</section>

		<section>
			<title>Common conversion routines</title>

			<para>This subsection contains a set of conversion routines between values
				of different shapes, that are not required to have any specific meaning
				apart from reversability. If the storage space requirements for the
				two shapes are identical, the conversion can usually be achieved without
				change of representation. When that is the case, and if the two shapes
				can be stored at a common alignment, the conversion can simply be
				achieved by assignment via a common union, which will ensure the required
				alignment consistency.</para>
			</section>

			<section>
				<title><code>.~ptr_to_ptr</code></title>

				<programlisting language="tdf">
<code>a1</code>:	ALIGNMENT
<code>a2</code>:	ALIGNMENT
<code>p</code>:	EXP POINTER(<code>a1</code>)
	-&gt; EXP POINTER(<code>a2</code>)</programlisting>

				<para><code>.~ptr_to_ptr</code> converts pointers from one pointer shape to another.</para>

				<para>If <code>p</code> is any pointer with alignment <code>a1</code>, then <code>.~ptr_to_ptr
					</code>(<code>a2</code>, <code>a1</code>, <code>.~ptr_to_ptr</code>(<code>a1</code>,
					<code>a2</code>, <code>p</code>)) shall result in the same pointer <code>p</code>, provided
					that the number of bits required to store a pointer with alignment
					<code>a2</code> is not less than that required to store a pointer with alignment
					<code>a1</code>.</para>
			</section>

			<section>
				<title><code>.~ptr_to_int</code></title>

				<programlisting language="tdf">
<code>a</code>:	ALIGNMENT
<code>v</code>:	VARIETY
<code>p</code>:	EXP POINTER(<code>a</code>)
	-&gt; EXP INTEGER(<code>v</code>)</programlisting>

				<para><code>.~ptr_to_int</code> converts a pointer to an integer. The result is
					undefined if the <code>VARIETY</code> v is insufficient to distinguish
					between all possible distinct pointers <code>p</code> of alignment <code>a</code>.</para>
			</section>

			<section>
				<title><code>.~int_to_ptr</code></title>

				<programlisting language="tdf">
<code>v</code>:	VARIETY
<code>a</code>:	ALIGNMENT
<code>i</code>:	EXP INTEGER(<code>v</code>)
	-&gt; EXP POINTER(<code>a</code>)</programlisting>

				<para><code>.~int_to_ptr</code> converts an integer to a pointer. The result is
					undefined unless the integer i was obtained without modification from
					some pointer using <code>.~ptr_to_int</code> with the same variety and alignment
					arguments.</para>

				<para>If <code>p</code> is any pointer with alignment <code>a</code>, and <code>v</code>
					is <code>var_width</code>(<code>b</code>, <code>.~ptr_width</code>) for some <code>BOOL</code>
					<code>b</code>, then <code>.~int_to_ptr</code>(<code>v</code>, <code>a</code>, <code>.~ptr_to_int
					</code>(<code>a</code>, <code>v</code>, <code>p</code>)) shall result in the same pointer
					<code>p</code>.</para>
			</section>

			<section>
				<title><code>.~f_to_ptr</code></title>

				<programlisting language="tdf">
<code>a</code>:	ALIGNMENT
<code>fn</code>:	EXP PROC
	-&gt; EXP POINTER(<code>a</code>)</programlisting>

				<para><code>.~f_to_ptr</code> converts a procedure to a pointer. The result is
					undefined except as required for consistency with <code>.~ptr_to_f</code>.</para>
			</section>

			<section>
				<title><code>.~ptr_to_f</code></title>

				<programlisting language="tdf">
<code>a</code>:	ALIGNMENT
<code>p</code>:	EXP POINTER(<code>a</code>)
	-&gt; EXP PROC</programlisting>

				<para><code>.~ptr_to_f</code> converts a pointer to a procedure. The result is
					undefined unless the pointer p was obtained without modification from
					some procedure <code>f</code> using <code>.~f_to_ptr</code>(<code>a</code>,
					<code>f</code>). The same procedure <code>f</code> is delivered.</para>
			</section>
		</section>
	</chapter>

	<chapter id="basicmappingtoks">
		<title>Basic mapping tokens</title>

		<para>Basic mapping tokens provide target specific detail for specific language
			features that are defined to be target dependent. This detail need
			not be fixed for a particular target architecture, but needs to provide
			compatibility with any external library with which an application
			program is to be linked.</para>

		<para>Tokens specific to the C and Fortran language families are included.
			Like the target dependency tokens, it is again recommended that these
			tokens should not be used directly within application programs. They
			are designed for use within &lpi; definitions, which can provide a more
			appropriate interface for applications.</para>

		<para>Every operating system variant of an installer should have associated
			with it, a capsule containing the definitions of all the tokens specificed
			within <xref linkend="basicmappingtoks"/>.</para>

		<section id="cmappingtoks">
			<title>C mapping tokens</title>

			<section>
				<title><code>.~char_width</code></title>

				<programlisting language="tdf">
	-&gt; NAT</programlisting>

				<para><code>.~char_width</code> is the number of bits required to store values
					of the representation <code>VARIETY</code> that corresponds to the
					C type <code>char</code>.</para>
			</section>

			<section>
				<title><code>.~short_width</code></title>

				<programlisting language="tdf">
	-&gt; NAT</programlisting>

				<para><code>.~short_width</code> is the number of bits required to store values
					of the representation <code>VARIETY</code> that corresponds to the
					C type <code>short int</code>.</para>
			</section>

			<section>
				<title><code>.~int_width</code></title>

				<programlisting language="tdf">
	-&gt; NAT</programlisting>

				<para><code>.~int_width</code> is the number of bits required to store values
					of the representation <code>VARIETY</code> that corresponds to the
					C type <code>int</code>.</para>
			</section>

			<section>
				<title><code>.~long_width</code></title>

				<programlisting language="tdf">
	-&gt; NAT</programlisting>

				<para><code>.~long_width</code> is the number of bits required to store values
					of the representation <code>VARIETY</code> that corresponds to the
					C type <code>long int</code>.</para>
			</section>

			<section>
				<title><code>.~longlong_width</code></title>

				<programlisting language="tdf">
	-&gt; NAT</programlisting>

				<para><code>.~longlong_width</code> is the number of bits required to store values
					of the representation <code>VARIETY</code> that corresponds to the
					C type <code>long long int</code>.</para>
			</section>

			<section>
				<title><code>.~size_t_width</code></title>

				<programlisting language="tdf">
	-&gt; NAT</programlisting>

				<para><code>.~size_t_width</code> is the number of bits required to store values
					of the representation <code>VARIETY</code> that corresponds to the
					C type <code>size_t</code>. It will be the same as one of <code>.~short_width</code>,
					<code>.~int_width</code>, or <code>.~long_width</code>.</para>
			</section>

			<section>
				<title><code>.~fl_rep</code></title>

				<programlisting language="tdf">
	-&gt; NAT</programlisting>

				<para><code>.~fl_rep</code> is the sequence number (see <xref linkend="floatreps"/>)
					of the floating point representation to be used for values of C type
					<code>float</code>.</para>
			</section>

			<section>
				<title><code>.~dbl_rep</code></title>

				<programlisting language="tdf">
	-&gt; NAT</programlisting>

				<para><code>.~dbl_rep</code> is the sequence number (see subsection 3.2) of the
					floating point representation to be used for values of C type
					<code>double</code>.</para>
			</section>

			<section>
				<title><code>.~ldbl_rep</code></title>

				<programlisting language="tdf">
	-&gt; NAT</programlisting>

				<para><code>.~ldbl_rep</code> is the sequence number (see subsection 3.2) of the
					floating point representation to be used for values of C type
					<code>long double</code>.</para>
			</section>

			<section>
				<title><code>.~pv_align</code></title>

				<programlisting language="tdf">
	-&gt; ALIGNMENT</programlisting>

				<para><code>.~pv_align</code> is the common alignment for all pointers that can
					be represented by the C generic pointer type <code>void*</code>. For architecture
					independence, this would have to be a union of several alignments,
					but for many installers it can be simplified to
					<code>alignment</code>(<code>integer</code>(<code>var_width</code>(<code>false</code>,
					<code>.~char_width</code>))).</para>
			</section>

			<section>
				<title><code>.~min_struct_rep</code></title>

				<programlisting language="tdf">
	-&gt; NAT</programlisting>

				<para><code>.~min_struct_rep</code> is the number of bits required to store values
					of the smallest C integral type which share the same alignment properties
					as a structured value whose members are all of that same integral
					type. It will be the same as one of <code>.~char_width</code>,
					<code>.~short_width</code>, <code>.~int_width</code>, or <code>.~long_width</code>.</para>
			</section>

			<section>
				<title><code>.~char_is_signed</code></title>

				<programlisting language="tdf">
	-&gt; BOOL</programlisting>

				<para><code>.~char_is_signed</code> is <code>true</code> if the C type <code>char</code>
					is treated as signed, or <code>false</code> if it is unsigned.</para>
			</section>

			<section>
				<title><code>.~bitfield_is_signed</code></title>

				<programlisting language="tdf">
	-&gt; BOOL</programlisting>

				<para><code>.~bitfield_is_signed</code> is <code>true</code> if bitfield members of
					structures in C are treated as signed, or <code>false</code> if unsigned.</para>
			</section>
		</section>

		<section>
			<title>Fortran mapping tokens</title>

			<section>
				<title><code>.~F_char_width</code></title>

				<programlisting language="tdf">
	-&gt; NAT</programlisting>

				<para><code>.~F_char_width</code> is the number of bits required to store values
					of the representation <code>VARIETY</code> that corresponds to the
					Fortran77 type <code>CHARACTER</code>.</para>

				<para>In most cases, <code>.~F_char_width</code> is the same as <code>.~char_width</code>.</para>
			</section>

			<section>
				<title><code>.~F_int_width</code></title>

				<programlisting language="tdf">
	-&gt; NAT</programlisting>

				<para><code>.~F_int_width</code> is the number of bits required to store values
					of the representation <code>VARIETY</code> that corresponds to the
					Fortran77 type <code>INTEGER</code>.</para>

				<para>In most cases, <code>.~F_int_width</code> is the same as <code>.~int_width</code>.</para>
			</section>

			<section>
				<title><code>.~F_fl_rep</code></title>

				<programlisting language="tdf">
	-&gt; NAT</programlisting>

				<para><code>.~F_fl_rep</code> is the sequence number (see <xref linkend="floatreps"/>)
					of the floating point representation to be used for values of Fortran77
					type <code>REAL</code>, with the constraint that <code>.~rep_fv_width</code>(<code>.~F_fl_rep
					</code>) = <code>.~F_int_width</code>.</para>

				<para>If this constraint cannot be met, <code>.~F_fl_rep</code> will be 0.</para>
			</section>

			<section>
				<title><code>.~F_dbl_rep</code></title>

				<programlisting language="tdf">
	-&gt; NAT</programlisting>

				<para><code>.~F_dbl_rep</code> is the sequence number (see subsection 3.2) of
					the floating point representation to be used for values of Fortran77
					type <code>DOUBLE PRECISION</code>, with the constraint that <code>.~rep_fv_width</code>(
					<code>.~F_dbl_rep</code>) = 2 * <code>.~F_int_width</code>.</para>

				<para>If this constraint cannot be met, <code>.~F_dbl_rep</code> will be 0.</para>
			</section>
		</section>
	</chapter>

	<chapter id="tdfinterfacetoks">
		<title>&tdf; Interface tokens</title>

		<para>A very few specifically named tokens are referred to within the &tdf;
			specification, which are required to complete the ability to use certain
			&tdf; constructs. Responsibility for providing appropriate definitions
			for these tokens is indicated with the specifications below.</para>

		<para>Similarly, a few tokens are specified within the &tdf; Diagnostic Specification.</para>

		<section>
			<title>Exception handling</title>

			<section>
				<title><code>~Throw</code></title>

				<programlisting language="tdf">
	<code>n</code>:	NAT
		-&gt; EXP BOTTOM</programlisting>

				<para>The <code>EXP</code> <code>e</code> defined as the body of this token will
					be evaluated on occurrence of any error whose <code>ERROR_TREATMENT</code>
					is <code>trap</code>. The type of error can be determined within <code>e</code>
					from the NAT <code>n</code>, which will be <code>error_val(ec)</code> for some <code>ERROR_CODE</code>
					<code>ec</code>. The token definition body <code>e</code> will typically consist
					of a <code>long_jump</code> to some previously set exception handler.</para>

				<para>Exception handling using <code>trap</code> and ~<code>Throw</code> will usually
					be determined by producers for languages that specify their own exception
					handling semantics. Responsibility for the <code>~Throw</code> token definition
					will therefore normally rest with producers, by including this token
					within the producer specific &lpi;.</para>
			</section>

			<section>
				<title><code>~Set_signal_handler</code></title>

				<programlisting language="tdf">
	-&gt; EXP OFFSET (locals_alignment, locals_alignment)</programlisting>

				<para><code>~Set_signal_handler</code> must be applied before any use of the
					<code>ERROR_TREATMENT</code> <code>trap</code>, to indicate the need for
					exception trapping. Responsibility for the <code>~Set_signal_handler</code>
					token definition will rest with installers. Responsibility for applying
					it will normally rest with producers.</para>

				<para>The resulting offset value will contain the amount of space beyond
					any stack limit, which must be reserved for use when handling a
					<code>stack_overflow</code> trap raised by exceeding that limit.</para>
			</section>

			<section>
				<title><code>~Sync_handler</code></title>

				<programlisting language="tdf">
	-&gt; EXP TOP</programlisting>

				<para><code>~Sync_handler</code> delays subsequent processing until any pending
					exceptions have been raised, as necessary to synchronise exception
					handler modification. It must be applied immediately prior to any
					action that modifies the effect of <code>~Throw</code>, such as assignment
					to a variable holding an exception handler as <code>long_jump</code> destination
					Responsibility for the <code>~Sync_handler</code> token definition will
					rest with installers. Responsibility for applying it will normally
					rest with producers.</para>
			</section>
		</section>

		<section>
			<title>&tdf; Diagnostic Specification</title>

			<para>The <ulink url="#"><!-- TODO -->&tdf; Diagnostic Specification</ulink>
				is a separate document which describes an extension to &tdf;, optionally
				used to provide program diagnostic information that can be transformed
				by installers to the form required by popular platform-specific debuggers.
				This extension cannot be considered fully developed and is therefore
				not included as part of standard &tdf;. Its use for other than <acronym>DRA</acronym>'s
				C producer has not been considered.</para>

			<section>
				<title><code>~exp_to_source</code>, <code>~diag_id_scope</code>,
					<code>~diag_type_scope</code>, <code>~diag_tag_scope</code></title>

				<programlisting language="tdf">
	<code>bdy</code>:	EXP
... :	 ...
	-&gt; EXP</programlisting>

				<para>Each of these four tokens has several arguments of which the first,
					<code>bdy</code>, is an <code>EXP</code>. In each case the default definition
					body, when no diagnostic information is required, is simply <code>bdy</code>.
					Note that this description is quite sufficient to enable installers
					to ignore any diagnostic information that may be included in produced
					&tdf;, without needing any further knowledge of the &tdf;
					Diagnostic Specification.</para>
			</section>
		</section>

		<section id="accessingvalist">
			<title>Accessing variable parameter lists</title>

			<para>Installers should provide token definitions for the tokens listed
				in this section.</para>

			<section>
				<title><code>~va_list</code></title>

				<programlisting language="tdf">
	-&gt; SHAPE</programlisting>

				<para>This is the <code>SHAPE</code> of a variable capable of holding state
					information used for stepping through the anonymous parameters of
					a procedure created by <code>make_proc</code>.</para>
			</section>

			<section>
				<title><code>~__va_start</code></title>

				<programlisting language="tdf">
<code>p</code>:	EXP POINTER var_param_alignment
	-&gt; EXP ~va_list</programlisting>

				<para>If <code>t</code> is the <code>TAG</code> introduced by <code>var_intro</code>
					<code>OPTION(TAGACC)</code> in <code>make_proc</code>, then the token application
					<code>~__va_start(obtain_tag(t))</code> will provide the initial value for
					a local variable to be used for stepping through the anonymous parameters
					of the procedure, starting with the first actual parameter (if any)
					that does not have a corresponding entry in the make_proc params_intro
					list.</para>
			</section>

			<section>
				<title><code>~va_arg</code></title>

				<programlisting language="tdf">
<code>v</code>:	EXP POINTER (alignment(~va_list))
<code>s</code>:	SHAPE
	-&gt; EXP <code>s</code></programlisting>

				<para>If <code>v</code> is the variable initialised by <code>~__va_start </code>(see
					above), then successive token applications  <code>~va_arg(v,s)</code>
					will deliver the anonymous parameter values in turn. The successive
					<code>SHAPE</code>s <code>s</code> must be the appropriate <code>SHAPE</code>s
					for the successive parameters.</para>
			</section>

			<section>
				<title><code>~va_end</code></title>

				<programlisting language="tdf">
<code>v</code>:	EXP POINTER (alignment(~va_list))
	-&gt; EXP TOP</programlisting>

				<para>If <code>v</code> is a variable initialised by <code>~__va_start</code>, the token
					application <code>~va_end(v)</code> indicates that no further use will be
					made of <code>v</code>.</para>
			</section>

			<section>
				<title><code>~next_caller_offset</code></title>

				<programlisting language="tdf">
<code>o1</code>:	EXP OFFSET (<code>fa</code>,parameter_alignment(<code>s1</code>))
<code>s1</code>:	SHAPE
<code>s2</code>:	SHAPE
	-&gt; EXP OFFSET (<code>fa</code>,parameter_alignment(<code>s2</code>))</programlisting>

				<para><code>~next_caller_offset</code> is used to provide access to successive
					elements of the <code>caller_params</code> of an <code>apply_general_proc</code>,
					by delivering successive <code>OFFSET</code>s of their positions relative
					to the environment pointer created by that procedure application.
					Both the <code>apply_general_proc</code> and associated <code>make_general_proc</code>
					will include <code>PROCPROPS</code> <code>var_callers</code>.</para>

				<para><code>o1</code> will be the <code>OFFSET</code> for a <code>caller_params</code>
					element of <code>SHAPE</code> <code>s1</code>, and will be derived either
					from <code>env_offset</code> for a <code>TAG</code> introduced by <code>caller_intro</code>
					of the <code>make_general_proc </code>, or from a previous application of <code>~next_caller_offset</code>.
					<code>s2</code> will be the <code>SHAPE</code> of the subsequent <code>caller_params</code>
					element, whose <code>OFFSET</code> is delivered. <code>fa</code> will include
					the set union of <code>ALIGNMENT</code>s appropriate to the <code>make_general_proc</code>
					(as specified by <code>current_env</code>).</para>
			</section>

			<section>
				<title><code>~next_callee_offset</code></title>

				<programlisting language="tdf">
<code>o1</code>:	EXP OFFSET (<code>fa</code>,parameter_alignment(<code>s1</code>))
<code>s1</code>:	SHAPE
<code>s2</code>:	SHAPE
	-&gt; EXP OFFSET (<code>fa</code>,parameter_alignment(<code>s2</code>))</programlisting>

				<para><code>~next_callee_offset</code> is used to provide access to successive
					elements of the <code>CALLEES</code> of an <code>apply_general_proc</code>
					or <code>tail_call</code>, by delivering successive <code>OFFSET</code>s
					of their positions relative to the environment pointer created by
					that procedure application. Both the procedure application and associated
					<code>make_general_proc</code> will include <code>PROCPROPS</code> <code>var_callees</code>.</para>

				<para><code>o1</code> will be the <code>OFFSET</code> for a <code>CALLEES</code>
					element of <code>SHAPE</code> <code>s1</code>, and will be derived either
					from <code>env_offset</code> for a <code>TAG</code> introduced by <code>callee_intro</code>
					of the <code>make_general_proc</code>, or from a previous application of
					<code>~next_callee_offset</code>. <code>s2</code>
					will be the <code>SHAPE</code> of the subsequent <code>CALLEES</code>
					element, whose <code>OFFSET</code>
					is delivered. <code>fa</code> will include the set union of <code>ALIGNMENT</code>s
					appropriate to the <code>make_general_proc</code> (as specified by <code>current_env </code>).</para>
			</section>
		</section>
	</chapter>

	<chapter id="lpis">
		<title>Language Programming Interfaces</title>

		<para>A Language Programming Interface (&lpi;) is here defined to mean a set
			of tokens, usually specific to a particular producer, which will encapsulate
			language features at a higher level than basic &tdf; constructs, more
			convenient for the producer to produce.</para>

		<para>Responsibility for the specification of individual &lpi;s lies with
			the appropriate producer itself. Before an application can be installed
			on some target platform, the appropriate &lpi; token definitions must
			have been built for that platform. In this sense, the &lpi; can be considered
			as a primitive &api;, which is discussed in <xref linkend="apis"/>.</para>

		<para>The process by which the &lpi; token definition library or capsule is
			generated for any specific platform will vary according to the &lpi;,
			and responsibility for defining that process will also lie with the
			appropriate producer. Some &lpi;s, such as that associated with <acronym>DRA</acronym>'s
			C producer, can be fully defined by architecture neutral &tdf;, using
			the tokens specified in <xref linkend="targetdep"/> and <xref linkend="basicmappingtoks"/>
			to encapsulate any target dependencies. When that is the case, the
			generation process can be fully automated. For other &lpi;s the process
			may be much less automated. In some cases where the source language
			implies a complex run-time system, this might even require a small
			amount of new code to be written for each platform.</para>

		<para>Generally, the individual &lpi; tokens do not need to be specified in
			the token registry, provided they follow a registered naming scheme
			to ensure uniqueness (see <xref linkend="namingscheme"/>). In exceptional
			circumstances it may be necessary for some &tdf; tool to recognise individual
			&lpi; tokens explicitly by name. This will be the case when experimenting
			with potential extensions to &tdf;, in the field of parallelism for
			example. In other cases a &tdf; installer or other tool may recognise
			an &lpi; token by name rather than its definition by choice, for some
			unspecified advantage. We make a pragmatic choice in such cases whether
			to include such token specifications in the token registry. For widely
			used producers, we can assume availability of the &lpi; token specifcations,
			or standard definitions, separately from the token register, but we
			should expect any such tokens to be specified within the register
			for all cases where significant advantage could be taken by an installer
			only if it recognises the token by name.</para>

		<section id="S19">
			<title>The <acronym>DRA</acronym> C &lpi;</title>

			<para><acronym>DRA</acronym>'s C producer &lpi; is defined by an architecture neutral token definition
				capsule provided with the producer. Target specific detail is included
				only by use of the target dependency tokens and C mapping tokens specified
				in <xref linkend="targetdep"/> and <xref linkend="cmappingtoks"/> respectively.
				Target specific versions of this capsule are obtained by transformation,
				using the preprocessing action of the &tdf; tool <code>tnc</code>, with
				definitions of the target dependency and C mapping tokens that are
				provided with the target installer. No special treatment is required
				for any of the C &lpi; tokens, though translation time can be slightly
				improved in a few cases if the names are recognised and standard token
				definition exercised explicitly within some installers.</para>

			<para>The <acronym>DRA</acronym> C &lpi; does not include standard library features, for which
				the C language requires header files. The standard C library is one
				example of an &api;, discussed in <xref linkend="apis"/>.</para>
		</section>

		<section id="S191">
			<title>The <acronym>DRA</acronym> C++ &lpi;</title>

			<para>The <acronym>DRA</acronym> C++ &lpi; extends the <acronym>DRA</acronym> C &lpi; adding tokens for target specific
				C++ features not found in C.  Again, standard library features are
				treated as an &api;.</para>
		</section>

		<section id="S20">
			<title>The Etnoteam Fortran &lpi;</title>

			<para>The details in this subsection are provisional, subject to confirmation
				of argument and result <code>SORT</code>s, and development of model
				token definitions.</para>

			<para>The following tokens are named here in case any installers may be
				able to produce better code than could be achieved by normal token
				expansion. In particular, some installers may be able to inline standard
				function calls.</para>

			<variablelist>
				<varlistentry>
					<term><code>.Et~SQRT</code></term>

					<listitem>
						<para>square root of any floating variety, including
							complex.</para>
					</listitem>
				</varlistentry>

				<varlistentry>
					<term><code>.Et~EXP</code></term>

					<listitem>
						<para>exponential (<code>e ** x</code>) of any
							floating variety, including complex.</para>
					</listitem>
				</varlistentry>

				<varlistentry>
					<term><code>.Et~LOG</code></term>

					<listitem>
						<para>(natural) logarithm of any floating variety, including
							complex.</para>
					</listitem>
				</varlistentry>

				<varlistentry>
					<term><code>.Et~LOG_10</code></term>

					<listitem>
						<para>base 10 logarithm of any floating variety,
							including complex.</para>
					</listitem>
				</varlistentry>

				<varlistentry>
					<term><code>.Et~LOG_2</code></term>

					<listitem>
						<para>base 2 logarithm of any floating variety, including
							complex.</para>
					</listitem>
				</varlistentry>

				<varlistentry>
					<term><code>.Et~SIN</code></term>

					<listitem>
						<para>sine of any floating variety, including complex.</para>
					</listitem>
				</varlistentry>

				<varlistentry>
					<term><code>.Et~COS</code></term>

					<listitem>
						<para>cosine of any floating variety, including complex.</para>
					</listitem>
				</varlistentry>

				<varlistentry>
					<term><code>.Et~TAN</code></term>

					<listitem>
						<para>tangent of any floating variety, including complex.</para>
					</listitem>
				</varlistentry>

				<varlistentry>
					<term><code>.Et~ASIN</code></term>

					<listitem>
						<para>inverse sine of any floating variety, including complex.</para>
					</listitem>
				</varlistentry>

				<varlistentry>
					<term><code>.Et~ACOS</code></term>

					<listitem>
						<para>inverse cosine of any floating variety, including
							complex.</para>
					</listitem>
				</varlistentry>

				<varlistentry>
					<term><code>.Et~ATAN</code></term>

					<listitem>
						<para>inverse (one argument) tangent of any floating
							variety, including complex.</para>
					</listitem>
				</varlistentry>

				<varlistentry>
					<term><code>.Et~ATAN2</code></term>

					<listitem>
						<para>inverse (two arguments) tangent of any floating
							variety, excluding complex.</para>
					</listitem>
				</varlistentry>

				<varlistentry>
					<term><code>.Et~SINH</code></term>

					<listitem>
						<para>hyperbolic sine of any floating variety, including
							complex.</para>
					</listitem>
				</varlistentry>

				<varlistentry>
					<term><code>.Et~COSH</code></term>

					<listitem>
						<para>hyperbolic cosine of any floating variety, including
							complex.</para>
					</listitem>
				</varlistentry>

				<varlistentry>
					<term><code>.Et~TANH</code></term>

					<listitem>
						<para>hyperbolic tangent of any floating variety, including
							complex.</para>
					</listitem>
				</varlistentry>

				<varlistentry>
					<term><code>.Et~ASINH</code></term>

					<listitem>
						<para>inverse hyperbolic sine of any floating variety,
							including complex.</para>
					</listitem>
				</varlistentry>

				<varlistentry>
					<term><code>.Et~ACOSH</code></term>

					<listitem>
						<para>inverse hyperbolic cosine of any floating variety,
							including complex.</para>
					</listitem>
				</varlistentry>

				<varlistentry>
					<term><code>.Et~ATANH</code></term>

					<listitem>
						<para>inverse hyperbolic tangent of any floating variety,
							including complex.</para>
					</listitem>
				</varlistentry>

				<varlistentry>
					<term><code>.Et~MOD</code></term>

					<listitem>
						<para>floating point remainder of any floating variety,
							excluding complex.</para>
					</listitem>
				</varlistentry>
			</variablelist>
		</section>
	</chapter>

	<chapter id="apis">
		<title>Application Programming Interfaces</title>

		<para>Application Programming Interfaces are typically specified with a
			C mapping, which define the required contents for C header files which
			a portable C program must include by name to gain access to target
			specific implementations of an &api; library. The &tdf; approach to &api;
			specification includes using a #pragma token syntax within architecture
			neutral C header files, such that all implementation dependencies
			are encapsulated by &api; specific tokens. These &api; tokens are the
			&tdf; representation of the &api;. Both the &api; library and &api; token
			definitions are required before a &tdf; program using the &api; can be
			installed on any particular platform.</para>

		<para>Platform specific definitions for &api; tokens are produced automatically,
			with few exceptions, for any platform with a conformant implementation
			of the &api;. This is achieved by a token library building process which
			analyses the architecture neutral header files for the &api; concerned,
			together with the platform specific header files that provide normal
			(non-&tdf;) C access to the &api;. The few exceptions occur where the
			platform specific header files have been written to make use of specific
			C compiler built-in features, typically recognised by identifiers
			with a prefix such as <code>__builtin_</code>. Such cases are very likely
			to require explicit recognition of the corresponding token name in
			&tdf; installers.</para>

		<para>Generally, &api; token names and specifications are not detailed in
			this token register. The token specifications are clearly dependent
			on the associated &api; specifications. Authority for controlling the
			actual &api; token names, and the relationship between &api; tokens and
			the various &api; standardisation authorities, remain separate subjects
			of discussion.</para>

		<para>Names and specifications are given or implied below for those &api;
			tokens which frequently require built-in support from installers,
			and for other cases where an installer may be able to produce better
			code than could be achieved by normal token expansion, for example
			by inlining standard function calls.</para>

		<section id="S22">
			<title>ANSI C standard functions</title>

			<para>The set of tokens implied below all have the form:</para>

			<section>
				<title><code>ansi.<code>header</code>.<code>function</code></code></title>

			<programlisting language="tdf">
... :	 ...
	-&gt; EXP</programlisting>

				<para>Tokens are defined for all cases where <code>header</code> is ctype or string
					or math or stdlib, and <code>function</code> is the name of a non-ellipsis
					function specified in the ANSI C standard library, declared within
					the corresponding header &lt;<code>header</code>.h&gt;.   (Note that ellipsis
					functions, such as <code>printf</code>, cannot be represented as tokens
					since they may take a variable number of arguments.)</para>

				<para>These tokens have arguments all of <code>SORT</code> <code>EXP</code>,
					whose number and shape, and token result shape, all correspond to
					the implementation shape of the named ANSI C standard library function
					parameters and result. For the few cases where the function is specified
					not to return (e.g. <code>ansi.stdlib.abort</code>), the result shape may
					be either <code>TOP</code> or <code>BOTTOM</code>.</para>
			</section>
		</section>

		<section id="S23">
			<title>Common exceptional cases</title>

			<section>
				<title><code>ansi.setjmp.setjmp</code></title>

				<programlisting language="tdf">
<code>jb</code>:	EXP
	-&gt; EXP</programlisting>

				<para><code>ansi.setjmp.setjmp</code> is a token which has the semantics and argument
					and result implementation shapes corresponding to the ANSI C macro
					<code>setjmp</code> declared within &lt;setjmp.h&gt;.</para>
			</section>

			<section>
				<title><code>ansi.setjmp.longjmp</code></title>

				<programlisting language="tdf">
<code>jb</code>:	EXP
<code>v</code>:	EXP
	-&gt; EXP</programlisting>

				<para><code>ansi.setjmp.longjmp</code> is a token which has the semantics and
					argument implementation shapes corresponding to the ANSI C macro <code>longjmp
					</code> declared within &lt;setjmp.h&gt;. The result shape may be either
					TOP or BOTTOM.</para>
			</section>

			<section>
				<title><code>~alloca</code></title>

				<programlisting language="tdf">
<code>i</code>:	EXP
	-&gt; EXP</programlisting>

				<para><code>~alloca</code> is a token which has the semantics and argument and
					result implementation shapes corresponding to the BSD specified function
					<code>alloca</code>.</para>
			</section>
		</section>

		<section>
			<title><code>ansi.stdarg.va_list, ansi.stdarg.__va_start,
				ansi.stdarg.va_arg, ansi.stdarg.va_end</code></title>

			<para>These four tokens are identical to the Interface Tokens <code>~va_list</code>,
				<code>~__va_start</code>, <code>~va_arg</code> and <code>~va_end</code> respectively.</para>
		</section>
	</chapter>
</book>

