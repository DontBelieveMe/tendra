<?xml version="1.0" standalone="no"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
  "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">

<!--
  $Id$
-->

<chapter id="C3">
  <title>Describing the structure</title>

  <para>
    The following examples show how TDF constructs are described in this
    document. The first is the construct <link linkend="C5S31.6">
    <emphasis>floating</emphasis></link>:

    <programlisting language="TDF">
      fv:              FLOATING_VARIETY
                  -&gt; SHAPE</programlisting>

    The constructs' arguments (one in this case) precede the
    <quote><emphasis>-&gt;</emphasis></quote> and the result follows it. Each
    argument is shown as follows:

    <programlisting language="TDF">
      name:            SORT</programlisting>

    The name standing before the colon is for use in the accompanying English
    description within the specification. It has no other significance.
  </para>

  <para>
    The example given above indicates that <emphasis>floating</emphasis> takes
    one argument.  This argument, <emphasis>v</emphasis>, is of <code>SORT
    FLOATING_VARIETY</code>.  After the <quote><code>-&gt;</code></quote> comes
    the <code>SORT</code> of the result of <emphasis>floating</emphasis>. It is
    a <code>SHAPE</code>.
  </para>

  <para>
    In the case of <emphasis>floating</emphasis> the formal description supplies
    the syntax and the accompanying English text supplies the semantics.
    However, in the case of some constructs it is convenient to specify more
    information in the formal section. For example, the specification of the
    construct <link
    linkend="C5S16.39"><emphasis>floating_negate</emphasis></link> not only
    states that it has an <code>EXP</code> argument and an <code>EXP</code>
    result:

    <programlisting language="TDF">
      flpt_err:         ERROR_TREATMENT
      arg1:            EXP FLOATING(f)
                 -&gt; EXP FLOATING(f)</programlisting>

    it also supplies additional information about those <code>EXP</code>s.  It
    specifies that these expressions will be floating point numbers of the same
    kind.
  </para>

  <para>
    Some construct's arguments are optional. This is denoted as follows (from
    <link linkend="C5S16.6"><emphasis>apply_proc</emphasis></link>):

    <programlisting language="TDF">
      result_shape:    SHAPE
      p:               EXP PROC
      params:          LIST(EXP)
      var_param:       OPTION(EXP)
                 -&gt; EXP result_shape</programlisting>

    <emphasis>var_param</emphasis> is an optional argument to the
    <emphasis>apply_proc</emphasis> construct shown above.
  </para>

  <para>
    Some constructs take a varying number of arguments.
    <emphasis>params</emphasis> in the above construct is an example. These are
    denoted by <code>LIST</code>. There is a similar construction,
    <code>SLIST</code>, which differs only in having a different encoding.
  </para>

  <para>
    Some constructs' results are governed by the values of their arguments.
    This is denoted by the <quote><code>?</code></quote> formation shown in the
    specification of the <link
    linkend="C5S16.14"><emphasis>case</emphasis></link> construct
    shown below:

    <programlisting language="TDF">
      exhaustive:      BOOL
      control: EXP INTEGER(v)
      branches:        LIST(CASELIM)
                 -&gt; EXP (exhaustive ? BOTTOM : TOP)</programlisting>

    If <emphasis>exhaustive</emphasis> is true, the resulting <code>EXP</code>
    has the <code>SHAPE BOTTOM</code>: otherwise it is <code>TOP</code>.
  </para>

  <para>
    Depending on a TDF-processing tool's purpose, not all of some constructs'
    arguments need necessarily be processed. For instance, installers do not
    need to process one of the arguments of the <emphasis>x_cond</emphasis>
    constructs (where <emphasis>x</emphasis> stands for a <code>SORT</code>,
    e.g. <link linkend="C5S16.2"><emphasis>exp_cond</emphasis></link> .
    Secondly, standard tools might want to ignore embedded fragments of TDF
    adhering to some private standard. In these cases it is desirable for tools
    to be able to skip the irrelevant pieces of TDF. <code>BITSTREAM</code>s and
    <code>BYTESTREAM</code>s are formations which permit this. In the encoding
    they are prefaced with information about their length.
  </para>

  <para>
    Some constructs' arguments are defined as being <code>BITSTREAM</code>s or
    <code>BYTESTREAM</code>s, even though the constructs specify them to be of a
    particular <code>SORT</code>. In these cases the argument's
    <code>SORT</code> is denoted as, for example, <code>BITSTREAM
    FLOATING_VARIETY </code>.  This construct must have a
    <code>FLOATING_VARIETY</code> argument, but certain TDF-processing tools may
    benefit from being able to skip past the argument (which might itself be a
    very large piece of TDF) without having to read its content.
  </para>

  <para>
    The nature of the <code>UNIT</code>s in a <code>GROUP</code> is determined
    by unit identifications. These occur in <emphasis>make_capsule</emphasis>.
    The values used for unit identifications are specified in the text as
    follows:

    <blockquote>
      <emphasis role="bold">Unit identification</emphasis>:
      <emphasis>some_name</emphasis>
    </blockquote>
    where <emphasis>some_name</emphasis> might be <emphasis>tokdec</emphasis>,
    <emphasis>tokdef</emphasis> etc.
  </para>

  <para>
    The kinds of linkable entity used are determined by linkable entity
    identifications. These occur in <emphasis>make_capsule</emphasis>. The
    values used for linkable entity identification are specified in the text as
    follows:

    <blockquote>
      <emphasis role="bold">Linkable entity identification</emphasis>:
      <emphasis>some_name</emphasis>
    </blockquote>
    where <emphasis>some_name</emphasis> might be <emphasis>tag</emphasis>,
    <emphasis>token</emphasis> etc.
  </para>

  <para>
    The bit encodings are also specified in this document. The details are given
    in <link linkend="C8">The bit encoding of TDF</link>. This section describes
    the encoding in terms of information given with the descriptions of the
    <code>SORT</code>s and constructs.
  </para>

  <para>
    With each <code>SORT</code> the number of bits used to encode the constructs
    is given in the following form:

    <blockquote>
      <emphasis role="bold">Number of encoding bits</emphasis>:
      <emphasis>n</emphasis>
    </blockquote>
    This number may be zero; if so the encoding is non-extendable. If it is
    non-zero the encoding may be extendable or non-extendable. This is specified
    in the following form:

    <blockquote>
      <emphasis role="bold">Is coding extendable</emphasis>: yes/no
    </blockquote>
    With each construct the number used to encode it is given in the following
    form:

    <blockquote>
      <emphasis role="bold">Encoding number</emphasis>: <emphasis>n</emphasis>
    </blockquote>
    If the number of encoding bits is zero, <emphasis>n</emphasis> will be zero.
  </para>

  <para>
    There may be a requirement that a component of a construct should start on a
    byte boundary in the encoding. This is denoted by inserting
    <code>BYTE_ALIGN</code> before the component <code>SORT</code>.
  </para>
</chapter>
