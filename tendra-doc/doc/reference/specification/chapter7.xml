<?xml version="1.0" standalone="no"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
  "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">

<!--
  $Id$
-->

<chapter id="C7">
  <title>Notes</title>

  <section id="C7S1">
    <title>Binding</title>

    <para>
      The following constructions introduce <code>TAG</code>s:
      <emphasis>identify</emphasis>, <emphasis>variable</emphasis>,
      <emphasis>make_proc</emphasis>, <emphasis>make_general_proc</emphasis>,
      <emphasis>make_id_tagdec</emphasis>, <emphasis>make_var_tagdec</emphasis>,
      <emphasis>common_tagdec</emphasis>.
    </para>

    <para>
      During the evaluation of <emphasis>identify</emphasis> and
      <emphasis>variable</emphasis> a value, <emphasis>v</emphasis>, is produced
      which is bound to the <code>TAG</code> during the evaluation of an
      <code>EXP</code> or <code>EXP</code>s. The <code>TAG</code> is <quote>in
      scope</quote> for these <code>EXP</code>s. This means that in the
      <code>EXP</code> a use of the <code>TAG</code> is permissible and will
      refer to the declaration.
    </para>

    <para>
      The <emphasis>make_proc</emphasis> and
      <emphasis>make_general_proc</emphasis> construction introduces
      <code>TAG</code>s which are bound to the actual parameters on each call of
      the procedure. These <code>TAG</code>s are <quote>in scope</quote> for the
      body of the procedure.
    </para>

    <para>
      If a <emphasis>make_proc</emphasis> or
      <emphasis>make_general_proc</emphasis> construction occurs in the body of
      another <emphasis>make_proc</emphasis> or
      <emphasis>make_general_proc</emphasis>, the <code>TAG</code>s of the inner
      procedure are not in scope in the outer procedure, nor are the
      <code>TAG</code>s of the outer in scope in the inner.
    </para>

    <para>
      The <emphasis>apply_general_proc</emphasis> construction permits the
      introduction of <code>TAG</code>s whose scope is the
      <emphasis>postlude</emphasis> argument. These are bound to the values of
      caller parameters after the evaluation of the body of the procedure.
    </para>

    <para>
      The <emphasis>make_id_tagdec</emphasis>,
      <emphasis>make_var_tagdec</emphasis> and
      <emphasis>common_tagdec</emphasis> constructions introduce
      <code>TAG</code>s which are <quote>in scope</quote> throughout all the
      <emphasis>tagdef</emphasis> <code>UNIT</code>s. These <code>TAG</code>s
      may have values defined for them in the <emphasis>tagdef</emphasis>
      <code>UNIT</code>s, or values may be supplied by linking.
    </para>

    <para>
      The following constructions introduce <code>LABEL</code>s:
      <emphasis>conditional</emphasis>, <emphasis>repeat</emphasis>,
      <emphasis>labelled</emphasis>.
    </para>

    <para>
      The construction themselves define <code>EXP</code>s for which these
      <code>LABEL</code>s are <quote>in scope</quote>. This means that in the
      <code>EXP</code>s a use of the <code>LABEL</code> is permissible and will
      refer to the introducing construction.
    </para>

    <para>
      <code>TAG</code>s, <code>LABEL</code>s and <code>TOKEN</code>s (as
      <code>TOKEN</code> parameters) introduced in the body of a
      <code>TOKEN</code> definition are systematically renamed in their scope
      each time the <code>TOKEN</code> definition is applied. The scope will be
      completely included by the <code>TOKEN</code> definition.
    </para>

    <para>
      Each of the values introduced in a <code>UNIT</code> will be named by a
      different <code>TAG</code>, and the labelling constructions will use
      different labels, so no visibility rules are needed. The set of
      <code>TAG</code>s and <code>LABEL</code>s used in a simple
      <code>UNIT</code> are considered separately from those in another simple
      <code>UNIT</code>, so no question of visibility arises. The compound and
      link <code>UNIT</code>s provide a method of relating the items in one
      simple <code>UNIT</code> to those in another, but this is through the
      intermediary of another set of <code>TAG</code>s and <code>TOKEN</code>s
      at the <code>CAPSULE</code> level.
    </para>
  </section>

  <section id="C7S2">
    <title>Character codes</title>

    <para>
      TDF does not have a concept of characters. It transmits integers of
      various sizes. So if a producer wishes to communicate characters to an
      installer, it will usually have to do so by encoding them in some way as
      integers.
    </para>

    <para>
      An ANSI C producer sending a TDF program to a set of normal C environments
      may well choose to encode its characters using the ASCII codes, an EBCDIC
      based producer transmitting to a known set of EBCDIC environments might
      use the code directly, and a wide character producer might likewise choose
      a specific encoding. For some programs this way of proceeding is
      necessary, because the codes are used both to represent characters and for
      arithmetic, so the particular encoding is enforced. In these cases it will
      not be possible to translate the characters to another encoding because
      the character codes will be used in the TDF as ordinary integers, which
      must not be translated.
    </para>

    <para>
      Some producers may wish to transmit true characters, in the sense that
      something is needed to represent particular printing shapes and nothing
      else. These representations will have to be transformed into the correct
      character encoding on the target machine.
    </para>

    <para>
      Probably the best way to do this is to use <code>TOKEN</code>s. A fixed
      representation for the printing marks could be chosen in terms of integers
      and <code>TOKEN</code>s introduced to represent the translation from these
      integers to local character codes, and from strings of integers to strings
      of local character codes. These definitions could be bound on the target
      machine and the installer should be capable of translating these
      constructions into efficient machine code. To make this a standard, unique
      <code>TOKEN</code>s should be used.
    </para>

    <para>
      But this raises the question, who chooses the fixed representation and the
      unique <code>TOKEN</code>s and their specification? Clearly TDF provides a
      mechanism for performing the standardisation without itself defining a
      standard.
    </para>

    <para>
      Here TDF gives rise to the need for extra standards, especially in the
      specification of globally named unique <code>TOKEN</code>s.
    </para>
  </section>

  <section id="C7S3">
    <title>Constant evaluation</title>

    <para>
      Some constructions require an <code>EXP</code> argument which is
      <quote>constant at install time</quote>.  For an <code>EXP</code> to
      satisfy this condition it must be constructed according to the following
      rules after substitution of token definitions and selection of
      <emphasis>exp_cond</emphasis> branches.
    </para>

    <para>
      If it contains <emphasis>obtain_tag</emphasis> then the tag will be
      introduced within the <code>EXP</code>, or defined with
      <emphasis>make_id_tagdef</emphasis> within the current capsule.
    </para>

    <para>
      It may not contain any of the following constructions:
      <emphasis>apply_proc, apply_general_proc, assign_with_mode</emphasis>,
      <emphasis>contents_with_mode</emphasis>, <emphasis>continue</emphasis>,
      <emphasis>current_env</emphasis>, <emphasis>error_jump</emphasis>,
      <emphasis>goto_local_lv</emphasis>, <emphasis>make_local_lv</emphasis>,
      <emphasis>move_some</emphasis>, <emphasis>repeat</emphasis>,
      <emphasis>round_as_state</emphasis>.
    </para>

    <para>
      Unless it is the <code>EXP</code> argument of a <code>TAGDEF</code>, a
      <quote>constant at install time</quote> may not contain
      <emphasis>env_offset</emphasis> or <emphasis>env_size</emphasis>.
    </para>

    <para>
      Any use of <emphasis>contents</emphasis> or <emphasis>assign</emphasis>
      will be applied only to <code>POINTER</code>s derived from
      <emphasis>variable</emphasis> constructions.
    </para>

    <para>
      If it contains <emphasis>labelled</emphasis> there will only be jumps to
      the <code>LABEL</code>s from within <emphasis>starter</emphasis>, not from
      within any of the <emphasis>places</emphasis>.
    </para>

    <para>
      Any use of <emphasis>obtain_tag</emphasis> defined with
      <emphasis>make_id_tagdef</emphasis> will occur after the end of the
      <emphasis>make_id_tagdef</emphasis>.
    </para>

    <para>
      Note specifically that a constant <code>EXP</code> forming the defining
      value of a <code>TAGDEF</code> construct may contain
      <emphasis>env_offset</emphasis> and/or <emphasis>env_size</emphasis>.
    </para>
  </section>

  <section id="C7S4">
    <title>Division and modulus</title>

    <para>
      Two classes of division (D) and remainder (M) construct are defined. The
      two classes have the same definition if both operands have the same sign.
      Neither is defined if the second argument is zero.
    </para>

    <para>
      <emphasis role="bold">Class 1</emphasis>:
    </para>

    <programlisting language="TDF">
        p D1 q = n</programlisting>

    <para>
      where:
    </para>

    <programlisting language="TDF">
        p = n*q + (p M1 q)
        sign(p M1 q) = sign(q)
        0 &lt;= |p M1 q| &lt; |q|</programlisting>

    <para>
      <emphasis role="bold">Class 2</emphasis>:
    </para>

    <programlisting language="TDF">
        p D2 q = n</programlisting>

    <para>
      where:
    </para>

    <programlisting language="TDF">
        p = n*q + (p M2 q)
        sign(p M2 q) = sign(p)
        0 &lt;= |p M2 q| &lt; |q|</programlisting>
  </section>

  <section id="C7S5">
    <title>Equality of EXPs</title>

    <para>
      A definition of equality of <code>EXP</code>s would be a considerable part
      of a formal specification of TDF, and is not given here.
    </para>
  </section>

  <section id="C7S6">
    <title>Equality of SHAPEs</title>

    <itemizedlist>
      <listitem>
        <para>
          Two <code>SHAPE</code>s are equal if they are both
          <code>BOTTOM</code>, or both <code>TOP</code> or both
          <code>PROC</code>.
        </para>
      </listitem>

      <listitem>
        <para>
          Two <code>SHAPE</code>s are equal if they are both
          <emphasis>integer</emphasis> or both <emphasis>floating</emphasis>, or
          both <emphasis>bitfield</emphasis>, and the corresponding parameters
          are equal.
        </para>
      </listitem>

      <listitem>
        <para>
          Two <code>SHAPE</code>s are equal if they are both <code>NOF</code>,
          the numbers of items are equal and the <code>SHAPE</code> parameters
          are equal.
        </para>
      </listitem>

      <listitem>
        <para>
          Two <code>OFFSET</code>s or two <code>POINTER</code>s are equal if
          their <code>ALIGNMENT</code> parameters are pairwise equal.
        </para>
      </listitem>

      <listitem>
        <para>
          Two <code>COMPOUND</code>s are equal if their <code>OFFSET</code>
          <code>EXP</code>s are equal.
        </para>
      </listitem>

      <listitem>
        <para>
          No other pairs of <code>SHAPE</code>s are equal.
        </para>
      </listitem>
    </itemizedlist>
  </section>

  <section id="C7S7">
    <title>Equality of ALIGNMENTs</title>

    <para>
      Two <code>ALIGNMENT</code>s are equal if and only if they are equal sets.
    </para>
  </section>

  <section id="C7S8">
    <title>Exceptions and jumps</title>

    <para>
      TDF allows simply for labels and jumps within a procedure, by means of the
      <emphasis>conditional</emphasis>, <emphasis>labelled</emphasis> and
      <emphasis>repeat</emphasis> constructions, and the
      <emphasis>goto</emphasis>, <emphasis>case</emphasis> and various
      <emphasis>test</emphasis> constructions.  But there are two more complex
      jumping situations.
    </para>

    <para>
      First there is the jump, known to stay within a procedure, but to a
      computed destination. Many languages have discouraged this kind of
      construction, but it is still available in Cobol (implicitly), and it can
      be used to provide other facilities (see below). TDF allows it by means of
      the <code>POINTER(</code>{<emphasis>code</emphasis><code>})</code>.  TDF
      is arranged so that this can usually be implemented as the address of the
      label. The <emphasis>goto_local_lv</emphasis> construction just jumps to
      the label.
    </para>

    <para>
      The other kind of construction needed is the jump out of a procedure to a
      label which is still active, restoring the environment of the destination
      procedure: the long jump. Related to this is the notion of exception.
      Unfortunately long jumps and exceptions do not co-exist well. Exceptions
      are commonly organised so that any necessary destruction operations are
      performed as the stack of frames is traversed; long jumps commonly go
      directly to the destination. TDF must provide some facility which can
      express both of these concepts. Furthermore exceptions come in several
      different versions, according to how the exception handlers are
      discriminated and whether exception handling is initiated if there is no
      handler which will catch the exception.
    </para>

    <para>
      Fortunately the normal implementations of these concepts provide a
      suggestion as to how they can be introduced into TDF. The local label
      value provides the destination address, the environment (produced by
      <emphasis>current_env</emphasis>) provides the stack frame for the
      destination, and the stack re-setting needed by the local label jumps
      themselves provides the necessary stack information. If more information
      is needed, such as which exception handlers are active, this can be
      created by producing the appropriate TDF.
    </para>

    <para>
      So TDF takes the long jump as the basic construction, and its parameters
      are a local label value and an environment. Everything else can be built
      in terms of these.
    </para>

    <para>
      The TDF arithmetic constructions allows one to specify a
      <code>LABEL</code> as destination if the result of the operation is
      exceptional. This is sufficient for the kind of explicit exception
      handling found in C++ and, in principle, could also be used to implement
      the kind of <quote>automatic</quote> exception detection and handling
      found in Ada, for example.
    </para>

    <para>
      However many architectures have facilities for automatically trapping on
      exceptions without explicit testing. To take advantage of this, there is a
      <emphasis>trap</emphasis> <code>ERROR_TREATMENT</code> with associated
      <code>ERROR_code</code>s. The action taken on an exception with
      <emphasis>trap</emphasis> <code>ERROR_TREATMENT</code> will be to
      <quote>throw</quote> the <code>ERROR_code</code>.  Since each language has
      its own idea of how to interpret the <code>ERROR_code</code> and handle
      exceptions, the onus is on the producer writer to describe how to throw an
      <code>ERROR_code</code>.
    </para>

    <para>
      The producer writer must give a definition of a <code>TOKEN</code>
      <emphasis>~Throw</emphasis> : <code>NAT</code> -&gt; <code>EXP</code>
      where the <code>NAT</code> will be the <emphasis>error_val</emphasis> of
      some <code>ERROR_code</code>. The expansion of this token will be
      consistent with the interpretation of the relevant <code>ERROR_code</code>
      and the method of handling exceptions. Usually this will consist of
      decoding the <code>ERROR_code</code> and doing a long_jump on some globals
      set up by the procedure in which the exception handling takes place.
    </para>

    <para>
      The translator writer will provide a parameterless <code>EXP TOKEN</code>,
      <emphasis>~Set_signal_handler</emphasis>. This <code>TOKEN</code> will use
      <emphasis>~Throw</emphasis> and must be applied before any possible
      exceptions. This implies that the definition of both
      <emphasis>~Throw</emphasis> and <emphasis>~Set_signal_handler</emphasis>
      must be bound before translation of any <code>CAPSULE</code> which uses
      them, presumeably by linking with some TDF libraries.
    </para>

    <para>
      These tokens are specified in more detail in the companion document,
      <ulink url="reference/xhtml/register/">TDF Token Register</ulink>.
    </para>
  </section>

  <section id="C7S9">
    <title>Procedures</title>

    <para>
      The <emphasis>var_intro</emphasis> of a <emphasis>make_proc</emphasis>, if
      present, may be used under one of two different circumstances. In one
      circumstance, the <code>POINTER TAG</code> provided by the
      <emphasis>var_intro</emphasis> is used to access the actual
      <emphasis>var_param</emphasis> of an <emphasis>apply_proc</emphasis>. If
      this is the case, all uses of <emphasis>apply_proc</emphasis> which have
      the effect of calling this procedure will have the
      <emphasis>var_param</emphasis> option present, and they will all have
      precisely the same number of <emphasis>params</emphasis> as
      <emphasis>params_intro</emphasis> in the <emphasis>make_proc</emphasis>.
      The body of the <emphasis>make_proc</emphasis> can access elements of the
      <emphasis>var_param</emphasis> by using <code>OFFSET</code> arithmetic
      relative to the <code>POINTER TAG</code>.  This provides a method of
      supplying a variable number of parameters, by composing them into a
      compound value which is supplied as the <emphasis>var_param</emphasis>.
    </para>

    <para>
      However, this has proved to be unsatisfactory for the implementation of
      variable number of parameters in C - one cannot choose the
      <code>POINTER</code> alignment of the <code>TAG</code> a priori in
      non-prototype calls.
    </para>

    <para>
      An alternative circumstance for using <emphasis>var_intro</emphasis> is
      where all uses of <emphasis>apply_proc</emphasis> which have the effect of
      calling this procedure may have more <emphasis>params</emphasis> present
      than the number of <emphasis>params_intro</emphasis>, and none of them
      will have their <emphasis>var_param</emphasis> option present.  The body
      of the <emphasis>make_proc</emphasis> can access the additional params by
      using installer-defined <code>TOKEN</code>s specified in the companion
      document <ulink url="reference/xhtml/register/">TDF Token Register</ulink>,
      analogous to the use of variable argument lists in C. A local variable
      <emphasis>v</emphasis> of shape <emphasis>~va_list</emphasis> must be
      initialised to <emphasis>~__va_start</emphasis>(<emphasis>p</emphasis>),
      where <emphasis>p</emphasis> is the <code>POINTER</code> obtained from the
      <emphasis>var_intro</emphasis>. Successive elements of the
      <emphasis>params</emphasis> list can then be obtained by successive
      applications of
      <emphasis>~va_arg</emphasis>(<emphasis>v</emphasis>,<emphasis>s</emphasis>)
      where <emphasis>s</emphasis> is the <code>SHAPE</code> of element
      obtained. Finally, <emphasis>~va_end</emphasis>(<emphasis>v</emphasis>)
      completes the use of <emphasis>v</emphasis>.
    </para>

    <para>
      The definition of caller parameters in general procedures addesses this
      difficulty in a different way, by describing the layout of caller
      parameters qualified by <code>PROCPROPS</code>
      <emphasis>var_callers</emphasis>.  This allows both the call and the body
      to have closely associated views of the <code>OFFSET</code>s within a
      parameter set, regardless of whether or not the particular parameter has
      been named. The installer-defined <code>TOKEN</code>
      <emphasis>~next_caller_offset</emphasis> provides access to successive
      caller parameters, by using <code>OFFSET</code>s relative to the current
      frame pointer <emphasis>current_env</emphasis>, adjusting for any
      differences there may be between the closely associated views.  The
      <emphasis>caller_intro</emphasis> list of the
      <emphasis>make_general_proc</emphasis> must not be empty, then the
      sequence of <code>OFFSET</code>s can start with an appropriate
      <emphasis>env_offset</emphasis>. Similar consideration applies to
      accessing within the callee parameters, using the installer-defined
      <code>TOKEN</code> <emphasis>~next_callee_offset</emphasis>.
    </para>

    <para>
      All uses of <emphasis>return</emphasis>,
      <emphasis>untidy_return</emphasis> and <emphasis>tail_call</emphasis> in a
      procedure will return values of the same <code>SHAPE</code>, and this will
      be the <emphasis>result_shape</emphasis> specified in all uses of
      <emphasis>apply_proc</emphasis> or <emphasis>apply_general_proc</emphasis>
      calling the procedure.
    </para>

    <para>
      The use of <emphasis>untidy_return</emphasis> gives a generalisation of
      <emphasis>local_alloc</emphasis>.  It extends the validity of pointers
      allocated by <emphasis>local_alloc</emphasis> within the immediatly
      enclosing procedure into the calling procedure.  The original space of
      these pointers may be invalidated by <emphasis>local_free</emphasis> just
      as if it had been generated by <emphasis>local_alloc</emphasis> in the
      calling procedure.
    </para>

    <para>
      The <code>PROCPROPS</code> <emphasis>check_stack</emphasis> may be used to
      check that limit set by set_stack_limit is not exceeded by the allocation
      of the static locals of a procedure body to be obeyed. If it is exceeded
      then the producer-defined <code>TOKEN</code> <emphasis>~Throw</emphasis>:
      <code>NAT</code> -&gt; <code>EXP</code> will be invoked as
      <emphasis>~Throw</emphasis>(<emphasis>error_val</emphasis>(<emphasis>stack_overflow</emphasis>)).
      Note that this will not include any space generated by
      <code>local_alloc</code>; an explicit test is required to do check these.
    </para>

    <para>
      Any <code>SHAPE</code> is permitted as the
      <emphasis>result_shape</emphasis> in an <emphasis>apply_proc</emphasis> or
      <emphasis>apply_general_proc</emphasis>.
    </para>
  </section>

  <section id="C7S10">
    <title>Frames</title>

    <para>
      TDF states that while a particular procedure activation is current, it is
      possible to create a <code>POINTER</code>, by using
      <emphasis>current_env</emphasis>, which gives access to all the declared
      variables and identifications of the activation which are alive and which
      have been marked as <emphasis>visible</emphasis>. The construction
      <emphasis>env_offset</emphasis> gives the <code>OFFSET</code> of one of
      these relative to such a <code>POINTER</code>.  These constructions may
      serve for several purposes.
    </para>

    <para>
      One significant purpose is to implement such languages as Pascal which
      have procedures declared inside other procedures. One way of implementing
      this is by means of a <quote>display</quote>, that is, a tuple of frame
      pointers of active procedures.
    </para>

    <para>
      Another purpose is to find active variables satisfying some criterion in
      all the procedure activations. This is commonly required for garbage
      collection. TDF does not force the installer to implement a frame pointer
      register, since some machines do not work best in this way.  Instead, a
      frame pointer is created only if required by
      <emphasis>current_env</emphasis>.  The implication of this is that this
      sort of garbage collection needs the collaboration of the producer to
      create TDF which makes the correct calls on
      <emphasis>current_env</emphasis> and <emphasis>env_offset</emphasis> and
      place suitable values in known positions.
    </para>

    <para>
      Programs compiled especially to provide good diagnostic information can
      also use these operations.
    </para>

    <para>
      In general any program which wishes to manipulate the frames of procedures
      other than the current one can use <emphasis>current_env</emphasis> and
      <emphasis>env_offset</emphasis> to do so.
    </para>

    <para>
      A frame consists of three components, the caller parameters, callee
      parameters and locals of the procedure involved. Since each component may
      have different internal methods of access within the frame, each has a
      different special frame alignment associated with pointers within them.
      These are <emphasis>callers_alignment</emphasis>,
      <emphasis>callees_alignment</emphasis> and
      <emphasis>locals_alignment</emphasis>. The <code>POINTER</code> produced
      by <emphasis>current_env</emphasis> will be some union of these special
      alignments depending on how the procedure was defined.
    </para>

    <para>
      Each of these frame alignments are considered to contain any
      <code>ALIGNMENT</code> produced by <emphasis>alignment</emphasis> from any
      <code>SHAPE</code>. Note that this does not say that they are the set
      union of all such <code>ALIGNMENT</code>s. This is because the
      interpretation of pointer and offset operations (notably
      <emphasis>add_to_pointer</emphasis>) may be different depending on the
      implementation of the frames; they may involve extra indirections.
    </para>

    <para>
      Accordingly, because of the constraints on
      <emphasis>add_to_ptr</emphasis>, an <code>OFFSET</code> produced by
      <emphasis>env_offset</emphasis> can only be added to a
      <code>POINTER</code> produced by <emphasis>current_env</emphasis>. It is a
      further constraint that such an <code>OFFSET</code> will only be added to
      a <code>POINTER</code> produced from <emphasis>current_env</emphasis> used
      on the procedure which declared the <code>TAG</code>.
    </para>
  </section>

  <section id="C7S11">
    <title>Lifetimes</title>

    <para>
      <code>TAG</code>s are bound to values during the evaluation of
      <code>EXP</code>s, which are specified by the construction which
      introduces the <code>TAG</code>. The evaluation of these <code>EXP</code>s
      is called the lifetime of the activation of the <code>TAG</code>.
    </para>

    <para>
      Note that lifetime is a different concept from that of scope. For example,
      if the <code>EXP</code> contains the application of a procedure, the
      evaluation of the body of the procedure is within the lifetime of the
      <code>TAG</code>, but the <code>TAG</code> will not be in scope.
    </para>

    <para>
      A similar concept applies to <code>LABEL</code>s.
    </para>
  </section>

  <section id="C7S12">
    <title>Alloca</title>

    <para>
      The constructions involving <emphasis>alloca</emphasis>
      (<emphasis>last_local</emphasis>, <emphasis>local_alloc</emphasis>,
      <emphasis>local_free</emphasis>, <emphasis>local_free_all</emphasis>) as
      well as the <emphasis>untidy_return</emphasis> construction imply a
      stack-like implementation which is related to procedure calls.  They may
      be implemented using the same stack as the procedure frames, if there is
      such a stack, or it may be more convenient to implement them separately.
      However note that if the <emphasis>alloca</emphasis> mechanism is
      implemented as a stack, this may be an upward or a downward growing stack.
    </para>

    <para>
      The state of this notional stack is referred to here as the
      <emphasis>alloca</emphasis> state. The construction
      <emphasis>local_alloc</emphasis> creates a new space on the
      <emphasis>alloca</emphasis> stack, the size of this space being given by
      an <code>OFFSET</code>. In the special case that this <code>OFFSET</code>
      is zero, <emphasis>local_alloc</emphasis> in effect gives the current
      <emphasis>alloca</emphasis> state (normally a <code>POINTER</code> to the
      top of the stack).
    </para>

    <para>
      A use of <emphasis>local_free_all</emphasis> returns the
      <emphasis>alloca</emphasis> state to what it was on entry to the current
      procedure.
    </para>

    <para>
      The construction <emphasis>last_local</emphasis> gives a
      <code>POINTER</code> to the top item on the stack, but it is necessary to
      give the size of this (as an <code>OFFSET</code>) because this cannot be
      deduced if the stack is upward growing. This top item will be the whole of
      an item previously allocated with <emphasis>local_alloc</emphasis>.
    </para>

    <para>
      The construction <emphasis>local_free</emphasis> returns the state of the
      <emphasis>alloca</emphasis> machine to what it was when its parameter
      <code>POINTER</code> was allocated. The <code>OFFSET</code> parameter will
      be the same value as that with which the <code>POINTER</code> was
      allocated.
    </para>

    <para>
      The <code>ALIGNMENT</code> of the <code>POINTER</code> delivered by
      <emphasis>local_alloc</emphasis> is <emphasis>alloca_alignment</emphasis>.
      This shall include the set union of all the <code>ALIGNMENT</code>s which
      can be produced by <emphasis>alignment</emphasis> from any
      <code>SHAPE</code>.
    </para>

    <para>
      The use of <emphasis>alloca_alignment</emphasis> arises so that the
      <emphasis>alloca</emphasis> stack can hold any kind of value.  The sizes
      of spaces allocated must be rounded up to the appropriate
      <code>ALIGNMENT</code>. Since this includes all value
      <code>ALIGNMENT</code>s a value of any <code>ALIGNMENT</code> can be
      assigned into this space.  Note that there is no necessary relation with
      the special frame alignments (see <link linkend="C7S10">section
      7.10</link>) though they must both contain all the <code>ALIGNMENT</code>s
      which can be produced by <emphasis>alignment</emphasis> from any
      <code>SHAPE</code>.
    </para>

    <para>
      Stack pushing is <emphasis>local_alloc</emphasis>. Stack popping can be
      performed by use of <emphasis>last_local</emphasis> and
      <emphasis>local_free</emphasis>. Remembering the state of the
      <emphasis>alloca</emphasis> stack and returning to it can be performed by
      using <emphasis>local_alloc</emphasis> with a zero <code>OFFSET</code> and
      <emphasis>local_free</emphasis>.
    </para>

    <para>
      Note that stack pushing can also be achieved by the use of a procedure
      call with <emphasis>untidy_return</emphasis>.
    </para>

    <para>
      A transfer of control to a local label by means of
      <emphasis>goto</emphasis>, <emphasis>goto_local_lv</emphasis>, any
      <emphasis>test</emphasis> construction or any
      <emphasis>error_jump</emphasis> will not change the
      <emphasis>alloca</emphasis> stack.
    </para>

    <para>
      <emphasis>If an installer implements identify and variable by creating
      space on a stack when they come into existence, rather than doing the
      allocation for identify and variable at the start of a procedure
      activation, then it may have to consider making the alloca stack into a
      second stack.</emphasis>
    </para>
  </section>

  <section id="C7S13">
    <title>Memory Model</title>

    <para>
      The layout of data in memory is entirely determined by the calculation of
      <code>OFFSET</code>s relative to <code>POINTER</code>s. That is, it is
      determined by <code>OFFSET</code> arithmetic and the
      <emphasis>add_to_ptr</emphasis> construction.
    </para>

    <para>
      A <code>POINTER</code> is parameterised by the <code>ALIGNMENT</code> of
      the data indicated. An <code>ALIGNMENT</code> is a set of all the
      different kinds of basic value which can be indicated by a
      <code>POINTER</code>. That is, it is a set chosen from all
      <code>VARIETY</code>s, all <code>FLOATING_VARIETY</code>s,
      <emphasis>all</emphasis> <code>BITFIELD_VARIETY</code>s<emphasis>,
      proc</emphasis>, <emphasis>code</emphasis>, <emphasis>pointer</emphasis>
      and <emphasis>offset</emphasis>. There are also three special
      <code>ALIGNMENT</code>s, <emphasis>frame_alignment</emphasis>,
      <emphasis>alloca_alignment</emphasis> and
      <emphasis>var_param_alignment</emphasis>.
    </para>

    <para>
      The parameter of a <code>POINTER</code> will not consist entirely of
      <code>BITFIELD_VARIETY</code>s.
    </para>

    <para>
      The implication of this is that the <code>ALIGNMENT</code> of all
      procedures is the same, the <code>ALIGNMENT</code> of all
      <code>POINTER</code>s is the same and the <code>ALIGNMENT</code> of all
      <code>OFFSET</code>s is the same.
    </para>

    <para>
      At present this corresponds to the state of affairs for all machines.  But
      it is certainly possible that, for example, 64-bit pointers might be
      aligned on 64-bit boundaries while 32-bit pointers are aligned on 32-bit
      boundaries. In this case it will become necessary to add different kinds
      of pointer to TDF. This will not present a problem, because, to use such
      pointers, similar changes will have to be made in languages to distinguish
      the kinds of pointer if they are to be mixed.
    </para>

    <para>
      The difference between two <code>POINTER</code>s is measured by an
      <code>OFFSET</code>. Hence an <code>OFFSET</code> is parameterised by two
      <code>ALIGNMENT</code>s, that of the starting <code>POINTER</code> and
      that of the end <code>POINTER</code>. The <code>ALIGNMENT</code> set of
      the first must include the <code>ALIGNMENT</code> set of the second.
    </para>

    <para>
      The parameters of an <code>OFFSET</code> may consist entirely of
      <code>BITFIELD_VARIETY</code>s.
    </para>

    <para>
      The operations on <code>OFFSET</code>s are subject to various constraints
      on <code>ALIGNMENT</code>s. It is important not to read into offset
      arithmetic what is not there. Accordingly some rules of the algebra of
      <code>OFFSET</code>s are given below.
    </para>

    <itemizedlist>
      <listitem>
        <para>
          <emphasis>offset_add</emphasis> is associative.
        </para>
      </listitem>

      <listitem>
        <para>
          <emphasis>offset_mult</emphasis> corresponds to repeated
          offset_addition.
        </para>
      </listitem>

      <listitem>
        <para>
          <emphasis>offset_max</emphasis> is commutative, associative and
          idempotent.
        </para>
      </listitem>

      <listitem>
        <para>
          <emphasis>offset_add</emphasis> distributes over
          <emphasis>offset_max</emphasis> where they form legal expressions.
        </para>
      </listitem>

      <listitem>
        <para>
          <emphasis>offset_test</emphasis>(<emphasis>prob</emphasis>, &gt;= ,
          <emphasis>a</emphasis>, <emphasis>b</emphasis>) continues if
          <emphasis>offset_max</emphasis>(<emphasis>a</emphasis>,<emphasis>b</emphasis>)
          = <emphasis>a</emphasis>.
        </para>
      </listitem>
    </itemizedlist>

    <section id="C7S13.1">
      <title>Simple model</title>

      <para>
        An example of the representation of <code>OFFSET</code> arithmetic is
        given below. This is not a definition, but only an example.  In order to
        make this clear a machine with bit addressing is hypothesized.  This
        machine is referred to as the simple model.
      </para>

      <para>
        In this machine <code>ALIGNMENT</code>s will be represented by the
        number by which the bit address of data must be divisible. For example,
        8-bit bytes might have an <code>ALIGNMENT</code> of 8, longs of 32 and
        doubles of 64. <code>OFFSET</code>s will be represented by the
        displacement in bits from a <code>POINTER</code>. <code>POINTER</code>s
        will be represented by the bit address of the data. Only one memory
        space will exist. Then in this example a possible conforming
        implementation would be as follows.
      </para>

      <itemizedlist>
        <listitem>
          <para>
            <emphasis>add_to_ptr</emphasis> is addition.
          </para>
        </listitem>

        <listitem>
          <para>
            <emphasis>offset_add</emphasis> is addition.
          </para>
        </listitem>

        <listitem>
          <para>
            <emphasis>offset_div</emphasis> and
            <emphasis>offset_div_by_int</emphasis> are exact division.
          </para>
        </listitem>

        <listitem>
          <para>
            <emphasis>offset_max</emphasis> is maximum.
          </para>
        </listitem>

        <listitem>
          <para>
            <emphasis>offset_mult</emphasis> is multiply.
          </para>
        </listitem>

        <listitem>
          <para>
            <emphasis>offset_negate</emphasis> is negate.
          </para>
        </listitem>

        <listitem>
          <para>
            <emphasis>offset_pad</emphasis>(<emphasis>a</emphasis>,
            <emphasis>x</emphasis>) is ((<emphasis>x</emphasis> +
            <emphasis>a</emphasis>
            - 1) / <emphasis>a</emphasis>) * <emphasis>a</emphasis>
          </para>
        </listitem>

        <listitem>
          <para>
            <emphasis>offset_subtract</emphasis> is subtract.
          </para>
        </listitem>

        <listitem>
          <para>
            <emphasis>offset_test</emphasis> is
            <emphasis>integer_test</emphasis>.
          </para>
        </listitem>

        <listitem>
          <para>
            <emphasis>offset_zero</emphasis> is 0.
          </para>
        </listitem>

        <listitem>
          <para>
            <emphasis>shape_offset</emphasis>(<emphasis>s</emphasis>) is the
            minimum number of bits needed to be moved to move a value of
            <code>SHAPE</code> <emphasis>s</emphasis>.
          </para>
        </listitem>
      </itemizedlist>

      <para>
        Note that these operations only exist where the constraints on the
        parameters are satisfied. Elsewhere the operations are undefined.
      </para>

      <para>
        All the computations in this representation are obvious, but there is
        one point to make concerning <emphasis>offset_max</emphasis>, which has
        the following arguments and result.
      </para>

      <programlisting language="TDF">
        arg1:            EXP OFFSET(x, y)
        arg2:            EXP OFFSET(z, y)
                   -&gt; EXP OFFSET(unite_alignments(x, z), y)</programlisting>

      <para>
        The <code>SHAPE</code>s could have been chosen to be:
      </para>

      <programlisting language="TDF">
        arg1:            EXP OFFSET(x, y)
        arg2:            EXP OFFSET(z, t)
                   -&gt; EXP OFFSET(unite_alignments(x, z),
                                 intersect_alignments(y, t))</programlisting>

      <para>
        where <emphasis>unite_alignments</emphasis> is set union and
        <emphasis>intersect_alignments</emphasis> is set intersection. This
        would have expressed the most general reality.  The representation of
        <emphasis>unite_alignments</emphasis>(<emphasis>x</emphasis>,
        <emphasis>z</emphasis>) is the maximum of the representations of
        <emphasis>x</emphasis> and <emphasis>z</emphasis> in the simple model.
        Unfortunately the representation of
        <emphasis>intersect_alignments</emphasis>(<emphasis>y</emphasis>,
        <emphasis>t</emphasis>) is not the minimum of the representations of
        <emphasis>y</emphasis> and <emphasis>t</emphasis>. In other words the
        simple model representation is not a homomorphism if
        <emphasis>intersect_alignments</emphasis> is used. Because the choice of
        representation in the installer is an important consideration the actual
        definition was chosen instead. It seems unlikely that this will affect
        practical programs significantly.
      </para>
    </section>

    <section id="C7S13.2">
      <title>Comparison of pointers and offsets</title>

      <para>
        Two <code>POINTER</code>s to the same <code>ALIGNMENT</code>,
        <emphasis>a</emphasis>, are equal if and only if the result of
        <emphasis>subtract_ptrs</emphasis> applied to them is equal to
        <emphasis>offset_zero</emphasis>(<emphasis>a</emphasis>).
      </para>

      <para>
        The comparison of <code>OFFSET</code>s is reduced to the definition of
        <emphasis>offset_max</emphasis> and the equality of <code>OFFSET</code>s
        by the note in <link linkend="C5S16.89">offset_test</link>.
      </para>
    </section>

    <section id="C7S13.3">
      <title>Circular types in languages</title>

      <para>
        It is assumed that circular types in programming languages will always
        involve the <code>SHAPE</code>s <code>PROC</code> or
        <code>POINTER</code>(<emphasis>x</emphasis>) on the circular path in
        their TDF representation. Since the <code>ALIGNMENT</code> of
        <code>POINTER</code> is {<emphasis>pointer</emphasis>} and does not
        involve the <code>ALIGNMENT</code> of the thing pointed at, circular
        <code>SHAPE</code>s are not needed. The circularity is always broken in
        <code>ALIGNMENT</code> (or <code>PROC</code>).
      </para>
    </section>

    <section id="C7S13.4">
      <title>Special alignments</title>

      <para>
        There are seven special <code>ALIGNMENT</code>s. One of these is
        <emphasis>code_alignment</emphasis>, the <code>ALIGNMENT</code> of the
        <code>POINTER</code> delivered by <emphasis>make_local_lv</emphasis>.
      </para>

      <para>
        The <code>ALIGNMENT</code> of a parameter of <code>SHAPE</code>
        <emphasis>s</emphasis> is given by
        <emphasis>parameter_alignment</emphasis>(<emphasis>s</emphasis>) which
        will always contain
        <emphasis>alignment</emphasis>(<emphasis>s</emphasis>).
      </para>

      <para>
        The other five special <code>ALIGNMENT</code>s are
        <emphasis>alloca_alignment</emphasis>, <emphasis>callees_alignment,
        callers_alignment, locals_alignment</emphasis> and
        <emphasis>var_param_alignment</emphasis>. Each of these contains the set
        union of all the <code>ALIGNMENT</code>s which can be produced by
        <emphasis>alignment</emphasis> from any <code>SHAPE</code>. But they
        need not be equal to that set union, nor need there be any relation
        between them.
      </para>

      <para>
        In particular they are not equal (in the sense of <link linkend="C7S7">
        equality of alignments -->Equality of <code>ALIGNMENT</code>s</link>).
      </para>

      <para>
        Each of these five refer to alignments of various components of a
        frame.
      </para>

      <para>
        Notice that pointers and offsets such as
        <code>POINTER</code>(<emphasis>callees_alignment</emphasis>(true)) and
        <code>OFFSET</code>(<emphasis>callees_alignment</emphasis>(true),
        <emphasis>x</emphasis>) etc. can have some special representation and
        that <emphasis>add_to_ptr</emphasis> and <emphasis>offset_add</emphasis>
        can operate correctly on these representations.  However it is necessary
        that
      </para>

      <programlisting language="TDF">
        alignment(POINTER(A))={pointer}</programlisting>

      <para>
        for any <code>ALIGNMENT</code> <emphasis>A</emphasis>.
      </para>
    </section>

    <section id="C7S13.5">
      <title>Atomic assignment</title>

      <para>
        At least one <code>VARIETY</code> shall exist such that
        <emphasis>assign</emphasis> and <emphasis>assign_with_mode</emphasis>
        are atomic operations. This <code>VARIETY</code> shall be specified as
        part of the installer specification. It shall be capable of representing
        the numbers 0 to 127.
      </para>

      <para>
        <emphasis>Note that it is not necessary for this to be the same
        <code>VARIETY</code> on each machine. Normal practice will be to use a
        <code>TOKEN</code> for this <code>VARIETY</code> and choose the
        definition of the <code>TOKEN</code> on the target machine.</emphasis>
      </para>
    </section>
  </section>

  <section id="C7S14">
    <title>Order of evaluation</title>

    <para>
      The order of evaluation is specified in certain constructions in terms of
      equivalent effect with a canonical order of evaluation. These
      constructions are <emphasis>conditional</emphasis>,
      <emphasis>identify</emphasis>, <emphasis>labelled</emphasis>,
      <emphasis>repeat</emphasis>, <emphasis>sequence</emphasis> and
      <emphasis>variable</emphasis>.  Let these be called the order-specifying
      constructions.
    </para>

    <para>
      The constructions which change control also specify a canonical order.
      These are <emphasis>apply_proc</emphasis>,
      <emphasis>apply_general_proc</emphasis>, <emphasis>case</emphasis>,
      <emphasis>goto</emphasis>, <emphasis>goto_local_lv</emphasis>,
      <emphasis>long_jump</emphasis>, <emphasis>return</emphasis>,
      u<emphasis>ntidy_return, return_to_label, tail_call,</emphasis> the
      <emphasis>test</emphasis> constructions and all instructions containing
      the <emphasis>error_jump</emphasis> and <emphasis>trap</emphasis>
      <code>ERROR_TREATMENT</code>s.
    </para>

    <para>
      The order of evaluation of the components of other constructions is
      as follows. The components may be evaluated in any order and with
      their components - down to the TDF leaf level - interleaved in any
      order. The constituents of the order specifying constructions may
      also be interleaved in any order, but the order of the operations
      within an order specifying operation shall be equivalent in effect
      to a canonical order.
    </para>

    <para>
      Note that the rule specifying when error_jumps or traps are to be taken
      (<link linkend="C5S15.4"><emphasis>error_jump</emphasis></link>) relaxes
      the strict rule that everything has to be <quote>as if</quote> completed
      by the end of certain constructions. Without this rule pipelines would
      have to stop at such points, in order to be sure of processing any errors.
      Since this is not normally needed, it would be an expensive requirement.
      Hence this rule. However a construction will be required to force errors
      to be processed in the cases where this is important.
    </para>
  </section>

  <section id="C7S15">
    <title>Original pointers</title>

    <para>
      Certain constructions are specified as producing original pointers. They
      allocate space to hold values and produce pointers indicating that new
      space. All other pointer values are derived pointers, which are produced
      from original pointers by a sequence of <emphasis>add_to_ptr</emphasis>
      operations. Counting original pointers as being derived from themselves,
      every pointer is derived from just one original pointer.
    </para>

    <para>
      A null pointer is counted as an original pointer.
    </para>

    <para>
      If procedures are called which come from outside the TDF world (such as
      <emphasis>calloc</emphasis>) it is part of their interface with TDF to
      state if they produce original pointers, and what is the lifetime of the
      pointer.
    </para>

    <para>
      As a special case, original pointers can be produced by using
      <emphasis>current_env</emphasis> and <emphasis>env_offset</emphasis> (see
      <link linkend="C5S16.25"><emphasis>current_env</emphasis></link>).
    </para>

    <para>
      Note that:
    </para>

    <programlisting language="TDF">
        add_to_ptr(p, offset_add(q, r))</programlisting>

    <para>
      is equivalent to:
    </para>

    <programlisting language="TDF">
        add_to_ptr(add_to_ptr(p, q), r)</programlisting>

    <para>
      In the case that <emphasis>p</emphasis> is the result of
      <emphasis>current_env</emphasis> and <emphasis>q</emphasis> is the result
      of <emphasis>env_offset</emphasis>:
    </para>

    <programlisting language="TDF">
        add_to_ptr(p, q)</programlisting>

    <para>
      is defined to be an original pointer. For any such expression
      <emphasis>q</emphasis> will be produced by <emphasis>env_offset</emphasis>
      applied to a <code>TAG</code> introduced in the procedure in which
      <emphasis>current_env</emphasis> was used to make <emphasis>p</emphasis>.
    </para>
  </section>

  <section id="C7S16">
    <title>Overlapping</title>

    <para>
      In the case of <emphasis>move_some</emphasis>, or
      <emphasis>assign</emphasis> or <emphasis>assign_with_mode</emphasis> in
      which <emphasis>arg2</emphasis> is a <emphasis>contents</emphasis> or
      <emphasis>contents_with_mode</emphasis>, it is possible that the source
      and destination of the transfer might overlap.
    </para>

    <para>
      In this case, if the operation is <emphasis>move_some</emphasis> or
      <emphasis>assign_with_mode</emphasis> and the <code>TRANSFER_MODE</code>
      contains <emphasis>overlap</emphasis>, then the transfer shall be
      performed correctly, that is, as if the data were copied from the source
      to an independent place and then to the destination.
    </para>

    <para>
      In all cases, if the source and destination do not overlap the transfer
      shall be performed correctly.
    </para>

    <para>
      Otherwise the effect is undefined.
    </para>
  </section>

  <section id="C7S17">
    <title>Incomplete assignment</title>

    <para>
      If the <emphasis>arg2</emphasis> component of an
      <emphasis>assign</emphasis> or <emphasis>assign_with_mode</emphasis>
      operation is left by means of a jump, the question arises as to what value
      is in the destination of the transfer.
    </para>

    <para>
      If the <code>TRANSFER_MODE</code> <emphasis>complete</emphasis> is used,
      the destination shall be left unchanged if the <emphasis>arg2</emphasis>
      component is left by means of a jump. If <emphasis>complete</emphasis> is
      not used and <emphasis>arg2</emphasis> is left by a jump, the destination
      may be affected in any way.
    </para>
  </section>

  <section id="C7S18">
    <title>Representing integers</title>

    <para>
      Integer <code>VARIETY</code>s shall be represented by a range of integers
      which includes those specified by the given bounds. This representation
      shall be twos-complement.
    </para>

    <para>
      If the lower bound of the <code>VARIETY</code> is non-negative, the
      representing range shall be from 0 to
      2<superscript><emphasis>8n</emphasis></superscript>-1 for some
      <emphasis>n</emphasis>.  <emphasis>n</emphasis> is called the number of
      bytes in the representation. The number of bits in the representation is
      8<emphasis>n</emphasis>.
    </para>

    <para>
      If the lower bound of the <code>VARIETY</code> is negative the
      representing range shall be from -2<superscript><emphasis>8n-1</emphasis></superscript> to
      2<superscript><emphasis>8n-1</emphasis></superscript>-1 for some <emphasis>n</emphasis>.
      <emphasis>n</emphasis> is called the number of bytes in the
      representation. The number of bits in the representation is
      8<emphasis>n</emphasis>
    </para>

    <para>
      Installers may limit the size of <code>VARIETY</code> that they implement.
      A statement of such limits shall be part of the specification of the
      installer. In no case may such limits be less than 64 bits, signed or
      unsigned.
    </para>

    <para>
      <emphasis>It is intended that there should be no upper limit allowed at
      some future date.</emphasis>
    </para>

    <para>
      Operations are performed in the representing <code>VARIETY</code>.  If the
      result of an operation does not lie within the bounds of the stated
      <code>VARIETY</code>, but does lie in the representation, the value
      produced in that representation shall be as if the <code>VARIETY</code>
      had the lower and upper bounds of the representation. The implication of
      this is usually that a number in a <code>VARIETY</code> is represented by
      that same number in the representation.
    </para>

    <para>
      If the bounds of a <code>VARIETY</code>, <emphasis>v</emphasis>, include
      those of a <code>VARIETY</code>, <emphasis>w</emphasis>, the representing
      <code>VARIETY</code> for <emphasis>v</emphasis> shall include or be equal
      to the representing <code>VARIETY</code> for <emphasis>w</emphasis>.
    </para>

    <para>
      The representations of two <code>VARIETY</code>s of the form
      <emphasis>var_limits</emphasis>(0,
      2<superscript><emphasis>n</emphasis></superscript>-1) and
      <emphasis>var_limits</emphasis>(-2<superscript><emphasis>n-1</emphasis></superscript>,
      2<superscript><emphasis>n-1</emphasis></superscript>-1) shall have the
      same number of bits and the mapping of their <code>ALIGNMENT</code>s into
      the target alignment shall be the same.
    </para>
  </section>

  <section id="C7S19">
    <title>Overflow and Integers</title>

    <para>
      It is necessary first to define what overflow means for integer operations
      and second to specify what happens when it occurs. The intention of TDF is
      to permit the simplest possible implementation of common constructions on
      all common machines while allowing precise effects to be achieved, if
      necessary at extra cost.
    </para>

    <para>
      Integer varieties may be represented in the computer by a range of
      integers which includes the bounds given for the variety. An arithmetic
      operation may therefore yield a result which is within the stated variety,
      or outside the stated variety but inside the range of representing values,
      or outside that range. Most machines provide instructions to detect the
      latter case; testing for the second case is possible but a little more
      costly.
    </para>

    <para>
      In the first two cases the result is defined to be the value in the
      representation. Overflow occurs only in the third case.
    </para>

    <para>
      If the <code>ERROR_TREATMENT</code> is <emphasis>impossible</emphasis>
      overflow will not occur. If it should happen to do so the effect of the
      operation is undefined.
    </para>

    <para>
      If the <code>ERROR_TREATMENT</code> is <emphasis>error_jump</emphasis> a
      <code>LABEL</code> is provided to jump to if overflow occurs.
    </para>

    <para>
      If the <code>ERROR_TREATMENT</code> is
      <emphasis>trap(overflow),</emphasis> a producer-defined <code>TOKEN</code>
      <emphasis>~Throw</emphasis>: <code>NAT</code> -&gt; <code>EXP</code> must
      be provided.  On an overflow, the installer will arrange that
      <emphasis>~Throw</emphasis>(<emphasis>error_val</emphasis>(<emphasis>overflow</emphasis>))
      is evaluated.
    </para>

    <para>
      The <emphasis>wrap</emphasis> <code>ERROR_TREATMENT</code> is provided so
      that a useful defined result may be produced in certain cases where it is
      usually easily available on most machines. This result is available on the
      assumption that machines use binary arithmetic for integers.  This is
      certainly so at present, and there is no close prospect of other bases
      being used.
    </para>

    <para>
      If a precise result is required further arithmetic and testing may be
      needed which the installer may be able to optimise away if the word
      lengths happen to suit the problem. In extreme cases it may be necessary
      to use a larger variety.
    </para>
  </section>

  <section id="C7S20">
    <title>Representing floating point</title>

    <para>
      <code>FLOATING_VARIETY</code>s shall be implemented by a representation
      which has at least the properties specified.
    </para>

    <para>
      Installers may limit the size of <code>FLOATING_VARIETY</code> which they
      implement. A statement of such limits shall be part of the specification
      of an installer.
    </para>

    <para>
      The limit may also permit or exclude infinities.
    </para>

    <para>
      Any installer shall implement at least one <code>FLOATING_VARIETY</code>
      with the following properties (c.f. IEEE doubles):
    </para>

    <itemizedlist>
      <listitem>
        <para>
          <emphasis>mantissa_digs</emphasis> shall not be less than 53.
        </para>
      </listitem>

      <listitem>
        <para>
          <emphasis>min_exponent</emphasis> shall not be less than 1023.
        </para>
      </listitem>

      <listitem>
        <para>
          <emphasis>max_exponent</emphasis> shall not be less than 1022.
        </para>
      </listitem>
    </itemizedlist>

    <para>
      Operations are performed and overflows detected in the representing
      <code>FLOATING_VARIETY</code>.
    </para>
  </section>

  <section id="C7S21">
    <title>Floating point errors</title>

    <para>
      The only permitted <code>ERROR_TREATMENT</code>s for operations delivering
      <code>FLOATING_VARIETY</code>s are <emphasis>impossible,
      error_jump</emphasis> and <emphasis>trap</emphasis> (overflow).
    </para>

    <para>
      The kinds of floating point error which can occur depend on the machine
      architecture (especially whether it has IEEE floating point) and on the
      definitions in the ABI being obeyed.
    </para>

    <para>
      Possible floating point errors depend on the state of the machine and may
      include overflow, divide by zero, underflow, invalid operation and
      inexact. The setting of this state is performed outside TDF (at present).
    </para>

    <para>
      If an <emphasis>error_jump</emphasis> or <emphasis>trap</emphasis> is
      taken as the result of a floating point error the operations to test what
      kind of error it was are outside the TDF definition (at present).
    </para>
  </section>

  <section id="C7S22">
    <title>Rounding and floating point</title>

    <para>
      Each machine has a rounding state which shall be one of
      <emphasis>to_nearest</emphasis>, <emphasis>toward_larger</emphasis>,
      <emphasis>toward_smaller</emphasis>, <emphasis>toward_zero</emphasis>. For
      each operation delivering a <code>FLOATING_VARIETY</code>, except for
      <emphasis>make_floating</emphasis>, any rounding necessary shall be
      performed according to the rounding state.
    </para>
  </section>

  <section id="C7S23">
    <title>Floating point accuracy</title>

    <para>
      While it is understood that most implementations will use IEEE floating
      arithmetic operations, there are machines which use other formats and
      operations. It is intended that they should not be excluded from having
      TDF implementations.
    </para>

    <para>
      For TDF to have reasonably consistent semantics across many platforms, one
      must have some <emphasis>minimum</emphasis> requirements on the accuracies
      of the results of the floating point operations defined in TDF. The
      provisional requirements sketched below would certainly be satisfied by an
      IEEE implementation.
    </para>

    <para>
      Let <emphasis>@</emphasis>  be some primitive dyadic arithmetic operator
      and <emphasis>@'</emphasis> be its TDF floating-point implementation. Let
      <emphasis>F</emphasis> be some non-complex <code>FLOATING_VARIETY</code>
      and <emphasis>F'</emphasis> be a representational variety of
      <emphasis>F</emphasis>.
    </para>

    <para>
      <emphasis role="bold">Condition 1</emphasis>:
    </para>

    <para>
      If <emphasis>a</emphasis>, <emphasis>b</emphasis> and <emphasis>a @
      b</emphasis> can all be represented exactly in <emphasis>F</emphasis>,
      then they will also be represented exactly in <emphasis>F'</emphasis>.
      Extending the '-notation in the obvious manner:
    </para>

    <programlisting language="TDF">
        (a @ b)' = (a' @' b')</programlisting>

    <para>
      This equality will also hold using the TDF equality test, i.e.:
    </para>

    <programlisting language="TDF">
        (a @ b)' =' (a' @' b')</programlisting>

    <para>
      <emphasis role="bold">Condition 2</emphasis>:
    </para>

    <para>
      The operator @' is monotonic in the sense apposite to the operator @. For
      example, consider the operator +; if x is any number and a and b are as
      above:
    </para>

    <programlisting language="TDF">
        (x &gt; b) =&gt; ((a' +' x') &gt;=  (a + b)')</programlisting>

    <para>
      and:
    </para>

    <programlisting language="TDF">
        (x &lt; b) =&gt;  ((a' +' x') &lt;= (a + b)')</programlisting>

    <para>
      and so on, reflecting the weakening of the ordering after the operation
      from &gt; to &gt;=  and &lt; to &lt;=.  Once again, the inequalities
      will hold for their TDF equivalents e.g., &gt;=' and &gt;'.
    </para>

    <para>
      Similar conditions can be expressed for the monadic operations.
    </para>

    <para>
      For the floating-point test operation, there are obvious analogues
      to both conditions. The weakening of the ordering in the monotonicity
      condition, however, may lead to surprising results, arising mainly
      from the uncertainty of the result of equality between floating numbers
      which cannot be represented exactly in <emphasis>F</emphasis>.
    </para>

    <para>
      Accuracy requirements for complex <code>FLOATING_VARIETY</code>s could
      follow directly by considering the above conditions applied to real and
      imaginary parts independently. The following proviso is added for some
      complex operations however, to allow for possible intermediate error
      conditions. With <emphasis>floating_div</emphasis>,
      <emphasis>floating_mult</emphasis> and <emphasis>floating_power</emphasis>
      for complex <code>FLOATING_VARIETY</code>s, errors are guaranteed not to
      occur only if the square of the modulus of each argument is representable
      and the square of the modulus of the result is representable. Whenever
      these additional constraints are not met, the operation will either
      complete with the accuracy conditions above applying, or it will complete
      according to the <code>ERROR_TREATMENT</code> specified.
    </para>
  </section>

  <section id="C7S24">
    <title>Representing bitfields</title>

    <para>
      <code>BITFIELD_VARIETY</code>s specify a number of bits and shall be
      represented by exactly that number of bits in twos-complement notation.
      Producers may expect them to be packed as closely as possible.
    </para>

    <para>
      Installers may limit the number of bits permitted in
      <code>BITFIELD_VARIETY</code>s.  Such a limit shall be not less than 32
      bits, signed or unsigned.
    </para>

    <para>
      <emphasis>It is intended that there should be no upper limit allowed at
      some future date.</emphasis>
    </para>

    <para>
      Some offsets of which the second parameter contains a
      <code>BITFIELD</code> alignment are subject to a constraint defined below.
      This constraint is referred to as <emphasis>variety_enclosed.</emphasis>
    </para>

    <para>
      The intent of this constraint is to force <code>BITFIELD</code>s to be
      implemented (in memory) as being included in some properly aligned
      <code>VARIETY</code> value.  The constraint applies to:
    </para>

    <programlisting language="TDF">
        x: offset(p, b)</programlisting>

    <para>
      and to:
    </para>

    <programlisting language="TDF">
        sh = bitfield(bfvar_bits(s, n))</programlisting>

    <para>
      where  <emphasis>alignment(sh)</emphasis> is included in
      <emphasis>b</emphasis>. The constraint is as follows:
    </para>
    
    <para>
      There will exist a <code>VARIETY</code>, <emphasis>v</emphasis>, and
      <emphasis>r</emphasis>:
      <emphasis>offset</emphasis>(<emphasis>p</emphasis>,
      <emphasis>q</emphasis>) where <emphasis>v</emphasis> is in
      <emphasis>q</emphasis>.
    </para>

    <programlisting language="TDF">
        offset_pad(b, r) &lt;= x</programlisting>

    <para>
      and:
    </para>

    <programlisting language="TDF">
        offset_pad(b, r + sz(v)) &gt;= offset_pad( b, x + sz(sh))</programlisting>

    <para>
      where the comparisons are in the sense of
      <emphasis>offset_test</emphasis>, + is <emphasis>offset_add</emphasis> and
      <emphasis>sz</emphasis> is <emphasis>shape_offset</emphasis>.
    </para>
  </section>

  <section id="C7S25">
    <title>Permitted limits</title>

    <para>
      An installer may specify limits on the sizes of some of the data
      <code>SHAPE</code>s which it implements. In each case there is a minimum
      set of limits such that all installers shall implement at least the
      specified <code>SHAPE</code>s. Part of the description of an installer
      shall be the limits it imposes. Installers are encouraged not to impose
      limits if possible, though it is not expected that this will be feasible
      for floating point numbers.
    </para>
  </section>

  <section id="C7S26">
    <title>Least Upper Bound</title>

    <para>
      The LUB of two <code>SHAPE</code>s, <emphasis>a</emphasis> and
      <emphasis>b</emphasis> is defined as follows:
    </para>

    <itemizedlist>
      <listitem>
        <para>
          If <emphasis>a</emphasis> and <emphasis>b</emphasis> are equal shapes,
          then <emphasis>a</emphasis>
        </para>
      </listitem>

      <listitem>
        <para>
          If <emphasis>a</emphasis> is <code>BOTTOM</code> then
          <emphasis>b</emphasis>
        </para>
      </listitem>

      <listitem>
        <para>
          If <emphasis>b</emphasis> is <code>BOTTOM</code> then
          <emphasis>a</emphasis>.
        </para>
      </listitem>

      <listitem>
        <para>
          Otherwise <code>TOP</code>.
        </para>
      </listitem>
    </itemizedlist>
  </section>

  <section id="C7S27">
    <title>Read-only areas</title>

    <para>
      Consider three scenarios in increasingly static order:
    </para>

    <itemizedlist>
      <listitem>
        <para>
          Dynamic loading. A new module is loaded, initialising procedures
          are obeyed and the results of these are then marked as read-only.
        </para>
      </listitem>

      <listitem>
        <para>
          Normal loading. An <emphasis>ld</emphasis> program is obeyed which
          produces various (possibly circular) structures which are put into an
          area which will be read-only when the program is obeyed.
        </para>
      </listitem>

      <listitem>
        <para>
          Using ROM. Data structures are created (again possibly circular) and
          burnt into ROM for use by a separate program.
        </para>
      </listitem>
    </itemizedlist>

    <para>
      In each case program is obeyed to create a structure, which is then
      frozen. The special case when the data is, say, just a string is not
      sufficiently general.
    </para>

    <para>
      This TDF specification takes the attitude that the use of read-only areas
      is a property of how TDF is used - a part of the installation process -
      and there should not be TDF constructions to say that some values in a
      <code>CAPSULE</code> are read-only. Such constructions could not be
      sufficiently general.
    </para>
  </section>

  <section id="C7S28">
    <title>Tag and Token signatures</title>

    <para>
      In a TDF program there will usually be references to <code>TAG</code>s
      which are not defined in TDF; their definitions are intended to be
      supplied by a host system in system specific libraries.
    </para>

    <para>
      These <code>TAG</code>s will be declared (but not defined) in a TDF
      <code>CAPSULE</code> and will be specified by external linkages of the
      <code>CAPSULE</code> with <code>EXTERNAL</code>s containg either
      <code>TDFIDENT</code>s or <code>UNIQUE</code>s. In previous versions of
      TDF, the external names required by system linking could only be derived
      from those <code>EXTERNAL</code>s.
    </para>

    <para>
      Version 4.0 gives an alternative method of constructing extra-TDF names.
      Each global <code>TAG</code> declaration can now contain a
      <code>STRING</code> signature field which may be used to derive the
      external name required by the system.
    </para>

    <para>
      This addition is principally motivated by the various <quote>name
      mangling</quote> schemes of C++. The <code>STRING</code> signature can be
      constructed by concatenations and token expansions. Suitable usages of
      <code>TOKEN</code>s can ensure that the particular form of name-mangling
      can be deferred to installation time and hence allow, at least
      conceptually, linking with different C++ libraries.
    </para>

    <para>
      As well as <code>TAG</code> declarations, <code>TAG</code> definitions are
      allowed to have signatures.  The restriction that the signature (if
      present) of a <code>TAG</code> definition being identical to its
      corresponding definition could allow type checking across seperately
      compiled <code>CAPSULE</code>s.
    </para>

    <para>
      Similar considerations apply to <code>TOKEN</code>s; although token names
      are totally internal to TDF, it would allow one to check that a token
      declared in one <code>CAPSULE</code> has the same <quote>type</quote> as
      its definition in another.
    </para>
  </section>

  <section id="C7S29">
    <title>Dynamic initialisation</title>

    <para>
      The dynamic initialisation of global variables is required for languages
      like C++. Previous to version 4.0, the only initialisations permissable
      were load-time ones; in particular no procedure calls were allowed in
      forming the initialising value. Version 4.0 introduces the constructor
      <emphasis>initial_value</emphasis> to remedy this situation.
    </para>

    <para>
      Several different implementation strategies could be considered for this.
      Basically, one must ensure that all the initial_value expressions are
      transformed into assignments to globals in some procedure. One might
      expect that there would be one such procedure invented for each
      <code>CAPSULE</code> and that somehow this procedure is called before the
      main program.
    </para>

    <para>
      This raises problems on how we can name this procedure so that it can be
      identified as being a special initialising procedure. Some UNIX linkers
      reserve a name like <emphasis>__init</emphasis> specially so that all
      instances of it from different modules can be called before the main
      procedure. Other cases may require a pre-pass on the
      <emphasis>.o</emphasis> files prior to system linking.
    </para>
  </section>
</chapter>
