<?xml version="1.0" standalone="no"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
  "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">

<article>
  <articleinfo>
    <title>C++ and Portability</title>

    <othercredit class="copyeditor">
      <firstname>Katherine</firstname>
      <surname>Flavel</surname>
      <affiliation><orgname>The TenDRA Project</orgname></affiliation>
    </othercredit>
    <corpauthor>DERA</corpauthor>

    <pubdate>2004</pubdate>

    <copyright>
      <year>2004</year>
      <year>2005</year>
      <year>2007</year>

      <holder>The TenDRA Project</holder>
    </copyright>

    <copyright>
      <year>1998</year>

      <holder>DERA</holder>
    </copyright>

	<revhistory>
		<revision>
			<date>01 10 2007</date>
			<revremark>Split off from the C++ Producer User Guide</revremark>
			<author><firstname>kate</firstname></author>
		</revision>
	</revhistory>
  </articleinfo>

  <!-- TODO this is a more of a memo than an article. maybe it will be expanded in the future -->

  <section id="porting">
    <title>Common porting problems</title>
  <para>
  Experience in porting pre-ISO C++ programs has shown that the following
  new ISO C++ features tend to cause the most problems:
  <itemizedlist>
  <listitem><A HREF="pragma.html#implicit">Implicit <code>int</code></A> has
  been banned.
  </listitem>
  <listitem><A HREF="pragma.html#string">String literals are now <code>const</code>
  </A>, although in simple assignments the <code>const</code> is
  implicitly removed.
  </listitem>
  <listitem>The scope of a <A HREF="pragma.html#for">variable declared in
  a for-init-statement</A> is the <code>for</code> statement itself.
  </listitem>
  <listitem><A HREF="lib.html#mangle">Variables have linkage</A> and so should
  be declared <code>extern &quot;C&quot;</code> if appropriate.
  </listitem>
  <listitem>The standard C library is now declared in the <code>std</code>
  namespace.
  </listitem>
  <listitem>The <A HREF="pragma.html#template">template compilation model</A>
  has been clarified.  The notation for explicit instantiation and
  specialisation has changed.
  </listitem>
  <listitem>Templates are analysed at their point of definition as well as
  their point of instantiation.
  </listitem>
  <listitem><A HREF="pragma.html#keyword">New keywords</A> have been introduced.
  </listitem>
  </itemizedlist>
  Note that many of these features have controlling <code>#pragma</code>
  directives, so that it is possible to switch to using the pre-ISO
  features.
  </para>
  </section>

  <section id="libio">
    <title>Porting <code>libio</code></title>
  <para>
  Perhaps the library component which is most likely to be required
  is
  <code>&lt;iostream&gt;</code>.  A readily available freeware implementation
  of a pre-ISO (i.e. non-template) <code>&lt;iostream&gt;</code>
  package is given by the <code>libio</code> component of <code>libg++</code>.
  This section describes some of the problems encountered in porting
  this package (version 2.7.1).
  </para>
  <para>
  The <A HREF="man.html"><code>tcc</code> compiler flags</A> used in
  porting <code>libio</code> were:
  <programlisting>
tcc -Yposix -Yc++ -sC:cc</programlisting>
  indicating that the POSIX API is to be used and that the <code>.cc</code>
  suffix is used to identify C++ source files.
  </para>
  <para>
  In <code>iostream.h</code>, <code>cin</code>, <code>cout</code>,
  <code>cerr</code> and <code>clog</code> should be declared with C
  linkage, otherwise the C++ producer includes the type in the
  <A HREF="lib.html#mangle">mangled name</A> and the fake
  <code>iostream</code> hacks in <code>stdstream.cc</code> don't work.
  The definition of <code>EOF</code> in this header can cause problems
  if both <code>iostream.h</code> and <code>stdio.h</code> are included.
  In this case <code>stdio.h</code> should be included first.
  </para>
  <para>
  In <code>stdstream.cc</code>, the <A HREF="lib.html#derive">correct
  definitions</A> for the fake <code>iostream</code> structures are
  as follows:
  <programlisting language="C++">
struct _fake_istream::myfields {
    _ios_fields *vb ;		// pointer to virtual base class ios
    _IO_ssize_t _gcount ;	// istream fields
    void *vptr ;		// pointer to virtual function table
} ;

struct _fake_ostream::myfields {
    _ios_fields *vb ;		// pointer to virtual base class ios
    void *vptr ;		// pointer to virtual function table
} ;</programlisting>
  The fake definition macros are then defined as follows:
  <programlisting language="C++">
#define OSTREAM_DEF( NAME, SBUF, TIE, EXTRA_FLAGS )\
    extern &quot;C&quot; _fake_ostream NAME = { { &amp;NAME.base, 0 }, .... } ;

#define ISTREAM_DEF( NAME, SBUF, TIE, EXTRA_FLAGS )\
    extern &quot;C&quot; _fake_istream NAME = { { &amp;NAME.base, 0, 0 }, .... } ;</programlisting>
  Note that these are declared with C linkage as above.
  </para>
  <para>
  In <code>stdstrbufs.cc</code>, the <A HREF="lib.html#other">correct
  definitions</A> for the virtual function table names are as follows:
  <programlisting language="C++">
#define filebuf_vtable		__vt__7filebuf
#define stdiobuf_vtable		__vt__8stdiobuf</programlisting>
  Note that the <code>_G_VTABLE_LABEL_PREFIX</code> macro is incorrectly
  defined by the configuration process (it should be <code>__vt__</code>),
  but the <code>##</code> directives in which it is used don't work
  on an ISO compliant preprocessor anyway (token concatenation takes
  place after replacement of macro parameters, but before further macro
  expansion). The dummy virtual function tables should also be declared
  with C linkage to suppress name mangling.
  </para>
  In addition, the initialisation of the standard streams relies on
  the file pointers <code>stdout</code> etc. being constant expressions,
  which in general they are not.  The directive:
  <programlisting language="C++">
#pragma TenDRA++ rvalue token as const allow</programlisting>
  will cause the C++ producer to assume that all <A HREF="token.html#exp">
  tokenised rvalue expressions</A> are constant.
  <para>
  In <code>streambuf.cc</code>, if <code>errno</code> is to be explicitly
  declared it should have C linkage or be declared in the <code>std</code>
  namespace.
  </para>
  <para>
  In <code>iomanip.cc</code>, the explicit template instantiations should
  be prefixed by <code>template</code>.  The corresponding template
  declarations in <code>iomanip.h</code> should be declared using
  <A HREF="pragma.html#template"><code>export</code></A> (note that
  the <code>__GNUG__</code> version uses <code>extern</code>, which
  may yet win out over <code>export</code>).
  </para>
  </section>
</article>

