/* $Id$ */

/*
 * Copyright 2011, The TenDRA Project.
 * Copyright 1997, United Kingdom Secretary of State for Defence.
 *
 * See doc/copyright/ for the full copyright terms.
 */






/*
 *  AUTOMATICALLY GENERATED BY lexi VERSION 1.2
 */


/* LOOKUP TABLE */

static unsigned char lookup_tab[257] = {
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0001, 0x0001, 0x0000, 0x0000, 0x0001, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0001, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x000c, 0x000c, 0x000c, 0x000c, 0x000c, 0x000c, 0x000c, 0x000c,
    0x000c, 0x000c, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x000a, 0x000a, 0x000a, 0x000a, 0x000a, 0x000a, 0x000a,
    0x000a, 0x000a, 0x000a, 0x000a, 0x000a, 0x000a, 0x000a, 0x000a,
    0x000a, 0x000a, 0x000a, 0x000a, 0x000a, 0x000a, 0x000a, 0x000a,
    0x000a, 0x000a, 0x000a, 0x0000, 0x0000, 0x0000, 0x0000, 0x000a,
    0x0000, 0x000a, 0x000a, 0x000a, 0x000a, 0x000a, 0x000a, 0x000a,
    0x000a, 0x000a, 0x000a, 0x000a, 0x000a, 0x000a, 0x000a, 0x000a,
    0x000a, 0x000a, 0x000a, 0x000a, 0x000a, 0x000a, 0x000a, 0x000a,
    0x000a, 0x000a, 0x000a, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
    0x0000
};

#ifndef LEX_EOF
#define LEX_EOF		256
#endif

#define lookup_char(C)	((int)lookup_tab[(C)])
#define is_white(T)	((T) & 0x0001)
#define is_alpha(T)	((T) & 0x0002)
#define is_digit(T)	((T) & 0x0004)
#define is_alphanum(T)	((T) & 0x0008)


/* MAIN PASS ANALYSER */

int
read_token(void)
{
    start: {
	int c0 = read_char(), t0;
	t0 = lookup_char(c0);
	if (is_white(t0)) goto start;
	switch (c0) {
	    case '"': {
		return(get_string(c0));
	    }
	    case '(': {
		return(lex_open_Hround);
	    }
	    case ')': {
		return(lex_close_Hround);
	    }
	    case ',': {
		return(lex_comma);
	    }
	    case '-': {
		int c1 = read_char();
		if (c1 == '>') {
		    return(lex_arrow);
		}
		unread_char(c1);
		break;
	    }
	    case '/': {
		int c1 = read_char();
		if (c1 == '*') {
		    return(get_comment(c0, c1));
		}
		unread_char(c1);
		break;
	    }
	    case ':': {
		return(lex_colon);
	    }
	    case '=': {
		return(lex_equal);
	    }
	    case '{': {
		return(lex_open_Hbrace);
	    }
	    case '|': {
		return(lex_or);
	    }
	    case '}': {
		return(lex_close_Hbrace);
	    }
	    case LEX_EOF: {
		return(lex_eof);
	    }
	}
	if (is_alpha(t0)) {
	    return(get_identifier(c0));
	}
	return(unknown_token(c0));
    }
}
