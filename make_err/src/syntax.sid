/* $Id$ */

/*
 * Copyright 2011, The TenDRA Project.
 * Copyright 1997, United Kingdom Secretary of State for Defence.
 *
 * See doc/copyright/ for the full copyright terms.
 */

%types%

/*
    TYPES

    The types correspond to those generated by the calculus.  In addition,
    ID represents an identifier name and STRING represents a string.
*/

ID ;
STRING ;

ENTRY ;
KEY ;
MAP ;
MSG ;
NAME ;
PARAM ;
PROP ;
TYPE ;
USAGE ;

LIST-ENTRY ;
LIST-MAP ;
LIST-MSG ;
LIST-NAME ;
LIST-PARAM ;
LIST-PROP ;


%terminals%

/*
    TERMINALS

    These terminals give the various terminals identified by the lexical
    analysis routines.
*/

identifier : () -> ( :ID ) ;
string : () -> ( :STRING ) ;

alt-name ;
db-name ;
entries ;
key ;
keys ;
prefix ;
properties ;
rig ;
types ;
usage ;

comp-output ;
from-comp ;
from-db ;

arrow ;
colon ;
comma ;
equal ;
or ;
open-round ;
close-round ;
open-brace ;
close-brace ;
eof ;
!unknown ;


%productions%


/*
    MESSAGE LIST

    A message consists of a list of parameter names and strings.
*/

<find_param> : ( :ID, :LIST-PARAM ) -> ( :PARAM ) ;
<message_param> : ( :PARAM ) -> ( :MSG ) ;
<message_string> : ( :STRING ) -> ( :MSG ) ;
<empty_message_list> : () -> ( :LIST-MSG ) ;
<cons_message_list> : ( :MSG, :LIST-MSG ) -> ( :LIST-MSG ) ;

message-list : ( s : LIST-PARAM ) -> ( p : LIST-MSG ) = {
	a = identifier ;
	n = <find_param> ( a, s ) ;
	m = <message_param> ( n ) ;
	q = message-list ( s ) ;
	p = <cons_message_list> ( m, q ) ;
    ||
	a = string ;
	m = <message_string> ( a ) ;
	q = message-list ( s ) ;
	p = <cons_message_list> ( m, q ) ;
    ||
	p = <empty_message_list> ;
} ;


/*
    MAPPING LIST

    A mapping consists of a message list and an associated key.
*/

<find_key> : ( :ID ) -> ( :KEY ) ;
<make_map> : ( :KEY, :LIST-MSG, :LIST-MSG ) -> ( :MAP ) ;
<empty_map_list> : () -> ( :LIST-MAP ) ;
<cons_map_list> : ( :MAP, :LIST-MAP ) -> ( :LIST-MAP ) ;

map-list : ( s : LIST-PARAM ) -> ( p : LIST-MAP ) = {
	key ; open-round ; a = identifier ; close-round ;
	k = <find_key> ( a ) ;
	m1 = message-list ( s ) ;
	{
		or ; m2 = message-list ( s ) ;
	    ||
		m2 = m1 ;
	} ;
	n = <make_map> ( k, m1, m2 ) ;
	q = map-list ( s ) ;
	p = <cons_map_list> ( n, q ) ;
    ||
	p = <empty_map_list> ;
} ;


/*
    PROPERTIES LIST

    A properties list is a non-empty, comma-separated list of properties.
*/

<find_props> : ( :ID ) -> ( :PROP ) ;
<empty_props_list> : () -> ( :LIST-PROP ) ;
<cons_props_list> : ( :PROP, :LIST-PROP ) -> ( :LIST-PROP ) ;

props-list : () -> ( p : LIST-PROP ) = {
	a = identifier ;
	b = <find_props> ( a ) ;
	{
		comma ; q = props-list ;
	    ||	q = <empty_props_list> ;
	} ;
	p = <cons_props_list> ( b, q ) ;
} ;


/*
    SIGNATURE

    A message signature consists of an optional list of types and parameter
    names.
*/

<find_type> : ( :ID ) -> ( :TYPE ) ;
<make_param> : ( :TYPE, :ID ) -> ( :PARAM ) ;
<empty_param_list> : () -> ( :LIST-PARAM ) ;
<cons_param_list> : ( :PARAM, :LIST-PARAM ) -> ( :LIST-PARAM ) ;

param-list : () -> ( p : LIST-PARAM ) = {
	a = identifier ; t = <find_type> ( a ) ; colon ;
	b = identifier ;
	c = <make_param> ( t, b ) ;
	{
		comma ; q = param-list ;
	    ||	q = <empty_param_list> ;
	} ;
	p = <cons_param_list> ( c, q ) ;
} ;

signature : () -> ( p : LIST-PARAM ) = {
	p = param-list ;
    ||	p = <empty_param_list> ;
} ;


/*
    DATABASE ENTRY

    This rule describes the main component of the input, an individual
    database entry.
*/

<null_identifier> : () -> ( :ID ) ;
<find_usage> : ( :ID ) -> ( :USAGE ) ;
<null_usage> : () -> ( :USAGE ) ;
<make_entry> : ( :ID, :ID, :LIST-PARAM, :USAGE, :USAGE, :LIST-PROP,
		 :LIST-MAP ) -> ( :ENTRY ) ;

entry : () -> ( e : ENTRY ) = {
	a = identifier ; open-round ; s = signature ; close-round ;
	open-brace ;
	{
		alt-name ; colon ; b = identifier ;
	    ||	b = <null_identifier> ;
	} ;
	{
		usage ; colon ; c = identifier ;
		u = <find_usage> ( c ) ;
		{
			or ; d = identifier ;
			w = <find_usage> ( d ) ;
		    ||
			w = u ;
		} ;
		v = w ;
	    ||
		u = <null_usage> ;
		v = <null_usage> ;
	} ;
	{
		properties ; colon ;
		{
			q = props-list ;
		    ||	q = <empty_props_list> ;
		} ;
		p = q ;
	    ||
		p = <empty_props_list> ;
	} ;
	m = map-list ( s ) ;
	close-brace ;
	e = <make_entry> ( a, b, s, u, v, p, m ) ;
} ;


/*
    ENTRIES LIST

    The main component of the top level unit is a list of entries.
*/

<empty_entry_list> : () -> ( :LIST-ENTRY ) ;
<cons_entry_list> : ( :ENTRY, :LIST-ENTRY ) -> ( :LIST-ENTRY ) ;

entries-list : () -> ( p : LIST-ENTRY ) = {
	a = entry ;
	q = entries-list ;
	p = <cons_entry_list> ( a, q ) ;
    ||
	p = <empty_entry_list> ;
} ;


/*
    IDENTIFIER LIST

    The various lists of types, properties etc. in the top level unit are
    just simple lists of identifiers.
*/

<empty_name_list> : () -> ( :LIST-NAME ) ;
<make_name> : ( :ID ) -> ( :NAME ) ;
<make_name_aux> : ( :ID ) -> ( :NAME ) ;
<cons_name_list> : ( :NAME, :LIST-NAME ) -> ( :LIST-NAME ) ;
<join_name_list> : ( :NAME, :LIST-NAME ) -> ( :LIST-NAME ) ;

name-seq : () -> ( p : LIST-NAME, q : LIST-NAME, r : LIST-NAME ) = {
	a = identifier ;
	n = <make_name> ( a ) ;
	{
		equal ; b = identifier ;
		m = <make_name_aux> ( b ) ;
		{
			or ; c = identifier ;
			k1 = <make_name_aux> ( c ) ;
		    ||
			k1 = m ;
		} ;
		k = k1 ;
	    ||
		m = n ;
		k = n ;
	} ;
	{
		comma ; ( p1, q1, r1 ) = name-seq ;
	    ||
		p1 = <empty_name_list> ;
		q1 = <empty_name_list> ;
		r1 = <empty_name_list> ;
	} ;
	p = <cons_name_list> ( n, p1 ) ;
	q = <join_name_list> ( m, q1 ) ;
	r = <join_name_list> ( k, r1 ) ;
} ;

name-list : () -> ( p : LIST-NAME, q : LIST-NAME, r : LIST-NAME ) = {
	( p, q, r ) = name-seq ;
    ||
	p = <empty_name_list> ;
	q = <empty_name_list> ;
	r = <empty_name_list> ;
} ;


/*
    COMPLETE UNIT

    The input consists of various standard information plus lists of
    types, properties, keys, usages and entries.
*/

<set_db> : ( :ID, :ID ) -> () ;
<set_rig> : ( :ID ) -> () ;
<set_prefix> : ( :ID, :ID, :ID ) -> () ;
<set_types> : ( :LIST-NAME, :LIST-NAME, :LIST-NAME ) -> () ;
<set_props> : ( :LIST-NAME, :LIST-NAME, :LIST-NAME ) -> () ;
<set_keys> : ( :LIST-NAME, :LIST-NAME, :LIST-NAME ) -> () ;
<set_usages> : ( :LIST-NAME, :LIST-NAME, :LIST-NAME ) -> () ;
<set_entries> : ( :LIST-ENTRY ) -> () ;
<syntax_error> : () -> () ;

unit : () -> () = {
	/* Database name */
	{
		db-name ; colon ; d = identifier ;
		{
			or ; e = identifier ;
		    ||	e = d ;
		} ;
		<set_db> ( d, e ) ;
	    ||
		$ ;
	} ;
	{
		rig ; colon ; r = identifier ;
		<set_rig> ( r ) ;
	    ||
		$ ;
	} ;

	/* Standard prefixes */
	{
		prefix ; colon ;
		{
			comp-output ; arrow ; q1 = identifier ;
		    ||	q1 = <null_identifier> ;
		} ;
		{
			from-comp ; arrow ; q2 = identifier ;
		    ||	q2 = <null_identifier> ;
		} ;
		{
			from-db ; arrow ; q3 = identifier ;
		    ||	q3 = <null_identifier> ;
		} ;
		<set_prefix> ( q1, q2, q3 ) ;
	    ||
		q1 = <null_identifier> ;
		q2 = <null_identifier> ;
		q3 = <null_identifier> ;
		<set_prefix> ( q1, q2, q3 ) ;
	} ;

	/* List of types */
	{
		types ; colon ; ( t1, t2, t3 ) = name-list ;
	    ||
		t1 = <empty_name_list> ;
		t2 = <empty_name_list> ;
		t3 = <empty_name_list> ;
	} ;
	<set_types> ( t1, t2, t3 ) ;

	/* List of properties */
	{
		properties ; colon ; ( p1, p2, p3 ) = name-list ;
	    ||
		p1 = <empty_name_list> ;
		p2 = <empty_name_list> ;
		p3 = <empty_name_list> ;
	} ;
	<set_props> ( p1, p2, p3 ) ;

	/* List of keys */
	{
		keys ; colon ; ( k1, k2, k3 ) = name-list ;
	    ||
		k1 = <empty_name_list> ;
		k2 = <empty_name_list> ;
		k3 = <empty_name_list> ;
	} ;
	<set_keys> ( k1, k2, k3 ) ;

	/* List of usages */
	{
		usage ; colon ; ( u1, u2, u3 ) = name-list ;
	    ||
		u1 = <empty_name_list> ;
		u2 = <empty_name_list> ;
		u3 = <empty_name_list> ;
	} ;
	<set_usages> ( u1, u2, u3 ) ;

	/* List of entries */
	{
		entries ; colon ; e = entries-list ;
	    ||	e = <empty_entry_list> ;
	} ;
	<set_entries> ( e ) ;
	eof ;
    ##
	<syntax_error> ;
}  ;

%entry% unit ;
