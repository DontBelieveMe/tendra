<?xml version="1.0" encoding="ISO-8859-1"?>
<!DOCTYPE refentry SYSTEM "minidocbook.dtd">

<!-- $Id$ -->
<refentry>
<!--
        Copyright (c) 2002-2007 The TenDRA Project <http://www.tendra.org/>.
        All rights reserved.

        Redistribution and use in source and binary forms, with or without
        modification, are permitted provided that the following conditions are met:

        1. Redistributions of source code must retain the above copyright notice,
           this list of conditions and the following disclaimer.
        2. Redistributions in binary form must reproduce the above copyright notice,
           this list of conditions and the following disclaimer in the documentation
           and/or other materials provided with the distribution.
        3. Neither the name of The TenDRA Project nor the names of its contributors
           may be used to endorse or promote products derived from this software
           without specific, prior written permission.

        THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS
        IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
        THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
        PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR
        CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
        EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
        PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
        OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
        WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
        OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
        ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-->
<!--
			 Crown Copyright (c) 1997

	This TenDRA(r) Manual Page is subject to Copyright
	owned by the United Kingdom Secretary of State for Defence
	acting through the Defence Evaluation and Research Agency
	(DERA).	It is made available to Recipients with a
	royalty\-free licence for its use, reproduction, transfer
	to other parties and amendment for any purpose not excluding
	product development provided that any such use et cetera
	shall be deemed to be acceptance of the following conditions:\-

			(1) Its Recipients shall ensure that this Notice is
			reproduced upon any copies or amended versions of it;

			(2) Any amended version of it shall be clearly marked to
			show both the nature of and the organisation responsible
			for the relevant amendment or amendments;

			(3) Its onward transfer from a recipient to another
			party shall be deemed to be that party's acceptance of
			these conditions;

			(4) DERA gives no warranty or assurance as to its
			quality or suitability for any purpose and DERA accepts
			no liability whatsoever in relation to any use to which
			it may be put.
-->

	<refmeta>
		<refentrytitle>tdfc2 C/C++ symbol table dump format</refentrytitle>
		<manvolnum>5</manvolnum>
	</refmeta>

	<refnamediv>
		<refname>tdfcdump</refname>
		<refpurpose>tdfc2 C/C++ symbol table dump format</refpurpose>
	</refnamediv>

	<!--
		TODO: very much work in progress. This contains the details for
		the symbol table from the tcpplus and tdfc user guides. These
		ought to be consolidated into one description.
		Likewise the syntax reference, which is now a .5 manpage.
	-->

	<refsection>
		<title>Overview</title>

		<para>&tchk; produces an extra output file, called a dump output file, for
			each translation unit processed. This file is in the form given by the
			symbol table output specification in Annex E, and contains information
			about the objects declared, defined or used within an application. Each
			object encountered during processing is assigned a unique reference
			number allowing uses of the object to be traced back to the declaration
			and definition of the object.</para>

		<para>In the default mode only external declaration and definition
			information is written to each dump file.
			The file to be used as the symbol table output file, plus details
			of what information is to be included in the dump file can be specified
			by passing various flags using the <code>-d</code> command-line option
			to &tcpplus;; these flags are documented by &tdfc2;.</para>

		<para>The symbol table dump provides a method whereby third party tools
			can interface with the C and C++ producers.	The producer outputs
			information on the identifiers declared within a source file, their
			uses etc. into a file which can then be post-processed by a separate
			tool. Any error messages and warnings can also be included in this
			file, allowing more sophisticated error presentation tools to be written.</para>

		<para>The dump information is currently used for four main purposes:
			detecting included header files from which nothing is used within the
			translation unit; production of lint-like error output; &api; usage
			analysis and type checking between translation units.</para>

		<para>The format of the dump file is described below; a
			summary of the syntax is given in &tdfcdump.5;.</para>
	</refsection>

	<!-- TODO hereafter is from tcpplus -->

	<refsection>
		<title>Lexical elements</title>

		<para>A symbol table dump file consists of a sequence of characters giving
			information on identifiers, errors etc. arising from a translation
			unit. The fundamental lexical tokens are a <replaceable>number</replaceable>, consisting
			of a sequence of decimal digits, and a <replaceable>string</replaceable>, consisting of
			a sequence of characters enclosed in angle braces.
			A <replaceable>string</replaceable> can have one of two forms:</para>

		<programlisting language="bnf"><replaceable>string</replaceable> :
	&lt;<replaceable>characters</replaceable>&gt;
	&amp;<replaceable>number</replaceable>&lt;<replaceable>characters</replaceable>&gt;</programlisting>

		<para>In the first form, the <replaceable>characters</replaceable> are terminated by the first
			<code>&gt;</code> character encountered.	In the second form, the
			number of characters is given by the preceding <replaceable>number</replaceable>.	No
			white space is allowed either before or after the <replaceable>number</replaceable>.
			To aid parsers, the C++ producer always uses the second form for strings
			containing more than 100 characters.	There are no escape characters
			in strings; the
			<replaceable>characters</replaceable> can contain any characters, including newlines and
			<code>#</code>, except that the first form cannot contain a
			<code>&gt;</code> character.</para>

		<para>Space, tab and newline characters are white space.	Comments begin
			with <code>#</code> and run to the end of the line.	Comments are treated
			as white space.	All other characters are treated as distinct lexical
			tokens.</para>
	</refsection>

	<refsection>
		<title>Overall syntax</title>

		<para>A symbol table dump file takes the form of a list of commands of various
			kinds conveying information on the analysed file.	This can be represented
			as follows:</para>

		<programlisting language="bnf"><replaceable>dump-file</replaceable> :
	<replaceable>command-list&opt.bnf;</replaceable>

<replaceable>command-list</replaceable> :
	<replaceable>command command-list&opt.bnf;</replaceable>

<replaceable>command</replaceable> :
	<replaceable>version-command</replaceable>
	<replaceable>identifier-command</replaceable>
	<replaceable>scope-command</replaceable>
	<replaceable>override-command</replaceable>
	<replaceable>base-command</replaceable>
	<replaceable>api-command</replaceable>
	<replaceable>template-command</replaceable>
	<replaceable>promotion-command</replaceable>
	<replaceable>error-command</replaceable>
	<replaceable>path-command</replaceable>
	<replaceable>file-command</replaceable>
	<replaceable>include-command</replaceable>
	<replaceable>string-command</replaceable></programlisting>

		<para>The various kinds of command are discussed below.	The first command
			in the dump file should be of the form:</para>

		<programlisting language="bnf"><replaceable>version-command</replaceable> :
	V <replaceable>number number string</replaceable></programlisting>

		<para>where the two numbers give the version of the dump file format (the
			version described here is 1.1 so both numbers should be 1) and the
			string gives the language being represented, for example,
			<code>&lt;C++&gt;</code>.</para>
	</refsection>

	<refsection>
		<title>File locations</title>

		<para>A location within a source file can be specified using three
			<replaceable>number</replaceable>s and two <replaceable>string</replaceable>s.	These give respectively, the
			column number, the line number taking <code>#line</code> directives
			into account, the line number not taking <code>#line</code> directives
			into account, the file name taking <code>#line</code> directives into
			account, and the file name not taking <code>#line</code> directives
			into account.	Any or all of the trailing elements can be replaced by
			<code>*</code> to indicate that they have not changed relative to
			the last <replaceable>location</replaceable> given.	Note that for the two line numbers,
			unchanged means that the difference of the line numbers, taking
			<code>#line</code> directives into account or not, is unchanged.
			Thus:</para>

		<programlisting language="bnf"><replaceable>location</replaceable> :
	<replaceable>number number number string string</replaceable>
	<replaceable>number number number string</replaceable> *
	<replaceable>number number number</replaceable> *
	<replaceable>number number</replaceable> *
	<replaceable>number</replaceable> *
	*</programlisting>

		<para>Note that there is a concept of the current file
			location, relative to which other locations are given.
			The initial value of the current file location is undefined.
			Unless otherwise stated, all <replaceable>location</replaceable>
			elements update the current file location.</para>
	</refsection>

	<refsection>
		<title>Identifier names</title>

		<para>Each identifier is represented in the symbol table dump by a unique
			number. The number representing an identifier is introduced in the
			first declaration or use of that identifier and thereafter the number
			alone is used to denote the identifier:</para>

		<programlisting language="bnf"><replaceable>identifier</replaceable> :
	<replaceable>number</replaceable> = <replaceable>identifier-name access&opt.bnf; scope-identifier</replaceable>
	<replaceable>number</replaceable></programlisting>

		<para>The identifier name is given by:</para>

		<programlisting language="bnf"><replaceable>identifier-name</replaceable> :
	<replaceable>string</replaceable>
	C <replaceable>type</replaceable>
	D <replaceable>type</replaceable>
	O <replaceable>string</replaceable>
	T <replaceable>type</replaceable></programlisting>

		<para>denoting respectively, a simple identifier name, a constructor for
			a type, a destructor for a type, an overloaded operator function name,
			and a conversion function name.	The empty string is used for anonymous
			identifiers.</para>

		<para>The optional identifier access is given by:</para>

			<programlisting language="bnf"><replaceable>access</replaceable> :
	N
	B
	P</programlisting>

		<para>denoting <code>public</code>, <code>protected</code> and
			<code>private</code> respectively.	An absent <replaceable>access</replaceable> is equivalent
			to <code>public</code>.	Note that all identifiers, not just class
			members, can have access specifiers; however the access of a non-member
			is always <code>public</code>.</para>

		<para>The scope (i.e. class, namespace, block etc.)
			in which an identifier is declared is given by:</para>

		<programlisting language="bnf"><replaceable>scope-identifier</replaceable> :
	<replaceable>identifier</replaceable>
	*</programlisting>

		<para>denoting either a named or an unnamed scope.</para>
	</refsection>

	<refsection>
		<title>Identifier uses</title>

		<para>Each declaration or use of an identifier is represented by a command
			of the form:</para>

		<programlisting language="bnf"><replaceable>identifier-command</replaceable> :
	D <replaceable>identifier-info type-info</replaceable>
	M <replaceable>identifier-info type-info</replaceable>
	T <replaceable>identifier-info type-info</replaceable>
	Q <replaceable>identifier-info</replaceable>
	U <replaceable>identifier-info</replaceable>
	L <replaceable>identifier-info</replaceable>
	C <replaceable>identifier-info</replaceable>
	W <replaceable>identifier-info type-info</replaceable></programlisting>

		<para>where:</para>

		<programlisting language="bnf"><replaceable>identifier-info</replaceable> :
<replaceable>identifier-key location identifier</replaceable></programlisting>

		<para>gives the kind of identifier being declared or used, the location
			of the declaration or use, and the number associated with the identifier.
			Each declaration may, depending on the <replaceable>identifier-key</replaceable>, associate
			various <replaceable>type-info</replaceable> with the identifier, giving its type etc.</para>

		<para>The various kinds of <replaceable>identifier-command</replaceable> are described below.
			Any can be preceded by <code>I</code> to indicate an implicit declaration
			or use.	<code>D</code> denotes a definition.	<code>M</code> (make)
			denotes a declaration.	<code>T</code> denotes a tentative definition
			(C only).	<code>Q</code> denotes the end of a definition, for those
			identifiers such as classes and functions whose definitions may be
			spread over several lines.	<code>U</code> denotes an undefine operation
			(such as <code>#undef</code> for macro identifiers).	<code>C</code>
			denotes a call to a function identifier; <code>L</code> (load) denotes
			other identifier uses.	Finally <code>W</code> denotes implicit type
			information such as the C producer gleans from its
			weak prototype analysis (see &tchk.doc;).</para>

		<para>The various <replaceable>identifier-key</replaceable>s are their
			associated <replaceable>type-info</replaceable>
			fields are given by the following table:</para>

		<table>
			<col align="center"/>
			<col align="left"/>
			<col align="left"/>

			<thead>
				<tr>
					<th>Key</th>
					<th>Type information</th>
					<th>Description</th>
				</tr>
			</thead>

			<tbody>
				<tr>
					<td><code>K</code></td>
					<td><code>*</code></td>
					<td>keyword</td>
				</tr>

				<tr>
					<td><code>MO</code></td>
					<td><replaceable>sort</replaceable></td>
					<td>object macro</td>
				</tr>

				<tr>
					<td><code>MF</code></td>
					<td><replaceable>sort</replaceable></td>
					<td>function macro</td>
				</tr>

				<tr>
					<td><code>MB</code></td>
					<td><replaceable>sort</replaceable></td>
					<td>built-in macro</td>
				</tr>

				<tr>
					<td><code>TC</code></td>
					<td><replaceable>type</replaceable></td>
					<td>class tag</td>
				</tr>

				<tr>
					<td><code>TS</code></td>
					<td><replaceable>type</replaceable></td>
					<td>structure tag</td>
				</tr>

				<tr>
					<td><code>TU</code></td>
					<td><replaceable>type</replaceable></td>
					<td>union tag</td>
				</tr>

				<tr>
					<td><code>TE</code></td>
					<td><replaceable>type</replaceable></td>
					<td>enumeration tag</td>
				</tr>

				<tr>
					<td><code>TA</code></td>
					<td><replaceable>type</replaceable></td>
					<td><code>typedef</code> name</td>
				</tr>

				<tr>
					<td><code>NN</code></td>
					<td><code>*</code></td>
					<td>namespace name</td>
				</tr>

				<tr>
					<td><code>NA</code></td>
					<td><replaceable>scope-identifier</replaceable></td>
					<td>namespace alias</td>
				</tr>

				<tr>
					<td><code>VA</code></td>
					<td><replaceable>type</replaceable></td>
					<td>automatic variable</td>
				</tr>

				<tr>
					<td><code>VP</code></td>
					<td><replaceable>type</replaceable></td>
					<td>function parameter</td>
				</tr>

				<tr>
					<td><code>VE</code></td>
					<td><replaceable>type</replaceable></td>
					<td><code>extern</code> variable</td>
				</tr>

				<tr>
					<td><code>VS</code></td>
					<td><replaceable>type</replaceable></td>
					<td><code>static</code> variable</td>
				</tr>

				<tr>
					<td><code>FE</code></td>
					<td><replaceable>type identifier&opt.bnf;</replaceable></td>
					<td><code>extern</code> function</td>
				</tr>

				<tr>
					<td><code>FS</code></td>
					<td><replaceable>type identifier&opt.bnf;</replaceable></td>
					<td><code>static</code> function</td>
				</tr>

				<tr>
					<td><code>FB</code></td>
					<td><replaceable>type identifier&opt.bnf;</replaceable></td>
					<td>built-in operator function</td>
				</tr>

				<tr>
					<td><code>CF</code></td>
					<td><replaceable>type identifier&opt.bnf;</replaceable></td>
					<td>member function</td>
				</tr>

				<tr>
					<td><code>CS</code></td>
					<td><replaceable>type identifier&opt.bnf;</replaceable></td>
					<td><code>static</code> member function</td>
				</tr>

				<tr>
					<td><code>CV</code></td>
					<td><replaceable>type identifier&opt.bnf;</replaceable></td>
					<td>virtual member function</td>
				</tr>

				<tr>
					<td><code>CM</code></td>
					<td><replaceable>type</replaceable></td>
					<td>data member</td>
				</tr>

				<tr>
					<td><code>CD</code></td>
					<td><replaceable>type</replaceable></td>
					<td><code>static</code> data member</td>
				</tr>

				<tr>
					<td><code>E</code></td>
					<td><replaceable>type</replaceable></td>
					<td>enumerator</td>
				</tr>

				<tr>
					<td><code>L</code></td>
					<td><code>*</code></td>
					<td>label</td>
				</tr>

				<tr>
					<td><code>XO</code></td>
					<td><replaceable>sort</replaceable></td>
					<td>object token</td>
				</tr>

				<tr>
					<td><code>XF</code></td>
					<td><replaceable>sort</replaceable></td>
					<td>procedure token</td>
				</tr>

				<tr>
					<td><code>XP</code></td>
					<td><replaceable>sort</replaceable></td>
					<td>token parameter</td>
				</tr>

				<tr>
					<td><code>XT</code></td>
					<td><replaceable>sort</replaceable></td>
					<td>template parameter</td>
				</tr>
			</tbody>
		</table>

		<para>The function identifier keys can optionally be followed by
			<code>C</code> indicating that the function has C linkage, and
			<code>I</code> indicating that the function is inline.	By default,
			functions declared in a C++ dump file have C++ linkage and functions
			declared in a C dump file have C linkage.	The optional
			<replaceable>identifier</replaceable> which forms part of the <replaceable>type-info</replaceable> of these
			functions is used to form linked lists of overloaded functions.</para>
	</refsection>

	<refsection>
		<title>Identifier scopes</title>

		<para>Each identifier belongs to a scope, called its parent scope, in which
			it is declared.	For example, the parent of a member of a class is
			the class itself.	This information is expressed in an identifier
			declaration using a <replaceable>scope-identifier</replaceable>.
			In addition to the obvious scopes such as classes and namespaces,
			there are other scopes such as blocks in function definitions.
			It is possible to introduce dummy identifiers to name such scopes.
			The parent of such a dummy identifier will be the enclosing scope identifier,
			so these dummy identifiers naturally represent the block structure.
			The parent of the top-level block in a function definition can be
			considered to be the function itself.</para>

		<para>Information on the start and end of such scopes is given by:</para>

		<programlisting language="bnf"><replaceable>scope-command</replaceable> :
	SS <replaceable>scope-key location identifier</replaceable>
	SE <replaceable>scope-key location identifier</replaceable></programlisting>

		<para>where:</para>

		<programlisting language="bnf"><replaceable>scope-key</replaceable> :
	N
	S
	B
	D
	H
	CT
	CF
	CC</programlisting>

		<para>gives the kind of scope involved: a namespace, a class, a block, some
			other declarative scope, a declaration block (see below), a true conditional
			scope, a false conditional scope or a target dependent conditional
			scope.</para>

		<para>A declaration block is a sequence of declarations enclosed in directives
			of the form:</para>

		<programlisting language="cpp">#pragma TenDRA declaration block <replaceable>identifier</replaceable> begin
....
#pragma TenDRA declaration block end</programlisting>

		<para>This allows the sequence of declarations to be associated with the given
			<replaceable>identifier</replaceable> in the symbol dump file.	This technique is used
			in the API description files to aid analysis tools in determining
			which declarations are part of the API.</para>
	</refsection>

	<refsection>
		<title>Other identifier information</title>

		<para>Other information associated with an identifier may be expressed using
			other dump commands.	For example:</para>

		<programlisting language="bnf"><replaceable>override-command</replaceable> :
	O <replaceable>identifier identifier</replaceable></programlisting>

		<para>is used to express the fact that the two <replaceable>identifier</replaceable>s are virtual
			member functions, the first of which overrides the second.</para>

		<para>The command:</para>

		<programlisting language="bnf"><replaceable>base-command</replaceable> :
	B <replaceable>identifier-key identifier base-graph</replaceable>

<replaceable>base-graph</replaceable> :
	<replaceable>base-class</replaceable>
	<replaceable>base-class</replaceable> ( <replaceable>base-list</replaceable> )

<replaceable>base-class</replaceable> :
	<replaceable>number</replaceable> = V<replaceable>&opt.bnf; access&opt.bnf; type-name</replaceable>
	<replaceable>number</replaceable> :

<replaceable>base-list</replaceable> :
	<replaceable>base-graph base-list&opt.bnf;</replaceable></programlisting>

		<para>associates a base class graph with a class identifier.	Any class
			which does not have an associated <replaceable>base-command</replaceable> can be assumed
			to have no base classes.	Each node in the graph is a <replaceable>type-name</replaceable>
			with an associated list of base classes.	A <code>V</code> is used
			to indicate a virtual base class.	Each node is numbered; duplicate
			numbers are used to indicate bases identified via the virtual base
			class structure.	Any base class can then be referred to as:</para>

		<programlisting language="bnf"><replaceable>base-number</replaceable> :
	<replaceable>number</replaceable> : <replaceable>type-name</replaceable></programlisting>

		<para>indicating the base class with the given number in the given class.</para>

		<para>The command:</para>

		<programlisting language="bnf"><replaceable>api-command</replaceable> :
	X <replaceable>identifier-key identifier string</replaceable></programlisting>

		<para>associates the external token name given by the <replaceable>string</replaceable> with
			the given tokenised identifier.</para>

		<para>The command:</para>

		<programlisting language="bnf"><replaceable>template-command</replaceable> :
	Z <replaceable>identifier-key identifier token-application specialise-info</replaceable></programlisting>

		<para>is used to introduce an identifier corresponding to an instance of
			a template, <replaceable>token-application</replaceable>.	This instance may correspond
			to a specialisation of the primary template; this information is represented
			by:</para>

		<programlisting language="bnf"><replaceable>specialise-info</replaceable> :
	<replaceable>identifier</replaceable>
	<replaceable>token-application</replaceable>
	*</programlisting>

		<para>where <code>*</code> indicates a non-specialised instance.</para>
	</refsection>

	<refsection>
		<title>Types</title>

		<para>The built-in types are represented in the symbol
			table dump as follows:</para>

		<table>
			<col align="left"/>
			<col align="center"/>
			<col align="center"/>
			<col align="left"/>
			<col align="center"/>

			<thead>
				<tr>
					<th>Type</th>
					<th>Encoding</th>
					<th role="gap"/>
					<th>Type</th>
					<th>Encoding</th>
				</tr>
			</thead>

			<tbody>
				<tr>
					<td><code>char</code></td>
					<td><code>c</code></td>
					<td role="gap"/>
					<td><code>float</code></td>
					<td><code>f</code></td>
				</tr>

				<tr>
					<td><code>signed char</code></td>
					<td><code>Sc</code></td>
					<td role="gap"/>
					<td><code>double</code></td>
					<td><code>d</code></td>
				</tr>

				<tr>
					<td><code>unsigned char</code></td>
					<td><code>Uc</code></td>
					<td role="gap"/>
					<td><code>long double</code></td>
					<td><code>r</code></td>
				</tr>

				<tr>
					<td><code>signed short</code></td>
					<td><code>s</code></td>
					<td role="gap"/>
					<td><code>void</code></td>
					<td><code>v</code></td>
				</tr>

				<tr>
					<td><code>unsigned short</code></td>
					<td><code>Us</code></td>
					<td role="gap"/>
					<td role="na">(bottom)</td>
					<td><code>u</code></td>
				</tr>

				<tr>
					<td><code>signed int</code></td>
					<td><code>i</code></td>
					<td role="gap"/>
					<td><code>bool</code></td>
					<td><code>b</code></td>
				</tr>

				<tr>
					<td><code>unsigned int</code></td>
					<td><code>Ui</code></td>
					<td role="gap"/>
					<td><code>ptrdiff_t</code></td>
					<td><code>y</code></td>
				</tr>

				<tr>
					<td><code>signed long</code></td>
					<td><code>l</code></td>
					<td role="gap"/>
					<td><code>size_t</code></td>
					<td><code>z</code></td>
				</tr>

				<tr>
					<td><code>unsigned long</code></td>
					<td><code>Ul</code></td>
					<td role="gap"/>
					<td><code>wchar_t</code></td>
					<td><code>w</code></td>
				</tr>

				<tr>
					<td><code>signed long long</code></td>
					<td><code>x</code></td>
					<td role="gap"/>
					<td role="na" align="center">&ndash;</td>
					<td role="na" align="center">&ndash;</td>
				</tr>

				<tr>
					<td><code>unsigned long long</code></td>
					<td><code>Ux</code></td>
					<td role="gap"/>
					<td role="na" align="center">&ndash;</td>
					<td role="na" align="center">&ndash;</td>
				</tr>
			</tbody>
		</table>

		<para>Named types (classes, enumeration types etc.) can be represented by
			the corresponding identifier or token application:</para>

		<programlisting language="bnf"><replaceable>type-name</replaceable> :
	<replaceable>identifier</replaceable>
	<replaceable>token-application</replaceable></programlisting>

		<para>Composite and qualified types are represented
			in terms of their subtypes as follows:</para>

		<table>
			<col align="left"/>
			<col align="left"/>

			<thead>
				<tr>
					<th>Type</th>
					<th>Encoding</th>
				</tr>
			</thead>

			<tbody>
				<tr>
					<td><code>const</code> type</td>
					<td><code>C</code> <replaceable>type</replaceable></td>
				</tr>

				<tr>
					<td><code>volatile</code> type</td>
					<td><code>V</code> <replaceable>type</replaceable></td>
				</tr>

				<tr>
					<td>pointer type</td>
					<td><code>P</code> <replaceable>type</replaceable></td>
				</tr>

				<tr>
					<td>reference type</td>
					<td><code>R</code> <replaceable>type</replaceable></td>
				</tr>

				<tr>
					<td>pointer to member type</td>
					<td><code>M</code> <replaceable>type-name</replaceable> <code>:</code> <replaceable>type</replaceable></td>
				</tr>

				<tr>
					<td>function type</td>
					<td><code>F</code> <replaceable>type parameter-types</replaceable></td>
				</tr>

				<tr>
					<td>array type</td>
					<td><code>A</code> <replaceable>nat&opt.bnf;</replaceable> <code>:</code> <replaceable>type</replaceable></td>
				</tr>

				<tr>
					<td>bitfield type</td>
					<td><code>B</code> <replaceable>nat</replaceable> <code>:</code> <replaceable>type</replaceable></td>
				</tr>

				<tr>
					<td>template type</td>
					<td><code>t</code> <replaceable>parameter-list&opt.bnf;</replaceable> <code>:</code> <replaceable>type</replaceable></td>
				</tr>

				<tr>
					<td>promotion type</td>
					<td><code>p</code> <replaceable>type</replaceable></td>
				</tr>

				<tr>
					<td>arithmetic type</td>
					<td><code>a</code> <replaceable>type</replaceable> <code>:</code> <replaceable>type</replaceable></td>
				</tr>

				<tr>
					<td>integer literal type</td>
					<td><code>n</code> <replaceable>lit-base&opt.bnf; lit-suffix&opt.bnf;</replaceable></td>
				</tr>

				<tr>
					<td>weak function prototype (C only)</td>
					<td><code>W</code> <replaceable>type parameter-types</replaceable></td>
				</tr>

				<tr>
					<td>weak parameter type (C only)</td>
					<td><code>q</code> <replaceable>type</replaceable></td>
				</tr>
			</tbody>
		</table>

		<para>Other types can be represented by their textual representation using
			the form <code>Q</code> <replaceable>string</replaceable>, or by <code>*</code>, indicating
			an unknown type.</para>

		<para>The parameter types for a function type are represented as follows:</para>

		<programlisting language="bnf"><replaceable>parameter-types</replaceable> :
	: <replaceable>exception-spec&opt.bnf; func-qualifier&opt.bnf;</replaceable> :
	. <replaceable>exception-spec&opt.bnf; func-qualifier&opt.bnf;</replaceable> :
	. <replaceable>exception-spec&opt.bnf; func-qualifier&opt.bnf;</replaceable> .
	, <replaceable>type parameter-types</replaceable></programlisting>

		<para>where the <code>::</code> form indicates that there are no further
			parameters, the <code>.:</code> form indicates that the parameters
			are terminated by an ellipsis, and the <code>..</code> form indicates
			that no information is available on the further parameters (this can
			only happen with non-prototyped functions in C).	The function qualifiers
			are given by:</para>

		<programlisting language="bnf"><replaceable>func-qualifier</replaceable> :
	C <replaceable>func-qualifier&opt.bnf;</replaceable>
	V <replaceable>func-qualifier&opt.bnf;</replaceable></programlisting>

<para>representing <code>const</code> and <code>volatile</code> member functions.
	The function exception specifier is given by:</para>

		<programlisting language="bnf"><replaceable>exception-spec</replaceable> :
	( <replaceable>exception-list&opt.bnf;</replaceable> )

<replaceable>exception-list</replaceable> :
	<replaceable>type</replaceable>
	<replaceable>type</replaceable> , <replaceable>exception-list</replaceable></programlisting>

		<para>with an absent exception specifier, as in C++, indicating that any
			exception may be thrown.</para>

		<para>Array and bitfield sizes are represented as follows:</para>

		<programlisting language="bnf"><replaceable>nat</replaceable> :
	+ <replaceable>number</replaceable>
	- <replaceable>number</replaceable>
	<replaceable>identifier</replaceable>
	<replaceable>token-application</replaceable>
	<replaceable>string</replaceable></programlisting>

		<para>where a <replaceable>string</replaceable> is used to hold a textual representation of
			complex values.</para>

		<para>Template types are represented by a list of template parameters, which
			will have previously been declared using the <code>XT</code> identifier
			key, followed by the underlying type expressed in terms of these parameters.
			The parameters are represented as follows:</para>

		<programlisting language="bnf"><replaceable>parameter-list</replaceable> :
	<replaceable>identifier</replaceable>
	<replaceable>identifier</replaceable> , <replaceable>parameter-list</replaceable></programlisting>

		<para>Integer literal types are represented by the value of the literal
			followed by a representation of the literal base and suffix.	These
			are given by:</para>

		<programlisting language="bnf"><replaceable>lit-base</replaceable> :
	O
	X</programlisting>

		<para>representing octal and hexadecimal literals respectively (decimal
			is the default), and:</para>

		<programlisting language="bnf"><replaceable>lit-suffix</replaceable> :
	U
	l
	Ul
	x
	Ux</programlisting>

		<para>representing the <code>U</code>, <code>L</code>, <code>UL</code>,
			<code>LL</code> and <code>ULL</code> suffixes respectively.</para>

		<para>Target dependent integral promotion types are represented using
			<code>p</code>, so for example the promotion of <code>unsigned short</code>
			is represented as <code>pUs</code>.	Information on the other cases,
			where the promotion type is known, can be given in a command of the
			form:</para>

		<programlisting language="bnf"><replaceable>promotion-command</replaceable> :
	P <replaceable>type</replaceable> : <replaceable>type</replaceable></programlisting>

		<para>Thus the fact that the promotion of <code>short</code> is <code>int</code>
			would be expressed by the command <code>Ps:i</code>.</para>
	</refsection>

	<refsection>
		<title>Sorts</title>

		<para>A <replaceable>sort</replaceable> in the symbol table dump corresponds to the sort of
			a token declared in the &pragmatoken.doc; <code>#pragma token</code>
			syntax.	Expression tokens are represented as follows:</para>

		<programlisting language="bnf"><replaceable>expression-sort</replaceable> :
	ZEL <replaceable>type</replaceable>
	ZER <replaceable>type</replaceable>
	ZEC <replaceable>type</replaceable>
	ZN</programlisting>

		<para>corresponding to <code>lvalue</code>, <code>rvalue</code> and
			<code>const</code> <code>EXP</code> tokens of the given type, and
			<code>NAT</code> or <code>INTEGER</code> tokens, respectively. Statement
			tokens are represent by:</para>

		<programlisting language="bnf"><replaceable>statement-sort</replaceable> :
	ZS</programlisting>

		<para>Type tokens are represented as follows:</para>

		<programlisting language="bnf"><replaceable>type-sort</replaceable> :
	ZTO
	ZTI
	ZTF
	ZTA
	ZTP
	ZTS
	ZTU</programlisting>

		<para>corresponding to <code>TYPE</code>, <code>VARIETY</code>, <code>FLOAT</code>,
			<code>ARITHMETIC</code>, <code>SCALAR</code>, <code>STRUCT</code>
			or <code>CLASS</code>, and <code>UNION</code> token respectively.	There
			are corresponding <code>TAG</code> forms:</para>

		<programlisting language="bnf"><replaceable>tag-type-sort</replaceable> :
	ZTTS
	ZTTU</programlisting>

		<para>Member tokens are represented using:</para>

		<programlisting language="bnf"><replaceable>member-sort</replaceable> :
	ZM <replaceable>type</replaceable> : <replaceable>type-name</replaceable></programlisting>

		<para>where the first type gives the member type and the second gives the
			parent structure or union type.</para>

		<para>Procedure tokens can be represented using:</para>

		<programlisting language="bnf"><replaceable>proc-sort</replaceable> :
	ZPG <replaceable>parameter-list&opt.bnf;</replaceable> ; <replaceable>parameter-list&opt.bnf;</replaceable> : <replaceable>sort</replaceable>
	ZPS <replaceable>parameter-list&opt.bnf;</replaceable> : <replaceable>sort</replaceable></programlisting>

		<para>The first form corresponds to the more general form of <code>PROC</code>
			token, that expressed using <code>{ .... | .... }</code>, which has
			separate lists of bound and program parameters.	These token parameters
			will have previously been declared using the <code>XP</code> identifier
			key.	The second form corresponds to the case where the bound and
			program parameter lists are equal, that expressed as a <code>PROC</code>
			token using <code>( .... )</code>.	A more specialised version of
			this second form is a <code>FUNC</code> token, which is represented
			as:</para>

		<programlisting language="bnf"><replaceable>func-sort</replaceable> :
	ZF <replaceable>type</replaceable></programlisting>

		<para>As noted above, template parameters are represented by a <replaceable>sort</replaceable>.
			Template type parameters are represented by <code>ZTO</code>, while
			template expression parameters are represent by <code>ZEC</code>
			(recall that such parameters are always constant expressions).	The
			remaining case, template template parameters, can be represented as:</para>

		<programlisting language="bnf"><replaceable>template-sort</replaceable> :
	ZTt <replaceable>parameter-list&opt.bnf;</replaceable> :</programlisting>

		<para>Finally, the number of parameters in a macro definition is represented
			by a <replaceable>sort</replaceable> of the form:</para>

		<programlisting language="bnf"><replaceable>macro-sort</replaceable> :
	ZUO
	ZUF <replaceable>number</replaceable></programlisting>

		<para>corresponding to a object-like macro and a function-like macro with
			the given number of parameters, respectively.</para>
	</refsection>

	<refsection>
		<title>Token applications</title>

		<para>Given an identifier representing a <code>PROC</code> token or a template,
			an application of that token or an instance of that template can be
			represented using:</para>

		<programlisting language="bnf"><replaceable>token-application</replaceable> :
	T <replaceable>identifier</replaceable> , <replaceable>token-argument-list</replaceable> :</programlisting>

		<para>where the token or template arguments are given by:</para>

		<programlisting language="bnf"><replaceable>token-argument-list</replaceable> :
	<replaceable>token-argument</replaceable>
	<replaceable>token-argument</replaceable> , <replaceable>token-argument-list</replaceable></programlisting>

		<para>Note that the case where there are no arguments is generally just
			represented by <replaceable>identifier</replaceable>; this case is specified separately
			in the rest of the grammar.</para>

		<para>A <replaceable>token-argument</replaceable> can represent a value of any of the sorts
			listed above: expressions, integer constants, statements, types, members,
			functions and templates.	These are given respectively by:</para>

		<programlisting language="bnf"><replaceable>token-argument</replaceable> :
	E <replaceable>expression</replaceable>
	N <replaceable>nat</replaceable>
	S <replaceable>statement</replaceable>
	T <replaceable>type</replaceable>
	M <replaceable>member</replaceable>
	F <replaceable>identifier</replaceable>
	C <replaceable>identifier</replaceable></programlisting>

		<para>where:</para>

		<programlisting language="bnf"><replaceable>expression</replaceable> :
	<replaceable>nat</replaceable>

<replaceable>statement</replaceable> :
	<replaceable>expression</replaceable>

<replaceable>member</replaceable> :
	<replaceable>identifier</replaceable>
	<replaceable>string</replaceable></programlisting>
	</refsection>

	<refsection>
		<title>Errors</title>

		<para>By default the error messages generated by the checker are
			written in a simple ascii form to stderr. If instead, the errors
			are written to the dump file using the <code>-sym:e</code> option
			mentioned above, an alternative lint-like error output may be
			generated by processing the dump files. The lint-like errors are
			enabled by passing the <code>-Ycompact</code> flag to tchk.</para>

		<para>Each error in the &tcpplus; &make_err; error catalogue is
			represented by a number.	These numbers happen to correspond to the
			position of the error within the catalogue, but in general this need
			not be the case.	The first use of each error introduces the error
			number by associating it with a <replaceable>string</replaceable> giving the error name.
			This has the form <code>cpp.</code><replaceable>error</replaceable> where <replaceable>error</replaceable>
			gives an error name from the C++ (<code>cpp</code>) error catalogue.
			Thus:</para>

		<programlisting language="bnf"><replaceable>error-name</replaceable> :
	<replaceable>number</replaceable> = <replaceable>string</replaceable>
	<replaceable>number</replaceable></programlisting>

		<para>Each error message written to the symbol table dump has the form:</para>

		<programlisting language="bnf"><replaceable>error-command</replaceable> :
	ES <replaceable>location error-info</replaceable>
	EW <replaceable>location error-info</replaceable>
	EI <replaceable>location error-info</replaceable>
	EF <replaceable>location error-info</replaceable>
	EC <replaceable>error-info</replaceable>
	EA <replaceable>error-argument</replaceable></programlisting>

		<para>denoting constraint errors, warnings, internal errors, fatal errors,
			continuation errors and error arguments respectively.	Note that an
			error message may consist of several components; the initial error
			plus a number of continuation errors.	Each error message may also
			have a number of error argument associated with it.	This error information
			is given by:</para>

		<programlisting language="bnf"><replaceable>error-info</replaceable> :
	<replaceable>error-name number number</replaceable></programlisting>

		<para>where the first <replaceable>number</replaceable> gives the number of error arguments
			which should be read, and the second is nonzero to indicate that a
			continuation error should be read.</para>

		<para>Each error argument has one of the forms:</para>

		<programlisting language="bnf"><replaceable>error-argument</replaceable> :
	B <replaceable>base-number</replaceable>
	C <replaceable>scope-identifier</replaceable>
	E <replaceable>expression</replaceable>
	H <replaceable>identifier-name</replaceable>
	I <replaceable>identifier</replaceable>
	L <replaceable>location</replaceable>
	N <replaceable>nat</replaceable>
	S <replaceable>string</replaceable>
	T <replaceable>type</replaceable>
	V <replaceable>number</replaceable>
	V - <replaceable>number</replaceable></programlisting>

		<para>corresponding to the various syntactic categories described above.
			Note that a <replaceable>location</replaceable> error argument, while expressed relative
			to the current file location, does not change this
			location.</para>
	</refsection>

	<refsection>
		<title>File inclusions</title>

		<para>It is possible to include information on header files within the symbol
			table dump.	Firstly a number is associated with each directory on
			the <code>#include</code> search path:</para>

		<programlisting language="bnf"><replaceable>path-command</replaceable> :
	FD <replaceable>number</replaceable> = <replaceable>string string&opt.bnf;</replaceable></programlisting>

		<para>The first <replaceable>string</replaceable> gives the directory pathname; the second,
			if present, gives the associated directory name as specified in the
			<code>-N</code> command-line option.</para>

		<para>Now the start and end of each file are marked using:</para>

		<programlisting language="bnf"><replaceable>file-command</replaceable> :
	FS <replaceable>location directory</replaceable>
	FE <replaceable>location</replaceable></programlisting>

		<para>where <replaceable>directory</replaceable> gives the number of the directory in the search
			path where the file was found, or <code>*</code> if the file was found
			by other means.	It is worth noting that if, for example, a function
			definition is the last item in a file, the <code>FE</code> command
			will appear in the symbol table dump before the <code>QFE</code> command
			for the end of the function definition.	This is because lexical analysis,
			where the end of file is detected, takes place before parsing, where
			the end of function is detected.</para>

		<para>A <code>#include</code> directive, whether explicit or implicit, can
			be represented using:</para>

		<programlisting language="bnf"><replaceable>include-command</replaceable> :
	FIA <replaceable>location string</replaceable>
	FIQ <replaceable>location string</replaceable>
	FIN <replaceable>location string</replaceable>
	FIS <replaceable>location string</replaceable>
	FIE <replaceable>location string</replaceable>
	FIR <replaceable>location</replaceable></programlisting>

		<para>the first three corresponding to header names of the forms
			<code>&lt;....&gt;</code>, <code>&quot;....&quot;</code> and <code>[....]</code>
			respectively, the next two corresponding to start-up and end-up files, and the final form
			being used to resume the original file after the <code>#include</code>
			directive has been processed.</para>
	</refsection>

	<refsection>
		<title>String literals</title>

		<para>It is possible to dump information on string literals to the symbol
			table dump file using the commands:</para>

		<programlisting language="bnf"><replaceable>string-command</replaceable> :
	A <replaceable>location string</replaceable>
	AC <replaceable>location string</replaceable>
	AL <replaceable>location string</replaceable>
	ACL <replaceable>location string</replaceable></programlisting>

		<para>representing string literals, character literals, wide string literals
			and wide character literals respectively.
			The given <replaceable>string</replaceable> gives the string text.</para>
	</refsection>

	<!-- TODO: hereafter just the grammar -->

	<refsection>
		<title>Basics</title>

		<programlisting language="bnf">
digit : one of 0 1 2 3 4 5 6 7 8 9
digit-sequence :
<replaceable>        digit</replaceable><replaceable>        digit-sequence</replaceable>
number :
<replaceable>        digit-sequence</replaceable>
string :
<replaceable>        &lt;characters&gt;</replaceable><replaceable>        &amp;digit-sequence&lt;characters&gt;</replaceable>
location :
<replaceable>        number number number string string</replaceable><replaceable>        number number number string *</replaceable><replaceable>        number number number *</replaceable><replaceable>        number number *</replaceable><replaceable>        number *</replaceable><replaceable>        *</replaceable></programlisting>
	</refsection>

	<refsection>
		<title>Dump commands</title>

		<programlisting language="bnf">
dump-file :
                <replaceable>command-list</replaceable>&opt.bnf;
command-list :
<replaceable>        command</replaceable><replaceable>        command command-list</replaceable>
command :
<replaceable>        B base-definition             </replaceable><replaceable>base class graph</replaceable><replaceable>        error-command</replaceable><replaceable>        file-command</replaceable><replaceable>        I identifier-command        </replaceable><replaceable>implicit declarations etc.</replaceable><replaceable>        identifier-command</replaceable><replaceable>        scope-command</replaceable><replaceable>        O identifier identifier </replaceable><replaceable>overriding virtual function</replaceable><replaceable>        P type : type     </replaceable><replaceable>promotion type specifier</replaceable><replaceable>        string-command</replaceable><replaceable>        V number number string    </replaceable><replaceable>version number</replaceable><replaceable>        X api-info            </replaceable><replaceable>external token name</replaceable><replaceable>        Z template-info</replaceable><replaceable>template instance</replaceable></programlisting>
	</refsection>

	<refsection>
		<title>E.3 API information</title>

		<programlisting language="bnf">
api-info :
<replaceable>        identifier key identifier string</replaceable></programlisting>
	</refsection>

	<refsection>
		<title>Base definitions</title>

		<programlisting language="bnf">
virtual :
<replaceable>        V</replaceable>
base-class :
<replaceable>        number = virtual</replaceable>&opt.bnf;<replaceable> access</replaceable>&opt.bnf;<replaceable> type-name
</replaceable><replaceable>        number :</replaceable>
base-list :
<replaceable>        base-graph</replaceable><replaceable>        base-graph base-list</replaceable>
base-graph :
<replaceable>        base-class</replaceable><replaceable>        base-class ( base-list )</replaceable>
base-definition :
<replaceable>        identifier-key number base-graph</replaceable>
base-number :
<replaceable>        number : type-name</replaceable></programlisting>
	</refsection>

	<refsection>
		<title>Error commands</title>

		<programlisting language="bnf">
error-command :
<replaceable>        EA error-argument             </replaceable><replaceable>error argument</replaceable><replaceable>        EC error-info     </replaceable><replaceable>continuation error</replaceable><replaceable>        EF location error-info    </replaceable><replaceable>fatal error</replaceable><replaceable>        EI location error-info    </replaceable><replaceable>internal error</replaceable><replaceable>        ES location error-info    </replaceable><replaceable>serious error</replaceable><replaceable>        EW location error-info    </replaceable><replaceable>warning</replaceable>
error-info :
<replaceable>        error-name number number</replaceable>
error-name :
<replaceable>        number = string</replaceable><replaceable>        number</replaceable>
error-argument :
<replaceable>        B base-number</replaceable><replaceable>        C scope-identifier</replaceable><replaceable>        E exp</replaceable><replaceable>        H hashid</replaceable><replaceable>        I identifier</replaceable><replaceable>        L location</replaceable><replaceable>        N nat</replaceable><replaceable>        S string</replaceable><replaceable>        T type</replaceable><replaceable>        V number</replaceable><replaceable>        V -number</replaceable></programlisting>
		</refsection>

		<refsection>
			<title>File commands</title>

			<programlisting language="bnf">
file-command :
<replaceable>        FD number = string stringopt        </replaceable><replaceable>inclusion directory</replaceable><replaceable>        FE location         </replaceable><replaceable>file end</replaceable><replaceable>        FIA location string         </replaceable><replaceable>file include with &lt;&gt;</replaceable><replaceable>        FIE location string         </replaceable><replaceable>include end-up</replaceable><replaceable>        FIN location string         </replaceable><replaceable>file include with []</replaceable><replaceable>        FIQ location string</replaceable><replaceable>file include with ""</replaceable>
                FIR location        <replaceable>resume file</replaceable>
                FIS location string         <replaceable>include startup</replaceable>
                FS location directory     <replaceable>file start</replaceable>
directory :
                number
                *</programlisting>
	</refsection>

	<refsection>
		<title>Identifier commands</title>

		<programlisting language="bnf">
identifier-command :
                C identifier-info             <replaceable>call identifier</replaceable>
                D identifier-info type-info         <replaceable>define identifier</replaceable>
                L identifier-info             <replaceable>use identifier</replaceable>
                M identifier-info type-info         <replaceable>declare identifier</replaceable>
                Q identifier-info             <replaceable>end identifier definition</replaceable>
                T identifier-info type-info         <replaceable>tentatively define identifier</replaceable>
                U identifier-info             <replaceable>undefine identifier</replaceable>
                W identifier-info type-info         <replaceable>weak prototype</replaceable>
identifier-info :
                identifier-key location identifier
identifier-key :
                CD            <replaceable>static data member</replaceable>
                CF function-key <replaceable>member function</replaceable>
                CM            <replaceable>data member</replaceable>
                CS function-key <replaceable>static member function</replaceable>
                CV function-key <replaceable>virtual member function</replaceable>
                E             <replaceable>enumerator</replaceable>
                FB function-key <replaceable>builtin function</replaceable>
                FE function key <replaceable>external function</replaceable>
                FS function-key <replaceable>static function</replaceable>
                K             <replaceable>keyword</replaceable>
                L             <replaceable>label</replaceable>
                MB            <replaceable>built-in macro</replaceable>
                MF            <replaceable>function-like macro</replaceable>
                MO            <replaceable>object-like macro</replaceable>
                NA            <replaceable>namespace alias</replaceable>
                NN            <replaceable>namespace name</replaceable>
                TA            <replaceable>type alias</replaceable>
                TC            <replaceable>class tag</replaceable>
                TE            <replaceable>enum tag</replaceable>
                TS            <replaceable>struct tag</replaceable>
                TU            <replaceable>union tag</replaceable>
                VA            <replaceable>automatic variable</replaceable>
                VE            <replaceable>extern variable</replaceable>
                VP            <replaceable>function parameter</replaceable>
                VS            <replaceable>static variable</replaceable>
                XF            <replaceable>procedure token</replaceable>
                XO            <replaceable>object token</replaceable>
                XP            <replaceable>token parameter</replaceable>
                XT            <replaceable>template parameter</replaceable>
function-key :
                empty
                C function-key    <replaceable>C linkage</replaceable>
                I function-key    <replaceable>inline</replaceable>
identifier :
                number = hashid accessopt scope-identifier
                number
hashid :
                string    <replaceable>simple name</replaceable>
                C type    <replaceable>constructor</replaceable>
                D type    <replaceable>destructor</replaceable>
                O string                <replaceable>operator</replaceable>
                T type    <replaceable>conversion</replaceable>
access :
                B             <replaceable>protected</replaceable>
                N             <replaceable>public</replaceable>
                P             <replaceable>private</replaceable></programlisting>
	</refsection>

	<refsection>
		<title>Scope commands</title>

		<programlisting language="bnf">
scope-command :
                SE scope-key location identifier                <replaceable>end scope</replaceable>
                SS scope-key location identifier                <replaceable>start scope</replaceable>
scope-key :
                B             <replaceable>block scope</replaceable>
                CC            <replaceable>conditional scope</replaceable>
                N             <replaceable>namespace scope</replaceable>
                CF            <replaceable>false conditional scope</replaceable>
                CT            <replaceable>true conditional scope</replaceable>
                D             <replaceable>other declarative scope</replaceable>
                H             <replaceable>header scope</replaceable>
                S             <replaceable>class scope</replaceable>
scope-identifier :
                identifier
                *</programlisting>
	</refsection>

	<refsection>
		<title>String command</title>

		<programlisting language="bnf">
string-command :
                A location string             <replaceable>string literal</replaceable>
                AC location string            <replaceable>character literal</replaceable>
                ACL location string         <replaceable>wide character literal</replaceable>
                AL location string            <replaceable>wide string literal</replaceable></programlisting>
	</refsection>

	<refsection>
		<title>Templates</title>

		<programlisting language="bnf">
specialisation-info :
                token-application
                *
template-info :
                identifier-key identifier token-application specialisation-info</programlisting>
	</refsection>

	<refsection>
		<title>Token sort information</title>

		<programlisting language="bnf">
sort :
                ZEC type-info     <replaceable>constant expression</replaceable>
                ZEL type-info     <replaceable>lvalue expression</replaceable>
                ZER type-info     <replaceable>rvalue expression</replaceable>
                ZF type-info        <replaceable>function</replaceable>
                ZM type-info : type-name                <replaceable>member</replaceable>
                ZN            <replaceable>integral constant</replaceable>
                ZPS parameter-list-opt : sort     <replaceable>procedure type ()</replaceable>
                ZPG parameter-list-opt ; parameter-list-opt:sort 
<replaceable>                        procedure type {}</replaceable>
                ZS            <replaceable>statement</replaceable>
                ZTA         <replaceable>arithmetic type</replaceable>
                ZTF         <replaceable>floating type</replaceable>
                ZTI         <replaceable>integral type</replaceable>
                ZTO         <replaceable>opaque type</replaceable>
                ZTP         <replaceable>scalar type</replaceable>
                ZTS         <replaceable>structure type</replaceable>
                ZTt parameter-list-opt :                <replaceable>template type</replaceable>
                ZTTS        <replaceable>structure tag </replaceable>
                ZTTU        <replaceable>union tag</replaceable>
                ZTU         <replaceable>union type</replaceable>
                ZUF number            <replaceable>function macro</replaceable>
                ZUO         <replaceable>object macro</replaceable>
exp :
                nat
member :
                identifier
                string
statement :
                exp
token-argument :
                C identifier        <replaceable>template argument</replaceable>
                E exp     <replaceable>expression argument</replaceable>
                F identifier        <replaceable>function argument</replaceable>
                M member                <replaceable>member argument</replaceable>
                N nat     <replaceable>integer constant argument</replaceable>
                S statement         <replaceable>statement argument</replaceable>
                T type-info         <replaceable>type argument</replaceable>
token-argument-list :
                token-argument
                token-argument , token-argument-list
token-application :
                T identifier , token-argument-list :</programlisting>
		</refsection>

		<refsection>
			<title>E.12 Type information</title>

			<programlisting language="bnf">
type-info :
                scope-identifier                <replaceable>for namespace alias</replaceable>
                sort        <replaceable>for token, macro etc.</replaceable>
                type        <replaceable>for variable etc.</replaceable>
                type identifier-opt         <replaceable>for overloaded function</replaceable>
type :
                qualifieropt unqualified-type
qualifier :
                C             <replaceable>const</replaceable>
                V             <replaceable>volatile</replaceable>
                CV            <replaceable>const volatile</replaceable>
unqualified-type :
                type-name
                token-application
                c             <replaceable>char</replaceable>
                s             <replaceable>short</replaceable>
                i             <replaceable>int</replaceable>
                l             <replaceable>long</replaceable>
                x             <replaceable>long long</replaceable>
                f             <replaceable>float</replaceable>
                d             <replaceable>double</replaceable>
                r             <replaceable>long double</replaceable>
                v             <replaceable>void</replaceable>
                b             <replaceable>bool</replaceable>
                w             <replaceable>wchar_t</replaceable>
                Sc            <replaceable>signed char</replaceable>
                Uc            <replaceable>unsigned char</replaceable>
                Us            <replaceable>unsigned short</replaceable>
                Ui            <replaceable>unsigned int</replaceable>
                Ul            <replaceable>unsigned long</replaceable>
                Ux            <replaceable>unsigned long long</replaceable>
                u             <replaceable>bottom</replaceable>
                y             <replaceable>ptrdiff_t</replaceable>
                z             <replaceable>size_t</replaceable>
                a type : type     <replaceable>arithmetic type</replaceable>
                n nat     <replaceable>literal type</replaceable>
                p type    <replaceable>promoted type</replaceable>
                t parameter-listopt : type            <replaceable>template type</replaceable>
                A natopt : type <replaceable>array type</replaceable>
                B nat : type        <replaceable>bitfield type</replaceable>
                F type parameter-types    <replaceable>function type</replaceable>
                M type-name : type            <replaceable>pointer to member type</replaceable>
                P type    <replaceable>pointer type</replaceable>
                R type    <replaceable>reference type</replaceable>
                W type parameter-types    <replaceable>weak function type</replaceable>
                Q string                <replaceable>quoted type</replaceable>
                *             <replaceable>unknown type</replaceable>
parameter-types :
                : exceptionopt qualifieropt :     <replaceable>no parameters</replaceable>
                . exceptionopt qualifieropt :     <replaceable>ellipsis</replaceable>
                . exceptionopt qualifieropt .     <replaceable>unknown</replaceable>
                , type parameter-types
exception :
                ( exception-listopt )
exception-list :
                type
                type, exception-list
parameter-list :
                identifier
                identifier , parameter-list
type-name :
                identifier
nat :
                +number
                -number
                string
                identifier
                token-application</programlisting>
	</refsection>

	<!-- TODO this is from tcpplus; it is to be merged with the above (or superceed it; whichever) -->
	<refsection>
    <title>C++ Symbol table dump syntax</title>
  <para>The following gives a summary of the syntax for the
  symbol table dump file (version 1.1):</para>

  <programlisting language="bnf">
<replaceable>dump-file</replaceable> :
	<replaceable>command-list&opt.bnf;</replaceable>

<replaceable>command-list</replaceable> :
	<replaceable>command command-list&opt.bnf;</replaceable>

<replaceable>command</replaceable> :
	<replaceable>version-command</replaceable>
	<replaceable>identifier-command</replaceable>
	<replaceable>scope-command</replaceable>
	<replaceable>override-command</replaceable>
	<replaceable>base-command</replaceable>
	<replaceable>api-command</replaceable>
	<replaceable>template-command</replaceable>
	<replaceable>promotion-command</replaceable>
	<replaceable>error-command</replaceable>
	<replaceable>path-command</replaceable>
	<replaceable>file-command</replaceable>
	<replaceable>include-command</replaceable>
	<replaceable>string-command</replaceable>

<replaceable>version-command</replaceable> :
	V <replaceable>number number string</replaceable>


<replaceable>location</replaceable> :
	<replaceable>number number number string string</replaceable>
	<replaceable>number number number string</replaceable> *
	<replaceable>number number number</replaceable> *
	<replaceable>number number</replaceable> *
	<replaceable>number</replaceable> *
	*


<replaceable>identifier</replaceable> :
	<replaceable>number</replaceable> = <replaceable>identifier-name access&opt.bnf; scope-identifier</replaceable>
	<replaceable>number</replaceable>

<replaceable>identifier-name</replaceable> :
	<replaceable>string</replaceable>
	C <replaceable>type</replaceable>
	D <replaceable>type</replaceable>
	O <replaceable>string</replaceable>
	T <replaceable>type</replaceable>

<replaceable>access</replaceable> :
	N
	B
	P

<replaceable>scope-identifier</replaceable> :
	<replaceable>identifier</replaceable>
	*

<replaceable>identifier-command</replaceable> :
	D <replaceable>identifier-info type-info</replaceable>
	M <replaceable>identifier-info type-info</replaceable>
	T <replaceable>identifier-info type-info</replaceable>
	Q <replaceable>identifier-info</replaceable>
	U <replaceable>identifier-info</replaceable>
	L <replaceable>identifier-info</replaceable>
	C <replaceable>identifier-info</replaceable>
	W <replaceable>identifier-info type-info</replaceable>
	I <replaceable>identifier-command</replaceable>

<replaceable>identifier-info</replaceable> :
	<replaceable>identifier-key location identifier</replaceable>

<replaceable>identifier-key</replaceable> :
	K
	MO
	MF
	MB
	TC
	TS
	TU
	TE
	TA
	NN
	NA
	VA
	VP
	VE
	VS
	FE <replaceable>function-key&opt.bnf;</replaceable>
	FS <replaceable>function-key&opt.bnf;</replaceable>
	FB <replaceable>function-key&opt.bnf;</replaceable>
	CF <replaceable>function-key&opt.bnf;</replaceable>
	CS <replaceable>function-key&opt.bnf;</replaceable>
	CV <replaceable>function-key&opt.bnf;</replaceable>
	CM
	CD
	E
	L
	XO
	XF
	XP
	XT

<replaceable>function-key</replaceable> :
	C <replaceable>function-key&opt.bnf;</replaceable>
	I <replaceable>function-key&opt.bnf;</replaceable>

<replaceable>type-info</replaceable> :
	<replaceable>type identifier&opt.bnf;</replaceable>
	<replaceable>sort</replaceable>
	<replaceable>scope-identifier</replaceable>
	*


<replaceable>scope-command</replaceable> :
	SS <replaceable>scope-key location identifier</replaceable>
	SE <replaceable>scope-key location identifier</replaceable>

<replaceable>scope-key</replaceable> :
	N
	S
	B
	D
	H
	CT
	CF
	CC


<replaceable>override-command</replaceable> :
	O <replaceable>identifier identifier</replaceable>


<replaceable>base-command</replaceable> :
	B <replaceable>identifier-key identifier base-graph</replaceable>

<replaceable>base-graph</replaceable> :
	<replaceable>base-class</replaceable>
	<replaceable>base-class</replaceable> ( <replaceable>base-list</replaceable> )

<replaceable>base-class</replaceable> :
	<replaceable>number</replaceable> = V<replaceable>&opt.bnf; access&opt.bnf; type-name</replaceable>
	<replaceable>number</replaceable> :

<replaceable>base-list</replaceable> :
	<replaceable>base-graph base-list&opt.bnf;</replaceable>

<replaceable>base-number</replaceable> :
	<replaceable>number</replaceable> : <replaceable>type-name</replaceable>


<replaceable>api-command</replaceable> :
	X <replaceable>identifier-key identifier string</replaceable>


<replaceable>template-command</replaceable> :
	Z <replaceable>identifier-key identifier token-application specialise-info</replaceable>

<replaceable>specialise-info</replaceable> :
	<replaceable>identifier</replaceable>
	<replaceable>token-application</replaceable>
	*


<replaceable>type</replaceable> :
	<replaceable>type-name</replaceable>
	c
	s
	i
	l
	x
	b
	w
	y
	z
	f
	d
	r
	v
	u
	Sc
	Uc
	Us
	Ui
	Ul
	Ux
	C <replaceable>type</replaceable>
	V <replaceable>type</replaceable>
	P <replaceable>type</replaceable>
	R <replaceable>type</replaceable>
	M <replaceable>type-name</replaceable> : <replaceable>type</replaceable>
	F <replaceable>type parameter-types</replaceable>
	A <replaceable>nat&opt.bnf;</replaceable> : <replaceable>type</replaceable>
	B <replaceable>nat</replaceable> : <replaceable>type</replaceable>
	t <replaceable>parameter-list&opt.bnf;</replaceable> : <replaceable>type</replaceable>
	p <replaceable>type</replaceable>
	a <replaceable>type</replaceable> : <replaceable>type</replaceable>
	n <replaceable>lit-base&opt.bnf; lit-suffix&opt.bnf;</replaceable>
	W <replaceable>type parameter-types</replaceable>
	q <replaceable>type</replaceable>
	Q <replaceable>string</replaceable>
	*

<replaceable>type-name</replaceable> :
	<replaceable>identifier</replaceable>
	<replaceable>token-application</replaceable>

<replaceable>parameter-types</replaceable> :
	: <replaceable>exception-spec&opt.bnf; func-qualifier&opt.bnf;</replaceable> :
	. <replaceable>exception-spec&opt.bnf; func-qualifier&opt.bnf;</replaceable> :
	. <replaceable>exception-spec&opt.bnf; func-qualifier&opt.bnf;</replaceable> .
	, <replaceable>type parameter-types</replaceable>

<replaceable>func-qualifier</replaceable> :
	C <replaceable>func-qualifier&opt.bnf;</replaceable>
	V <replaceable>func-qualifier&opt.bnf;</replaceable>

<replaceable>exception-spec</replaceable> :
	( <replaceable>exception-list&opt.bnf;</replaceable> )

<replaceable>exception-list</replaceable> :
	<replaceable>type</replaceable>
	<replaceable>type</replaceable> , <replaceable>exception-list</replaceable>

<replaceable>nat</replaceable> :
	+ <replaceable>number</replaceable>
	- <replaceable>number</replaceable>
	<replaceable>identifier</replaceable>
	<replaceable>token-application</replaceable>
	<replaceable>string</replaceable>

<replaceable>parameter-list</replaceable> :
	<replaceable>identifier</replaceable>
	<replaceable>identifier</replaceable> , <replaceable>parameter-list</replaceable>

<replaceable>lit-base</replaceable> :
	O
	X

<replaceable>lit-suffix</replaceable> :
	U
	l
	Ul
	x
	Ux


<replaceable>promotion-command</replaceable> :
	P <replaceable>type</replaceable> : <replaceable>type</replaceable>


<replaceable>sort</replaceable> :
	<replaceable>expression-sort</replaceable>
	<replaceable>statement-sort</replaceable>
	<replaceable>type-sort</replaceable>
	<replaceable>tag-type-sort</replaceable>
	<replaceable>member-sort</replaceable>
	<replaceable>proc-sort</replaceable>
	<replaceable>func-sort</replaceable>
	<replaceable>template-sort</replaceable>
	<replaceable>macro-sort</replaceable>

<replaceable>expression-sort</replaceable> :
	ZEL <replaceable>type</replaceable>
	ZER <replaceable>type</replaceable>
	ZEC <replaceable>type</replaceable>
	ZN

<replaceable>statement-sort</replaceable> :
	ZS

<replaceable>type-sort</replaceable> :
	ZTO
	ZTI
	ZTF
	ZTA
	ZTP
	ZTS
	ZTU

<replaceable>tag-type-sort</replaceable> :
	ZTTS
	ZTTU

<replaceable>member-sort</replaceable> :
	ZM <replaceable>type</replaceable> : <replaceable>type-name</replaceable>

<replaceable>proc-sort</replaceable> :
	ZPG <replaceable>parameter-list&opt.bnf;</replaceable> ; <replaceable>parameter-list&opt.bnf;</replaceable> : <replaceable>sort</replaceable>
	ZPS <replaceable>parameter-list&opt.bnf;</replaceable> : <replaceable>sort</replaceable>

<replaceable>func-sort</replaceable> :
	ZF <replaceable>type</replaceable>

<replaceable>template-sort</replaceable> :
	ZTt <replaceable>parameter-list&opt.bnf;</replaceable> :

<replaceable>macro-sort</replaceable> :
	ZUO
	ZUF <replaceable>number</replaceable>

<replaceable>token-application</replaceable> :
	T <replaceable>identifier</replaceable> , <replaceable>token-argument-list</replaceable> :

<replaceable>token-argument-list</replaceable> :
	<replaceable>token-argument</replaceable>
	<replaceable>token-argument</replaceable> , <replaceable>token-argument-list</replaceable>

<replaceable>token-argument</replaceable> :
	E <replaceable>expression</replaceable>
	N <replaceable>nat</replaceable>
	S <replaceable>statement</replaceable>
	T <replaceable>type</replaceable>
	M <replaceable>member</replaceable>
	F <replaceable>identifier</replaceable>
	C <replaceable>identifier</replaceable>

<replaceable>expression</replaceable> :
	<replaceable>nat</replaceable>

<replaceable>statement</replaceable> :
	<replaceable>expression</replaceable>

<replaceable>member</replaceable> :
	<replaceable>identifier</replaceable>
	<replaceable>string</replaceable>


<replaceable>error-name</replaceable> :
	<replaceable>number</replaceable> = <replaceable>string</replaceable>
	<replaceable>number</replaceable>

<replaceable>error-command</replaceable> :
	ES <replaceable>location error-info</replaceable>
	EW <replaceable>location error-info</replaceable>
	EI <replaceable>location error-info</replaceable>
	EF <replaceable>location error-info</replaceable>
	EC <replaceable>error-info</replaceable>
	EA <replaceable>error-argument</replaceable>

<replaceable>error-info</replaceable> :
	<replaceable>error-name number number</replaceable>

<replaceable>error-argument</replaceable> :
	B <replaceable>base-number</replaceable>
	C <replaceable>scope-identifier</replaceable>
	E <replaceable>expression</replaceable>
	H <replaceable>identifier-name</replaceable>
	I <replaceable>identifier</replaceable>
	L <replaceable>location</replaceable>
	N <replaceable>nat</replaceable>
	S <replaceable>string</replaceable>
	T <replaceable>type</replaceable>
	V <replaceable>number</replaceable>
	V - <replaceable>number</replaceable>


<replaceable>path-command</replaceable> :
	FD <replaceable>number</replaceable> = <replaceable>string string&opt.bnf;</replaceable>

<replaceable>directory</replaceable> :
	<replaceable>number</replaceable>
	*

<replaceable>file-command</replaceable> :
	FS <replaceable>location directory</replaceable>
	FE <replaceable>location</replaceable>

<replaceable>include-command</replaceable> :
	FIA <replaceable>location string</replaceable>
	FIQ <replaceable>location string</replaceable>
	FIN <replaceable>location string</replaceable>
	FIS <replaceable>location string</replaceable>
	FIE <replaceable>location string</replaceable>
	FIR <replaceable>location</replaceable>


<replaceable>string-command</replaceable> :
	A <replaceable>location string</replaceable>
	AC <replaceable>location string</replaceable>
	AL <replaceable>location string</replaceable>
	ACL <replaceable>location string</replaceable></programlisting>
	</refsection>
</refentry>

