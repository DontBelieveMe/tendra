<?xml version="1.0"?>
<!DOCTYPE chapter SYSTEM "minidocbook.dtd">

<chapter>
	<title>Dialect Features</title>

	<para>This chapter describes the capabilities of the TenDRA C checker for
		enforcing the ISO C standard as well as features for detecting areas
		left undefined by the standard. It also lists the non-ISO dialect
		features supported by the checker in order to provide compatibility
		with older versions of C and allow the use of third-party source which
		may contain non-standard constructs.</para>

	<section>
		<title>Resolving linkage problems</title>

		<para>Often the way that identifier names are resolved can alter the
			semantics of a program. For example, in:</para>

		<programlisting language="c">void f () {
	{
		extern void g ();
		g ( 3 );
	}
	g ( 7 );
}</programlisting>

		<para>the external declaration of <code>g</code> is only in scope in
			the inner block of <code>f</code>. Thus, at the second call of
			<code>g</code>, it is not in scope, and so is inferred to have
			declaration:</para>

		<programlisting language="c">extern int g ();</programlisting>

		<para>(see 3.4). This conflicts with the previous declaration of
			<code>g</code> which, although not in scope, has been registered
			in the external namespace. The pragma:</para>

		<programlisting language="c">#pragma TenDRA unify external linkage on</programlisting>

		<para>modifies the algorithm for resolving external linkage by
			searching the external namespace before inferring a declaration. In
			the example above, this results in the second use of <code>g</code>
			being resolved to the previous external declaration. The
			<emphasis>on</emphasis> can be replaced by <code>warning</code>
			to give a warning when such resolutions are detected, or
			<code>off</code> to switch this feature off.</para>

		<para>Another linkage problem, which is left undefined in the ISO C
			standard, is illustrated by the following program:</para>

		<programlisting language="c">int f ()
{
	extern int g ();
	return ( g () );
}

static int g ()
{
	return ( 0 );
}</programlisting>

		<para>Is the external variable <code>g</code> (the declaration of which
			would be inferred if it was omitted) the same as the static variable
			<code>g</code>? Of course, had the order of the two functions been
			reversed, there would be no doubt that they were, however, in the
			given case it is undefined. By default, the linkage is resolved
			externally, so that the two uses of g are not identified. However,
			the checker can be made to resolve its linkage internally, so that
			the two uses of <code>g</code> are identified. The resolution
			algorithm can be set using:</para>

		<programlisting language="c">#pragma TenDRA linkage resolution : <emphasis>action</emphasis></programlisting>

		<para>where <emphasis>action</emphasis> can be one of:</para>

		<itemizedlist>
			<listitem>
				<para>
					<code>(internal) on</code>
				</para>
			</listitem>
			<listitem>
				<para>
					<code>(internal) warning</code>
				</para>
			</listitem>
			<listitem>
				<para>
					<code>(external) on</code>
				</para>
			</listitem>
			<listitem>
				<para>
					<code>(external) warning</code>
				</para>
			</listitem>
			<listitem>
				<para>
					<code>off</code>
				</para>
			</listitem>
		</itemizedlist>

		<para>depending on whether the linkage resolution is internal,
			external, or default, and whether a warning message is required.
			The most useful behaviour is to issue a warning for all such
			occurrences (by setting action to <code>(internal) warning</code>,
			for example) so that the programmer can be alerted to clarify what
			was intended.</para>
	</section>

	<section>
		<title>Identifier linkage</title>

		<para>The ISO C standard, section 6.1.2.2, states that <quote>if,
			within a translation unit, an identifier appears with both internal
			and external linkage, the behaviour is undefined</quote>. By
			default, the checker silently declares the variable with external
			linkage. The check to detect variables which are redeclared with
			incompatible linkage is controlled using:</para>

		<programlisting language="c">#pragma TenDRA incompatible linkage <emphasis>permit</emphasis></programlisting>

		<para>where <emphasis>permit</emphasis> may be <code>allow</code>
			(default mode), <code>warning</code> (warn about incompatible
			linkage) or <code>disallow</code> (raise errors for redeclarations
			with incompatible linkage).</para>
	</section>

	<section>
		<title>7.4 Implicit integer types</title>

		<para>Older C dialects allow external variables to be specified without
			a type, the type <code>int</code> being inferred. Thus, for
			example:</para>

		<programlisting language="c">a, b;</programlisting>

		<para>is equivalent to:</para>

		<programlisting language="c">int a, b;</programlisting>

		<para>By default these inferred declarations are not permitted, though
			tchk's behaviour can be modified using:</para>

		<programlisting language="c">#pragma TenDRA implicit int type for external declaration <emphasis>permit</emphasis></programlisting>

		<para>where <emphasis>permit</emphasis> is <code>allow</code>,
			<code>warning</code> or <code>disallow</code>.</para>

		<para>A more common feature, allowed by the ISO C standard, but
			considered bad style by some, is the inference of an int return
			type for functions defined in the form:</para>

		<programlisting language="c">f ( int n )
{
	....
}</programlisting>

		<para>the checker's treatment of such functions can be determined
			using:</para>

		<programlisting language="c">#pragma TenDRA implicit int type for function return <emphasis>permit</emphasis></programlisting>

		<para>where <emphasis>permit</emphasis> can be <code>allow</code>,
			<code>warning</code> or <code>disallow</code>.</para>
	</section>

	<section>
		<title>Bitfield types</title>

		<para>The ISO C standard only allows <code>signed int</code>,
			<code>unsigned int</code> and their equivalent types as type
			specifiers in bitfields. Using the default checking profile,
			tchk raises errors for other integral types used as type
			specifiers in bitfields. This behaviour may be modified using
			the pragma:</para>

		<programlisting language="c">#pragma TenDRA extra int bitfield type <emphasis>permit</emphasis></programlisting>

		<para>where <emphasis>permit</emphasis> is one of <code>allow</code>
			(no errors raised), <code>warning</code> (allow non-int bitfields
			through with a warning) or <code>disallow</code> (raise errors
			for non-int bitfields).</para>

		<para>If non-int bitfields are allowed, the bitfield is treated as if
			it had been declared with an <code>int</code> type of the same
			signedness as the given type. The use of the type <code>char</code>
			as a bitfield type still generally causes an error, since whether a
			plain <code>char</code> is treated as <code>signed</code> or
			<code>unsigned</code> is implementation-dependent. The pragma:</para>

		<programlisting language="c">#pragma TenDRA character<emphasis> set-sign</emphasis></programlisting>

		<para>where <emphasis>set-sign</emphasis> is <code>signed</code>,
			<code>unsigned</code> or <code>either</code>, can be used to specify
			the signedness of a plain <code>char</code> bitfield. If
			<emphasis>set-sign</emphasis> is <code>signed</code> or
			<code>unsigned</code>, the bitfield is treated as though it were
			declared <code>signed char</code> or <code>unsigned char</code>
			respectively. If <emphasis>set-sign</emphasis> is
			<code>either</code>, the sign of the bitfield is target-dependent
			and the use of a plain <code>char</code> bitfield causes an
			error.</para>
	</section>

	<section>
		<title>Extra type definitions</title>

		<para>In accordence with the ISO C standard, in default mode tchk does
			not allow a type to be defined more than once using a
			<code>typedef</code>. The pragma:</para>

		<programlisting language="c">#pragma TenDRA extra type definition <emphasis>permit</emphasis></programlisting>

		<para>where <emphasis>permit</emphasis> is <code>allow</code>
			(silently accepts redefinitions, provided they are consistent),
			<code>warning</code> or <code>disallow</code>.</para>
	</section>

	<section>
		<title>Static block level functions</title>

		<para>The ISO C standard (Section 6.5.1) states that the declaration of
			an identifier for a function that has block scope shall have no
			explicit storage-class specifier other than extern. By default,
			tchk raises an error for declarations which do not conform to this
			rule. The behaviour can be modified using:</para>

		<programlisting language="c">#pragma TenDRA block function static <emphasis>permit</emphasis></programlisting>

		<para>where <emphasis>permit</emphasis> is <code>allow</code>
			(accept block scope function declarations with other storage-class
			specifiers), <code>disallow</code> or <code>warning</code>.</para>
	</section>

	<section>
		<title>Incomplete array element types</title>

		<para>The ISO C standard (Section 6.1.2.5) states that an incomplete
			type e.g an undefined structure or union type, is not an object
			type and that array elements must be of object type. The default
			behaviour of the checker causes errors when incomplete types are
			used to specify array element types. The pragma:</para>

		<programlisting language="c">#pragma TenDRA incomplete type as object type <emphasis>permit</emphasis></programlisting>

		<para>can be used to alter the treatment of array declarations with
			incomplete element types. <emphasis>permit</emphasis> is one of
			<code>allow</code>, <code>disallow</code> or <code>warning</code>
			as usual.</para>
	</section>

	<section>
		<title>Forward enumeration declarations</title>

		<para>The ISO C Standard (Section 6.5.2.3) states that the first
			introduction of an enumeration tag shall declare the constants
			associated with that tag. This rule is enforced by the checker in
			default mode, however it can be relaxed using the pragma:</para>

		<programlisting language="c">#pragma TenDRA forward enum declaration <emphasis>permit</emphasis></programlisting>

		<para>where replacing <emphasis>permit</emphasis> by <code>allow</code>
			permits the declaration and use of an enumeration tag before the
			declaration of its associated enumeration constants.
			A <code>disallow</code> variant which restores the default
			behaviour is also available.</para>
	</section>

	<section>
		<title>Untagged compound types</title>

		<para>The ISO C standard states that a declaration must declare at
			least a declarator, a tag or the members of an enumeration. The
			checker detects such declarations and, by default, raises an error.
			The severity of the errors can be altered by:</para>

		<programlisting language="c">#pragma TenDRA unknown struct/union <emphasis>permit</emphasis></programlisting>

		<para>where <emphasis>permit</emphasis> may be <code>allow</code> to
			allow code such as:</para>

		<programlisting language="c">struct {
	int i;
	int j;
};</programlisting>

		<para>through without errors (statements such as this occur in some
			system headers) or <code>disallow</code> to restore the default
			behaviour.</para>
	</section>

	<section>
		<title>External volatility</title>

		<para>The inclusion of the pragma:</para>

		<programlisting language="c">#pragma TenDRA external volatile_t</programlisting>

		<para>instructs the checker thereafter to treat any object declared
			with external linkage (ISO C standard Section 6.1.2.2) as if it
			were volatile (ISO C standard Section 6.5.3). This was a feature of
			some traditional C dialects. In the default mode, objects with
			external linkage are only treated as volatile if they were declared
			with the <code>volatile</code> type qualifier.</para>
	</section>

	<section>
		<title>Identifier name length</title>

		<para>Under the ISO C standard rules on identifier name length, an
			implementation is only required to treat the first 31 characters
			of an internal name and the first 6 characters of an external name
			as significant. The TenDRA C checker provides a facility for users
			to specify the maximum number of characters allowed in an identifier
			name, to prevent unexpected results when the application is moved to
			a new implementation. The limit is set using:</para>

		<programlisting language="c">#pragma TenDRA set name limit <emphasis>integer_constant</emphasis></programlisting>

		<para>There is currently no distinction made between external and
			internal names for length checking. Identifier name lengths are not
			checked in the default mode.</para>
	</section>

	<section>
		<title>Ellipsis in function calls</title>

		<para>An ellipsis is not an identifier and should not be used in a
			function call, even if, as in the program below, the function
			prototype contains an ellipsis:</para>

		<programlisting language="c">int f (int a, ...)
{
	return 1;
}

int main()
{
	int x, y;
	x = f(y, ...);
	return 1;
}</programlisting>

		<para>In default mode the checker raises an error if an ellipsis is
			used as a parameter in a function call. The severity of this
			error can be modified by using:</para>

		<programlisting language="c">#pragma TenDRA ident ... <emphasis>permit</emphasis></programlisting>

		<para>If <emphasis>permit</emphasis> is replaced by <code>allow</code>
			the ellipsis is ignored, if <code>warning</code> is used tchk
			produces a warning and if <code>disallow</code> is used the default
			behaviour is restored.</para>
	</section>

	<section>
		<title>Conditional lvalues</title>

		<para>The <code>?</code> operator cannot normally be used to define an
			lvalue, so that for example, the program:</para>

		<programlisting language="c">struct s {
	int a, b;
};

void f ( int n, struct s *s1, struct s *s2 )
{
	( n ? s1 : s2) -&gt; a = 0;
}</programlisting>

		<para>is not allowed in ISO C. The pragma:</para>

		<programlisting language="c">#pragma TenDRA conditional lvalue allow</programlisting>

		<para>allows conditional lvalues if:</para>

		<itemizedlist>
			<listitem>
				<para>Both options of the conditional operator have compatible
					compound types;</para>
			</listitem>
			<listitem>
				<para>Both options of the conditional are lvalues.</para>
			</listitem>
		</itemizedlist>

		<para>(there is also a <code>disallow</code> variant, but
			<code>warning</code> is not permitted in this case).</para>
	</section>

	<section>
		<title>Unifying the tag name space</title>

		<para>Each object in the tag name space is associated with a
			classification (<code>struct</code>, <code>union</code> or
			<code>enum</code>) of the type to which it refers. If such a tag is
			used, it must be preceded by the correct classification, otherwise
			the checker produces an error by default. However, the
			pragma:</para>

		<programlisting language="c">#pragma TenDRA ignore struct/union/enum tag <emphasis>status</emphasis></programlisting>

		<para>may be used to change the severity of the error. The options for
			<emphasis>status</emphasis> are: <code>on</code> (allows a tag to
			be used with any of the three classifications, the correct
			classification being inferred from the type definition),
			<code>warning</code> or <code>off</code>.</para>
	</section>

	<section>
		<title>Initialisation of compound types</title>

		<para>Many older C dialects do not allow the initialisation of automatic
			variables of compound type. Thus, for example:</para>

		<programlisting language="c">void f ()
{
	struct {
		int a;
		int b;
	} x = { 3, 2 };
}</programlisting>

		<para>would not be allowed by some older compilers, although by default
			tchk does not raise any errors since the code is legal according to
			the ISO C standard. The checker's behaviour may be changed
			using:</para>

		<programlisting language="c">#pragma TenDRA initialization of struct/union (auto) <emphasis>permit</emphasis></programlisting>

		<para>where <emphasis>permit</emphasis> is <code>allow</code>,
			<code>warning</code> or <code>disallow</code>. This feature is
			particularly useful when developing a program which is intended to
			be compiled with a compiler which does not support automatic
			compound initialisations.</para>
	</section>

	<section>
		<title>Variable initialisation</title>

		<para>The ISO C standard (Section 6.5.7) states that all expressions in
			an initialiser for an object that has static storage duration or in
			an initialiser-list for an object that has aggregate or union type
			shall be constant expressions. The pragma:</para>

		<programlisting language="c">#pragma TenDRA variable initialization <emphasis>permit</emphasis></programlisting>

		<para>may be used to allow non-constant initialisers if
			<emphasis>permit</emphasis> is replaced by <code>allow</code>. The
			other option for <emphasis>permit</emphasis> is <code>disallow</code>
			which restores the default behaviour of flagging non-constant
			initialisers for objects of static storage duration as errors.</para>
	</section>

	<section>
		<title>Escape sequences</title>

		<para>The ISO C standard specifies a small set of escape sequences in
			strings, for example <code>\n</code> as newline. Unknown escape
			sequences lead to an error in the default mode , however the
			severity of the error may be altered using:</para>

		<programlisting language="c">#pragma TenDRA unknown escape <emphasis>permit</emphasis></programlisting>

		<para>where <emphasis>permit</emphasis> is <code>allow</code> (silently
			replaces the unknown escape sequence, <emphasis>\z</emphasis> say,
			by <code>z</code>), <code>warning</code> or
			<code>disallow</code>.</para>
	</section>

	<section>
		<title><code>$</code> in identifier names</title>

		<para>The ISO C standard (Section 6.1) states that the use of the character
			<code>$</code> in identifier names is illegal. The pragma:</para>

		<programlisting language="c">#pragma TenDRA dollar as ident allow</programlisting>

		<para>can be used to allow such identifiers, which by default are flagged
			as errors. There is also a <code>disallow</code> variant which restores
			the default behaviour.</para>
	</section>

	<section>
		<title>Writeable string literals</title>

		<para>The ISO C standard, section 6.1.4, states that <quote>if the
			program attempts to modify a string literal of either form, the
			behaviour is undefined</quote>. Assignments to string literals of
			the form:</para>

		<programlisting language="c">"abc" = '3';</programlisting>

		<para>always result in errors. Other attempts to modify members of
			string literals, e.g.</para>

		<programlisting language="c">"abc"[1] = '3';</programlisting>

		<para>are permitted in the default checking mode. This behaviour can be
			changed using:</para>

		<programlisting language="c">#pragma TenDRA writeable string literal <emphasis>permit</emphasis></programlisting>

		<para>where <emphasis>permit</emphasis> may be <code>allow</code>,
			<code>warning</code> or <code>disallow</code>.</para>
	</section>

	<section>
		<title>Concatenation of character string literals
			and wide character string literals</title>

		<para>The ISO C standard, section 6.1.4, states that if a character
			string literal is adjacent to a wide character string literal, the
			behaviour is undefined. By default, this is flagged as an error by
			the checker. If the pragma:</para>

		<programlisting language="c">#pragma TenDRA unify incompatible string literal <emphasis>permit</emphasis></programlisting>

		<para>is used, with <emphasis>permit</emphasis> set to
			<code>allow</code> or <code>warning</code> the character string
			literal is converted to a wide character string literal and the
			strings are concatenated, although in the <code>warning</code> case
			a warning is output. The <code>disallow</code> version of the pragma
			restores the default behaviour.</para>
	</section>

	<section>
		<title>Nested comments</title>

		<para>The occurence of the <code>/*</code> characters inside a C
			comment, i.e. text surrounded by the <code>/*</code> and
			<code>*/</code> symbols, is usually a mistake and can lead to the
			termination of a comment unexpectedly. By default such nested
			comments are processed silently, however an error or warning can be
			produced by setting:</para>

		<programlisting language="c">#pragma TenDRA nested comment analysis <emphasis>status</emphasis></programlisting>

		<para>with <emphasis>status</emphasis> as <code>on</code> or
			<code>warning</code>. If <emphasis>status</emphasis> is
			<code>off</code> the default behaviour is restored.</para>
	</section>

	<section>
		<title>Empty source files</title>

		<para>The ISO standard states that each source file should contain at
			least one declaration or definition. Source files which contain no
			external declarations or definitions are flagged as errors by the
			checker in default mode. The severity of the error may be altered
			using:</para>

		<programlisting language="c">#pragma TenDRA no external declaration <emphasis>permit</emphasis></programlisting>

		<para>where the options for <emphasis>permit</emphasis> are
			<code>allow</code> (no errors raised), <code>warning</code>
			or <code>disallow</code>.</para>
	</section>

	<section>
		<title>Extra commas</title>

		<para>The ISO C standard does not allow extra commas in enumeration
			type declarations e.g.</para>

		<programlisting language="c">enum e = { red , orange , yellow , };</programlisting>

		<para>The extra comma at the end of the declaration is flagged as an
			error by default, but this behaviour may be changed by using:</para>

		<programlisting language="c">#pragma TenDRA extra , <emphasis>permit</emphasis></programlisting>

		<para>where <emphasis>permit</emphasis> has the usual
			<code>allow</code>, <code>disallow</code> and <code>warning</code>
			options.</para>
	</section>

	<section>
		<title>Extra semicolons</title>

		<para>Some dialects of C allow extra semicolons at the external
			declaration and definition level in contravention of the ISO C
			standard. For example, the program:</para>

		<programlisting language="c">int f ()
{
	return ( 0 );
};</programlisting>

		<para>is not ISO compliant. The checker enforces the ISO rules by
			default, but the errors raised may be reduced to warning or
			suppressed entirely using:</para>

		<programlisting language="c">#pragma TenDRA extra ; <emphasis>permit</emphasis></programlisting>

		<para>with <emphasis>permit</emphasis> as <code>warning</code> or
			<code>allow</code>. The <code>disallow</code> options restores
			the default behaviour.</para>
	</section>

	<section>
		<title>Compatibility with C++ to TDF producer</title>

		<para>In the interests of compatibility between the C checker and the
			new C++ checker, all pragmas beginning:</para>

		<programlisting language="c">#pragma TenDRA ++</programlisting>

		<para>are silently ignored by tchk.</para>
	</section>
</chapter>
