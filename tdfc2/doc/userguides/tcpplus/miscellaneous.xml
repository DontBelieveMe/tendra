<?xml version="1.0" standalone="no"?>
<!DOCTYPE chapter SYSTEM "minidocbook.dtd">

<chapter>
	<title>Miscellaneous configuration</title>

	<section id="linkage">
		<title>Object linkage</title>

		<para>If an object is declared with both external and internal linkage in
			the same translation unit then, by default, an error is given.	This
			behaviour can be changed using the directive:</para>

		<programlisting language="cpp">#pragma TenDRA incompatible linkage <emphasis>allow</emphasis></programlisting>

		<para>When incompatible linkages are allowed, whether the resultant identifier
			has external or internal linkage can be set using one of the directives:</para>

		<programlisting language="cpp">#pragma TenDRA linkage resolution : off
#pragma TenDRA linkage resolution : (external) <emphasis>on</emphasis>
#pragma TenDRA linkage resolution : (internal) <emphasis>on</emphasis></programlisting>

		<para>It is possible to declare objects with external linkage in a block.
			C leaves it undefined whether declarations of the same object in different
			blocks, such as:</para>

		<programlisting language="c">void f ()
{
	extern int a ;
	....
}

void g ()
{
	extern double a ;
	....
}</programlisting>

		<para>are checked for compatibility.	However in C++ the one definition
			rule implies that such declarations are indeed checked for compatibility.
			The status of this check can be set using the directive:</para>

		<programlisting language="cpp">#pragma TenDRA unify external linkage <emphasis>on</emphasis></programlisting>

		<para>Note that it is not possible in ISO C or C++ to declare objects or
			functions with internal linkage in a block.	While <code>static</code>
			object definitions in a block have a specific meaning, there is no
			real reason why <code>static</code> functions should not be declared
			in a block.	This behaviour can be enabled using the directive:</para>

		<programlisting language="cpp">#pragma TenDRA block function static <emphasis>allow</emphasis></programlisting>

		<para>Inline functions have external linkage by default in ISO C++, but
			internal linkage in older dialects.	The default linkage can be set
			using the directive:</para>

		<programlisting language="cpp">#pragma TenDRA++ inline linkage <emphasis>linkage-spec</emphasis></programlisting>

		<para>where <emphasis>linkage-spec</emphasis> can be <code>external</code> or
			<code>internal</code>.	Similarly <code>const</code> objects have
			internal linkage by default in C++, but external linkage in C.	The
			default linkage can be set using the directive:</para>

		<programlisting language="cpp">#pragma TenDRA++ const linkage <emphasis>linkage-spec</emphasis></programlisting>

		<para>Older dialects of C treated all identifiers with external linkage
			as if they had been declared <code>volatile</code> (i.e. by being
			conservative in optimising such values).	This behaviour can be enabled
			using the directive:</para>

		<programlisting language="cpp">#pragma TenDRA external volatile_t</programlisting>

		<para>It is possible to set the default language linkage using the directive:</para>

		<programlisting language="cpp">#pragma TenDRA++ external linkage <emphasis>string-literal</emphasis></programlisting>

		<para>This is equivalent to enclosing the rest of the current checking scope
			in:</para>

		<programlisting language="cpp">extern <emphasis>string-literal</emphasis> {
	....
}</programlisting>

		<para>It is unspecified what happens if such a directive is used within
			an explicit linkage specification and does not nest correctly.	This
			directive is particularly useful when used in a <link linkend="scope">named
			environment</link> associated with an include directory.	For example,
			it can be used to express the fact that all the objects declared in
			headers included from that directory have C linkage.</para>

		<para>A change in ISO C++ relative to older dialects is that the language
			linkage of a function now forms part of the function type.	For example:</para>

		<programlisting language="cpp">extern &quot;C&quot; int f ( int ) ;
int ( *pf ) ( int ) = f ;		// error</programlisting>

		<para>The directive:</para>

		<programlisting language="cpp">#pragma TenDRA++ external function linkage <emphasis>on</emphasis></programlisting>

		<para>can be used to control whether function types with differing language
			linkages, but which are otherwise compatible, are considered compatible
			or not.</para>
	</section>

	<section id="static">
		<title>Static identifiers</title>

		<para>By default, objects and functions with internal linkage are mapped
			to tags without external names in the output TDF capsule.	Thus such
			names are not available to the installer and it needs to make up internal
			names to represent such objects in its output.	This is not desirable
			in such operations as profiling, where a meaningful internal name
			is needed to make sense of the output.	The directive:</para>

		<programlisting language="cpp">#pragma TenDRA preserve <emphasis>identifier-list</emphasis></programlisting>

		<para>can be used to preserve the names of the given list of identifiers
			with internal linkage.	This is done using the <code>static_name_def</code>
			TDF construct.	The form:</para>

		<programlisting language="cpp">#pragma TenDRA preserve *</programlisting>

		<para>will preserve the names of all identifiers with internal linkage in
			this way.</para>
	</section>

	<section id="template">
		<title>Template compilation</title>

		<para>The C++ producer makes the distinction between exported templates,
			which may be used in one module and defined in another, and non-exported
			templates, which must be defined in every module in which they are
			used. As in the ISO C++ standard, the <code>export</code> keyword
			is used to distinguish between the two cases.	In the past, different
			compilers have had different template compilation models; either all
			templates were exported or no templates were exported.	The latter
			is easily emulated - if the <code>export</code> keyword is not used
			then no templates will be exported.	To emulate the former behaviour
			the directive:</para>

		<programlisting language="cpp">#pragma TenDRA++ implicit export template <emphasis>on</emphasis></programlisting>

		<para>can be used to treat all templates as if they had been declared using
			the <code>export</code> keyword.</para>

		<warning>
			<para>The automatic instantiation of exported templates has not yet been
				implemented correctly.	It is intended that such instantiations will
				be generated during <link linkend="spec">intermodule analysis</link>
				(where they conceptually belong).	At present it is necessary to work
				round this using explicit instantiations.</para>
		</warning>
	</section>

</chapter>

