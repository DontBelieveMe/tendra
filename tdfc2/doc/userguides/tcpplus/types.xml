<?xml version="1.0" standalone="no"?>
<!DOCTYPE chapter SYSTEM "minidocbook.dtd">

<chapter>
	<title>Configuration for types</title>

	<section id="longlong">
		<title>Extended integral types</title>

		<para>The <code>long long</code> integral types are not part of ISO C or
			C++ by default, however support for them can be enabled using the
			directive:</para>

		<programlisting language="cpp">#pragma TenDRA longlong type <emphasis>allow</emphasis></programlisting>

		<para>This support includes allowing <code>long long</code> in type specifiers
			and allowing <code>LL</code> and <code>ll</code> as integer literal
			suffixes.</para>

		<para>There is a further directive given by the two cases:</para>

		<programlisting language="cpp">#pragma TenDRA set longlong type : long long
#pragma TenDRA set longlong type : long</programlisting>

		<para>which can be used to control the implementation of the <code>long
			long</code> types.	Either they can be mapped to the
			default representation, which is guaranteed
			to contain at least 64 bits, or they can be mapped to the corresponding
			<code>long</code> types.</para>

		<para>Because these <code>long long</code> types are not an intrinsic part
			of C++ the implementation does not integrate them into the language
			as fully as is possible.	This is to prevent the presence or otherwise
			of <code>long long</code> types affecting the semantics of code which
			does not use them.	For example, it would be possible to extend the
			rules for the types of integer literals, integer promotion types and
			arithmetic types to say that if the given value does not fit into
			the standard integral types then the extended types are tried.	This
			has not been done, although these rules could be implemented by changing
			the definitions of the standard tokens
			used to determine these types.	By default, only the rules for arithmetic
			types involving a <code>long long</code> operand and for <code>LL</code>
			integer literals mention <code>long long</code> types.</para>
	</section>

	<section id="bitfield-types">
		<title>Bitfield types</title>

		<para>The C++ rules on bitfield types differ slightly from the C rules.
			Firstly any integral or enumeration type is allowed in a bitfield,
			and secondly the bitfield width may exceed the underlying type size
			(the extra bits being treated as padding).	These properties can be
			controlled using the directives:</para>

		<programlisting language="cpp">#pragma TenDRA extra bitfield int type <emphasis>allow</emphasis>
#pragma TenDRA bitfield overflow <emphasis>allow</emphasis></programlisting>

			<para>respectively.</para>
	</section>

	<section id="typedef">
		<title>Type declarations</title>

		<para>C does not allow multiple definitions of a <code>typedef</code> name,
			whereas C++ allows multiple consistent definitions.	This behaviour
			can be controlled using the directive:</para>

		<programlisting language="cpp">#pragma TenDRA extra type definition <emphasis>allow</emphasis></programlisting>
	</section>

	<section id="compatible">
		<title>Type compatibility</title>

		<para>The directive:</para>

		<programlisting language="cpp">#pragma TenDRA incompatible type qualifier <emphasis>allow</emphasis></programlisting>

		<para>allows objects to be redeclared with different cv-qualifiers (normally
			such redeclarations would be incompatible).	The composite type is
			qualified using the join of the cv-qualifiers in the various redeclarations.</para>

		<para>The directive:</para>

		<programlisting language="cpp">#pragma TenDRA compatible type : <emphasis>type-id</emphasis> == <emphasis>type-id</emphasis> : <emphasis>allow</emphasis></programlisting>

		<para>asserts that the given two types are compatible.	Currently the only
			implemented version is <code>char * == void *</code> which enables
			<code>char *</code> to be used as a generic pointer as it was in older
			dialects of C.</para>
	</section>

	<section id="complete">
		<title>Incomplete types</title>

		<para>Some dialects of C allow incomplete arrays as member types.	These
			are generally used as a place-holder at the end of a structure to
			allow for the allocation of an arbitrarily sized array.	Support for
			this feature can be enabled using the directive:</para>

		<programlisting language="cpp">#pragma TenDRA incomplete type as object type <emphasis>allow</emphasis></programlisting>
	</section>

</chapter>

