<?xml version="1.0" standalone="no"?>
<!DOCTYPE preface SYSTEM "minidocbook.dtd">

<chapter>
	<title>Configuring the Compiler</title>

	<para>This majority of this document describes how the C++ producer can
		be configured to apply extra static checks or to support various
		dialects of C++.
		In all cases the default behaviour is precisely that specified in
		the ISO C++ standard with no extra checks.</para>

	<para>Certain very basic configuration information is specified using a
		<link linkend="table">portability table</link>, however the primary
		method of configuration is by means of <code>#pragma</code>
		directives.
		These directives may be placed within the program itself, however
		it is generally more convenient to group them into a
		start-up file in order to create a
		user-defined compilation profile (see the <option>-X</option>
		option for &tcc;).
		The <code>#pragma</code> directives recognised by the C++ producer
		have one of the equivalent forms:</para>

	<programlisting language="cpp">#pragma TenDRA ....
#pragma TenDRA++ ....</programlisting>

	<para>Some of these are common to the C and C++ producers (although
		often with differing default behaviour).
		The C producer will ignore any <code>TenDRA++</code> directives, so
		these may be used in compilation profiles which are to be used by
		both producers.
		In the descriptions below, the presence of a <code>++</code> is
		used to indicate a directive which is C++ specific; the other
		directives are common to both producers.</para>

	<para>Within the description of the <code>#pragma</code> syntax,
		<emphasis>on</emphasis> stands for <code>on</code>,
		<code>off</code> or <code>warning</code>, <emphasis>allow</emphasis>
		stands for <code>allow</code>, <code>disallow</code> or <code>warning</code>,
		<emphasis>string-literal</emphasis> is any string literal,
		<emphasis>integer-literal</emphasis> is any integer literal,
		<emphasis>identifier</emphasis> is any simple, unqualified identifier name,
		and <emphasis>type-id</emphasis> is any type identifier.
		Other syntactic items are described in the text.
		A complete grammar for the <code>#pragma</code>
		directives accepted by the C++ producer is given in &pragmatoken.doc;.</para>

	<!-- TODO: these sections are probably repeated by the tdfc/tchk document; consolidate -->
	<section id="table">
		<title>Portability tables</title>

		<para>Certain very basic configuration information is read from a file called
			a portability table, which may be specified to the producer using
			a <code>-n</code> option.
			This information includes the minimum sizes of the basic integral types, the
			<link linkend="char">sign of plain <code>char</code></link>, and whether signed
			types can be assumed to be symmetric (for example, [-127,127]) or
			maximum (for example, [-128,127]).</para>

		<!-- TODO: see <invent a .5 manpage> for the portability file format.

		<para>The default portability table values, which are built into the producer,
			can be expressed in the form:</para>

		TODO: take table from tdfc appendix
		<programlisting>
char_bits			8
short_bits			16
int_bits			16
long_bits			32
signed_range			symmetric
char_type			either
ptr_int				none
ptr_fn				no
non_prototype_checks		yes
multibyte			1</programlisting>

		<para>This illustrates the syntax for the portability table; note that all
			ten entries are required, even though the last four are ignored.</para>
-->
	</section>

	<section id="low">
		<title>Low level configuration</title>

		<para>The simplest level of configuration is to reset the severity level
			of a particular error message using:</para>

		<programlisting language="cpp">#pragma TenDRA++ error <emphasis>string-literal on</emphasis>
#pragma TenDRA++ error <emphasis>string-literal allow</emphasis></programlisting>

		<para>The given <emphasis>string-literal</emphasis> should name an error from the
			&make_err; error catalogue.	A severity of <code>on</code>
			or <code>disallow</code> indicates that the associated diagnostic
			message should be an error, which causes the compilation to fail.
			A severity of
			<code>warning</code> indicates that the associated diagnostic message
			should be a warning, which is printed but allows the compilation to
			continue.	A severity of <code>off</code> or <code>allow</code>
			indicates that the associated error should be ignored.	Reducing the
			severity of any error from its default value, other than via one of
			the dialect directives described in this section, results in undefined
			behaviour.</para>

		<para>The next level of configuration is to reset the severity level of
			a particular compiler option using:</para>

		<programlisting language="cpp">#pragma TenDRA++ option <emphasis>string-literal on</emphasis>
#pragma TenDRA++ option <emphasis>string-literal allow</emphasis></programlisting>

		<para>The given <emphasis>string-literal</emphasis> should name an option from the option
			catalogue.	The simplest form of compiler option just sets the severity
			level of one or more error messages.	Some of these options may require
			additional processing to be applied.</para>

		<para>It is possible to link a particular error message to a particular
			compiler option using:</para>

		<programlisting language="cpp">#pragma TenDRA++ error <emphasis>string-literal</emphasis> as option <emphasis>string-literal</emphasis></programlisting>

		<para>Note that the directive:</para>

		<programlisting language="cpp">#pragma TenDRA++ use error <emphasis>string-literal</emphasis></programlisting>

		<para>can be used to raise a given error at any point in a translation unit
			in a similar fashion to the <code>#error</code> directive.	The values
			of any parameters for this error are unspecified.</para>

		<para>The directives just described give the primitive operations on error
			messages and compiler options.	Many of the remaining directives in
			this section are merely higher level ways of expressing these primitives.</para>
	</section>

	<section id="scope">
		<title>Checking scopes</title>

		<para>Most compiler options are scoped.	A checking scope may be defined
			by enclosing a list of declarations within:</para>

		<programlisting language="cpp">#pragma TenDRA begin
....
#pragma TenDRA end</programlisting>

		<para>If the final <code>end</code> directive is omitted then the scope
			ends at the end of the translation unit.	Checking scopes may be nested
			in the obvious way.	A checking scope inherits its initial set of
			checks from its enclosing scope (this includes the implicit main checking
			scope consisting of the entire input file).	Any checks switched on
			or off within a scope apply only to the remainder of that scope and
			any scope it contains.	A particular check can only be set once in
			a given scope. The set of applied checks reverts to its previous state
			at the end of the scope.</para>

		<para>A checking scope can be named using the directives:</para>

		<programlisting language="cpp">#pragma TenDRA begin name environment <emphasis>identifier</emphasis>
....
#pragma TenDRA end</programlisting>

		<para>Checking scope names occupy a namespace distinct from any other namespace
			within the translation unit.	A named scope defines a set of modifications
			to the current checking scope.	These modifications may be reapplied
			within a different scope using:</para>

		<programlisting language="cpp">#pragma TenDRA use environment <emphasis>identifier</emphasis></programlisting>

		<para>The default behaviour is not to allow checks set in the named checking
			scope to be reset in the current scope.	This can however be modified
			using:</para>

		<programlisting language="cpp">#pragma TenDRA use environment <emphasis>identifier</emphasis> reset <emphasis>allow</emphasis></programlisting>

		<para>Another use of a named checking scope is to associate a checking scope
			with a named include file directory.	This is done using:</para>

		<programlisting language="cpp">#pragma TenDRA directory <emphasis>identifier</emphasis> use environment <emphasis>identifier</emphasis></programlisting>

		<para>where the directory name is one introduced via a
			<code>-N</code> command-line option.
			The effect of this directive, if a <code>#include</code> directive
			is found to resolve to a file from the given directory, is as if the
			file was enclosed in directives of the form:</para>

		<programlisting language="cpp">#pragma TenDRA begin
#pragma TenDRA use environment <emphasis>identifier</emphasis> reset allow
....
#pragma TenDRA end</programlisting>

		<para>The checks applied to the expansion of a macro definition are those
			from the scope in which the macro was defined, not that in which it
			was expanded. The macro arguments are checked in the scope in which
			they are specified, that is to say, the scope in which the macro is
			expanded.	This enables macro definitions to remain localised with
			respect to checking scopes.</para>
	</section>

</chapter>

