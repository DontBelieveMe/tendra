<?xml version="1.0"?>
<!DOCTYPE article SYSTEM "minidocbook.dtd">

<!-- $Id$ -->

<article>

	<articleinfo>
		<title>The C/C++ Symbol Table Dump</title>

		<authorgroup>
			<editor>
				<firstname>Katherine</firstname>
				<surname>Flavel</surname>
				<affiliation><orgname>The TenDRA Project</orgname></affiliation>
			</editor>

			<corpauthor>DERA</corpauthor>
		</authorgroup>

		<pubdate>1998</pubdate>

		<copyright>
			<year>2011</year>
			<year>2010</year>
			<year>2008</year>
			<holder>The TenDRA Project</holder>
		</copyright>

		<copyright>
			<year>1998</year>
			<holder>DERA</holder>
		</copyright>

		<revhistory>
			<revision role="version">
				<date>2010-02-21</date>
				<authorinitials>kate</authorinitials>
				<revdescription>
					<para>Moved out the DRA producers as a standalone tool.</para>
				</revdescription>
			</revision>

			<revision role="docs">
				<date>2008-03-25</date>
				<authorinitials>kate</authorinitials>
				<revdescription>
					<para>Moved out a description of the symbol table semantics
						from &tdfc2-userguide.doc; into a
						seperate document.</para>
				</revdescription>
			</revision>

			<revision role="version">
				<date>1998-07-30</date>
				<revnumber>tcpplus 1.8.2</revnumber>
				<authorinitials>DERA</authorinitials>
				<revdescription>
					<para>TenDRA 4.1.2 release.</para>
				</revdescription>
			</revision>
		</revhistory>
	</articleinfo>

	<!-- TODO: very much work in progress. This contains the details for
		the symbol table from the tcpplus and tdfc user guides. These
		ought to be consolidated into one description.
		Likewise the syntax reference, which is now a .5 manpage.
	-->

	<section>
		<title>Overview</title>

		<para>&tchk; produces an extra output file, called a dump output file, for
			each translation unit processed. This file is in the form given by the
			symbol table output specification in Annex E, and contains information
			about the objects declared, defined or used within an application. Each
			object encountered during processing is assigned a unique reference
			number allowing uses of the object to be traced back to the declaration
			and definition of the object.</para>

		<para>In the default mode only external declaration and definition
			information is written to each dump file.
			The file to be used as the symbol table output file, plus details
			of what information is to be included in the dump file can be specified
			by passing various flags using the <code>-d</code> command-line option
			to &tcpplus;; these flags are documented by &tdfc2.1;.</para>

		<para>The symbol table dump provides a method whereby third party tools
			can interface with the C and C++ producers.	The producer outputs
			information on the identifiers declared within a source file, their
			uses etc. into a file which can then be post-processed by a separate
			tool. Any error messages and warnings can also be included in this
			file, allowing more sophisticated error presentation tools to be written.</para>

		<para>The dump information is currently used for four main purposes:
			detecting included header files from which nothing is used within the
			translation unit; production of lint-like error output; &api; usage
			analysis and type checking between translation units.</para>

		<para>The format of the dump file is described below; a
			summary of the syntax is given in &tdfcdump.5;.</para>
	</section>

	<!-- TODO hereafter is from tcpplus -->

	<section>
		<title>Lexical elements</title>

		<para>A symbol table dump file consists of a sequence of characters giving
			information on identifiers, errors etc. arising from a translation
			unit. The fundamental lexical tokens are a <replaceable>number</replaceable>, consisting
			of a sequence of decimal digits, and a <replaceable>string</replaceable>, consisting of
			a sequence of characters enclosed in angle braces.
			A <replaceable>string</replaceable> can have one of two forms:</para>

		<programlisting language="bnf"><replaceable>string</replaceable> :
	&lt;<replaceable>characters</replaceable>&gt;
	&amp;<replaceable>number</replaceable>&lt;<replaceable>characters</replaceable>&gt;</programlisting>

		<para>In the first form, the <replaceable>characters</replaceable> are terminated by the first
			<code>&gt;</code> character encountered.	In the second form, the
			number of characters is given by the preceding <replaceable>number</replaceable>.	No
			white space is allowed either before or after the <replaceable>number</replaceable>.
			To aid parsers, the C++ producer always uses the second form for strings
			containing more than 100 characters.	There are no escape characters
			in strings; the
			<replaceable>characters</replaceable> can contain any characters, including newlines and
			<code>#</code>, except that the first form cannot contain a
			<code>&gt;</code> character.</para>

		<para>Space, tab and newline characters are white space.	Comments begin
			with <code>#</code> and run to the end of the line.	Comments are treated
			as white space.	All other characters are treated as distinct lexical
			tokens.</para>
	</section>

	<section>
		<title>Overall syntax</title>

		<para>A symbol table dump file takes the form of a list of commands of various
			kinds conveying information on the analysed file.	This can be represented
			as follows:</para>

		<programlisting language="bnf"><replaceable>dump-file</replaceable> :
	<replaceable>command-list&opt.bnf;</replaceable>

<replaceable>command-list</replaceable> :
	<replaceable>command command-list&opt.bnf;</replaceable>

<replaceable>command</replaceable> :
	<replaceable>version-command</replaceable>
	<replaceable>identifier-command</replaceable>
	<replaceable>scope-command</replaceable>
	<replaceable>override-command</replaceable>
	<replaceable>base-command</replaceable>
	<replaceable>api-command</replaceable>
	<replaceable>template-command</replaceable>
	<replaceable>promotion-command</replaceable>
	<replaceable>error-command</replaceable>
	<replaceable>path-command</replaceable>
	<replaceable>file-command</replaceable>
	<replaceable>include-command</replaceable>
	<replaceable>string-command</replaceable></programlisting>

		<para>The various kinds of command are discussed below.	The first command
			in the dump file should be of the form:</para>

		<programlisting language="bnf"><replaceable>version-command</replaceable> :
	V <replaceable>number number string</replaceable></programlisting>

		<para>where the two numbers give the version of the dump file format (the
			version described here is 1.1 so both numbers should be 1) and the
			string gives the language being represented, for example,
			<code>&lt;C++&gt;</code>.</para>
	</section>

	<section>
		<title>File locations</title>

		<para>A location within a source file can be specified using three
			<replaceable>number</replaceable>s and two <replaceable>string</replaceable>s.	These give respectively, the
			column number, the line number taking <code>#line</code> directives
			into account, the line number not taking <code>#line</code> directives
			into account, the file name taking <code>#line</code> directives into
			account, and the file name not taking <code>#line</code> directives
			into account.	Any or all of the trailing elements can be replaced by
			<code>*</code> to indicate that they have not changed relative to
			the last <replaceable>location</replaceable> given.	Note that for the two line numbers,
			unchanged means that the difference of the line numbers, taking
			<code>#line</code> directives into account or not, is unchanged.
			Thus:</para>

		<programlisting language="bnf"><replaceable>location</replaceable> :
	<replaceable>number number number string string</replaceable>
	<replaceable>number number number string</replaceable> *
	<replaceable>number number number</replaceable> *
	<replaceable>number number</replaceable> *
	<replaceable>number</replaceable> *
	*</programlisting>

		<para>Note that there is a concept of the current file
			location, relative to which other locations are given.
			The initial value of the current file location is undefined.
			Unless otherwise stated, all <replaceable>location</replaceable>
			elements update the current file location.</para>
	</section>

	<section>
		<title>Identifiers</title>

		<para>Each identifier is represented in the symbol table dump by a unique
			number.	The same number always represents the same identifier.</para>

		<section>
			<title>Identifier names</title>

			<para>The number representing an identifier is introduced in the first declaration
				or use of that identifier and thereafter the number alone is used
				to denote the identifier:</para>

			<programlisting language="bnf"><replaceable>identifier</replaceable> :
	<replaceable>number</replaceable> = <replaceable>identifier-name access&opt.bnf; scope-identifier</replaceable>
	<replaceable>number</replaceable></programlisting>

			<para>The identifier name is given by:</para>

			<programlisting language="bnf"><replaceable>identifier-name</replaceable> :
	<replaceable>string</replaceable>
	C <replaceable>type</replaceable>
	D <replaceable>type</replaceable>
	O <replaceable>string</replaceable>
	T <replaceable>type</replaceable></programlisting>

			<para>denoting respectively, a simple identifier name, a constructor for
				a type, a destructor for a type, an overloaded operator function name,
				and a conversion function name.	The empty string is used for anonymous
				identifiers.</para>

			<para>The optional identifier access is given by:</para>

				<programlisting language="bnf"><replaceable>access</replaceable> :
	N
	B
	P</programlisting>

			<para>denoting <code>public</code>, <code>protected</code> and
				<code>private</code> respectively.	An absent <replaceable>access</replaceable> is equivalent
				to <code>public</code>.	Note that all identifiers, not just class
				members, can have access specifiers; however the access of a non-member
				is always <code>public</code>.</para>

			<para>The scope (i.e. class, namespace, block etc.)
				in which an identifier is declared is given by:</para>

			<programlisting language="bnf"><replaceable>scope-identifier</replaceable> :
	<replaceable>identifier</replaceable>
	*</programlisting>

			<para>denoting either a named or an unnamed scope.</para>
		</section>

		<section>
			<title>Identifier uses</title>

			<para>Each declaration or use of an identifier is represented by a command
				of the form:</para>

			<programlisting language="bnf"><replaceable>identifier-command</replaceable> :
	D <replaceable>identifier-info type-info</replaceable>
	M <replaceable>identifier-info type-info</replaceable>
	T <replaceable>identifier-info type-info</replaceable>
	Q <replaceable>identifier-info</replaceable>
	U <replaceable>identifier-info</replaceable>
	L <replaceable>identifier-info</replaceable>
	C <replaceable>identifier-info</replaceable>
	W <replaceable>identifier-info type-info</replaceable></programlisting>

			<para>where:</para>

			<programlisting language="bnf"><replaceable>identifier-info</replaceable> :
	<replaceable>identifier-key location identifier</replaceable></programlisting>

			<para>gives the kind of identifier being declared or used, the location
				of the declaration or use, and the number associated with the identifier.
				Each declaration may, depending on the <replaceable>identifier-key</replaceable>, associate
				various <replaceable>type-info</replaceable> with the identifier, giving its type etc.</para>

			<para>The various kinds of <replaceable>identifier-command</replaceable> are described below.
				Any can be preceded by <code>I</code> to indicate an implicit declaration
				or use.	<code>D</code> denotes a definition.	<code>M</code> (make)
				denotes a declaration.	<code>T</code> denotes a tentative definition
				(C only).	<code>Q</code> denotes the end of a definition, for those
				identifiers such as classes and functions whose definitions may be
				spread over several lines.	<code>U</code> denotes an undefine operation
				(such as <code>#undef</code> for macro identifiers).	<code>C</code>
				denotes a call to a function identifier; <code>L</code> (load) denotes
				other identifier uses.	Finally <code>W</code> denotes implicit type
				information such as the C producer gleans from its
				weak prototype analysis (see &tchk.doc;).</para>

			<para>The various <replaceable>identifier-key</replaceable>s are their
				associated <replaceable>type-info</replaceable>
				fields are given by the following table:</para>

			<table>
				<col align="center"/>
				<col align="left"/>
				<col align="left"/>

				<thead>
					<tr>
						<th>Key</th>
						<th>Type information</th>
						<th>Description</th>
					</tr>
				</thead>

				<tbody>
					<tr>
						<td><code>K</code></td>
						<td><code>*</code></td>
						<td>keyword</td>
					</tr>

					<tr>
						<td><code>MO</code></td>
						<td><replaceable>sort</replaceable></td>
						<td>object macro</td>
					</tr>

					<tr>
						<td><code>MF</code></td>
						<td><replaceable>sort</replaceable></td>
						<td>function macro</td>
					</tr>

					<tr>
						<td><code>MB</code></td>
						<td><replaceable>sort</replaceable></td>
						<td>built-in macro</td>
					</tr>

					<tr>
						<td><code>TC</code></td>
						<td><replaceable>type</replaceable></td>
						<td>class tag</td>
					</tr>

					<tr>
						<td><code>TS</code></td>
						<td><replaceable>type</replaceable></td>
						<td>structure tag</td>
					</tr>

					<tr>
						<td><code>TU</code></td>
						<td><replaceable>type</replaceable></td>
						<td>union tag</td>
					</tr>

					<tr>
						<td><code>TE</code></td>
						<td><replaceable>type</replaceable></td>
						<td>enumeration tag</td>
					</tr>

					<tr>
						<td><code>TA</code></td>
						<td><replaceable>type</replaceable></td>
						<td><code>typedef</code> name</td>
					</tr>

					<tr>
						<td><code>NN</code></td>
						<td><code>*</code></td>
						<td>namespace name</td>
					</tr>

					<tr>
						<td><code>NA</code></td>
						<td><replaceable>scope-identifier</replaceable></td>
						<td>namespace alias</td>
					</tr>

					<tr>
						<td><code>VA</code></td>
						<td><replaceable>type</replaceable></td>
						<td>automatic variable</td>
					</tr>

					<tr>
						<td><code>VP</code></td>
						<td><replaceable>type</replaceable></td>
						<td>function parameter</td>
					</tr>

					<tr>
						<td><code>VE</code></td>
						<td><replaceable>type</replaceable></td>
						<td><code>extern</code> variable</td>
					</tr>

					<tr>
						<td><code>VS</code></td>
						<td><replaceable>type</replaceable></td>
						<td><code>static</code> variable</td>
					</tr>

					<tr>
						<td><code>FE</code></td>
						<td><replaceable>type identifier&opt.bnf;</replaceable></td>
						<td><code>extern</code> function</td>
					</tr>

					<tr>
						<td><code>FS</code></td>
						<td><replaceable>type identifier&opt.bnf;</replaceable></td>
						<td><code>static</code> function</td>
					</tr>

					<tr>
						<td><code>FB</code></td>
						<td><replaceable>type identifier&opt.bnf;</replaceable></td>
						<td>built-in operator function</td>
					</tr>

					<tr>
						<td><code>CF</code></td>
						<td><replaceable>type identifier&opt.bnf;</replaceable></td>
						<td>member function</td>
					</tr>

					<tr>
						<td><code>CS</code></td>
						<td><replaceable>type identifier&opt.bnf;</replaceable></td>
						<td><code>static</code> member function</td>
					</tr>

					<tr>
						<td><code>CV</code></td>
						<td><replaceable>type identifier&opt.bnf;</replaceable></td>
						<td>virtual member function</td>
					</tr>

					<tr>
						<td><code>CM</code></td>
						<td><replaceable>type</replaceable></td>
						<td>data member</td>
					</tr>

					<tr>
						<td><code>CD</code></td>
						<td><replaceable>type</replaceable></td>
						<td><code>static</code> data member</td>
					</tr>

					<tr>
						<td><code>E</code></td>
						<td><replaceable>type</replaceable></td>
						<td>enumerator</td>
					</tr>

					<tr>
						<td><code>L</code></td>
						<td><code>*</code></td>
						<td>label</td>
					</tr>

					<tr>
						<td><code>XO</code></td>
						<td><replaceable>sort</replaceable></td>
						<td>object token</td>
					</tr>

					<tr>
						<td><code>XF</code></td>
						<td><replaceable>sort</replaceable></td>
						<td>procedure token</td>
					</tr>

					<tr>
						<td><code>XP</code></td>
						<td><replaceable>sort</replaceable></td>
						<td>token parameter</td>
					</tr>

					<tr>
						<td><code>XT</code></td>
						<td><replaceable>sort</replaceable></td>
						<td>template parameter</td>
					</tr>
				</tbody>
			</table>

			<para>The function identifier keys can optionally be followed by
				<code>C</code> indicating that the function has C linkage, and
				<code>I</code> indicating that the function is inline.	By default,
				functions declared in a C++ dump file have C++ linkage and functions
				declared in a C dump file have C linkage.	The optional
				<replaceable>identifier</replaceable> which forms part of the <replaceable>type-info</replaceable> of these
				functions is used to form linked lists of overloaded functions.</para>
		</section>

		<section>
			<title>Identifier scopes</title>

			<para>Each identifier belongs to a scope, called its parent scope, in which
				it is declared.	For example, the parent of a member of a class is
				the class itself.	This information is expressed in an identifier
				declaration using a <replaceable>scope-identifier</replaceable>.
				In addition to the obvious scopes such as classes and namespaces,
				there are other scopes such as blocks in function definitions.
				It is possible to introduce dummy identifiers to name such scopes.
				The parent of such a dummy identifier will be the enclosing scope identifier,
				so these dummy identifiers naturally represent the block structure.
				The parent of the top-level block in a function definition can be
				considered to be the function itself.</para>

			<para>Information on the start and end of such scopes is given by:</para>

			<programlisting language="bnf"><replaceable>scope-command</replaceable> :
	SS <replaceable>scope-key location identifier</replaceable>
	SE <replaceable>scope-key location identifier</replaceable></programlisting>

			<para>where:</para>

			<programlisting language="bnf"><replaceable>scope-key</replaceable> :
	N
	S
	B
	D
	H
	CT
	CF
	CC</programlisting>

			<para>gives the kind of scope involved: a namespace, a class, a block, some
				other declarative scope, a declaration block (see below), a true conditional
				scope, a false conditional scope or a target dependent conditional
				scope.</para>

			<para>A declaration block is a sequence of declarations enclosed in directives
				of the form:</para>

			<programlisting language="cpp">#pragma TenDRA declaration block <replaceable>identifier</replaceable> begin
....
#pragma TenDRA declaration block end</programlisting>

			<para>This allows the sequence of declarations to be associated with the given
				<replaceable>identifier</replaceable> in the symbol dump file.	This technique is used
				in the API description files to aid analysis tools in determining
				which declarations are part of the API.</para>
		</section>

		<section>
			<title>Other identifier information</title>

			<para>Other information associated with an identifier may be expressed using
				other dump commands.	For example:</para>

			<programlisting language="bnf"><replaceable>override-command</replaceable> :
	O <replaceable>identifier identifier</replaceable></programlisting>

			<para>is used to express the fact that the two <replaceable>identifier</replaceable>s are virtual
				member functions, the first of which overrides the second.</para>

			<para>The command:</para>

			<programlisting language="bnf"><replaceable>base-command</replaceable> :
	B <replaceable>identifier-key identifier base-graph</replaceable>

<replaceable>base-graph</replaceable> :
	<replaceable>base-class</replaceable>
	<replaceable>base-class</replaceable> ( <replaceable>base-list</replaceable> )

<replaceable>base-class</replaceable> :
	<replaceable>number</replaceable> = V<replaceable>&opt.bnf; access&opt.bnf; type-name</replaceable>
	<replaceable>number</replaceable> :

<replaceable>base-list</replaceable> :
	<replaceable>base-graph base-list&opt.bnf;</replaceable></programlisting>

			<para>associates a base class graph with a class identifier.	Any class
				which does not have an associated <replaceable>base-command</replaceable> can be assumed
				to have no base classes.	Each node in the graph is a <replaceable>type-name</replaceable>
				with an associated list of base classes.	A <code>V</code> is used
				to indicate a virtual base class.	Each node is numbered; duplicate
				numbers are used to indicate bases identified via the virtual base
				class structure.	Any base class can then be referred to as:</para>

			<programlisting language="bnf"><replaceable>base-number</replaceable> :
	<replaceable>number</replaceable> : <replaceable>type-name</replaceable></programlisting>

			<para>indicating the base class with the given number in the given class.</para>

			<para>The command:</para>

			<programlisting language="bnf"><replaceable>api-command</replaceable> :
	X <replaceable>identifier-key identifier string</replaceable></programlisting>

			<para>associates the external token name given by the <replaceable>string</replaceable> with
				the given tokenised identifier.</para>

			<para>The command:</para>

			<programlisting language="bnf"><replaceable>template-command</replaceable> :
	Z <replaceable>identifier-key identifier token-application specialise-info</replaceable></programlisting>

			<para>is used to introduce an identifier corresponding to an instance of
				a template, <replaceable>token-application</replaceable>.	This instance may correspond
				to a specialisation of the primary template; this information is represented
				by:</para>

			<programlisting language="bnf"><replaceable>specialise-info</replaceable> :
	<replaceable>identifier</replaceable>
	<replaceable>token-application</replaceable>
	*</programlisting>

			<para>where <code>*</code> indicates a non-specialised instance.</para>
		</section>
	</section>

	<section>
		<title>Types</title>

		<para>The built-in types are represented in the symbol
			table dump as follows:</para>

		<table>
			<col align="left"/>
			<col align="center"/>
			<col align="center"/>
			<col align="left"/>
			<col align="center"/>

			<thead>
				<tr>
					<th>Type</th>
					<th>Encoding</th>
					<th role="gap"/>
					<th>Type</th>
					<th>Encoding</th>
				</tr>
			</thead>

			<tbody>
				<tr>
					<td><code>char</code></td>
					<td><code>c</code></td>
					<td role="gap"/>
					<td><code>float</code></td>
					<td><code>f</code></td>
				</tr>

				<tr>
					<td><code>signed char</code></td>
					<td><code>Sc</code></td>
					<td role="gap"/>
					<td><code>double</code></td>
					<td><code>d</code></td>
				</tr>

				<tr>
					<td><code>unsigned char</code></td>
					<td><code>Uc</code></td>
					<td role="gap"/>
					<td><code>long double</code></td>
					<td><code>r</code></td>
				</tr>

				<tr>
					<td><code>signed short</code></td>
					<td><code>s</code></td>
					<td role="gap"/>
					<td><code>void</code></td>
					<td><code>v</code></td>
				</tr>

				<tr>
					<td><code>unsigned short</code></td>
					<td><code>Us</code></td>
					<td role="gap"/>
					<td role="na">(bottom)</td>
					<td><code>u</code></td>
				</tr>

				<tr>
					<td><code>signed int</code></td>
					<td><code>i</code></td>
					<td role="gap"/>
					<td><code>bool</code></td>
					<td><code>b</code></td>
				</tr>

				<tr>
					<td><code>unsigned int</code></td>
					<td><code>Ui</code></td>
					<td role="gap"/>
					<td><code>ptrdiff_t</code></td>
					<td><code>y</code></td>
				</tr>

				<tr>
					<td><code>signed long</code></td>
					<td><code>l</code></td>
					<td role="gap"/>
					<td><code>size_t</code></td>
					<td><code>z</code></td>
				</tr>

				<tr>
					<td><code>unsigned long</code></td>
					<td><code>Ul</code></td>
					<td role="gap"/>
					<td><code>wchar_t</code></td>
					<td><code>w</code></td>
				</tr>

				<tr>
					<td><code>signed long long</code></td>
					<td><code>x</code></td>
					<td role="gap"/>
					<td role="na" align="center">&ndash;</td>
					<td role="na" align="center">&ndash;</td>
				</tr>

				<tr>
					<td><code>unsigned long long</code></td>
					<td><code>Ux</code></td>
					<td role="gap"/>
					<td role="na" align="center">&ndash;</td>
					<td role="na" align="center">&ndash;</td>
				</tr>
			</tbody>
		</table>

		<para>Named types (classes, enumeration types etc.) can be represented by
			the corresponding identifier or token application:</para>

		<programlisting language="bnf"><replaceable>type-name</replaceable> :
	<replaceable>identifier</replaceable>
	<replaceable>token-application</replaceable></programlisting>

		<para>Composite and qualified types are represented
			in terms of their subtypes as follows:</para>

		<table>
			<col align="left"/>
			<col align="left"/>

			<thead>
				<tr>
					<th>Type</th>
					<th>Encoding</th>
				</tr>
			</thead>

			<tbody>
				<tr>
					<td><code>const</code> type</td>
					<td><code>C</code> <replaceable>type</replaceable></td>
				</tr>

				<tr>
					<td><code>volatile</code> type</td>
					<td><code>V</code> <replaceable>type</replaceable></td>
				</tr>

				<tr>
					<td>pointer type</td>
					<td><code>P</code> <replaceable>type</replaceable></td>
				</tr>

				<tr>
					<td>reference type</td>
					<td><code>R</code> <replaceable>type</replaceable></td>
				</tr>

				<tr>
					<td>pointer to member type</td>
					<td><code>M</code> <replaceable>type-name</replaceable> <code>:</code> <replaceable>type</replaceable></td>
				</tr>

				<tr>
					<td>function type</td>
					<td><code>F</code> <replaceable>type parameter-types</replaceable></td>
				</tr>

				<tr>
					<td>array type</td>
					<td><code>A</code> <replaceable>nat&opt.bnf;</replaceable> <code>:</code> <replaceable>type</replaceable></td>
				</tr>

				<tr>
					<td>bitfield type</td>
					<td><code>B</code> <replaceable>nat</replaceable> <code>:</code> <replaceable>type</replaceable></td>
				</tr>

				<tr>
					<td>template type</td>
					<td><code>t</code> <replaceable>parameter-list&opt.bnf;</replaceable> <code>:</code> <replaceable>type</replaceable></td>
				</tr>

				<tr>
					<td>promotion type</td>
					<td><code>p</code> <replaceable>type</replaceable></td>
				</tr>

				<tr>
					<td>arithmetic type</td>
					<td><code>a</code> <replaceable>type</replaceable> <code>:</code> <replaceable>type</replaceable></td>
				</tr>

				<tr>
					<td>integer literal type</td>
					<td><code>n</code> <replaceable>lit-base&opt.bnf; lit-suffix&opt.bnf;</replaceable></td>
				</tr>

				<tr>
					<td>weak function prototype (C only)</td>
					<td><code>W</code> <replaceable>type parameter-types</replaceable></td>
				</tr>

				<tr>
					<td>weak parameter type (C only)</td>
					<td><code>q</code> <replaceable>type</replaceable></td>
				</tr>
			</tbody>
		</table>

		<para>Other types can be represented by their textual representation using
			the form <code>Q</code> <replaceable>string</replaceable>, or by <code>*</code>, indicating
			an unknown type.</para>

		<para>The parameter types for a function type are represented as follows:</para>

		<programlisting language="bnf"><replaceable>parameter-types</replaceable> :
	: <replaceable>exception-spec&opt.bnf; func-qualifier&opt.bnf;</replaceable> :
	. <replaceable>exception-spec&opt.bnf; func-qualifier&opt.bnf;</replaceable> :
	. <replaceable>exception-spec&opt.bnf; func-qualifier&opt.bnf;</replaceable> .
	, <replaceable>type parameter-types</replaceable></programlisting>

		<para>where the <code>::</code> form indicates that there are no further
			parameters, the <code>.:</code> form indicates that the parameters
			are terminated by an ellipsis, and the <code>..</code> form indicates
			that no information is available on the further parameters (this can
			only happen with non-prototyped functions in C).	The function qualifiers
			are given by:</para>

		<programlisting language="bnf"><replaceable>func-qualifier</replaceable> :
	C <replaceable>func-qualifier&opt.bnf;</replaceable>
	V <replaceable>func-qualifier&opt.bnf;</replaceable></programlisting>

<para>representing <code>const</code> and <code>volatile</code> member functions.
	The function exception specifier is given by:</para>

		<programlisting language="bnf"><replaceable>exception-spec</replaceable> :
	( <replaceable>exception-list&opt.bnf;</replaceable> )

<replaceable>exception-list</replaceable> :
	<replaceable>type</replaceable>
	<replaceable>type</replaceable> , <replaceable>exception-list</replaceable></programlisting>

		<para>with an absent exception specifier, as in C++, indicating that any
			exception may be thrown.</para>

		<para>Array and bitfield sizes are represented as follows:</para>

		<programlisting language="bnf"><replaceable>nat</replaceable> :
	+ <replaceable>number</replaceable>
	- <replaceable>number</replaceable>
	<replaceable>identifier</replaceable>
	<replaceable>token-application</replaceable>
	<replaceable>string</replaceable></programlisting>

		<para>where a <replaceable>string</replaceable> is used to hold a textual representation of
			complex values.</para>

		<para>Template types are represented by a list of template parameters, which
			will have previously been declared using the <code>XT</code> identifier
			key, followed by the underlying type expressed in terms of these parameters.
			The parameters are represented as follows:</para>

		<programlisting language="bnf"><replaceable>parameter-list</replaceable> :
	<replaceable>identifier</replaceable>
	<replaceable>identifier</replaceable> , <replaceable>parameter-list</replaceable></programlisting>

		<para>Integer literal types are represented by the value of the literal
			followed by a representation of the literal base and suffix.	These
			are given by:</para>

		<programlisting language="bnf"><replaceable>lit-base</replaceable> :
	O
	X</programlisting>

		<para>representing octal and hexadecimal literals respectively (decimal
			is the default), and:</para>

		<programlisting language="bnf"><replaceable>lit-suffix</replaceable> :
	U
	l
	Ul
	x
	Ux</programlisting>

		<para>representing the <code>U</code>, <code>L</code>, <code>UL</code>,
			<code>LL</code> and <code>ULL</code> suffixes respectively.</para>

		<para>Target dependent integral promotion types are represented using
			<code>p</code>, so for example the promotion of <code>unsigned short</code>
			is represented as <code>pUs</code>.	Information on the other cases,
			where the promotion type is known, can be given in a command of the
			form:</para>

		<programlisting language="bnf"><replaceable>promotion-command</replaceable> :
	P <replaceable>type</replaceable> : <replaceable>type</replaceable></programlisting>

		<para>Thus the fact that the promotion of <code>short</code> is <code>int</code>
			would be expressed by the command <code>Ps:i</code>.</para>
	</section>

	<section>
		<title>Sorts</title>

		<para>A <replaceable>sort</replaceable> in the symbol table dump corresponds to the sort of
			a token declared in the &pragmatoken.doc; <code>#pragma token</code>
			syntax.	Expression tokens are represented as follows:</para>

		<programlisting language="bnf"><replaceable>expression-sort</replaceable> :
	ZEL <replaceable>type</replaceable>
	ZER <replaceable>type</replaceable>
	ZEC <replaceable>type</replaceable>
	ZN</programlisting>

		<para>corresponding to <code>lvalue</code>, <code>rvalue</code> and
			<code>const</code> <code>EXP</code> tokens of the given type, and
			<code>NAT</code> or <code>INTEGER</code> tokens, respectively. Statement
			tokens are represent by:</para>

		<programlisting language="bnf"><replaceable>statement-sort</replaceable> :
	ZS</programlisting>

		<para>Type tokens are represented as follows:</para>

		<programlisting language="bnf"><replaceable>type-sort</replaceable> :
	ZTO
	ZTI
	ZTF
	ZTA
	ZTP
	ZTS
	ZTU</programlisting>

		<para>corresponding to <code>TYPE</code>, <code>VARIETY</code>, <code>FLOAT</code>,
			<code>ARITHMETIC</code>, <code>SCALAR</code>, <code>STRUCT</code>
			or <code>CLASS</code>, and <code>UNION</code> token respectively.	There
			are corresponding <code>TAG</code> forms:</para>

		<programlisting language="bnf"><replaceable>tag-type-sort</replaceable> :
	ZTTS
	ZTTU</programlisting>

		<para>Member tokens are represented using:</para>

		<programlisting language="bnf"><replaceable>member-sort</replaceable> :
	ZM <replaceable>type</replaceable> : <replaceable>type-name</replaceable></programlisting>

		<para>where the first type gives the member type and the second gives the
			parent structure or union type.</para>

		<para>Procedure tokens can be represented using:</para>

		<programlisting language="bnf"><replaceable>proc-sort</replaceable> :
	ZPG <replaceable>parameter-list&opt.bnf;</replaceable> ; <replaceable>parameter-list&opt.bnf;</replaceable> : <replaceable>sort</replaceable>
	ZPS <replaceable>parameter-list&opt.bnf;</replaceable> : <replaceable>sort</replaceable></programlisting>

		<para>The first form corresponds to the more general form of <code>PROC</code>
			token, that expressed using <code>{ .... | .... }</code>, which has
			separate lists of bound and program parameters.	These token parameters
			will have previously been declared using the <code>XP</code> identifier
			key.	The second form corresponds to the case where the bound and
			program parameter lists are equal, that expressed as a <code>PROC</code>
			token using <code>( .... )</code>.	A more specialised version of
			this second form is a <code>FUNC</code> token, which is represented
			as:</para>

		<programlisting language="bnf"><replaceable>func-sort</replaceable> :
	ZF <replaceable>type</replaceable></programlisting>

		<para>As noted above, template parameters are represented by a <replaceable>sort</replaceable>.
			Template type parameters are represented by <code>ZTO</code>, while
			template expression parameters are represent by <code>ZEC</code>
			(recall that such parameters are always constant expressions).	The
			remaining case, template template parameters, can be represented as:</para>

		<programlisting language="bnf"><replaceable>template-sort</replaceable> :
	ZTt <replaceable>parameter-list&opt.bnf;</replaceable> :</programlisting>

		<para>Finally, the number of parameters in a macro definition is represented
			by a <replaceable>sort</replaceable> of the form:</para>

		<programlisting language="bnf"><replaceable>macro-sort</replaceable> :
	ZUO
	ZUF <replaceable>number</replaceable></programlisting>

		<para>corresponding to a object-like macro and a function-like macro with
			the given number of parameters, respectively.</para>
	</section>

	<section>
		<title>Token applications</title>

		<para>Given an identifier representing a <code>PROC</code> token or a template,
			an application of that token or an instance of that template can be
			represented using:</para>

		<programlisting language="bnf"><replaceable>token-application</replaceable> :
	T <replaceable>identifier</replaceable> , <replaceable>token-argument-list</replaceable> :</programlisting>

		<para>where the token or template arguments are given by:</para>

		<programlisting language="bnf"><replaceable>token-argument-list</replaceable> :
	<replaceable>token-argument</replaceable>
	<replaceable>token-argument</replaceable> , <replaceable>token-argument-list</replaceable></programlisting>

		<para>Note that the case where there are no arguments is generally just
			represented by <replaceable>identifier</replaceable>; this case is specified separately
			in the rest of the grammar.</para>

		<para>A <replaceable>token-argument</replaceable> can represent a value of any of the sorts
			listed above: expressions, integer constants, statements, types, members,
			functions and templates.	These are given respectively by:</para>

		<programlisting language="bnf"><replaceable>token-argument</replaceable> :
	E <replaceable>expression</replaceable>
	N <replaceable>nat</replaceable>
	S <replaceable>statement</replaceable>
	T <replaceable>type</replaceable>
	M <replaceable>member</replaceable>
	F <replaceable>identifier</replaceable>
	C <replaceable>identifier</replaceable></programlisting>

		<para>where:</para>

		<programlisting language="bnf"><replaceable>expression</replaceable> :
	<replaceable>nat</replaceable>

<replaceable>statement</replaceable> :
	<replaceable>expression</replaceable>

<replaceable>member</replaceable> :
	<replaceable>identifier</replaceable>
	<replaceable>string</replaceable></programlisting>
	</section>

	<section>
		<title>Errors</title>

		<para>By default the error messages generated by the checker are
			written in a simple ascii form to stderr. If instead, the errors
			are written to the dump file using the <code>-sym:e</code> option
			mentioned above, an alternative lint-like error output may be
			generated by processing the dump files. The lint-like errors are
			enabled by passing the <code>-Ycompact</code> flag to tchk.</para>

		<para>Each error in the &tcpplus; &make_err; error catalogue is
			represented by a number.	These numbers happen to correspond to the
			position of the error within the catalogue, but in general this need
			not be the case.	The first use of each error introduces the error
			number by associating it with a <replaceable>string</replaceable> giving the error name.
			This has the form <code>cpp.</code><replaceable>error</replaceable> where <replaceable>error</replaceable>
			gives an error name from the C++ (<code>cpp</code>) error catalogue.
			Thus:</para>

		<programlisting language="bnf"><replaceable>error-name</replaceable> :
	<replaceable>number</replaceable> = <replaceable>string</replaceable>
	<replaceable>number</replaceable></programlisting>

		<para>Each error message written to the symbol table dump has the form:</para>

		<programlisting language="bnf"><replaceable>error-command</replaceable> :
	ES <replaceable>location error-info</replaceable>
	EW <replaceable>location error-info</replaceable>
	EI <replaceable>location error-info</replaceable>
	EF <replaceable>location error-info</replaceable>
	EC <replaceable>error-info</replaceable>
	EA <replaceable>error-argument</replaceable></programlisting>

		<para>denoting constraint errors, warnings, internal errors, fatal errors,
			continuation errors and error arguments respectively.	Note that an
			error message may consist of several components; the initial error
			plus a number of continuation errors.	Each error message may also
			have a number of error argument associated with it.	This error information
			is given by:</para>

		<programlisting language="bnf"><replaceable>error-info</replaceable> :
	<replaceable>error-name number number</replaceable></programlisting>

		<para>where the first <replaceable>number</replaceable> gives the number of error arguments
			which should be read, and the second is nonzero to indicate that a
			continuation error should be read.</para>

		<para>Each error argument has one of the forms:</para>

		<programlisting language="bnf"><replaceable>error-argument</replaceable> :
	B <replaceable>base-number</replaceable>
	C <replaceable>scope-identifier</replaceable>
	E <replaceable>expression</replaceable>
	H <replaceable>identifier-name</replaceable>
	I <replaceable>identifier</replaceable>
	L <replaceable>location</replaceable>
	N <replaceable>nat</replaceable>
	S <replaceable>string</replaceable>
	T <replaceable>type</replaceable>
	V <replaceable>number</replaceable>
	V - <replaceable>number</replaceable></programlisting>

		<para>corresponding to the various syntactic categories described above.
			Note that a <replaceable>location</replaceable> error argument, while expressed relative
			to the current file location, does not change this
			location.</para>
	</section>

	<section>
		<title>File inclusions</title>

		<para>It is possible to include information on header files within the symbol
			table dump.	Firstly a number is associated with each directory on
			the <code>#include</code> search path:</para>

		<programlisting language="bnf"><replaceable>path-command</replaceable> :
	FD <replaceable>number</replaceable> = <replaceable>string string&opt.bnf;</replaceable></programlisting>

		<para>The first <replaceable>string</replaceable> gives the directory pathname; the second,
			if present, gives the associated directory name as specified in the
			<code>-N</code> command-line option.</para>

		<para>Now the start and end of each file are marked using:</para>

		<programlisting language="bnf"><replaceable>file-command</replaceable> :
	FS <replaceable>location directory</replaceable>
	FE <replaceable>location</replaceable></programlisting>

		<para>where <replaceable>directory</replaceable> gives the number of the directory in the search
			path where the file was found, or <code>*</code> if the file was found
			by other means.	It is worth noting that if, for example, a function
			definition is the last item in a file, the <code>FE</code> command
			will appear in the symbol table dump before the <code>QFE</code> command
			for the end of the function definition.	This is because lexical analysis,
			where the end of file is detected, takes place before parsing, where
			the end of function is detected.</para>

		<para>A <code>#include</code> directive, whether explicit or implicit, can
			be represented using:</para>

		<programlisting language="bnf"><replaceable>include-command</replaceable> :
	FIA <replaceable>location string</replaceable>
	FIQ <replaceable>location string</replaceable>
	FIN <replaceable>location string</replaceable>
	FIS <replaceable>location string</replaceable>
	FIE <replaceable>location string</replaceable>
	FIR <replaceable>location</replaceable></programlisting>

		<para>the first three corresponding to header names of the forms
			<code>&lt;....&gt;</code>, <code>&quot;....&quot;</code> and <code>[....]</code>
			respectively, the next two corresponding to start-up and end-up files, and the final form
			being used to resume the original file after the <code>#include</code>
			directive has been processed.</para>
	</section>

	<section>
		<title>String literals</title>

		<para>It is possible to dump information on string literals to the symbol
			table dump file using the commands:</para>

		<programlisting language="bnf"><replaceable>string-command</replaceable> :
	A <replaceable>location string</replaceable>
	AC <replaceable>location string</replaceable>
	AL <replaceable>location string</replaceable>
	ACL <replaceable>location string</replaceable></programlisting>

		<para>representing string literals, character literals, wide string literals
			and wide character literals respectively.
			The given <replaceable>string</replaceable> gives the string text.</para>
	</section>

</article>

