<?xml version="1.0"?>
<!DOCTYPE chapter SYSTEM "minidocbook.dtd">

<chapter>
	<title>Data Flow and Variable Analysis</title>

	<para>The checker has a number of features which can be used to help track
		down potential programming errors relating to the use of variables
		within a source file and the flow of control through the program.
		Examples of this are detecting sections of unused code, flagging
		expressions that depend upon the order of evaluation where the order is
		not defined, checking for unused static variables, etc.</para>

	<section id="unreachable">
		<title>Unreachable code analysis</title>

		<para>Consider the following function definition:</para>

		<programlisting language="c">int f ( int n )
{
	if ( n ) {
		return ( 1 );
	} else {
		return ( 0 );
	}
	return ( 2 );
}
</programlisting>

		<para>The final return statement is redundant since it can never be reached. The test for unreachable code is controlled by:</para>

		<programlisting language="c">#pragma TenDRA unreachable code <emphasis>permit</emphasis></programlisting>

		<para>where <emphasis>permit</emphasis> is replaced by <code>disallow</code>
			to give an error if unreached code is detected, <code>warning</code>
			to give a warning, or <code>allow</code> to disable the test (this is the
			default).</para>

		<para>There are also equivalent command-line options to tchk of the
			form <code>-X:unreached=</code><code>state</code>, where
			<code>state</code> can be <code>check</code>, <code>warn</code> or
			<code>dont</code>.</para>

		<para>Annotations to the code in the form of user-defined keywords may
			be used to indicate that a certain statement is genuinely reached
			or unreached. These keywords are introduced using:</para>

		<programlisting language="c">#pragma TenDRA keyword REACHED for set reachable
#pragma TenDRA keyword UNREACHED for set unreachable</programlisting>

		<para>The statement <code>REACHED</code> then indicates that this
			portion of the program is actually reachable, whereas
			<code>UNREACHED</code> indicates that it is unreachable.
			For example, one way of fixing the program above
			might be to say that the final return is reachable (this is a
			blatant lie, but never mind). This would be done as follows:</para>

		<programlisting language="c">int f ( int n ) {
	if ( n ) {
		return ( 1 );
	} else {
		return ( 0 );
	}
	REACHED
	return ( 2 );
}
</programlisting>

		<para>An example of the use of <code>UNREACHED</code> might be
			in the function below which falls out of the bottom without a
			return statement. We might know that, because it is never
			called with c equal to zero, the end of the function is never
			reached. This could be indicated as follows:</para>

		<programlisting language="c">int f ( int c ) {
	if ( c ) return ( 1 );
	UNREACHED
}</programlisting>

		<para>As always, if new keywords are introduced into a program then
			definitions need to be provided for conventional compilers. In this
			case, this can be done as follows:</para>

		<programlisting language="c">#ifdef __TenDRA__
#pragma TenDRA keyword REACHED for set reachable
#pragma TenDRA keyword UNREACHED for set unreachable
#else
#define REACHED
#define UNREACHED
#endif</programlisting>
	</section>

	<section>
		<title>Case fall through</title>

		<para>Another flow analysis check concerns fall through in case
			statements. For example, in:</para>

		<programlisting language="c">void f ( int n )
{
	switch ( n ) {
		case 1 : puts ( "one" );
		case 2 : puts ( "two" );
	}
}</programlisting>

		<para>the control falls through from the first case to the second. This
			may be due to an error in the program (a missing break statement),
			or be deliberate. Even in the latter case, the code is not
			particularly maintainable as it stands - there is always the risk
			when adding a new case that it will interrupt this carefully
			contrived flow. Thus it is customary to comment all case fall
			throughs to serve as a warning.</para>

		<para>In the default mode, the TenDRA C checker ignores all such fall
			throughs. A check to detect fall through in case statements is
			controlled by:</para>

		<programlisting language="c">#pragma TenDRA fall into case <emphasis>permit</emphasis></programlisting>

		<para>where <emphasis>permit</emphasis> is <code>allow</code> (no
			errors), <code>warning</code> (warn about case fall through)
			or <code>disallow</code> (raise errors for case fall through).</para>

		<para>There are also equivalent command-line options to tcc of the
			form -<code>X:fall_thru=</code><code>state</code>, where
			<code>state</code> can be <code>check</code>, <code>warn</code> or
			<code>dont</code>.</para>

		<para>Deliberate case fall throughs can be indicated by means of a
			keyword, which has been introduced using:</para>

		<programlisting language="c">#pragma TenDRA keyword FALL_THROUGH for fall into case</programlisting>

		<para>Then, if the example above were deliberate, this could be indicated by:</para>

		<programlisting language="c">void f ( int n ) {
	switch ( n ) {
		case 1 : puts ( "one" );
		FALL_THROUGH
		case 2 : puts ( "two" );
	}
}</programlisting>

		<para>Note that <code>FALL_THROUGH</code> is inserted between the two
			cases, rather than at the end of the list of statements following
			the first case.</para>

		<para>If a keyword is introduced in this way, then an alternative
			definition needs to be introduced for conventional compilers. This
			might be done as follows:</para>

	<programlisting language="c">#ifdef __TenDRA__
#pragma TenDRA keyword FALL_THROUGH for fall into case
#else
#define FALL_THROUGH
#endif</programlisting>
	</section>

	<section>
		<title>Unusual flow in conditional statements</title>

		<para>The following three checks are designed to detect possible errors
			in conditional statements.</para>

		<section>
			<title>Empty if statements</title>

			<para>Consider the following C statements:</para>

			<programlisting language="c">if ( var1 == 1 ) ;
	var2 = 0 ;</programlisting>

			<para>The conditional statement serves no purpose here and the
				second statement will always be executed regardless of the
				value of var1. This is almost certainly not what the programmer
				intended to write. A test for if statements with no body is
				controlled by:</para>

			<programlisting language="c">#pragma TenDRA extra ; after conditional <emphasis>permit</emphasis></programlisting>

			<para>with the usual <code>allow</code> (this is the default setting),
				<code>warning</code> and <code>disallow</code> options for
				<emphasis>permit</emphasis>.</para>
		</section>

		<section id="uoaace">
			<title>Use of assignments as control expressions</title>

			<para>Using the C assignment operator, <code>=</code>, when the
				equality operator <code>==</code> was intended is an extremely
				common problem. The pragma:</para>

			<programlisting language="c">#pragma TenDRA assignment as bool <emphasis>permit</emphasis></programlisting>

			<para>is used to control the treatment of assignments used as the
				controlling expression of a conditional statement or a loop,
				e.g.</para>

			<programlisting language="c">if( var = 1 ) { ...</programlisting>

			<para>The options for <emphasis>permit</emphasis> are <code>allow</code>,
				<code>warning</code> and <code>disallow</code>. The default
				setting allows assignments to be used as control statements
				without raising an error.</para>
		</section>

		<section>
			<title>Constant control expressions</title>

			<para>Statements with constant control expressions are not really
				conditional at all since the value of the control statement can
				be evaluated statically. Although this feature is sometimes
				used in loops, relying on a break, goto or return statement to
				end the loop, it may be useful to detect all constant control
				expressions to check that they are deliberate. The check for
				statically constant control expressions is controlled using:</para>

			<programlisting language="c">#pragma TenDRA const conditional <emphasis>permit</emphasis></programlisting>

			<para>where <emphasis>permit</emphasis> may be replaced by
				<code>disallow</code> to give an error when constant control
				expressions are encountered, <code>warning</code> to replace
				the error by a warning, or the check may be switched off using
				<code>allow</code> (this is the default).</para>
		</section>
	</section>

	<section id="if">
		<title>Conditional and iteration statements</title>

		<para>The directive:</para>

		<programlisting language="cpp">#pragma TenDRA const conditional <emphasis>allow</emphasis></programlisting>

		<para>can be used to enable a check for constant expressions used in conditional
			contexts.	A literal constant is allowed in the condition of a <code>while
			</code>, <code>for</code> or <code>do</code> statement to allow for
			such common constructs as:</para>

		<programlisting language="cpp">while ( true ) {
	// while statement body
}</programlisting>

		<para>and target dependent constant expressions are allowed in the condition
			of an <code>if</code> statement, but otherwise constant conditions
			are reported according to the status of this check.</para>

		<para>The common error of writing <code>=</code> rather than <code>==</code>
			in conditions can be detected using the directive:</para>

		<programlisting language="cpp">#pragma TenDRA assignment as bool <emphasis>allow</emphasis></programlisting>

		<para>which can be used to disallow such assignment expressions in contexts
			where a boolean is expected.	The error message can be suppressed
			by enclosing the assignment within parentheses.</para>

		<para>Another common error associated with iteration statements, particularly
			with certain brace styles, is the
			accidental insertion of an extra semicolon as in:</para>

		<programlisting language="cpp">for ( init ; cond ; step ) ;
{
	// for statement body
}</programlisting>

		<para>The directive:</para>

		<programlisting language="cpp">#pragma TenDRA extra ; after conditional <emphasis>allow</emphasis></programlisting>

		<para>can be used to enable a check for such suspicious empty iteration
			statement bodies (it actually checks for <code>;{</code>).</para>
	</section>

	<section>
		<title>Operator precedence</title>

		<para>The ISO C standard section 6.3, provides a set of rules governing
			the order in which operators within expressions should be applied.
			These rules are said to specify the operator precedence and are
			summarised in the table over the page. Operators on the same line
			have the same precedence and the rows are in order of decreasing
			precedence. Note that the unary <code>+</code>, <code>-</code>,
			<code>*</code> and <code>&amp;</code> operators have higher
			precedence than the binary forms and thus appear higher in the
			table.</para>

		<para>The precedence of operators is not always intuitive and often
			leads to unexpected results when expressions are evaluated. A
			particularly common example is to write:</para>

		<programlisting language="c">if ( var &amp; TEST == 1) { ...
}
else { ...
</programlisting>

		<para>assuming that the control expression will be evaluated as:</para>

		<programlisting language="c">( ( var &amp; TEST ) == 1 )</programlisting>

		<para>However, the <code>==</code> operator has a higher precedence
			than the bitwise <code>&amp;</code> operator and the control
			expression is evaluated as:</para>

		<programlisting language="c">( var &amp; ( TEST == 1 ) )</programlisting>

		<para>which in general will give a different result.</para>

		<table>
			<title>ISO C Rules for Operator Precedence</title>

			<col align="left"/>
			<col align="left"/>

			<thead>
				<tr>
					<th>Operators</th>
					<th>Precedence</th>
				</tr>
			</thead>

			<tbody>
				<tr>
					<td>
						<code><emphasis>function call</emphasis>()</code> <code>[]</code>
						<code>-&gt;</code> <code>.</code>
						<code>++<emphasis>(postfix)</emphasis></code>
						<code>--<emphasis>(postfix)</emphasis></code></td>
					<td>highest</td>
				</tr>

				<tr>
					<td>
						<code>!</code> <code>~</code> <code>++</code> <code>--</code>
						<code>+</code> <code>-</code> <code>*</code> <code>&amp;</code>
						<code>(<emphasis>type</emphasis>)</code> <code>sizeof</code></td>
					<td/>
				</tr>

				<tr>
					<td>
						<code>*</code> <code>/</code> <code>%</code></td>
					<td/>
				</tr>

				<tr>
					<td>
						<code>+</code><emphasis>(binary)</emphasis>
						<code>-</code><emphasis>(binary)</emphasis></td>
					<td/>
				</tr>

				<tr>
					<td>
						<code>&lt;&lt;</code> <code>&gt;&gt;</code></td>
					<td/>
				</tr>

				<tr>
					<td>
						<code>&lt;</code> <code>&lt;=</code> <code>&gt;</code> <code>&gt;=</code></td>
					<td/>
				</tr>

				<tr>
					<td>
						<code>==</code> <code>!=</code></td>
					<td/>
				</tr>

				<tr>
					<td>
						<code>&amp;</code></td>
					<td/>
				</tr>

				<tr>
					<td>
						<code>^</code></td>
					<td/>
				</tr>

				<tr>
					<td>
						<code>|</code></td>
					<td/>
				</tr>

				<tr>
					<td>
						<code>&amp;&amp;</code></td>
					<td/>
				</tr>

				<tr>
					<td>
						<code>||</code></td>
					<td/>
				</tr>

				<tr>
					<td>
						<code>?:</code></td>
					<td/>
				</tr>

				<tr>
					<td>
						<code>=</code> <code>+=</code> <code>-=</code> <code>*=</code>
						<code>/=</code> <code>%=</code> <code>&amp;=</code> <code>^=</code>
						<code>|=</code> <code>&lt;&lt;=</code> <code>&gt;&gt;=</code></td>
					<td/>
				</tr>

				<tr>
					<td>,</td>
					<td>lowest</td>
				</tr>
			</tbody>
		</table>

		<para>The TenDRA C checker can be configured to flag expressions
			containing certain operators whose precedence is commonly confused,
			namely:</para>

		<itemizedlist>
			<listitem>
				<para><code>&amp;&amp;</code> <emphasis>versus</emphasis>
					<code>||</code></para>
			</listitem>

			<listitem>
				<para><code>&lt;&lt;</code> <emphasis>and</emphasis>
					<code>&gt;&gt;</code> <emphasis>versus</emphasis>
					<code>+</code> <emphasis>and</emphasis> <code>-</code></para>
			</listitem>

			<listitem>
				<para><code>&amp;</code> <emphasis>versus</emphasis> <code>==</code>
					<code>!=</code> <code>&lt;</code> <code>&gt;</code>
					<code>&lt;=</code> <code>&gt;=</code> <code>+</code>
					<emphasis>and</emphasis> <code>-</code></para>
			</listitem>

			<listitem>
				<para><code>^</code> <emphasis>versus</emphasis> <code>&amp;</code>
					<code>==</code> <code>|=</code> <code>&lt;</code> <code>&gt;</code>
					<code>&lt;=</code> <code>&gt;=</code> <code>+</code>
					<emphasis>and</emphasis> <code>-</code></para>
			</listitem>

			<listitem>
				<para><code>|</code> <emphasis>versus</emphasis> <code>^</code>
					<code>&amp;</code> <code>==</code> <code>|=</code>
					<code>&lt;</code> <code>&gt;</code> <code>&lt;=</code>
					<code>&gt;=</code> <code>+</code> <emphasis>and</emphasis>
					<code>-</code></para>
			</listitem>
		</itemizedlist>

		<para>The check is switched off by default. The the directive:</para>

		<programlisting language="cpp">#pragma TenDRA operator precedence analysis <emphasis>on</emphasis></programlisting>

		<para>can be used to enable a check for expressions where the operator precedence
			is not necessarily what might be expected.	The intended precedence
			can be clarified by means of explicit parentheses.	The precedence
			levels checked are as follows:</para>

		<itemizedlist>
			<listitem>
				<para><code>&amp;&amp;</code> versus <code>||</code>.</para>
			</listitem>

			<listitem>
				<para><code>&lt;&lt;</code> and <code>&gt;&gt;</code> versus binary
					<code>+</code> and <code>-</code>.</para>
			</listitem>

			<listitem>
				<para>Binary <code>&amp;</code> versus binary <code>+</code>,		 <code>-</code>,
					<code>==</code>, <code>!=</code>, <code>&gt;</code>,		 <code>&gt;=</code>,
					<code>&lt;</code> and <code>&lt;=</code>.</para>
			</listitem>

			<listitem>
				<para><code>^</code> versus binary <code>&amp;</code>, <code>+</code>,
					<code>-</code>, <code>==</code>, <code>!=</code>, <code>&gt;</code>,
					<code>&gt;=</code>, <code>&lt;</code> and <code>&lt;=</code>.</para>
			</listitem>

			<listitem>
				<para><code>|</code> versus binary <code>^</code>, <code>&amp;</code>,
					<code>+</code>, <code>-</code>, <code>==</code>, <code>!=</code>,
					<code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code> and
					<code>&lt;=</code>.</para>
			</listitem>
		</itemizedlist>

		<para>Also checked are expressions such as <code>a &lt; b &lt; c</code>
			which do not have their normal mathematical meaning.	For example,
			in:</para>

		<programlisting language="cpp">d = a &lt;&lt; b + c ;	// precedence is a &lt;&lt; ( b + c )</programlisting>

		<para>the precedence is counter-intuitive, although strangely enough, it
			isn't in:</para>

		<programlisting language="cpp">cout &lt;&lt; b + c ;		// precedence is cout &lt;&lt; ( b + c )</programlisting>

		<para>Other dubious arithmetic operations can be checked for using the directive:</para>

		<programlisting language="cpp">#pragma TenDRA integer operator analysis <emphasis>on</emphasis></programlisting>

		<para>This includes checks for operations, such as division by a negative
			value, which are implementation dependent, and those such as testing
			whether an unsigned value is less than zero, which serve no purpose.
			Similarly the directive:</para>

		<programlisting language="cpp">#pragma TenDRA++ pointer operator analysis <emphasis>on</emphasis></programlisting>

		<para>checks for dubious pointer operations.	This includes very simple
			bounds checking for arrays and checking that only the simple literal
			<code>0</code>
			is used in null pointer constants:</para>

		<programlisting language="cpp">char *p = 1 - 1 ;	// valid, but weird</programlisting>

		<para>The directive:</para>

		<programlisting language="cpp">#pragma TenDRA integer overflow analysis <emphasis>on</emphasis></programlisting>

		<para>is used to control the treatment of overflows in the evaluation of
			integer constant expressions.	This includes the detection of division
			by zero.</para>
	</section>

	<section>
		<title>Variable analysis</title>

		<para>The variable analysis checks are controlled by:</para>

		<programlisting language="c">#pragma TenDRA variable analysis status</programlisting>

		<para>Where <emphasis>status</emphasis> is <code>on</code>,
			<code>warning</code> or <code>off</code> as usual. The checks are
			switched off in the default mode.</para>

		<para>There are also equivalent command line options to tchk of the
			form <code>-X:variable=</code><code>state</code>, where
			<code>state</code> can be <code>check</code>, <code>warn</code> or
			<code>dont</code>.</para>

		<para>The variable analysis is concerned with the evaluation of
			expressions and the use of local variables, including function
			arguments. Occasionally it may not be possible to statically
			perform a full analysis on an expression or variable and in these
			cases the messages produced indicate that there may be a problem.
			If a full analysis is possible a definite error or warning is
			produced. The individual checks are listed in sections 5.6.1 to
			5.6.6 and section 5.7 describes the source annotations which can be
			used to fine-tune the variable analysis.</para>

		<section>
			<title>Order of evaluation</title>

			<para>The ISO C standard specifies certain points in the expression
				syntax at which all prior expressions encountered are
				guaranteed to have been evaluated. These positions are called
				sequence points and occur:</para>

			<itemizedlist>
				<listitem>
					<para>after the arguments and function expression of a function call
						have been evaluated but before the call itself;</para>
				</listitem>

				<listitem>
					<para>after the first operand of a logical &amp;&amp;, or ||
						operator;</para>
				</listitem>

				<listitem>
					<para>after the first operand of the conditional operator, ?:;</para>
				</listitem>

				<listitem>
					<para>after the first operand of the comma operator;</para>
				</listitem>

				<listitem>
					<para>at the end of any full expression (a full expression may take
						one of the following forms: an initialiser; the expression in an
						expression statement; the controlling expression in an
						<code>if</code>, <code>while</code>, <code>do</code> or
						<code>switch</code> statement; each of the three optional
						expressions of a <code>for</code> statement; or the optional
						expression of a <code>return</code> statement).</para>
				</listitem>
			</itemizedlist>

			<para>Between two sequence points however, the order in which the
				operands of an operator are evaluated, and the order in which
				side effects take place is unspecified - any order which
				conforms to the operator precedence rules above is permitted.
				For example:</para>
			<!-- TODO not true, is it? this is UB, not unspecified -->

			<programlisting language="c">var = i + arr[ i++ ] ;</programlisting>

			<para>may evaluate to different values on different machines,
				depending on which argument of the <code>+</code> operator is
				evaluated first. The checker can detect expressions which
				depend on the order of evaluation of sub-expressions between
				sequence points and these are flagged as errors or warnings
				when the variable analysis is enabled.</para>
		</section>

		<section>
			<title>5.6.2 Modification between sequence points</title>

			<para>The ISO C standard states that if an object is modified more
				than once, or is modified and accessed other than to determine
				the new value, between two sequence points, then the behaviour
				is undefined. Thus the result of:</para>

			<programlisting language="c">var = arr[i++] + i++ ;</programlisting>

			<para>is undefined, since the value of i is being incremented twice
				between sequence points. This behaviour is detected by the
				variable analysis.</para>
		</section>

		<section>
			<title>Operand of <code>sizeof</code></title>

			<para>According to the ISO C standard, section 6.3.3.4, the operand
				of the <code>sizeof</code> operator is not itself evaluated. If
				the operand has any side-effects these will not occur. When the
				variable analysis is enabled, the checker detects the use of
				expressions with side-effects in the operand of the sizeof
				operator.</para>
		</section>

		<section>
			<title>Unused variables</title>

			<para>As part of the variable analysis, a simple test applied to
				each local variable at the end of its scope to determine
				whether it has been used in that scope. For example,
				in:</para>

			<programlisting language="c">int f ( int n )
{
	int r;
	return ( 0 );
}</programlisting>

			<para>both the function argument <code>n</code> and the local
				variable <code>r</code> are unused.</para>
		</section>

		<section>
			<title>Values set and not used</title>

			<para>This is a more complex test since it is applied to every
				instance of setting the variable. For example, in:</para>

			<programlisting language="c">int f ( int n )
{
	int r = 1;
	r = 5;
	return ( r );
}</programlisting>

			<para>the first value <code>r</code> is set to <code>1</code> and
				is not used before it is overwritten by <code>5</code> (this
				second value is used however). This test requires some flow
				analysis. For example, if the program is modified to:</para>

			<programlisting language="c">int f ( int n )
{
	int r = 1;
	if ( n == 3 ) {
		r = 5;
	}
	return ( r );
}</programlisting>

			<para>the initial value of <code>r</code> is used when
				<code>n != 3</code>, so no error is detected. However in:</para>

			<programlisting language="c">int f ( int n )
{
	int r = 1;
	if ( n == 3 ) {
		r = 5;
	} else {
		r = 6;
	}
	return ( r );
}
</programlisting>

			<para>the initial value of r is overwritten regardless of the
				result of the conditional, and hence is unused.</para>
		</section>

		<section>
			<title>Variable which has not been set is used</title>

			<para>This test also requires some flow analysis, for example
				in:</para>

			<programlisting language="c">int f ( int n )
{
	int r;
	if ( n == 3 ) {
		r = 5;
	}
	return ( r );
}</programlisting>

			<para>the use of the variable <code>r</code> as a return value is
				reported because there are paths leading to this statement in
				which <code>r</code> is not set (i.e. when <code>n != 3</code>).
				However, in:</para>

			<programlisting language="c">int f ( int n )
{
	int r;
	if ( n == 3 ) {
		r = 5;
	} else {
		r = 6;
	}
	return ( r );
}</programlisting>

			<para>r is always set before it is used, so no error is
				detected.</para>
		</section>
	</section>

	<section>
		<title>Overriding the variable analysis</title>

		<para>Although many of the problems discovered by the variable analysis
			are genuine mistakes, some may be as the result of deliberate
			decisions by the program writer. In this case, more information
			needs to be provided to the checker to convey the programmer's
			intentions. Four constructs are provided for this purpose: the
			discard variable, the set variable, the exhaustive switch and the
			non-returning function.</para>

		<section>
			<title>5.7.1 Discarding variables</title>

			<para>Actively discarding a variable counts as a use of that
				variable in the variable analysis, and so can be used to
				suppress messages concerning unused variables and values
				assigned to variables. There are two distinct methods to
				indicate that the variable x is to be discarded. The first
				uses a pragma:</para>

			<programlisting language="c">#pragma TenDRA discard x;</programlisting>

			<para>which the checker treats as if it were a C statement, ending
				in a semicolon. Having a statement which is noticed by one
				compiler but ignored by another can lead to problems. For
				example, in:</para>

			<programlisting language="c">if ( n == 3 )
#pragma TenDRA discard x;
	puts ( "n is three" );</programlisting>

			<para>tchk believes that <code>x</code> is discarded if
				<code>n == 3</code> and the message is always printed,
				whereas other compilers will ignore the <code>#pragma</code>
				statement and think that the message is printed if
				<code>n == 3</code>. An alternative, in many ways neater,
				solution is to introduce a new keyword for discarding
				variables. For example, to introduce the keyword
				<code>DISCARD</code> for this purpose, the pragma:</para>

			<programlisting language="c">#pragma TenDRA keyword DISCARD for discard variable</programlisting>

			<para>should be used. The variable <code>x</code> can then be
				discarded by means of the statement:</para>

			<programlisting language="c">DISCARD ( x );</programlisting>

			<para>A dummy definition for <code>DISCARD</code> to use with
				normal compilers needs to be given in order to maintain
				compilability with those compilers. For example, a complete
				definition of <code>DISCARD</code> might be:</para>

			<programlisting language="c">#ifdef __TenDRA__
#pragma TenDRA keyword DISCARD for discard variable
#else
#define DISCARD(x) (( void ) 0 )
#endif</programlisting>
			<!-- XXX surely ((void)x) (though that would have side-effects);
				sizeof(x) might be better, or simply to do nothing -->

			<para>Discarding a variable changes its assignment state to unset,
				so that any subsequent uses of the variable, without an
				intervening assignment to it, lead to a <quote>variable used
				before being set</quote> error. This feature can be exploited if the same variable is used for distinct purposes in different parts of its scope, by causing the variable analysis to treat the different uses separately. For example, in:</para>

			<programlisting language="c">void f ( void )
{
	int i = 0;
	while ( i++ &lt; 10 ) {
		puts ( "hello" );
	}
	while ( i++ &lt; 10 ) {
		puts ( "goodbye" );
	}
}</programlisting>

			<para>which is intended to print both messages ten times, the two
				uses of <code>i</code> as a loop counter are independent - they
				could have been implemented with different variables. By
				discarding <code>i</code> after the first loop, the second loop
				can be analysed separately. In this way, the error of failing
				to reset <code>i</code> to <code>0</code> can be detected.</para>
		</section>

		<section>
			<title>Setting variables</title>

			<para>In addition to discarding variables, it is also possible to
				set them. In deliberately setting a variable, the programmer is
				telling the checker to assume that some value will always have
				been assigned to the variable by that point, so that any
				<quote>variable used without being set</quote> errors can be
				suppressed. This construct is particularly useful in programs
				with complex flow control, to help out the variable analysis.
				For example, in:</para>

			<programlisting language="c">void f ( int n )
{
	int r;
	if ( n != 0 ) r = n;
	if ( n &gt; 2 ) {
		printf ( "%d\n", r );
	}
}</programlisting>

			<para><code>r</code> is only used if <code>n > 2</code>, in which
				case we also have <code>n != 0</code>, so that <code>r</code>
				has already been initialised. However, in its flow analysis,
				the TenDRA C checker treats all the conditionals it meets as
				if they were independent and does not look for any such complex
				dependencies (indeed it is possible to think of examples where
				such analysis would be impossible). Instead, it needs the
				programmer to clarify the flow of the program by asserting that
				<code>r</code> will be set if the second condition is true.</para>

			<para>Programmers may assert that the variable, <code>r</code>, is
				set either by means of a pragma:</para>

			<programlisting language="c">#pragma TenDRA set r;</programlisting>

			<para>or by using, for example:</para>

			<programlisting language="c">SET ( r );</programlisting>

			<para>where SET is a keyword which has previously been introduced
				to stand for the variable setting construct using:</para>

			<programlisting language="c">#pragma TenDRA keyword SET for set</programlisting>

			<para>(cf. <code>DISCARD</code> above).</para>
		</section>

		<section>
			<title>Exhaustive switch statements</title>

			<para>A special case of a flow control construct which may be used
				to set the value of a variable is a switch statement. Consider
				the program:</para>

			<programlisting language="c">char *f ( int n )
{
	char *r;
	switch ( n ) {
		case 1 : r = "one"; break;
		case 2 : r = "two"; break;
		case 3 : r = "three"; break;
	}
	return ( r );
}</programlisting>

			<para>This leads to an error indicating that <code>r</code> is used
				but not set, because it is not set if n lies outside the three
				cases in the switch statement. However, the programmer might
				know that <code>f</code> is only ever called with these three
				values, and hence that <code>r</code> is always set before it
				is used. This information could be expressed by asserting that
				<code>r</code> is set at the end of the switch construct (see
				above), but it would be better to express the cause of this
				setting rather than just its effect. The reason why
				<code>r</code> is always set is that the switch statement is
				exhaustive - there are case statements for all the possible
				values of <code>n</code>.</para>

			<para>Programmers may assert that a switch statement is exhaustive
				by means of a pragma immediately following it. For example, in
				the above case it would take the form:</para>

			<programlisting language="c">....
switch ( n )
#pragma TenDRA exhaustive
{
	case 1 : r = "one"; break;
	....</programlisting>

			<para>Again, there is an option to introduce a keyword,
				<code>EXHAUSTIVE</code> say, for exhaustive switch statements
				using:</para>

			<programlisting language="c">#pragma TenDRA keyword EXHAUSTIVE for exhaustive</programlisting>

			<para>Using this form, the example program becomes:</para>

			<programlisting language="c">switch ( n ) EXHAUSTIVE {
	case 1 : r = "one"; break;</programlisting>

			<para>In order to maintain compatibility with existing compilers,
				a dummy definition for <code>EXHAUSTIVE</code> must be
				introduced for them to use. For example, a complete definition
				of <code>EXHAUSTIVE</code> might be:</para>

			<programlisting language="c">#ifdef __TenDRA__
#pragma TenDRA keyword EXHAUSTIVE for exhaustive
#else
#define EXHAUSTIVE
#endif</programlisting>
		</section>

	<section id="switch">
		<title>Switch statements</title>

		<para>A <code>switch</code> statement is said to be exhaustive if its control
			statement is guaranteed to take one of the values of its
			<code>case</code> labels, or if it has a <code>default</code> label.
			The TenDRA C and C++ producers allow a <code>switch</code> statement
			to be asserted to be exhaustive using the syntax:</para>

		<programlisting language="cpp">switch ( cond ) EXHAUSTIVE {
	// switch statement body
}</programlisting>

		<para>where <code>EXHAUSTIVE</code> is either the directive:</para>

		<programlisting language="cpp">#pragma TenDRA exhaustive</programlisting>

		<para>or a keyword introduced using:</para>

		<programlisting language="cpp">#pragma TenDRA keyword <emphasis>identifier</emphasis> for exhaustive</programlisting>

		<para>Knowing whether a <code>switch</code> statement is exhaustive or not
			means that checks relying on flow analysis (including variable usage
			checks) can be applied more precisely.</para>

		<para>In certain circumstances it is possible to deduce whether a
			<code>switch</code> statement is exhaustive or not.	For example,
			the directive:</para>

		<programlisting language="cpp">#pragma TenDRA enum switch analysis <emphasis>on</emphasis></programlisting>

		<para>enables a check on <code>switch</code> statements on values of enumeration
			type.	Such statements should be exhaustive, either explicitly by
			using the <code>EXHAUSTIVE</code> keyword or declaring a
			<code>default</code> label, or implicitly by having a <code>case</code>
			label for each enumerator.	Conversely, the value of each <code>case</code>
			label should equal the value of an enumerator.	For the purposes of
			this check, boolean values are treated as if they were declared using
			an enumeration type of the form:</para>

		<programlisting language="cpp">enum bool { false = 0, true = 1 } ;</programlisting>

		<para>A common source of errors in <code>switch</code> statements is the
			fall-through from one <code>case</code> or <code>default</code>
			statement to the next.	A check for this can be enabled using:</para>

		<programlisting language="cpp">#pragma TenDRA fall into case <emphasis>allow</emphasis></programlisting>

		<para><code>case</code> or <code>default</code> labels where fall-through
			from the previous statement is intentional can be marked by preceding
			them by a keyword, <code>FALL_THRU</code> say, introduced using the
			directive:</para>

		<programlisting language="cpp">#pragma TenDRA keyword <emphasis>identifier</emphasis> for fall into case</programlisting>
	</section>

		<section>
			<title>Non-returning functions</title>

			<para>Consider a modified version of the program above, in which
				calls to <code>f</code> with an argument other than
				<code>1</code>, <code>2</code> or <code>3</code> cause an error
				message to be printed:</para>

			<programlisting language="c">extern void error ( const char * );
char *f ( int n )
{
	char *r;
	switch ( n ) {
		case 1 : r = "one"; break;
		case 2 : r = "two"; break;
		case 3 : r = "three"; break;
		default : error( "Illegal value" );
	}
	return ( r );
}</programlisting>

			<para>This causes an error because, in the default case,
				<code>r</code> is not set before it is used. However,
				depending on the semantics of the function, error, the
				return statement may never be reached in this case. This is
				because the fact that a function returns void can mean one
				of two distinct things:</para>

			<itemizedlist>
				<listitem>
					<para>That the function does not return a value. This is the usual
						meaning of <code>void</code>.</para>
				</listitem>
				<listitem>
					<para>That the function never returns, for example the library
						function, <code>exit</code>, uses <code>void</code> in this
						sense.</para>
				</listitem>
			</itemizedlist>

			<para>If error never returns, then the program above is correct;
				otherwise, an unset value of <code>r</code> may be
				returned.</para>

			<para>Therefore, we need to be able to declare the fact that a
				function never returns. This is done by introducing a new type to
				stand for the non-returning meaning of <code>void</code> (some
				compilers use <code>volatile void</code> for this purpose).
				This is done by means of the pragma:</para>

			<!-- TODO make this BOTTOM instead of VOID -->
			<programlisting language="c">#pragma TenDRA type VOID for bottom</programlisting>

			<para>to introduce a type <code>VOID</code> (although any
				identifier may be used) with this meaning. The declaration of
				error can then be expressed as:</para>

			<programlisting language="c">extern VOID error ( const char * );</programlisting>

			<para>In order to maintain compatibility with existing compilers a
				definition of <code>VOID</code> needs to be supplied. For
				example:</para>

			<programlisting language="c">#ifdef __TenDRA__
#pragma TenDRA type VOID for bottom
#else
typedef void VOID;
#endif</programlisting>

			<para>The largest class of non-returning functions occurs in the
				various standard APIs - for example, <code>exit</code> and
				<code>abort</code>. The TenDRA descriptions of these APIs
				contain this information. The information that a function does
				not return is taken into account in all flow analysis contexts.
				For example, in:</para>

			<programlisting language="c">#include &lt;stdlib.h&gt;

int f ( int n )
{
	exit ( EXIT_FAILURE );
	return ( n );
}</programlisting>

			<para><code>n</code> is unused because the <code>return</code>
				statement is not reached (a fact that can also be determined by
				the unreachable code analysis in section 5.2).</para>
		</section>

		<section id="return">
			<title>Return statements</title>

			<para>In C, but not in C++, it is possible to have a <code>return</code>
				statement without an expression in a function which does not return
				<code>void</code>.  It is possible to enable this behaviour using
				the directive:</para>

			<programlisting language="cpp">#pragma TenDRA incompatible void return <emphasis>allow</emphasis></programlisting>

			<para>Note that this check includes the implicit <code>return</code> caused
				by falling off the end of a function.   The effect of such a
				<code>return</code> statement is undefined. The C++ rule that falling
				off the end of <code>main</code> is equivalent to returning a value
				of 0 overrides this check.</para>
		</section>
	</section>

	<section>
		<title>Discard Analysis</title>

		<para>A couple of examples of what might be termed <quote>discard
			analysis</quote> have already been described - discarded (unused)
			local variables and discarded (unused) assignments to local
			variables (see section 5.6.4 and 5.6.5). The checker can perform
			three more types of discard analysis: discarded function returns,
			discarded computations and unused static variables and procedures.
			These three tests may be controlled as a group using:</para>

		<programlisting language="c">#pragma TenDRA discard analysis <emphasis>status</emphasis></programlisting>

		<para>where <emphasis>status</emphasis> is <code>on</code>,
			<code>warning</code> or <code>off</code>.</para>

		<para>In addition, each of the component tests may be switched on and
			off independently using pragmas of the form:</para>

		<programlisting language="c">#pragma TenDRA discard analysis (function return) <emphasis>status</emphasis>
#pragma TenDRA discard analysis (value) <emphasis>status</emphasis>
#pragma TenDRA discard analysis (static) <emphasis>status</emphasis></programlisting>

		<para>There are also equivalent command line options to tchk of the form
			<code>-X:test=state</code>, where <emphasis>test</emphasis> can be
			<code>discard_all</code>, <code>discard_func_ret</code>,
			<code>discard_value</code> or <code>unused_static</code>, and
			<emphasis>state</emphasis> can be <code>check</code>,
			<code>warn</code> or <code>dont</code>. These checks are all
			switched off in the default mode.</para>

		<para>Detailed descriptions of the individual checks follow in
			sections 5.8.1 - 5.8.3. Section 5.9 describes the facilities for
			fine-tuning the discard analysis.</para>

		<section>
			<title>Discarded function returns</title>

			<para>Functions which return a value which is not used form the
				commonest instances of discarded values. For example, in:</para>

			<programlisting language="c">#include &lt;stdio.h&gt;
int main ()
{
	puts ( "hello" );
	return ( 0 );
}</programlisting>

			<para>the function, <code>puts</code>, returns an <code>int</code>
				value, indicating whether an error has occurred, which is
				ignored.</para>
		</section>

		<section>
			<title>Discarded computed values</title>

			<para>A rarer instance of a discarded object, and one which is
				almost always an error, is where a value is computed but not
				used. For example, in:</para>

			<programlisting language="c">int f ( int n )
{
	int r = 4;
	if ( n == 3 )
	{
		r == 5;
	}
	return ( r );
}</programlisting>

			<para>the value <code>r == 5</code> is computed but not used.
				This is actually because it is a misprint for
				<code>r = 5</code>.</para>
		</section>

		<section>
			<title>Unused static variables and procedures</title>

			<para>The final example of discarded values, which perhaps more
				properly belongs with the variable analysis tests mentioned
				above, is for static objects which are unused in the source
				module in which they are defined. Of course this means that
				they are unused in the entire program. Such objects can
				usually be removed.</para>
		</section>
	</section>

	<section id="discard">
		<title>Discarded expressions</title>

		<para>The directive:</para>

		<programlisting language="cpp">#pragma TenDRA discard analysis <emphasis>on</emphasis></programlisting>

		<para>can be used to enable a check for values which are calculated but
			not used.	There are three checks controlled by this directive, each
			of which can be controlled independently.	The directive:</para>

		<programlisting language="cpp">#pragma TenDRA discard analysis (function return) <emphasis>on</emphasis></programlisting>

		<para>checks for functions which return a value which is not used.	The
			check needs to be enabled for both the declaration and the call of
			the function in order for a discarded function return to be reported.
			Discarded returns for overloaded operator functions are never reported.
			The directive:</para>

		<programlisting language="cpp">#pragma TenDRA discard analysis (value) <emphasis>on</emphasis></programlisting>

		<para>checks for other expressions which are not used.	Finally, the directive:</para>

		<programlisting language="cpp">#pragma TenDRA discard analysis (static) <emphasis>on</emphasis></programlisting>

		<para>checks for variables with internal linkage which are defined but not
			used.</para>

		<para>An unused function return or other expression can be asserted to be
			deliberately discarded by explicitly casting it to <code>void</code>
			or, equivalently, preceding it by a keyword introduced using the directive:</para>

		<programlisting language="cpp">#pragma TenDRA keyword <emphasis>identifier</emphasis> for discard value</programlisting>

		<para>A static variable can be asserted to be deliberately unused by including
			it in list of identifiers in a directive of the form:</para>

		<programlisting language="cpp">#pragma TenDRA suspend static <emphasis>identifier-list</emphasis></programlisting>
	</section>

	<section>
		<title>Overriding the discard analysis</title>

		<para>As with the variable analysis, certain constructs may be used to
			provide the checker with extra information about a program, to
			convey the programmer's intentions more clearly.</para>

		<section>
			<title>Discarding function returns and computed values</title>

			<para>Unwanted function returns and, more rarely, discarded
				computed values, may be actively ignored to indicate to the
				discard analysis that the value is being discarded
				deliberately. This can be done using the traditional method of
				casting the value to <code>void</code>:</para>

			<programlisting language="c">( void ) puts ( "hello" );</programlisting>

			<para>or by introducing a keyword, <code>IGNORE</code> say, for
				discarding a value. This is done using a pragma of the
				form:</para>

			<programlisting language="c">#pragma TenDRA keyword IGNORE for discard value</programlisting>

			<para>The example discarded value then becomes:</para>

			<programlisting language="c">IGNORE puts ( "hello" );</programlisting>

			<para>Of course it is necessary to introduce a definition of
				<code>IGNORE</code> for conventional compilers in order to
				maintain compilability. A suitable definition might be:</para>

			<programlisting language="c">#ifdef __TenDRA__
#pragma TenDRA keyword IGNORE for discard value
#else
#define IGNORE ( void )
#endif</programlisting>
		</section>

		<section>
			<title>Preserving unused statics</title>

			<para>Occasionally unused static values are introduced deliberately
				into programs. The fact that the static variables or procedures
				<code>x</code>, <code>y</code> and <code>z</code> are
				deliberately unused may be indicated by introducing the
				pragma:</para>

			<programlisting language="c">#pragma TenDRA suspend static x y z</programlisting>

			<para>at the outer level after the definition of all three
				objects.</para>

			<!-- TODO examples, please. rcsid, providing symbols for dlsym -->
		</section>
	</section>

	<section id="reach">
		<title>Unreached code analysis</title>

		<para>The directive:</para>

		<programlisting language="cpp">#pragma TenDRA unreachable code <emphasis>allow</emphasis></programlisting>

		<para>enables a flow analysis check to detect unreachable code.	It is possible
			to assert that a statement is reached or not reached by preceding
			it by a keyword introduced by one of the directives:</para>

		<programlisting language="cpp">#pragma TenDRA keyword <emphasis>identifier</emphasis> for set reachable
#pragma TenDRA keyword <emphasis>identifier</emphasis> for set unreachable</programlisting>

		<para>The fact that certain functions, such as <code>exit</code>, do not
			return a value can be exploited in the flow analysis routines.	The
			equivalent directives:</para>

		<programlisting language="cpp">#pragma TenDRA bottom <emphasis>identifier</emphasis>
#pragma TenDRA++ type <emphasis>identifier</emphasis> for bottom</programlisting>

		<para>can be used to introduce a <code>typedef</code> declaration for the
			type, bottom, returned by such functions.	The TenDRA API headers
			declare
			<code>exit</code> and similar functions in this way, for example:</para>

		<programlisting language="cpp">#pragma TenDRA bottom __bottom
__bottom exit ( int ) ;
__bottom abort ( void ) ;</programlisting>

		<para>The bottom type is compatible with <code>void</code> in function declarations
			to allow such functions to be redeclared in their conventional form.</para>
	</section>

	<section id="variable">
		<title>Variable flow analysis</title>

		<para>The directive:</para>

		<programlisting language="cpp">#pragma TenDRA variable analysis <emphasis>on</emphasis></programlisting>

		<para>enables checks on the uses of automatic variables and function parameters.
			These checks detect:</para>

		<itemizedlist>
			<listitem>
				<para>If a variable is not used in its scope.</para>
			</listitem>

			<listitem>
				<para>If the value of a variable is used before it has been assigned to.</para>
			</listitem>

			<listitem>
				<para>If a variable is assigned to twice without an intervening use.</para>
			</listitem>

			<listitem>
				<para>If a variable is assigned to twice without an intervening sequence point.</para>
			</listitem>
		</itemizedlist>

		<para>as illustrated by the variables <code>a</code>, <code>b</code>,
			<code>c</code> and <code>d</code> respectively in:</para>

		<programlisting language="cpp">void f ()
{
	int a ;        // a never used
	int b ;
	int c = b ;    // b not initialised
	c = 0 ;        // c assigned to twice
	int d = 0 ;
	d = ++d ;      // d assigned to twice
}</programlisting>

		<para>The second, and more particularly the third, of these checks requires
			some fairly sophisticated flow analysis, so any hints which can be
			picked up from <link linkend="switch">exhaustive <code>switch</code>
			statements</link> etc. is likely to increase the accuracy of the errors
			detected.</para>

		<para>In a non-static member function the various non-static data members
			are analysed as if they were automatic variables.	It is checked that
			each member is initialised in a constructor.	A common source of initialisation
			problems in a constructor is that the base classes and members are
			initialised in the canonical order of virtual bases, non-virtual direct
			bases and members in the order of their declaration, rather than in
			the order in which their initialisers appear in the constructor definition.
			Therefore a check that the initialisers appear in the canonical order
			is also applied.</para>

		<para>It is possible to change the state of a variable during the variable
			analysis using the directives:</para>

		<programlisting language="cpp">#pragma TenDRA set <emphasis>expression</emphasis>
#pragma TenDRA discard <emphasis>expression</emphasis></programlisting>

		<para>The first asserts that the variable given by the <emphasis>expression</emphasis>
			has been assigned to; the second asserts that the variable is not
			used.	An alternative way of expressing this is by means of keywords:</para>

		<programlisting language="cpp">SET ( <emphasis>expression</emphasis> )
DISCARD ( <emphasis>expression</emphasis> )</programlisting>

		<para>introduced using the directives.</para>

		<programlisting language="cpp">#pragma TenDRA keyword <emphasis>identifier</emphasis> for set
#pragma TenDRA keyword <emphasis>identifier</emphasis> for discard variable</programlisting>

		<para>respectively.	These expressions can appear in expression statements
			and as the first argument of a comma expression.</para>

		<warning>
			<para>The variable flow analysis checks have not yet been completely implemented.
				They may not detect errors in certain circumstances and for extremely
				convoluted code may occasionally give incorrect errors.</para>
		</warning>
	</section>

	<section id="hide">
		<title>Variable hiding</title>

		<para>The directive:</para>

		<programlisting language="cpp">#pragma TenDRA variable hiding analysis <emphasis>on</emphasis></programlisting>

		<para>can be used to enable a check for hiding of other variables and, in
			member functions, data members, by local variable declarations.</para>
	</section>

	<section id="exception">
		<title>Exception analysis</title>

		<para>The ISO C++ rules do not require exception specifications to be checked
			statically.	This is to facilitate the integration of large systems
			where a single change in an exception specification could have ramifications
			throughout the system.	However it is often useful to apply such checks,
			which can be enabled using the directive:</para>

		<programlisting language="cpp">#pragma TenDRA++ throw analysis <emphasis>on</emphasis></programlisting>

		<para>This detects any potentially uncaught exceptions and other exception
			problems.	In the error messages arising from this check, an uncaught
			exception of type <code>...</code> means that an uncaught exception
			of an unknown type (arising, for example, from a function without
			an exception specification) may be thrown.	For example:</para>

		<programlisting language="cpp">void f ( int ) throw ( int ) ;
void g ( int ) throw ( long ) ;
void h ( int ) ;

void e () throw ( int )
{
	f ( 1 ) ;	// OK
	g ( 2 ) ;	// uncaught 'long' exception
	h ( 3 ) ;	// uncaught '...' exception
}</programlisting>
	</section>

</chapter>

