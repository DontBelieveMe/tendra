<?xml version="1.0"?>
<!DOCTYPE chapter SYSTEM "minidocbook.dtd">

<chapter>
	<title>Configuring the Checker</title>

	<para>This section describes the built-in checking modes and the design
		of customised environments.</para>

	<para>There are several methods available for configuring the checker.
		Most configuration is provided by built-in "modes" which are selected
		by using the relevant <code>-X</code> command line option for &tcc.1;.
		These modes are documented by &tccmodes.5;.</para>

	<para>More detailed customisation may require special
		<code>#pragma</code> statements to be incorporated into the source
		code to be analysed (this commonly takes the form of a startup
		file). The configuration options generally act independently of one
		another and unless explicitly forbidden in the descriptions below,
		they may be combined in any way.</para>

	<section>
		<title>Individual command line checking options</title>

		<para>Some of the checks available can be controlled using a command
			line option of the form <code>-Xopt,opt,...</code>, where the various
			opt options give a comma-separated list of commands. These commands
			have the form test=status, where test is the name of the check, and
			status is either check (apply check and give an error if it fails),
			warn (apply check and give a warning if it fails) or dont (do not
			apply check). The names of checks can be found with their
			descriptions in Chapters 3 - 8; for example the check for implicit
			function declarations described in 3.4.1 may be switched on using
			<code>-X:implicit_func=check</code>.</para>

		<para>The command line options for portability checking are:</para>

		<table>
			<title>Command Line Options</title>

			<col align="left"/>
			<col align="center"/>
			<col align="left"/>

			<thead>
				<tr>
					<th>Check</th>
					<th>Reference</th>	<!-- TODO make link -->
					<th>Command Line Option</th>
				</tr>
			</thead>

			<!-- TODO normalise title case with other tables -->
			<!-- TODO check harr and not rarr -->
			<tbody>
				<tr>
					<td>Weak Prototype Analysis</td>
					<td>3.3.1</td>
					<td><code>-X:weak_proto=<emphasis>status</emphasis></code></td>
				</tr>

				<tr>
					<td>Implicit Function Declaration</td>
					<td>3.4</td>
					<td><code>-X:implicit_func=<emphasis>status</emphasis></code></td>
				</tr>

				<tr>
					<td>Printf String Checking</td>
					<td>3.2.2</td>
					<td><code>-X:printf=<emphasis>status</emphasis></code></td>
				</tr>

				<tr>
					<td>Incompatible Void Returns</td>
					<td>3.2.2</td>
					<td><code>-X:void_ret=<emphasis>status</emphasis></code></td>
				</tr>

				<tr>
					<td>Unreachable Code</td>
					<td>5.2</td>
					<td><code>-X:unreached=<emphasis>status</emphasis></code></td>
				</tr>

				<tr>
					<td>Case Fall Through</td>
					<td>5.3</td>
					<td><code>-X:fall_thru=<emphasis>status</emphasis></code></td>
				</tr>

				<tr>
					<td>Conversion Analysis</td>
					<td>3.2</td>
					<td><code>-X:convert_all=<emphasis>status</emphasis></code></td>
				</tr>

				<tr>
					<td rowspan="3">Integer &harr; Integer Conversion</td>
					<td rowspan="3">3.2.1</td>
					<td><code>-X:convert_int=<emphasis>status</emphasis></code></td>
				</tr>

				<tr>
					<td><code>-X:convert_int_implicit=<emphasis>status</emphasis></code></td>
				</tr>

				<tr>
					<td><code>-X:convert_int_explicit=<emphasis>status</emphasis></code></td>
				</tr>

				<tr>
					<td>Integer &harr; Pointer Conversion</td>
					<td>3.2.2</td>
					<td><code>-X:convert_int_ptr=<emphasis>status</emphasis></code></td>
				</tr>

				<tr>
					<td>Integer &harr; Pointer Conversion</td>
					<td>3.2.3</td>
					<td><code>-X:convert_ptr=<emphasis>status</emphasis></code></td>
				</tr>

				<tr>
					<td>Complete&nbsp;<code>struct</code>/<code>union</code>&nbsp;Analysis</td>
					<td>8.3</td>
					<td><code>-X:complete_struct=<emphasis>status</emphasis></code></td>
				</tr>

				<tr>
					<td>Variable Analysis</td>
					<td>5.6</td>
					<td><code>-X:variable=<emphasis>status</emphasis></code></td>
				</tr>

				<tr>
					<td>Discard Analysis</td>
					<td>5.8</td>
					<td><code>-X:discard_all=<emphasis>status</emphasis></code></td>
				</tr>

				<tr>
					<td>Discarded Function Returns</td>
					<td>5.8.1</td>
					<td><code>-X:discard_func_ret=<emphasis>status</emphasis></code></td>
				</tr>

				<tr>
					<td>Discarded Values</td>
					<td>5.8.2</td>
					<td><code>-X:discard_value=<emphasis>status</emphasis></code></td>
				</tr>

				<tr>
					<td>Unused Statics</td>
					<td>5.8.3</td>
					<td><code>-X:unused_static=<emphasis>status</emphasis></code></td>
				</tr>
			</tbody>
		</table>

		<para>where <emphasis>status</emphasis> can be <code>check</code>,
			<code>warn</code> or <code>dont</code>.</para>
	</section>

	<section>
		<title>2.1.5 Construct a customised checking environment</title>

		<para>The individual checks performed by the C static checker are
			generally controlled by <code>#pragma</code> directives. The reason
			for this is that the ISO standard places no restrictions on the syntax
			following a <code>#pragma</code> preprocessing directive, and most
			compilers/checkers can be configured to ignore any unknown
			<code>#pragma</code> directives they encounter.</para>

		<para>Most of these directives begin:</para>

		<programlisting language="c">#pragma TenDRA ...</programlisting>

		<para>and are always checked for syntactical correctness. The individual
			directives, together with the checks they control are described in
			Chapters 3 - 8. Section 2.2 describes the method of constructing a
			new checking profile from these individual checks.</para>
	</section>

	<section>
		<title>Scoping checking profiles</title>

		<para>Almost all the available checks are scoped (exceptions will be
			mentioned in the description of the check). A new checking scope
			may be started by inserting the pragma:</para>

		<programlisting language="c">#pragma TenDRA begin</programlisting>

		<para>at the outermost level. The scope runs until the matching:</para>

		<programlisting language="c">#pragma TenDRA end</programlisting>

		<para>directive, or to the end of the translation unit (the ISO C
			standard definition of a translation unit as being a source file,
			together with any headers or source files included using the
			<code>#include</code> preprocessing directive, less any source
			lines skipped by any of the conditional inclusion preprocessing
			directives, is used throughout this document).</para>

		<para>Checking scopes may be nested in the obvious way.</para>

		<para>Each new checking scope inherits its initial set of checks from
			the checking scope which immediately contains it (this includes the
			implicit main checking scope consisting of the entire source file).
			Any checks switched on or off within the scope apply only to that
			scope and any scope it contains. The set of checks applied reverts
			to its previous state at the end of a scope. Thus, for example:</para>

		<programlisting language="c">#pragma TenDRA variable analysis on
/* Variable analysis is on here */

#pragma TenDRA begin
#pragma TenDRA variable analysis off
	/* Variable analysis is off here */
#pragma TenDRA end

/* Variable analysis is on again here */</programlisting>

		<para>Once a check has been set any attempt to change its status
			within the same scope is flagged as an error. If checks need
			to be switched on and off in the same source file, they must
			be properly scoped. The built-in compilation modes have the
			entire source file as their scope.</para>

		<para>The method of applying different checking profiles to different
			parts of a program clearly needs to take into account those
			properties of C which can circumvent such scoping. Consider for
			example:</para>

		<programlisting language="c">#pragma TenDRA begin
#pragma TenDRA unknown escape allow
#define STRING "hello\!"
#pragma TenDRA end

char * f () {
	return ( STRING ) ;
}</programlisting>

		<para>The macro <code>STRING</code> is defined in an area where
			unknown escape sequences, such as <code>\!,</code> are allowed,
			but it is expanded in an area where they are not allowed (this
			is the default setting). The conventional approach to macro
			expansion would lead to the unknown escape sequence being
			flagged as an error, even though the user probably intended to
			avoid this. The checker therefore expands all macros using the
			checking profile in which they were defined, rather than the
			current checking scope.</para>

		<para>The directives describing the user's desired checking profile
			could be included directly in the program itself, ideally in some
			configuration file which is <code>#include</code>'d in all source
			files. It is however perhaps more appropriate to store the directives as a
			startup file, <emphasis>file</emphasis> say, which is passed to the checker
			using the <code>-f</code><emphasis>file</emphasis>command line option. It
			should be noted that user-defined compilation modes are defined on
			top of a built-in mode base (normally Xc, the default mode). It is
			therefore important to scope the new checking profile as described
			above.</para>

		<para>Names may be associated with checking scopes by using an
			alternative form of the begin directive:</para>

		<programlisting language="c">#pragma TenDRA begin name environment identifier</programlisting>

		<para>where identifier is any valid C identifier. Thereafter a
			statement of the form:</para>

		<programlisting language="c">#pragma TenDRA use environment identifier</programlisting>

		<para>changes the current checking environment to the environment
			associated with identifier.</para>

		<para>Sometimes it may be desirable to use different checking profiles
			for different parts of a translation unit, e.g. applying less
			strict checks to any system headers which may be included. The
			checker can be configured to apply a named checking scope,
			<emphasis>env_name</emphasis>, to any files included from a
			directory which has been named <emphasis>dir_name</emphasis>, using:</para>

		<programlisting language="c">#pragma TenDRA directory <emphasis>dir_name</emphasis> use environment <emphasis>env_name</emphasis></programlisting>

		<para>The directory name must be passed to the checker using the
			<code>-N</code> <emphasis>dir_name</emphasis> <code>:</code>
			<emphasis>dir</emphasis> <code>-I</code> <code>dir</code>
			command line option. This is equivalent to the usual
			<code>-Idir</code> option for specifying include paths, except that it
			also attaches the name dir_name to the directory.</para>
	</section>
</chapter>

