<!DOCTYPE BOOK PUBLIC "-//FreeBSD//DTD DocBook V4.1-Based Extension//EN">

<book>
  <bookinfo>
    <title>calculus User's Guide</title>
    
    <pubdate>$TenDRA$</pubdate>
    
    <corpauthor>The TenDRA Documentation Team</corpauthor>

    <copyright>
      <year>2002</year>
      <holder>TenDRA Documentation Team</holder>
    </copyright>

    <copyright>
      <year>1998</year>
      <holder>Defence Evaluation and Research Agency (DERA)</holder>
    </copyright>

    <abstract>
      <para>Please email us at <email>docs@ten15.org</email> if you see any
        errors</para>
    </abstract>
  </bookinfo>

  <preface>
    <title>Introduction</title>

    <para>This document describes a tool, <literal>calculus</literal>, which
      allows complex type systems to be described in a simple algebraic
      format, and transforms this into a system of C types which implements
      this algebra.</para>

    <para><literal>calculus</literal> was initially written as a design tool
      for use with the TenDRA C and C++ producers. The producers' internal
      datatypes reflect the highly complex interdependencies between the C and
      C++ language concepts (types, expressions and so on) which they were
      designed to represent. A tool for managing this complexity and allowing
      changes to the internal datatypes to be made with confidence was
      therefore seen to be an absolute necessity. The tool can also be applied
      in similar situations where a complex type system needs to be
      described.</para>

    <para>The tool also provides for a separation between the specification of
      the type system and its implementation in terms of actual C types.  This
      separation has a number of advantages. The advantages of maintaining a
      level of abstraction in the specification are obvious.  It is possible
      to apply extremely rigorous type checking to any program written using
      the tool, thereby allowing many potential errors to be detected at
      compile time. It is also possible to restrict access to the types to
      certain well-specified constructs, thereby increasing the
      maintainability of code written using the tool.</para>

    <para>This separation also has beneficial effects on the implementation of
      the type system. By leaving all the type checking aspects at the
      specification level, it is possible to impose an extremely homogeneous
      underlying implementation. This means, for example, that a single memory
      management system can be applied to all the types within the system. It
      also opens the possibility of writing operations which apply to all
      types within the system in a straightforward manner. The
      -XREF-#DiskOutputdisk reading and writing routines described below are
      an example of this.</para>

    <simplesect>
      <title>Using calculus</title>

      <para>The general form for invoking <literal>calculus</literal> is
        as</para>

      <programlisting>
calculus [ options ] input .... [ output ]
      </programlisting>

      <para>where <emphasis>input</emphasis> is a file containing the input
        type system description and <emphasis>output</emphasis> is the
        directory where the files implementing this system are to be output.
        This directory must already exist. If no <emphasis>output</emphasis>
        argument is given then the current working directory is assumed. Note
        that several <emphasis>input</emphasis> files can be given. Unless
        -XREF-#Moduleotherwise specified it is the last file which is used to
        generate the output.</para>

      <para>The form in which the -XREF-#TextInputinput type systems are
        expressed is described below. The form of the output depends on
        <emphasis>options</emphasis>. By default, the C implementation of the
        type system is output. If the <literal>-t</literal> option is passed
        to <literal>calculus</literal> then
        -XREF-../tcpplus/token.html<literal>#pragma token</literal> statements
        describing the type system specification are output.  This
        -XREF-#TokenOutputspecification is given below, with some of the more
        important -XREF-#COutputimplementation details being described in the
        following section.</para>

      <para>Note that it is necessary to check any program written using
        <literal>calculus</literal> against the <literal>#pragma
        token</literal> version of the specification in order to get the full
        benefits of the rigorous type checking provided by the tool.  Some
        sections of the program (if only the -XREF-#COutputSupportbasic
        functions) may be dependent upon the implementation, and so not be
        suitable for this form of checking.</para>
    </simplesect>

    <simplesect>
      <title>Example program</title>

      <para>The program <literal>calculus</literal> itself was written using a
        type system specified using the <literal>calculus</literal> tool.  It
        is designed to provide an example of its own application, with some
        features not strictly necessary for the functionality of the program
        being added for illustrative purposes.</para>
    </simplesect>
  </preface>

  <chapter>
    <title>Input syntax</title>

    <para></para>

    <programlisting>
algebra :
  ALGEBRA identifier version<subscript>opt</subscript> : item-list<subscript>opt</subscript>

version :
  ( integer . integer )

item-list :
  item
  item-list item

item :
  primitive
  identity
  enumeration
  structure
  union
    </programlisting>

    <para>The initial identifier gives the overall name of the algebra. A
      version number may also be associated with the algebra (if this is
      omitted the version is assumed to be 1.0). The main body of the algebra
      definition consists of a list of items describing the primitives, the
      identities, the enumerations, the structures and the unions comprising
      the algebra.</para>

    <para>Here <emphasis>identifier</emphasis> has the same meaning as in C.
      The only other significant lexical units are
      <emphasis>integer</emphasis>, which consists of a sequence of decimal
      digits, and <emphasis>string</emphasis>, which consists of any number of
      characters enclosed in double quotes. There are no escape sequences in
      strings. C style comments may be used anywhere in the input. White space
      is not significant.</para>

    <sect1>
      <title>Primitives</title>

      <para>Primitives form the basic components from which the other types
        in</para>

      <programlisting>
primitive :
  object-identifier = quoted-type ;
      </programlisting>

      <para>where the primitive identifier is given by:</para>

      <programlisting>
object-identifier :
  #<subscript>opt</subscript> :<subscript>opt</subscript> identifier
  #<subscript>opt</subscript> :<subscript>opt</subscript> identifier ( identifier )
      </programlisting>

      <para>and the primitive definition is a string which gives the C
        type</para>

      <programlisting>
quoted-type :
string
      </programlisting>

      <note>
        <para>Each primitive (and also each identity, each enumeration, each
          structure and each union) has two names associated with it. The
          second name is optional; if it is not given then it is assumed to be
          the same as the first name. The first name is that which will be
          given to the corresponding type in the output file. The second is a
          short form of this name which will be used in forming constructor
          names etc. in the output.</para>
      </note>

      <para>The optional hash and colon which may be used to qualify an object
        identifier are provided for backwards compatibility only and are not
        used in the output routines.</para>
    </sect1>

    <sect1>
      <title>Identities</title>

      <para>Identities are used to associate a name with a particular type in
        the algebra. In this they correspond to <literal>typedef</literal>s in
        C. They are described as follows:</para>

      <programlisting>
identity :
  object-identifier = type ;
      </programlisting>

      <para>where the definition type, <emphasis>type</emphasis>, is as</para>
    </sect1>

    <sect1>
      <title>Enumerations</title>

      <para>Enumerations are used to define types which can only take
        values</para>

      <programlisting>
enumeration :
  enum !<subscript>opt</subscript> object-identifier = { enumerator-list } ;
  enum !<subscript>opt</subscript> object-identifier = base-enumeration + {
enumerator-list } ;

      </programlisting>

      <para>where:</para>

      <programlisting>
base-enumeration :
  identifier
      </programlisting>

      <para>is the name of a previously defined enumeration type. The latter
        form is used to express extension enumeration types. An enumeration
        type may be qualified by an exclamation mark to indicate that no lists
        of this type will be constructed.</para>

      <para>The enumeration constants themselves are defined as
        follows:</para>

      <programlisting>
enumerator :
  identifier
  identifier = enumerator-value

enumerator-list :
  enumerator
  enumerator-list , enumerator
      </programlisting>

      <para>Each enumerator is assigned a value in an ascending sequence,
        starting at zero. The next value to be assigned can be set using an
        <emphasis>enumerator-value</emphasis>. This is an expression formed
        from <emphasis>integer</emphasis>s, <emphasis>identifier</emphasis>s
        representing previous enumerators from the same enumeration, and the
        question mark character which stands for the previous enumeration
        value. The normal C arithmetic operations can be applied to build up
        more complex <emphasis>enumerator-value</emphasis>s. All enumerator
        evaluation is done in the <literal>unsigned long</literal> type of the
        host machine. Values containing more than 32 bits are not
        portable.</para>

      <para>Enumerations thus correspond to enumeration types in C, except
        that</para>
    </sect1>

    <sect1>
      <title>Structures</title>

      <para>Structures are used to build up composite types from other types
        in the algebra. They correspond to structures in C. They are described
        as follows:</para>

      <programlisting>
structure :
  struct object-identifier = component-group ;
  struct object-identifier = base-structure + component-group ;
      </programlisting>

      <para>where:</para>

      <programlisting>
base-structure :
identifier
      </programlisting>

      <para>is the name of a previously defined structure type. The latter
        form is used to express (single) inheritance of structures. All
        components of the base structure also become components of the derived
        structure.</para>

      <para>The structure components themselves are defined as follows:</para>

      <programlisting>
component-group :
  { component-list<subscript>opt</subscript> }

component-list :
  component-declarations ;
  component-list component-declarations ;

component-declarations :
  type component-declarators

component-declarators :
  component-declarator
  component-declarators , component-declarator

component-declarator :
  identifier component-initialiser<subscript>opt</subscript>

component-initialiser :
  = string
      </programlisting>

      <para>The optional -XREF-#OutputStructcomponent initialiser strings
        are</para>

      <para>Structures are the only algebra construct which prevent the input
        from being a general graph. Unions may be defined in terms of
        themselves, but (as in C) pointers must be used to define structures
        in terms of themselves.</para>
    </sect1>

    <sect1>
      <title>Unions</title>

      <para>Unions are used to build up types which can hold a variety of
        information. They differ from C unions in that they are discriminated.
        They are described as follows:</para>

      <programlisting>
union :
  union object-identifier = component-group + field-group map-group <subscript>opt</subscript> ;
  union object-identifier = base-union + field-group map-group <subscript>opt</subscript> ;
      </programlisting>

      <para>where:</para>

      <programlisting>
base-union :
identifier
      </programlisting>

      <para>is the name of a previously defined union type. The latter form is
        used to express (single) inheritance of unions. All components, fields
        and maps of the base union also become components of the derived
        union. Note that only new fields and maps can be added in the derived
        union.</para>

      <para>The <emphasis>component-group</emphasis> gives a set of components
        which are common to all the different union cases. The cases
        themselves are described as follows:</para>

      <programlisting>
field-group :
{ field-list }

field :
  #<subscript>opt</subscript> #<subscript>opt</subscript> field-identifier-list -&gt; component-group
  #<subscript>opt</subscript> #<subscript>opt</subscript> field-identifier-list -&gt; base-field + component-group

base-field :
  identifier

field-list :
  field
  field-list , field

field-identifier :
  identifier

field-identifier-list :
  field-identifier
  field-identifier-list , field-identifier
      </programlisting>

      <para>The optional one or two hashes which may be used to qualify a list
        of field identifiers are used to indicate -XREF-#DiskAliasaliasing in
        the disk reading and writing routines. The
        <emphasis>base-field</emphasis> case is a notational convenience which
        allows one field in a union to inherit all the components of another
        field.</para>

      <note>
        <para>A number of field identifiers may be associated with the same
          set of field components. Any such list containing more than one
          identifier forms a field identifier set, named after the first field
          identifier.</para>
      </note>

      <para>In addition a number of maps may be associated with a union. These
        maps correspond to functions which take the union, plus a number of
        other map parameter types, and return the map return type. They are
        described as follows:</para>

      <programlisting>
map-group :
  : [ map-list<subscript>opt</subscript> ]

map :
  extended-type #<subscript>opt</subscript> identifier ( parameter-list<subscript>opt</subscript> )

map-list :
  map
  map-list map
      </programlisting>

      <para>where:</para>

      <programlisting>
parameter-list :
  parameter-declarations
  parameter-list ; parameter-declarations

parameter-declarations :
  extended-type parameter-declarators

parameter-declarators :
  identifier
  parameter-declarators , identifier
      </programlisting>

      <para>Note that the map parameter and return types are given by:</para>

      <programlisting>
extended-type :
  type
  quoted-type
      </programlisting>

      <para>In addition to the -XREF-#InputTypetypes derived from the
        algebra</para>

      <para>A map may be qualified by means of a hash. This means that the
        associated function also takes a -XREF-#OutputUnionMapsdestructor
        function as a parameter.</para>
    </sect1>

    <sect1>
      <title>Type constructors</title>

      <para>The types derived from the algebra may be described as
        follows:</para>

      <programlisting>
type :
  identifier
  PTR type
  LIST type
  STACK type
  VEC type
  VEC_PTR type
      </programlisting>

      <para>The simple types correspond to primitive, identity, enumeration,
        structure or union names. It is possible for a type to be used before
        it is defined, but it must be defined at some point.</para>

      <para>The derived type constructors correspond to pointers, lists,
        stacks, vectors and pointers into vectors. They may be used to build
        up further types from the basic algebra types.</para>

    </sect1>

    <sect1>
      <title>Relations between algebras</title>

      <para>As -XREF-#Optionsmentioned above, more than one input algebra may
        be specified to <literal>calculus</literal>. Each is processed
        separately, and output is generated for only one. By default this is
        the last algebra processed, however a specific algebra can be
        specified using the command-line option
        <literal>-A</literal><emphasis>name</emphasis>, where
        <emphasis>name</emphasis> is the name of the algebra to be used for
        output.</para>

      <para>Types may be imported from one algebra to another by means
        of</para>

      <programlisting>
import :
  IMPORT identifier ;
  IMPORT identifier :: identifier ;
      </programlisting>

      <para>which fit into the main syntax as an <emphasis>item</emphasis>.
        The first form imports all the types from the algebra given by
        <emphasis>identifier</emphasis> into the current algebra. The second
        imports a single type, given by the second
        <emphasis>identifier</emphasis> from the algebra given by the first
        <emphasis>identifier</emphasis>.</para>

      <para>Note that importing a type in this way also imports all the types
        used in its construction. This includes such things as structure
        components and union fields and maps. Thus an algebra consisting just
        of <emphasis>import</emphasis> commands can be used to express
        subalgebras in a simple fashion.</para>
    </sect1>
  </chapter>

  <chapter>
    <title>Output type system specification</title>

    <para>In this section we document the basic output of
      <literal>calculus</literal>. Two forms of the output can be generated
      - a description of the output specification in terms of the TenDRA
      <literal>#pragma token</literal> constructs, and the actual C code
      which implements these tokens.</para>

    <para>In this section the description given will be at the level of the
      output specification. The more important details of the -XREF-#COutputC
      implementation are given in the following section.</para>

    <para>The output is split among several header files in the specified
      output directory. The main output is printed into
      <emphasis>name</emphasis><literal>.h</literal>, where
      <emphasis>name</emphasis> is the overall algebra name. Unless otherwise
      stated, all the objects specified below are to be found in
      <emphasis>name</emphasis><literal>.h</literal>. However for each union,
      <emphasis>union</emphasis>, in the algebra certain information
      associated with the union is printed into
      <emphasis>union</emphasis><literal>_ops.h</literal>. If the union has
      any maps associated with it then further output is printed to
      <emphasis>union</emphasis><literal>_map.h</literal> and
      <emphasis>union</emphasis><literal>_hdr.h</literal>.</para>

    <sect1>
      <title>Version information</title>

      <para>Certain basic information about the input algebra is included in
        <emphasis>name</emphasis><literal>.h</literal>.
        <emphasis>name</emphasis><literal>_NAME</literal> is a string literal
        giving the overall algebra name.
        <emphasis>name</emphasis><literal>_VERSION</literal> is a string
        literal giving the algebra version number.
        <emphasis>name</emphasis><literal>_SPECIFICATION</literal> and
        <emphasis>name</emphasis><literal>_IMPLEMENTATION</literal> are flags
        which take the values 0 or 1 depending on whether the specification of
        the type system in terms of <literal>#pragma token</literal>
        statements or the C implementation is included.</para>
    </sect1>

    <sect1>
      <title>Basic types</title>

      <para>Six abstract type operators, each taking a type as argument
        and</para>

      <programlisting>
TYPE PTR ( TYPE t );
TYPE LIST ( TYPE t ) ;
TYPE STACK ( TYPE t ) ;
TYPE VEC ( TYPE t ) ;
TYPE VEC_PTR ( TYPE t ) ;
TYPE SIZE ( TYPE t ) ;
      </programlisting>

      <para>These represent a pointer to an object of type
        <emphasis>t</emphasis>, a list of objects of type
        <emphasis>t</emphasis>, a stack of objects of type
        <emphasis>t</emphasis>, a vector of objects of type
        <emphasis>t</emphasis>, a pointer into a vector of objects of type
        <emphasis>t</emphasis>, and an allocation block size for type
        <emphasis>t</emphasis> respectively. (It is possible to suppress all
        constructs involving <literal>VEC</literal> or
        <literal>VEC_PTR</literal> by passing the <literal>-x</literal>
        command-line option to <literal>calculus</literal>. Similarly
        <literal>STACK</literal> constructs may be suppressed using
        <literal>-z</literal>.)</para>

      <para>These constructors can be applied to any type, although in
        practice they are only applied to the types specified in the algebra
        and those derived from them. For example, we may form the type:</para>

      <programlisting>
LIST ( PTR ( int ) )
      </programlisting>

      <para>representing a list of pointers to <literal>int</literal>.</para>

      <programlisting>
INT_TYPE name_dim ;
      </programlisting>

      <para>is specified, where <emphasis>name</emphasis> is the
        overall</para>

      <para>A function pointer type:</para>

      <programlisting>
typedef void ( *DESTROYER ) () ;
      </programlisting>

      <para>is specified, which represents a destructor function. Two</para>

      <programlisting>
void destroy_name () ;
void dummy_destroy_name () ;
      </programlisting>

      <para>where <emphasis>name</emphasis> is as above.
        <literal>destroy_</literal><emphasis>name</emphasis> is the default
        destructor, whereas
        <literal>dummy_destroy_</literal><emphasis>name</emphasis> is a dummy
        destructor which has no effect. The details of the arguments passed to
        the destructors and so on are implementation dependent.</para>
    </sect1>

    <sect1>
      <title>Operations on sizes</title>

      <para>The <literal>SIZE</literal> type constructor is used to represent
        a multiple of the size of a type. It is used, for example, in the
        -XREF-#OutputPtrpointer stepping construct <literal>STEP_ptr</literal>
        to specify the number of units the pointer is to be increased by.
        Having a separate abstract type for the size of each type greatly
        increases the scope for type checking of memory allocation, and other,
        functions.</para>

      <para>For each basic type in the algebra (a primitive, a structure or
        a</para>

      <programlisting>
SIZE ( t ) SIZE_type ;
      </programlisting>

      <para>where <emphasis>t</emphasis> denotes the type itself, and</para>

      <para>For the five other type constructors
        -XREF-#OutputBasicdescribed</para>

      <programlisting>
SIZE ( PTR ( t ) ) SIZE_ptr ( TYPE t ) ;
SIZE ( LIST ( t ) ) SIZE_list ( TYPE t ) ;
SIZE ( STACK ( t ) ) SIZE_stack ( TYPE t ) ;
SIZE ( VEC ( t ) ) SIZE_vec ( TYPE t ) ;
SIZE ( VEC_PTR ( t ) ) SIZE_vec_ptr ( TYPE t ) ;
      </programlisting>

      <para>for any type <emphasis>t</emphasis>.</para>

      <para>These constructs allow the size of any type derived from the
        algebra to be built up. There is also a construct which corresponds to
        multiplying the size of a type by a constant. This takes the
        form:</para>

      <programlisting>
SIZE ( t ) SCALE ( SIZE ( t ), INT_TYPE itype ) ;
      </programlisting>

      <para>for any type <emphasis>t</emphasis> and any integral type</para>
    </sect1>

    <sect1>
      <title>Operations on pointers</title>

      <para>The <literal>PTR</literal> type constructor is used to represent a
        pointer to an object of type <emphasis>t</emphasis>. It should be
        emphasised that this construct is not in general implemented by means
        of the C pointer construct.</para>

      <sect2>
        <title>Simple pointer constructs</title>

        <para>There are several simple operations on pointers, given as</para>

        <programlisting>
PTR ( t ) NULL_ptr ( TYPE t ) ;
int IS_NULL_ptr ( PTR ( t ) ) ;
int EQ_ptr ( PTR ( t ), PTR ( t ) ) ;
PTR ( t ) STEP_ptr ( PTR ( t ), SIZE ( t ) ) ;
        </programlisting>

        <para>The construct <literal>NULL_ptr</literal> is used to form the
          null pointer to <emphasis>t</emphasis> for a type
          <emphasis>t</emphasis>. This is a constant expression.
          <literal>IS_NULL_ptr</literal> can be used to test whether a given
          pointer expression is a null pointer. Similarly
          <literal>EQ_ptr</literal> checks whether two pointers are equal
          (note that we can only compare pointers to the same type).  Finally
          <literal>STEP_ptr</literal> can be used to add a scalar value to a
          pointer.</para>
      </sect2>

      <sect2>
        <title>Unique pointers</title>

        <para>There are also constructs for generating and destroying
          unique</para>

        <programlisting>
PTR ( t ) UNIQ_ptr ( TYPE t ) ;
void DESTROY_UNIQ_ptr ( PTR ( t ) ) ;
        </programlisting>

        <para>A unique pointer is guaranteed to be different from all other
          undestroyed pointers. Dereferencing a unique pointer is
          undefined.</para>
      </sect2>

      <sect2>
        <title>Pointer construction and destruction</title>

        <para>The constructs:</para>

        <programlisting>
PTR ( t ) MAKE_ptr ( SIZE ( t ) ) ;
void DESTROY_ptr ( PTR ( t ), SIZE ( t ) ) ;
        </programlisting>

        <para>are used to respectively create and destroy a pointer to a
          given</para>
      </sect2>

      <sect2>
        <title>Assignment and dereference constructs</title>

        <para>The constructs for assigning and dereferencing pointers have one
          of two forms depending on the complexity of the type pointed to.
          For simple types, including primitive, enumeration and union types,
          they have the form:</para>

        <programlisting>
void COPY_type ( PTR ( t ), t ) ;
t DEREF_type ( PTR ( t ) ) ;
        </programlisting>

        <para>where <emphasis>t</emphasis> is the type involved and</para>

        <para>For more complex types, including structures, the assignment or
          dereference cannot be done in a single expression, so the constructs
          are specified to be statements as follows:</para>

        <programlisting>
STATEMENT COPY_type ( PTR ( t ), t ) ;
STATEMENT DEREF_type ( PTR ( t ), lvalue t ) ;
        </programlisting>

        <para>Here the <literal>lvalue</literal> type qualifier is used to
          indicate that the statement argument is an assignable
          <literal>lvalue</literal>. In this case it should give the location
          of an object of type <emphasis>t</emphasis> into which the pointer
          will be dereferenced.</para>

        <para>The appropriate assignment and dereference constructs are
          generated for each of the basic algebra types (primitives,
          enumerations, structures and unions). In addition there are generic
          assignment and dereference constructs for pointer types, list types,
          stack types, vector types and vector pointer types.  The first three
          are of the first form above, whereas the second two have the second
          form, as follows:</para>

        <programlisting>
void COPY_ptr ( PTR ( PTR ( t ) ), PTR ( t ) ) ;
PTR ( t ) DEREF_ptr ( PTR ( PTR ( t ) ) ) ;
void COPY_list ( PTR ( LIST ( t ) ), LIST ( t ) ) ;
LIST ( t ) DEREF_list ( PTR ( LIST ( t ) ) ) ;
void COPY_stack ( PTR ( STACK ( t ) ), STACK ( t ) ) ;
STACK ( t ) DEREF_stack ( PTR ( STACK ( t ) ) ) ;
STATEMENT COPY_vec ( PTR ( VEC ( t ) ), VEC ( t ) ) ;
STATEMENT DEREF_vec ( PTR ( VEC ( t ) ), lvalue VEC ( t ) ) ;
STATEMENT COPY_vec_ptr ( PTR ( VEC_PTR ( t ) ), VEC_PTR ( t ) ) ;
STATEMENT DEREF_vec_ptr ( PTR ( VEC_PTR ( t ) ), lvalue VEC_PTR ( t ) ) ;
        </programlisting>
      </sect2>
    </sect1>

    <sect1>
      <title>Operations on lists</title>

      <para>The <literal>LIST</literal> type constructor is used to represent
        a</para>

      <sect2>
        <title>Simple list constructs</title>

        <para>There are several simple list constructs:</para>

        <programlisting>
LIST ( t ) NULL_list ( TYPE t ) ;
int IS_NULL_list ( LIST ( t ) ) ;
int EQ_list ( LIST ( t ), LIST ( t ) ) ;
unsigned LENGTH_list ( LIST ( t ) ) ;
PTR ( t ) HEAD_list ( LIST ( t ) ) ;
LIST ( t ) TAIL_list ( LIST ( t ) ) ;
PTR ( LIST ( t ) ) PTR_TAIL_list ( LIST ( t ) ) ;
LIST ( t ) END_list ( LIST ( t ) ) ;
LIST ( t ) REVERSE_list ( LIST ( t ) ) ;
LIST ( t ) APPEND_list ( LIST ( t ), LIST ( t ) ) ;
        </programlisting>

        <para>Empty lists may be constructed or tested for.
          <literal>NULL_list</literal> is a constant expression. Two lists may
          be checked for equality (note that this is equality of lists, rather
          than element-wise equality). The number of elements in a list can be
          found. The head or tail (or <literal>car</literal> and
          <literal>cdr</literal>) of a list may be formed. The end element of
          a list may be selected. The order of the elements in a list can be
          reversed. One list can be appended to another.</para>
      </sect2>

      <sect2>
        <title>Unique lists</title>

        <para>There are also constructs for generating and destroying
          unique</para>

        <programlisting>
LIST ( t ) UNIQ_list ( TYPE t ) ;
void DESTROY_UNIQ_list ( LIST ( t ) ) ;
        </programlisting>

        <para>A unique lists is guaranteed to be different from all other
          undestroyed lists. Taking the head or tail of a unique list is
          undefined.</para>
      </sect2>

      <sect2>
        <title>List construction and destruction</title>

        <para>For each type <emphasis>t</emphasis> there are operations for
          constructing and deconstructing lists. For the basic types
          comprising the algebra these take the form:</para>

        <programlisting>
STATEMENT CONS_type ( t, LIST ( t ), lvalue LIST ( t ) ) ;
STATEMENT UN_CONS_type ( lvalue t, lvalue LIST ( t ), LIST ( t ) ) ;
STATEMENT DESTROY_CONS_type ( DESTROYER, lvalue t, lvalue LIST ( t ), LIST ( t ) ) ;
        </programlisting>

        <para>where <emphasis>type</emphasis> is the short type name.</para>

        <para>The operation <literal>CONS_</literal><emphasis>type</emphasis>
          is used to build a list whose head is the first argument and whose
          tail is the second argument. This is assigned to the third argument.
          <literal>UN_CONS_</literal><emphasis>type</emphasis> reverses this
          process, decomposing a list into its head and its tail.
          <literal>DESTROY_CONS_</literal><emphasis>type</emphasis> is
          similar, but it also applies the given destructor function to the
          decomposed list component.</para>

        <para>There are also generic list construction and deconstruction
          operations which apply to lists of pointers (with a
          <literal>ptr</literal> suffix), lists of lists (with a
          <literal>list</literal> suffix), lists of stacks (with a
          <literal>stack</literal> suffix), lists of vectors (with a
          <literal>vec</literal> suffix) and lists of pointers to vectors
          (with a <literal>vec_ptr</literal> suffix). For example, for lists
          of pointers these have the form:</para>

        <programlisting>
STATEMENT CONS_ptr ( PTR ( t ), LIST ( PTR ( t ) ), lvalue LIST ( PTR ( t ) ) ) ;
STATEMENT UN_CONS_ptr ( lvalue PTR ( t ), lvalue LIST ( PTR ( t ) ), LIST ( PTR ( t ) ) ) ;
STATEMENT DESTROY_CONS_ptr ( DESTROYER, lvalue PTR ( t ), lvalue LIST ( PTR ( t ) ), LIST ( PTR ( t ) ) ) ;
        </programlisting>

        <para>There is also a generic list destruction construct:</para>

        <programlisting>
STATEMENT DESTROY_list ( LIST ( t ), SIZE ( t ) ) ;
        </programlisting>

        <para>which may be used to destroy all the elements in a list.</para>
      </sect2>
    </sect1>

    <sect1>
      <title>Operations on stacks</title>

      <para>The <literal>STACK</literal> type constructor is used to represent
        stacks of objects of type <emphasis>t</emphasis>. Empty stacks can be
        created and tested for:</para>

      <programlisting>
STACK ( t ) NULL_stack ( TYPE t ) ;
int IS_NULL_stack ( STACK ( t ) ) ;
      </programlisting>

      <para>For each type <emphasis>t</emphasis> there are operations for
        pushing objects onto a stack and for popping elements off. For the
        basic types comprising the algebra these take the form:</para>

      <programlisting>
STATEMENT PUSH_type ( t, lvalue STACK ( t ) ) ;
STATEMENT POP_type ( lvalue t, lvalue STACK ( t ) ) ;
      </programlisting>

      <para>where <emphasis>type</emphasis> is the short type name. There are
        also generic constructs, such as <literal>PUSH_ptr</literal> for
        pushing any pointer type, similar to the -XREF-#OutputListgeneric list
        constructors above.</para>

      <para>Stacks are in fact just modified lists with pushing corresponding
        adding an element to the start of a list, and popping to removing the
        first element. There are constructs:</para>

      <programlisting>
LIST ( t ) LIST_stack ( STACK ( t ) ) ;
STACK ( t ) STACK_list ( LIST ( t ) ) ;
      </programlisting>

      <para>for explicitly converting between lists and stacks.</para>
    </sect1>

    <sect1>
      <title>Operations on vectors</title>

      <para>The <literal>VEC</literal> type constructor is used to represent
        vectors of objects of type <emphasis>t</emphasis>. There are a number
        of simple operations on vectors:</para>

      <programlisting>
VEC ( t ) NULL_vec ( TYPE t ) ;
name_dim DIM_vec ( VEC ( t ) ) ;
name_dim DIM_ptr_vec ( PTR ( VEC ( t ) ) ) ;
PTR ( t ) PTR_ptr_vec ( PTR ( VEC ( t ) ) ) ;
      </programlisting>

      <para>An empty vector can be constructed (note that, unlike null
        pointers and null lists, this is not a constant expression). The
        number of elements in a vector (or in a vector given by a pointer) can
        be determined (note how the type
        <emphasis>name</emphasis><literal>_dim</literal> is used to represent
        vector sizes). A pointer to a vector can be transformed into a pointer
        to the elements of the vector.</para>

      <para>In general a vector may be created or destroyed using the</para>

      <programlisting>
STATEMENT MAKE_vec ( SIZE ( t ), name_dim, lvalue VEC ( t ) ) ;
STATEMENT DESTROY_vec ( VEC ( t ), SIZE ( t ) ) ;
      </programlisting>

      <para>Finally a vector can be trimmed using:</para>

      <programlisting>
STATEMENT TRIM_vec ( VEC ( t ), SIZE ( t ), int, int, lvalue VEC (
t ) ) ;
      </programlisting>

      <para>the two integral arguments giving the lower and upper bounds
        for</para>
    </sect1>

    <sect1>
      <title>Operations on vector pointers</title>

      <para>The <literal>VEC_PTR</literal> type constructor is used to
        represent a pointer to an element of a vector of objects of type
        <emphasis>t</emphasis>. Apart from the basic constructors already
        mentioned, there are only two operations on vector pointers:</para>

      <programlisting>
VEC_PTR ( t ) VEC_PTR_vec ( VEC ( t ) ) ;
PTR ( t ) PTR_vec_ptr ( VEC_PTR ( t ) ) ;
      </programlisting>

      <para>The first transforms a vector into a vector pointer (pointing to
        its first argument). The second transforms a vector pointer into a
        normal pointer.</para>
    </sect1>

    <sect1>
      <title>Operations on primitives</title>

      <para>Each primitive specified within the algebra maps onto a
        <literal>typedef</literal> defining the type in terms of its given
        definition. The only operations on primitives are those listed above -
        the size constructs, the pointer assignment and dereference
        operations, the list construction and deconstruction operations and
        the stack push and pop operations.</para>
    </sect1>

    <sect1>
      <title>Operations on identities</title>

      <para>Each identity specified within the algebra maps onto a
        <literal>typedef</literal> in the output file. There are no operations
        on identities.</para>
    </sect1>

    <sect1>
      <title>Operations on enumerations</title>

      <para>Each enumeration specified within the algebra maps onto an
        unsigned integral type in the output file. The -XREF-#OutputPrimbasic
        operations listed above are always generated unless it has been
        indicated that -XREF-#InputEnumno lists of this type will be formed,
        when <literal>CONS_</literal><emphasis>type</emphasis> and the other
        list and stack operators are suppressed. In addition each enumerator
        which is a member of this enumeration maps onto a constant
        expression:</para>

      <programlisting>
t enum_member ;
      </programlisting>

      <para>where <emphasis>t</emphasis> is the enumeration type,
        <emphasis>enum</emphasis> is the short type name, and
        <emphasis>member</emphasis> is the enumerator name. It is guaranteed
        that the first enumerator will have value 0, the second 1, and so on,
        unless the value of the enumerator is explicitly given (as in C).
        There is also a constant expression:</para>

      <programlisting>
unsigned long ORDER_enum ;
      </programlisting>

      <para>giving one more than the maximum enumerator in the
        enumeration.</para>
    </sect1>

    <sect1>
      <title>Operations on structures</title>

      <para>Each structure specified within the algebra maps onto a
        <literal>typedef</literal> defining the type to be the C structure
        with the given components. In addition to the -XREF-#OutputPrimbasic
        operations listed above there are also field selectors defined.</para>

      <para>Suppose that <emphasis>t</emphasis> is a structure type with short
        name <emphasis>struct</emphasis>, and that <emphasis>comp</emphasis>
        is a component of <emphasis>t</emphasis> of type
        <emphasis>ctype</emphasis>. Then there is an operation:</para>

      <programlisting>
PTR ( ctype ) struct_comp ( PTR ( t ) ) ;
      </programlisting>

      <para>which transforms a pointer to the structure into a pointer to
        the</para>

      <programlisting>
STATEMENT MAKE_struct ( ctype, ...., PTR ( t ) ) ;
      </programlisting>

      <para>where <emphasis>ctype</emphasis> ranges over all the component
        types which do not have a component initialiser string in the
        structure definition. This is used to assign values to all the
        components of a structure. If a component has an initialiser string
        then this is used as an expression giving the initial value, otherwise
        the given operation argument is used. The initialiser strings are
        evaluated in the context of the
        <literal>MAKE_</literal><emphasis>struct</emphasis> statement. The
        parameters to the operation may be referred to by the corresponding
        component name followed by <literal>_</literal>. The partially
        initialised object may be referred to by the special character
        sequence <literal>%0</literal>. Any remainder operations should be
        written as <literal>%%</literal> rather than
        <literal>%</literal>.</para>

      <para>Inheritance in structures is handled as follows: if
        <emphasis>t</emphasis> is a derived structure with base structure
        <emphasis>btype</emphasis> then there is an operation:</para>

      <programlisting>
PTR ( btype ) CONVERT_struct_base ( PTR ( t ) ) ;
      </programlisting>

      <para>where <emphasis>struct</emphasis> and <emphasis>base</emphasis>
        are the short names of <emphasis>t</emphasis> and
        <emphasis>btype</emphasis> respectively.</para>
    </sect1>

    <sect1>
      <title>Operations on unions</title>

      <para>Each union specified within the algebra maps onto an opaque type
        in the output file. In addition to the -XREF-#OutputPrimbasic
        operations listed above there are a number of other constructs output
        into <emphasis>name</emphasis><literal>.h</literal>, namely:</para>

      <programlisting>
unsigned int ORDER_union ;
t NULL_union ;
int IS_NULL_union ( t ) ;
int EQ_union ( t, t ) ;
      </programlisting>

      <para>where <emphasis>t</emphasis> denotes the union type, and
        <emphasis>union</emphasis> is the short type name.
        <literal>ORDER_</literal><emphasis>union</emphasis> is a constant
        value giving the number of union fields.
        <literal>NULL_</literal><emphasis>union</emphasis> is a distinguished
        constant value of type <emphasis>t</emphasis>. Values of type
        <emphasis>t</emphasis> may be compared against this distinguished
        value, or against each other.</para>

      <sect2>
        <title>Union construction operations</title>

        <para>Most of the output for the union type <emphasis>t</emphasis> is
          output into the file
          <emphasis>union</emphasis><literal>_ops.h</literal>. This contains a
          construct:</para>

        <programlisting>
unsigned int TAG_union ( t ) ;
        </programlisting>

        <para>for extracting the discriminant tag from a union.</para>

        <para>For each shared component, <emphasis>comp</emphasis>, of
          <emphasis>t</emphasis> of type <emphasis>ctype</emphasis>, say,
          there is an operator:</para>

        <programlisting>
PTR ( ctype ) union_comp ( t ) ;
        </programlisting>

        <para>which extracts this component from the union.</para>

        <para>For each field, <emphasis>field</emphasis>, of the union there
          are constructs:</para>

        <programlisting>
unsigned int union_field_tag ;
int IS_union_field ( t ) ;
        </programlisting>

        <para>giving the (constant) discriminant tag associated with this
          field, and a test for whether an object of type
          <emphasis>t</emphasis> has this discriminant.</para>

        <para>In addition, for each unshared component,
          <emphasis>comp</emphasis>, of <emphasis>field</emphasis> of type
          <emphasis>ctype</emphasis>, say, there is an operator:</para>

        <programlisting>
PTR ( ctype ) union_field_comp ( t ) ;
        </programlisting>

        <para>which extracts this component from the union.</para>

        <para>There are also operations for constructing and deconstructing
          objects of type <emphasis>t</emphasis> for field
          <emphasis>field</emphasis> given as follows:</para>

        <programlisting>
STATEMENT MAKE_union_field ( ctype, ...., lvalue t ) ;
STATEMENT DECONS_union_field ( lvalue ctype, ...., t ) ;
STATEMENT DESTROY_union_field ( DESTROYER, lvalue ctype, ...., t ) ;
        </programlisting>

        <para>The operation
          <literal>MAKE_</literal><emphasis>union_field</emphasis> constructs
          a value of type <emphasis>t</emphasis> from the various components
          and assigns it into the last argument. The
          <emphasis>ctype</emphasis> arguments range over all the components
          of <emphasis>field</emphasis>, both the shared components and the
          unshared components, which do not have a component initialiser
          string in the definition. The union component are initialised either
          using the -XREF-#OutputStructinitialiser string or the given
          operation argument.</para>

        <para><literal>DECONS_</literal><emphasis>union_field</emphasis>
          performs the opposite operation, deconstructing an object of type
          <emphasis>t</emphasis> into its components for this field.
          <literal>DESTROY_</literal><emphasis>union_field</emphasis> is
          similar, except that it also applies the given destructor function
          to the original value. For these two operations
          <emphasis>ctype</emphasis> ranges over all the components, including
          those with initialiser strings.</para>
      </sect2>

      <sect2>
        <title>Union field sets</title>

        <para>Recall that -XREF-#InputUniona number of union field identifiers
          may be associated with the same set of components. In this case
          these fields form a union field set named after the first element of
          the set. There are operations:</para>

        <programlisting>
int IS_union_field_etc ( t ) ;
PTR ( ctype ) union_field_etc_comp ( t ) ;
STATEMENT MAKE_union_field_etc ( unsigned int, ctype, ...., lvalue
t ) ;
STATEMENT MODIFY_union_field_etc ( unsigned int, t ) ;
STATEMENT DECONS_union_field_etc ( lvalue ctype, ...., t ) ;
STATEMENT DESTROY_union_field_etc ( DESTROYER, lvalue ctype, ....,
t ) ;
        </programlisting>

        <para>defined on these sets. These are exactly analogous to the single
          field operations except that they work for any field in the set.
          Note that
          <literal>MAKE_</literal><emphasis>union_field</emphasis>
          <literal>_etc</literal> takes an extra argument, giving the tag
          associated with the particular element of the set being constructed.
          Also the construct
          <literal>MODIFY_</literal><emphasis>union_field</emphasis><literal>
          _etc</literal> is introduced to allow the tag of an existing object
          to be modified to another value within the same set.</para>

        <para>The valid range of union tags for this set can be given by
          the</para>

        <programlisting>
unsigned int union_field_tag ;
unsigned int union_field_etc_tag ;
        </programlisting>

        <para>A union is a member of this set if its tag is greater than or
          equal to <emphasis>union_field</emphasis><literal>_tag</literal> and
          strictly less than <emphasis>union_field</emphasis>
          <literal>_etc_tag</literal>.</para>
      </sect2>

      <sect2>
        <title>Inheritance in unions</title>

        <para>Inheritance in unions is handled as follows: if
          <emphasis>t</emphasis> is a derived union with base union
          <emphasis>btype</emphasis> then there is an operation:</para>

        <programlisting>
btype CONVERT_union_base ( t ) ;
        </programlisting>

        <para>where <emphasis>union</emphasis> and <emphasis>base</emphasis>
          are the short names of <emphasis>t</emphasis> and
          <emphasis>btype</emphasis> respectively.</para>
      </sect2>

      <sect2>
        <title>-XREF-OutputUnionMapsUnion maps</title>

        <para>For each map, <emphasis>map</emphasis>, on the union
          <emphasis>t</emphasis>, we have declared in
          <emphasis>union</emphasis><literal>_ops.h</literal> an
          operator:</para>

        <programlisting>
map_ret map_union ( t, map_par, .... ) ;
        </programlisting>

        <para>where <emphasis>map_ret</emphasis> is the map return type and
          <emphasis>map_par</emphasis> ranges over the map parameter types.
          This is except for maps with destructors (i.e. those qualified by a
          -XREF-#InputUnionhash symbol) which have the form:</para>

        <programlisting>
map_ret map_union ( t, DESTROYER, map_par, .... ) ;
        </programlisting>

        <para>These maps are implemented by having one function per field for
          each map. The output file <emphasis>union</emphasis>
          <literal>_map.h</literal> contains tables of these functions. These
          have the form:</para>

        <programlisting>
map_ret ( *map_union_table [ ORDER_union ] ) ( t,
map_par, .... ) = {
....
map_union_field,
....
} ;
        </programlisting>

        <para>where there is one entry per union field.</para>

        <para>In order to aid the construction of these functions a set of
          function headers is provided in <emphasis>union</emphasis>
          <literal>_hdr.h</literal>. These take the form:</para>

        <programlisting>
#define HDR_map_union_field\
  map_ret map_union_field ( name_union, destroyer, par, .... )\
  t name_union ;\
  DESTROYER destroyer ; /* if required */\
  map_par par ;\
  ....\
  {\
ctype comp ;\
....\
DECONS_union_field ( comp, ...., name_union ) ;
        </programlisting>

        <para>There is also an alternative function header,
          <literal>HDR_</literal><emphasis>map</emphasis>_d_
          <emphasis>union_field</emphasis>, which calls
          <literal>DESTROY_</literal><emphasis>union_field</emphasis> rather
          than <literal>DECONS_</literal><emphasis>union_field</emphasis>. The
          destructor function used is <emphasis>destroyer</emphasis>, if this
          parameter is present, or the default destructor,
          <literal>destroy_</literal><emphasis>name</emphasis>,
          otherwise.</para>
      </sect2>
    </sect1>
  </chapter>

  <chapter>
    <title>Implementation details</title>

    <sect1>
      <title>Implementation of types</title>

      <para>The C implementation of the type system
        -XREF-#TokenOutputspecified above is based on a single type,
        <emphasis>name</emphasis>, with the same name as the input algebra.
        This is defined as follows:</para>

      <programlisting>
typedef union name_tag {
  unsigned int ag_tag ;
  union name_tag *ag_ptr ;
  unsigned ag_enum ;
  unsigned long ag_long_enum ;
  name_dim ag_dim ;
  t ag_prim_type ;
  ....
} name ;
      </programlisting>

      <para>where <emphasis>t</emphasis> runs over all the primitive types.
        All of the types in the algebra can be packed into a block of cells of
        type <emphasis>name</emphasis>. The following paragraphs describe the
        implementation of each type, together with how they are packed as
        blocks of cells. This is illustrated by the following diagram:</para>

      <figure id="calc">
        <title>Packing of Types</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="calc" scale="100" format="PNG">
          </imageobject>
        </mediaobject>
      </figure>

      <para>Primitive types are implemented by a <literal>typedef</literal>
        defining the type in terms of its -XREF-#OutputPrimgiven definition. A
        primitive type can be packed into a single cell using the appropriate
        <literal>ag_prim_</literal><emphasis>type</emphasis> field of the
        union.</para>

      <para>Identity types are implemented by a <literal>typedef</literal>
        defining the type as being equal to another -XREF-#OutputIdenttype
        from the algebra.</para>

      <para>Enumeration types are all implemented as <literal>unsigned
        int</literal> if all its values fit into 16 bits, or <literal>unsigned
        long</literal> otherwise. An enumeration type can be packed into a
        single cell using the <literal>ag_enum</literal> or
        <literal>ag_long_enum</literal> field of the union.</para>

      <para>Structure types are implemented by a <literal>typedef</literal>
        defining the type to be the C structure with the
        -XREF-#OutputStructgiven components. A structure type may be packed
        into a block of cells by packing each of the components in
        turn.</para>

      <para>Union types are all implemented by a pointer to
        <emphasis>name</emphasis>. This pointer references a block of cells.
        The null pointer represents
        <literal>NULL_</literal><emphasis>union</emphasis>, otherwise the
        first cell contains the union discriminant tag (in the
        <literal>ag_tag</literal> field), with the subsequent cells containing
        the packed field components (shared components first, then unshared
        components). If the union has only one field then the discriminant can
        be omitted. The union itself can be packed into a single cell using
        the <literal>ag_ptr</literal> field of the union.</para>

      <para>Pointer types are all implemented by a pointer to
        <emphasis>name</emphasis>. Null pointers represent
        <literal>NULL_ptr</literal>, otherwise the pointer references a single
        cell. This cell contains a pointer to the packed version of the object
        being pointed to in its <literal>ag_ptr</literal> field.  A pointer
        type itself can be packed into a single cell using the
        <literal>ag_ptr</literal> field of the union.</para>

      <para>List types are all implemented by a pointer to
        <emphasis>name</emphasis>. Null pointers represent
        <literal>NULL_list</literal>, otherwise the pointer references a block
        of two cells. The first cell gives the tail of the list in its
        <literal>ag_ptr</literal> field; the second cell contains a pointer to
        the packed version of the head of the list in its
        <literal>ag_ptr</literal> field. A list type itself can be packed into
        a single cell using the <literal>ag_ptr</literal> field of the
        union.</para>

      <para>Stack types are identical to list types, with the head of the
        list</para>

      <para>Vector pointer and vector types are all implemented by
        structures</para>

      <programlisting>
typedef unsigned int name_dim ;

typedef struct {
  name *vec ;
  name *ptr ;
} name_VEC_PTR ;

typedef struct {
  name_dim dim ;
  name_VEC_PTR elems ;
} name_VEC ;
      </programlisting>

      <para>The <literal>vec</literal> field of a vector pointer contains a
        pointer to a block of cells containing the packed versions of the
        elements of the vector. The <literal>ptr</literal> field is a pointer
        to the current element of this block. A vector type also has a field
        giving the vector size. A vector pointer type can be packed into a
        block of two cells, using the <literal>ag_ptr</literal> field of each
        to hold its two components.  A vector type can similarly be packed
        into a block of three cells, the first holding the vector size in its
        <literal>ag_dim</literal> field.</para>

      <para>All size types are implemented as <literal>int</literal>.</para>
    </sect1>

    <sect1>
      <title>Support routines</title>

      <para>The implementation requires the user to provide certain support
        functions. Most fundamental are the routines for allocating and
        deallocating the blocks of cells which are used to store the types.
        These are specified as follows:</para>

      <programlisting>
name *gen_name ( unsigned int ) ;
void destroy_name ( name *, unsigned int ) ;
void dummy_destroy_name ( name *, unsigned int ) ;
      </programlisting>

      <para>where <literal>gen_</literal><emphasis>name</emphasis> allocates a
        block of cells of the given size,
        <literal>destroy_</literal><emphasis>name</emphasis> deallocates the
        given block, and
        <literal>dummy_destroy_</literal><emphasis>name</emphasis> has
        -XREF-#OutputBasicno effect. The precise details of how the memory
        management is to be handled are left to the user.</para>

      <para>Certain generic list functions must also be provided,
        namely:</para>

      <programlisting>
void destroy_name_list ( name *, unsigned int ) ;
name *reverse_name_list ( name * ) ;
name *append_name_list ( name *, name * ) ;
name *end_name_list ( name * ) ;
      </programlisting>

      <para>which implement the constructs <literal>DESTROY_list</literal>,
        <literal>REVERSE_list</literal>, <literal>APPEND_list</literal> and
        <literal>END_list</literal> respectively.</para>

      <para>Finally a dummy empty vector:</para>

      <programlisting>
name_VEC empty_name_vec ;
      </programlisting>

      <para>needs to be defined.</para>

      <para>Examples of these support routines can be found in the
        -XREF-#Example<literal>calculus</literal> program itself.</para>
    </sect1>

    <sect1>
      <title>Run-time checking</title>

      <para>The type checking facilities supported by
        <literal>calculus</literal> allow for compile-time detection of many
        potential programming errors, however there are many problems, such as
        dereferencing null pointers, deconstructing empty lists and union tag
        errors which can only be detected at run-time. For this reason
        <literal>calculus</literal> can be made to add extra assertions to
        check for such errors into its output. This is done by specifying the
        <literal>-a</literal> command-line option.</para>

      <para>These assertions are implemented by means of macros. If the macro
        <literal>ASSERTS</literal> is defined then these macros expand to give
        the run-time checks. If not the output is exactly equivalent to that
        which would have been output if the <literal>-a</literal> option had
        not been given.</para>

      <para>The assertions require certain support functions which are output
        into a separate file, <literal>assert_def.h</literal>. These functions
        need to be compiled into the program when <literal>ASSERTS</literal>
        is defined. Note that the functions are implementation
        specific.</para>
    </sect1>
  </chapter>

  <chapter>
    <title>Disk reading and writing</title>

    <para>One of the facilities which the -XREF-#COutputTypeshomogeneous
      implementation of the type system described above allows for is the
      addition of persistence. Persistence in this context means allowing
      objects to be written to, and read from, disk. Also discussed in this
      section is the related topic of the object printing routines, which
      allow a human readable representation of objects of the type system to
      be output for debugging or other purposes.</para>

    <para>The disk reading and writing routines are output into the files
      <literal>read_def.h</literal> and <literal>write_def.h</literal>
      respectively if the <literal>-d</literal> command-line option is passed
      to <literal>calculus</literal>. The object printing routines are output
      if the <literal>-p</literal> option is given, with additional code
      designed for use with run-time debuggers being added if the
      <literal>-a</literal> option is also given.</para>

    <para>All of these routines use extra constructs output in the main output
      files (<emphasis>name</emphasis><literal>.h</literal> and
      <emphasis>union</emphasis><literal>_ops.h</literal>), but not normally
      accessible. The macro
      <emphasis>name</emphasis><literal>_IO_ROUTINES</literal> should be
      defined in order to make these available for the disk reading and
      writing routines to use.</para>

    <sect1>
      <title>Disk writing routines</title>

      <para>The disk writing routines output in
        <literal>write_def.h</literal></para>

      <programlisting>
static void WRITE_type ( t ) ;
      </programlisting>

      <para>for each type <emphasis>t</emphasis> mentioned within the
        algebra</para>

      <para>Note that such routines are output not only for the basic types,
        such as unions and structures, but also for any composite types, such
        as pointers and lists, which are used in their definition. The
        <emphasis>type</emphasis> component of the name
        <literal>WRITE_</literal><emphasis>type</emphasis> is derived from
        basic types <emphasis>t</emphasis> by using the short type name.  For
        composite types it is defined recursively as follows:</para>

      <programlisting>
LIST ( t ) -&gt; list_type
PTR ( t ) -&gt; ptr_type
STACK ( t ) -&gt; stack_type
VEC ( t ) -&gt; vec_type
VEC_PTR ( t ) -&gt; vptr_type
      </programlisting>

      <para>Such functions are defined for identity types and composite types
        involving identity types by means of macros which define them in terms
        of the identity definitions.
        <literal>WRITE_</literal><emphasis>type</emphasis> functions for the
        primitive types should be provided by the user to form a foundation on
        which all the other functions may be built.</para>

      <para>The user may wish to generate
        <literal>WRITE_</literal><emphasis>type</emphasis> (or other disk
        reading and writing) functions for types other than those mentioned in
        the algebra definition. This can be done by means of a command-line
        option of the form <literal>-E</literal><emphasis>input</emphasis>
        where <emphasis>input</emphasis> is a file containing a list of the
        extra types required. In the notation -XREF-#TextInputused above the
        syntax for <emphasis>input</emphasis> is given by:</para>

      <programlisting>
extra :
  type-list<subscript>opt</subscript>

type-list :
  type ;
  type-list type ;
      </programlisting>

      <para>The <literal>WRITE_</literal><emphasis>type</emphasis> functions
        are defined recursively in an obvious fashion. The user needs to
        provide the writing routines for the primitives already mentioned,
        plus support routines (or macros):</para>

      <programlisting>
void WRITE_BITS ( int, unsigned int ) ;
void WRITE_DIM ( name_dim ) ;
void WRITE_ALIAS ( unsigned int ) ;
      </programlisting>

      <para>for writing a number of bits to disk, writing a vector
        dimension</para>

      <para>Any of the <literal>WRITE_</literal><emphasis>type</emphasis>
        functions may be overridden by the user by defining a macro
        <literal>WRITE_</literal><emphasis>type</emphasis> with the desired
        effect. Note that the
        <literal>WRITE_</literal><emphasis>type</emphasis> function for an
        identity can be overridden independently of the function for the
        identity definition. This provides a method for introducing types
        which are representationally the same, but which are treated
        differently by the disk reading and writing routines.</para>
    </sect1>

    <sect1>
      <title>Disk reading routines</title>

      <para>The disk reading routines output in <literal>read_def.h</literal>
        are exactly analogous to the disk writing routines. For each type
        <emphasis>t</emphasis> (except primitives) there is a function or
        macro:</para>

      <programlisting>
static t READ_type ( void ) ;
      </programlisting>

      <para>which reads an object of that type from disk. The user must
        provide the <literal>READ_</literal><emphasis>type</emphasis>
        functions for the primitive types, plus support routines:</para>

      <programlisting>
unsigned int READ_BITS ( int ) ;
name_dim READ_DIM ( void ) ;
unsigned int READ_ALIAS ( void ) ;
      </programlisting>

      <para>for reading a number of bits from disk, reading a vector dimension
        and reading an -XREF-#DiskAliasobject alias. The
        <literal>READ_</literal><emphasis>type</emphasis> functions may be
        overridden by means of macros as before.</para>
    </sect1>

    <sect1>
      <title>Object printing routines</title>

      <para>The object printing routines output in</para>

      <programlisting>
static void PRINT_type ( FILE *, t, char *, int ) ;
      </programlisting>

      <para>for each type <emphasis>t</emphasis>, which prints an object of
        type <emphasis>t</emphasis> to the given file, using the given object
        name and indentation value. The user needs to provide basic output
        routines:</para>

      <programlisting>
void OUTPUT_type ( FILE *, t ) ;
      </programlisting>

      <para>for each primitive type. The
        <literal>PRINT_</literal><emphasis>type</emphasis> functions may be
        overridden by means of macros as before.</para>

      <para>The printing routines are under the control of three
        variables</para>

      <programlisting>
static int print_indent_step = 4 ;
static int print_ptr_depth = 1 ;
static int print_list_expand = 0 ;
      </programlisting>

      <para>These determine the indentation to be used in the output, to what
        depth pointers are to be dereferenced when printing, and whether lists
        and stacks are to be fully expanded into a sequence of elements or
        just split into a head and a tail.</para>

      <para>One application of these object printing routines is to aid
        debugging programs written using the <literal>calculus</literal> tool.
        The form of the type system implementation means that it is not easy
        to extract information using run-time debuggers without a detailed
        knowledge of the structure of this implementation. As a more
        convenient alternative, if both the <literal>-p</literal> and
        <literal>-a</literal> command-line options are given then
        <literal>calculus</literal> will generate functions:</para>

      <programlisting>
void DEBUG_type ( t ) ;
      </programlisting>

      <para>defined in terms of
        <literal>PRINT_</literal><emphasis>type</emphasis>, for printing an
        object of the given type to the standard output. Many debuggers have
        problems passing structure arguments, so for structure, vector and
        vector pointer types
        <literal>DEBUG_</literal><emphasis>type</emphasis> takes the
        form:</para>

      <programlisting>
void DEBUG_type ( t * ) ;
      </programlisting>

      <para>These debugging routines are only defined conditionally, if
        the</para>
    </sect1>

    <sect1>
      <title>Aliasing</title>

      <para>An important feature of the disk reading and writing routines,
        namely aliasing, has been mentioned but not yet described. The problem
        to be faced is that many of the objects built up using type systems
        defined using <literal>calculus</literal> will be cyclic - they will
        include references to themselves in their own definitions. Aliasing is
        a mechanism for breaking such cycles by ensuring that only one copy of
        an object is ever written to disk, or that only one copy is created
        when reading from disk. This is done by associating a unique number as
        an alias for the object.</para>

      <para>For example, when writing to disk, the first time the object is
        written the alias definition is set up. Consequently the alias number
        is written instead of the object it represents. Similarly when reading
        from disk, an alias may be associated with an object when it is read.
        When this alias is encountered subsequently it will always refer to
        this same object.</para>

      <para>The objects on which aliasing can be specified are the
        -XREF-#InputUnionunion fields. A union field may be qualified by one
        or two hash symbols to signify that objects of that type should be
        aliased.</para>

      <para>The two hash case is used to indicate that the user wishes to gain
        access to the objects during the aliasing mechanism. In the disk
        writing case, the object to be written, <emphasis>x</emphasis> say, is
        split into its components using the appropriate
        <literal>DECONS_</literal><emphasis>union_field</emphasis> construct.
        Then the user-defined routine, or macro:</para>

      <programlisting>
ALIAS_union_field ( comp, ...., x ) ;
      </programlisting>

      <para>(where <emphasis>comp</emphasis> ranges over all the union
        components) is called prior to writing the object components to
        disk.</para>

      <para>Similarly in the disk reading case, the object being read,
        <emphasis>x</emphasis>, is initialised by calling the user-defined
        routine:</para>

      <programlisting>
UNALIAS_union_field ( x ) ;
      </programlisting>

      <para>prior to reading the object components from disk. Each object
        component is then read into a local variable,
        <emphasis>comp</emphasis>. Finally the user-defined routine:</para>

      <programlisting>
UNIFY_union_field ( comp, ...., x ) ;
      </programlisting>

      <para>(where <emphasis>comp</emphasis> ranges over all the union
        components) is called to assign these values to <emphasis>x</emphasis>
        before returning.</para>

      <para>In the single hash case the object is not processed in this way.
        It is just written straight to disk, or has its components immediately
        assigned to it when reading from disk.</para>

      <para>Note that aliasing is used, not just in the disk reading and
        writing routines, but also in the object printing functions. After
        calling any such function the user should call the routine:</para>

      <programlisting>
void clear_name_alias ( void ) ;
      </programlisting>

      <para>to clear all aliases.</para>

      <para>Aliases are implemented by adding an extra field to the objects to
        be aliased, which contains the alias number, if this has been
        assigned, or zero, otherwise. A list of all these extra fields is
        maintained. In addition to the routine
        <literal>clear_</literal><emphasis>name</emphasis>_alias mentioned
        above, the user should provide support functions and variables:</para>

      <programlisting>
unsigned int crt_name_alias ;
void set_name_alias ( name *, unsigned int ) ;
name *find_name_alias ( unsigned int ) ;
      </programlisting>

      <para>giving the next alias number to be assigned, and routines for
        adding an alias to the list of all aliases, and looking up an alias in
        this list. Example implementations of these routines are given in the
        -XREF-#Example<literal>calculus</literal> program itself.</para>
    </sect1>

    <sect1>
      <title>Application to calculus</title>

      <para>As -XREF-#Examplementioned above, the <literal>calculus</literal>
        program itself is an example of its own application. It therefore
        contains routines for reading and writing a representation of an
        algebra to and from disk, and for pretty-printing the contents of an
        algebra. These may be accessed using the -XREF-#Optionscommand-line
        options mentioned above.</para>

      <para>If the <literal>-w</literal> command-line option is specified to
        <literal>calculus</literal> then it reads its input file,
        <emphasis>input</emphasis>, as normal, but writes a disk
        representation of the input algebra to <emphasis>output</emphasis>,
        which in this instance is an output file, rather than an output
        directory. An output file produced in this way can then be specified
        as an input file to <literal>calculus</literal> if the
        <literal>-r</literal> option is given. Finally the input algebra may
        be pretty-printed to an output file (or the standard output if no
        <emphasis>output</emphasis> argument is given) by specifying the
        <literal>-o</literal> option.</para>
    </sect1>
  </chapter>

  <chapter>
    <title>Template files</title>

    <para>It is possible to use <literal>calculus</literal> to generate an
      output file from a template input file, <emphasis>template</emphasis>,
      using the syntax:</para>

    <programlisting>
calculus [ options ] input .... -Ttemplate output
    </programlisting>

    <para>The template file consists of a list of either template directives
      or source lines containing escape sequences which are expanded by
      <literal>calculus</literal>. Template directive lines are distinguished
      by having <literal>@</literal> as their first character. Escape
      sequences consist of <literal>%</literal> following by one or more
      characters.</para>

    <para>There are two template directives; loops take the form:</para>

    <programlisting>
@loop control
....
@end
    </programlisting>

    <para>and conditionals take the form:</para>

    <programlisting>
@if condition
....
@else
....
@endif
    </programlisting>

    <para>or:</para>

    <programlisting>
@if condition
....
@endif
    </programlisting>

    <para>where <literal>....</literal> stands for any sequence of
      template</para>

    <para>The <emphasis>control</emphasis> statements in a loop can be
      <literal>primitive</literal>, <literal>identity</literal>,
      <literal>enum</literal>, <literal>struct</literal> or
      <literal>union</literal> to loop over all the primitive, identity,
      enumeration structure or union types within the input algebra. Within an
      <literal>enum</literal> loop it is possible to use
      <literal>enum.const</literal> to loop over all the enumeration constants
      of the current enumeration type. Within a <literal>struct</literal> loop
      it is possible to use <literal>struct.comp</literal> to loop over all
      the components of the current structure. Within a
      <literal>union</literal> loop it is possible to use
      <literal>union.comp</literal> to loop over all the shared components of
      the current union, <literal>union.field</literal> to loop over all the
      fields of the current union, and <literal>union.map</literal> to loop
      over all the maps of the current union. Within a
      <literal>union.field</literal> loop it is possible to use
      <literal>union.field.comp</literal> to loop over all the components of
      the current union field. Within a <literal>union.map</literal> loop it
      is possible to use <literal>union.map.arg</literal> to loop over all the
      arguments of the current union map.</para>

    <para>The valid <emphasis>condition</emphasis> statements in a conditional
      are <literal>true</literal> and <literal>false</literal>, plus
      <literal>comp.complex</literal>, which is true if the current structure
      or union field component has a complex type (i.e. those for which
      <literal>COPY_</literal><emphasis>type</emphasis> and
      <literal>DEREF_</literal><emphasis>type</emphasis> require two
      arguments), and <literal>comp.default</literal>, which is true if the
      current structure or union field component has a default initialiser
      value.</para>

    <para>A number of escape sequences can be used anywhere.
      <literal>%ZX</literal> and <literal>%ZV</literal> give the name and
      version number of the version of <literal>calculus</literal> used.
      <literal>%Z</literal> and <literal>%V</literal> give the name and
      version number of the input algebra. <literal>%%</literal> and
      <literal>%@</literal> give <literal>%</literal> and <literal>@</literal>
      respectively, and <literal>%</literal> as the last character in a line
      suppresses the following newline character.</para>

    <para>Within a <literal>primitive</literal> loop, <literal>%PN</literal>
      gives the primitive name, <literal>%PM</literal> gives the short
      primitive name and <literal>%PD</literal> gives the primitive
      definition.</para>

    <para>Within an <literal>identity</literal> loop, <literal>%IN</literal>
      gives the identity name, <literal>%IM</literal> gives the short identity
      name and <literal>%IT</literal> gives the identity definition.</para>

    <para>Within an <literal>enum</literal> loop, <literal>%EN</literal> gives
      the enumeration name, <literal>%EM</literal> gives the short enumeration
      name and <literal>%EO</literal> gives the enumeration order,
      <literal>ORDER_</literal><emphasis>enum</emphasis>. Within an
      <literal>enum.const</literal> loop, <literal>%ES</literal> gives the
      enumeration constant name and <literal>%EV</literal> gives its
      value.</para>

    <para>Within a <literal>struct</literal> loop, <literal>%SN</literal>
      gives the structure name and <literal>%SM</literal> gives the short
      structure name.</para>

    <para>Within a <literal>union</literal> loop, <literal>%UN</literal> gives
      the union name, <literal>%UM</literal> gives the short union name and
      <literal>%UO</literal> gives the union order,
      <literal>ORDER_</literal><emphasis>union</emphasis>. Within a
      <literal>union.field</literal> loop, <literal>%FN</literal> gives the
      field name. Within a <literal>struct.comp</literal>,
      <literal>union.comp</literal> or <literal>union.field.comp</literal>
      loop, <literal>%CN</literal> gives the component name,
      <literal>%CT</literal> gives the component type, <literal>%CU</literal>
      gives the short form of the component type and <literal>%CV</literal>
      gives the default component initialiser value (if
      <literal>comp.default</literal> is true). Within a
      <literal>union.map</literal> loop, <literal>%MN</literal> gives the map
      name and <literal>%MR</literal> gives the map return type. Within a
      <literal>union.map.arg</literal> loop, <literal>%AN</literal> gives the
      argument name and <literal>%AT</literal> gives the argument type.</para>

    <para>As an example, the following template file gives a simple
      algebra</para>

    <programlisting>
ALGEBRA %X (%V):

/* PRIMITIVE TYPES */
@loop primitive
%PN (%PM) = "%PD" ;
@end

/* IDENTITY TYPES */
@loop identity
%IN (%IM) = %IT ;
@end

/* ENUMERATION TYPES */
@loop enum

enum %EN (%EM) = {
@loop enum.const
  %ES = %EV,
@end
} ;
@end

/* STRUCTURE TYPES */
@loop struct

struct %SN (%SM) = {
@loop struct.comp
  %CT %CN ;
@end
} ;
@end

/* UNION TYPES */
@loop union

union %UN (%UM) = {
@loop union.comp
%CT %CN ;
@end
} + {
@loop union.field
%FN -&gt; {
@loop union.field.comp
  %CT %CN ;
@end
} ;
@end
  } ;
@end
    </programlisting>
  </chapter>
</book>
