<!DOCTYPE BOOK PUBLIC "-//FreeBSD//DTD DocBook V4.1-Based Extension//EN"[
<!ENTITY % bookinfo PUBLIC "-//FreeBSD//ENTITIES DocBook BookInfo Entities//EN">
%bookinfo;
<!ENTITY tcpplus.manpage SYSTEM "../manpages/tcpplus/manpage.sgml">
<!ENTITY % man PUBLIC "-//FreeBSD//ENTITIES DocBook Manual Page Entities//EN">
%man;
<!ENTITY % doc PUBLIC "-//FreeBSD//ENTITIES DocBook Document Entities//EN">
%doc
]>

<book>
  <bookinfo>
    <title>C++ Producer Guide</title>

    <pubdate>$TenDRA$</pubdate>

    <corpauthor>The TenDRA Documentation Team</corpauthor>

    <copyright>
      <year>2002</year>
      <year>2003</year>
      <year>2004</year>
      <year>2005</year>
      <holder>TenDRA Documentation Team</holder>
    </copyright>

    <copyright>
      <year>1997</year>
      <year>1998</year>
      <holder>Defence Evaluation and Research Agency (DERA)</holder>
    </copyright>

    <abstract>
      <para>Please email us at <email>docs@ten15.org</email> if you see any errors</para>
    </abstract>

    <legalnotice id='legalnotice'>
      <para>Extensions to this document from the original
        <ulink url='ftp://ftp.ten15.org/pub/source/TenDRA-4.1.2-doc.tar.gz'>TenDRA-4.1.2-doc.tar.gz</ulink>
        source distribution are covered by the <link linkend='legal-bsdl'>BSDL</link>,
        while all prior modifications remain under the
        <link linkend='legal-crown'>Crown Copyright</link>.</para>
    </legalnotice>

    &bookinfo.legalnotice;

    &bookinfo.legalnotice-crown;

  </bookinfo>

  <preface id='intro'>
    <title>Introduction</title>

    <para>This document is designed as a technical overview of the TenDRA C++
      to TDF/ANDF producer. It is divided into two broad areas; descriptions of
      the <link linkend='interface-desc'>public interfaces</link> of the
      producer, and an overview of the
      producer <link linkend='program-overview'>source code</link>.</para>

    <para>Whereas the interface description contains most of the information
      which would be required in a users' guide, it is not necessarily in a
      readily digestible form. The C++ producer is designed to complement the
      existing TenDRA C to TDF producer; although they are completely distinct
      programs, the same design philosophy underlies both and they share a number
      of common interfaces. There are no radical differences between the two
      producers, besides the fact that the C++ producer covers a vastly larger
      and more complex language. This means that much of the &doc.tdfc; existing
      documentation on the C producer can be taken as also applying to the C++
      producer. This document tries to make clear where the C++ producer extends
      the C producer's interfaces, and those portions of these interfaces which
      are not directly applicable to C++.</para>

    <para>A familiarity with both C++ and TDF is assumed. The version of
      C++ implemented is that given by the <xref linkend='bib-draft-pro-std'> .
      All references to &quot;ISO C++&quot; within the document should
      strictly be qualified using the word &quot;draft&quot;, but for convenience
      this has been left implicit. The C++ producer has a number of switches
      which allow it to be configured for older dialects of C++. In particular,
      the version of C++ described in the  ARM (<xref linkend='bib-anno-cpp-ref-man'> ) is fully supported.</para>

    <para>The &doc.tdf; may be consulted for a
      description of the compiler intermediate language used. The paper
      &doc.port; <emphasis>TDF and Portability</emphasis> provides a useful (if
      slightly old) introduction to some of the ideas relating to static program
      analysis and interface checking which underlie the whole TenDRA compilation
      system.</para>
  </preface>

  <bibliography>
    <biblioentry>
      <title>Tdfc: The C to TDF Producer Issue 1.0
      (DRA/CIS3/OSSG/TR/95/102/1.0)</title>
    </biblioentry>

    <biblioentry id='bib-draft-pro-std'>
      <title>
        <ulink url="http://www.maths.warwick.ac.uk/c++/pub/wp/html/cd2/">Working paper for
        Draft Proposed Internation Standard for Information Systems - Programming
      Language C++</ulink> X3J16/96-0225</title>

      <copyright><year>December 1996</year></copyright>
    </biblioentry>

    <biblioentry id='bib-anno-cpp-ref-man'>
      <authorgroup>
        <author>
          <firstname>Margaret</firstname><surname>Ellis</surname>
        </author>

        <author>
          <firstname>Bjarne</firstname><surname>Stroustrup</surname>
        </author>
      </authorgroup>
      <title>
        <ulink url="http://heg-school.aw.com/cseng/authors/ellis/annocpp/annocpp.html">The Annotated C++ Reference Manual</ulink></title>
      <copyright><year>1990</year></copyright>
      <publishername>Addison-Wesley</publishername> <isbn>0-201-51459-1</isbn>
    </biblioentry>

    <biblioentry id='bib-ccs'>
      <title>C Coding Standards, DRA/CIS(SE2)/WI/94/57/2.0 (OSSG internal
      document)</title>
    </biblioentry>
  </bibliography>

  <chapter id='interface-desc'>
    <title>Interface Descriptions</title>

    <para>The most important public interfaces of the C++ producer are the ISO
      C++ standard and the TDF 4.0 specification; however there are other
      interfaces, mostly common to both the C and C++ producers, which are
      described in this section.</para>

    <para>An important design criterion of the C++ producer was that it should
      be strictly ISO conformant by default, but have a method whereby dialect
      features and extra static program analysis can be enabled. This compiler
      configuration is controlled by the <link linkend='configuration'>
      <literal>#pragma TenDRA</literal></link>
      directives described in the first section.</para>

    <para>The requirement that the C and C++ producers should be able to
      translate portable C or C++ programs into target independent TDF requires a
      mechanism whereby the target dependent implementations of APIs can be
      represented. This mechanism, the <link linkend='token-syntax'>
      <literal>#pragma token</literal> syntax</link>,
      is described in the following section. Note that at
      present this mechanism only contains support for C APIs; it is considered
      that the C++ language itself contains sufficient interface mechanisms for
      C++ APIs to be described.</para>

    <para>The C and C++ producers provide two mechanisms whereby type and
      declaration information derived from a translation unit can be stored to a
      file for post-processing by other tools. The first is the
      <link linkend='symbol-table-dump'>symbol table dump</link>, which is a
      public interface designed for use by third
      party tools. The second is the <link linkend='cpp-spec-file'>C++ spec file</link>, which is
      designed for ease of reading and writing by the producers themselves, and
      is used for intermodule analysis.</para>

    <para>The mapping from C++ to TDF implemented by the C++ producer is
      largely straightforward. There are however target dependencies arising
      within the language itself which require special handling. These are
      represented by certain <link linkend='implementation-details'>standard
      tokens </link> which the producer
      requires to be defined on the target machine. These tokens are also used to
      describe the interface between the producer and the run-time system. Note
      that the C++ producer is primarily concerned with the C++ language, not
      with the standard C++ library. An example implementation of those library
      components which are required as an integral part of the language (memory
      allocation, exception handling, run-time type information etc.) is
      provided. Otherwise, libraries should be obtained from third parties. A
      number of hints on <link linkend='standard-lib'>integrating such
      libraries</link> with the C++ producer are given.</para>

    <sect1 id='invocation'>
      <title>Invocation</title>

      <para>In this section it is described how the C++ to TDF producer,
        <literal>tcpplus</literal>, fits into the overall compilation scheme
        controlled by the TenDRA compiler front-end, <literal>tcc</literal>, or
        the TenDRA checker front-end, <literal>tchk</literal>. While it is
        possible to use <literal>tcpplus</literal> as a stand-alone program, it
        is recommended that it should be invoked via <literal>tcc</literal> or
        <literal>tchk</literal>. The <literal>tcc</literal> users' guide should
        be consulted for more details.</para>

      <para><literal>tcc</literal> and <literal>tchk</literal> require the
        <literal>-Yc++</literal> command-line option in order to enable their C++
        capabilities. Files with a <literal>.C</literal> suffix are recognised as
        C++ source files and passed to <literal>tcpplus</literal> for processing
        (see <xref linkend='compilation-scheme'> ). It is possible to change the suffix used
        for C++ source files; for example <literal>-sC:cc</literal> causes
        <literal>.cc</literal> files to be recognised as C++ source files. An
        interesting variation is <literal>-sC:c</literal> which causes C source
        files to be processed by the C++ producer. Similarly
        <literal>.I</literal> files are recognised as preprocessed C++ source
        files and <literal>.K</literal> files are recognised as C++ spec
        files.</para>

      <para>Most of the command-line option handling for
        <literal>tcpplus</literal> is done by <literal>tcc</literal> and
        <literal>tchk</literal>, however it is possible to pass the option
        <emphasis>opt</emphasis> directly to <literal>tcpplus</literal> using the
        option <literal>-Wx,</literal><emphasis>opt</emphasis> to
        <literal>tcc</literal> or <literal>tchk</literal>. Similarly
        <literal>-Wg,</literal><emphasis>opt</emphasis> and
        <literal>-WS,</literal><emphasis>opt</emphasis> can be used to pass
        options to the C++ preprocessor and the C++ spec linker (both of which
        are actually <literal>tcpplus</literal> invoked with different options)
        respectively.</para>

      <sect2 id='compilation-scheme'>
        <title>Compilation scheme</title>

        <para>The overall compilation scheme controlled by
          <literal>tcc</literal>, as it relates to the C++ producer, can be
          represented as follows:</para>

        <figure id="compile-scheme">
          <title>Compile Scheme</title>

          <mediaobject>
            <imageobject><imagedata fileref="compile" format=
            "PNG"></imageobject>
          </mediaobject>
        </figure>

        <para>Each C++ source file, <literal>a.C</literal> say, is processed
          using <literal>tcpplus</literal> to give an output TDF capsule,
          <literal>a.j</literal>, which is passed to the installer phase of
          <literal>tcc</literal>. The capsule is linked with any target dependent
          token definition libraries, translated to assembler and assembled to
          give a binary object file, <literal>a.o</literal>. The various object
          files comprising the program are then linked with the system libraries
          to give a final executable, <literal>a.out</literal>.</para>

        <para>In addition to this main compilation scheme,
          <literal>tcpplus</literal> can additionally be made to output a
          <link linkend='cpp-spec-file'>C++ spec file</link> for each C++ source file,
          <literal>a.K</literal> say. These C++ spec files can be linked, using
          <literal>tcpplus</literal> in its spec linker mode, to give an
          additional TDF capsule, <literal>x.j</literal> say, and a combined C++
          spec file, <literal>x.K</literal>. The main purpose of this C++ spec
          linking is to perform intermodule checks on the program, however in the
          course of this checking exported templates which are defined in one
          module and used in another are instantiated. This extra code is output
          to <literal>x.j</literal>, which is then installed and linked in the
          normal way.</para>

        <para>Note that intermodule checks, and hence intermodule template
          instantiations, are only performed if the <literal>-im</literal> option
          is passed to <literal>tcc</literal>.</para>

        <para>The TenDRA checker, <literal>tchk</literal>, is similar to
          <literal>tcc</literal> except that it disables TDF output and has
          intermodule analysis enabled by default.</para>
      </sect2>

      <sect2 id='producer-options'>
        <title>Producer options</title>

    <para>Please see the <link linkend='tcpplus-manpage'><literal>tcpplus
      </literal> manual page</link> for a complete list of
      command-line options.</para>

      </sect2>
    </sect1>

    <sect1 id='configuration'>
      <title>Configuration</title>

      <para>This section describes how the C++ producer can be configured to
        apply extra static checks or to support various dialects of C++. In all
        cases the default behaviour is precisely that specified in the ISO C++
        standard with no extra checks.</para>

      <para>Certain very basic configuration information is specified using a
        <link linkend='port-tables'>portability table</link>, however the
        primary method of
        configuration is by means of <literal>#pragma</literal> directives. These
        directives may be placed within the program itself, however it is
        generally more convenient to group them into a
        <link linkend='tcpplus-f-option'>startup file</link> 
        in order to create a user-defined compilation
        profile. The <literal>#pragma</literal> directives recognised by the C++
        producer have one of the equivalent forms:</para>
<programlisting>
#pragma TenDRA ....
#pragma TenDRA++ ....
</programlisting>

      <para>Some of these are common to the C and C++ producers (although often
        with differing default behaviour). The C producer will ignore any
        <literal>TenDRA++</literal> directives, so these may be used in
        compilation profiles which are to be used by both producers. In the
        descriptions below, the presence of a <literal>++</literal> is used to
        indicate a directive which is C++ specific; the other directives are
        common to both producers.</para>

      <para>Within the description of the <literal>#pragma</literal> syntax,
        <emphasis>on</emphasis> stands for <literal>on</literal>,
        <literal>off</literal> or <literal>warning</literal>,
        <emphasis>allow</emphasis> stands for <literal>allow</literal>,
        <literal>disallow</literal> or <literal>warning</literal>,
        <emphasis>string-literal</emphasis> is any string literal,
        <emphasis>integer-literal</emphasis> is any integer literal,
        <emphasis>identifier</emphasis> is any simple, unqualified identifier
        name, and <emphasis>type-id</emphasis> is any type identifier. Other
        syntactic items are described in the text. A
        <link linkend='pragma-directive-syntax'>complete grammar</link>
        for the <literal>#pragma</literal> directives accepted by the C++
        producer is given as an annex.</para>

      <sect2 id='port-tables'>
        <title>Portability tables</title>

        <para>Certain very basic configuration information is read from a file
          called a portability table, which may be specified to the producer
          using a <link linkend='tcpplus-n-option'><literal>-n</literal>
          option</link>. This
          information includes the minimum sizes of the basic integral types, the
          <link linkend='character-literals'>sign of plain
          <literal>char</literal></link>, and whether signed
          types can be assumed to be symmetric (for example, [-127,127]) or
          maximum (for example, [-128,127]).</para>

        <para>The default portability table values, which are built into the
          producer, can be expressed in the form:</para>
<programlisting>
char_bits           8
short_bits          16
int_bits            16
long_bits           32
signed_range            symmetric
char_type           either
ptr_int             none
ptr_fn              no
non_prototype_checks        yes
multibyte           1
</programlisting>

        <para>This illustrates the syntax for the portability table; note that
          all ten entries are required, even though the last four are
          ignored.</para>
      </sect2>

      <sect2 id='low-level-conf'>
        <title>Low level configuration</title>

        <para>The simplest level of configuration is to reset the severity
          level of a particular error message using:</para>
<programlisting>
#pragma TenDRA++ error <emphasis>string-literal on</emphasis>
#pragma TenDRA++ error <emphasis>string-literal allow</emphasis>
</programlisting>

        <para>The given <emphasis>string-literal</emphasis> should name an
          error from the <link linkend='error-catalogue'>error
          catalogue</link>. A severity of
          <literal>on</literal> or <literal>disallow</literal> indicates that the
          associated diagnostic message should be an error, which causes the
          compilation to fail. A severity of <literal>warning</literal> indicates
          that the associated diagnostic message should be a warning, which is
          printed but allows the compilation to continue. A severity of
          <literal>off</literal> or <literal>allow</literal> indicates that the
          associated error should be ignored. Reducing the severity of any error
          from its default value, other than via one of the dialect directives
          described in this section, results in undefined behaviour.</para>

        <para>The next level of configuration is to reset the severity level of
          a particular compiler option using:</para>
<programlisting>
#pragma TenDRA++ option <emphasis>string-literal on</emphasis>
#pragma TenDRA++ option <emphasis>string-literal allow</emphasis>
</programlisting>

        <para>The given <emphasis>string-literal</emphasis> should name an
          option from the option catalogue. The simplest form of compiler option
          just sets the severity level of one or more error messages. Some of
          these options may require additional processing to be applied.</para>

        <para>It is possible to link a particular error message to a particular
          compiler option using:</para>
<programlisting>
#pragma TenDRA++ error <emphasis>string-literal</emphasis> as option <emphasis>string-literal</emphasis>
</programlisting>

        <para>Note that the directive:</para>
<programlisting>
#pragma TenDRA++ use error <emphasis>string-literal</emphasis>
</programlisting>

        <para>can be used to raise a given error at any point in a translation
          unit in a similar fashion to the <literal>#error</literal> directive.
          The values of any parameters for this error are unspecified.</para>

        <para>The directives just described give the primitive operations on
          error messages and compiler options. Many of the remaining directives
          in this section are merely higher level ways of expressing these
          primitives.</para>
      </sect2>

      <sect2 id='checking-scopes'>
        <title>Checking scopes</title>

        <para>Most compiler options are scoped. A checking scope may be defined
          by enclosing a list of declarations within:</para>
<programlisting>
#pragma TenDRA begin
....
#pragma TenDRA end
</programlisting>

        <para>If the final <literal>end</literal> directive is omitted then the
          scope ends at the end of the translation unit. Checking scopes may be
          nested in the obvious way. A checking scope inherits its initial set of
          checks from its enclosing scope (this includes the implicit main
          checking scope consisting of the entire input file). Any checks
          switched on or off within a scope apply only to the remainder of that
          scope and any scope it contains. A particular check can only be set
          once in a given scope. The set of applied checks reverts to its
          previous state at the end of the scope.</para>

        <para>A checking scope can be named using the directives:</para>
<programlisting>
#pragma TenDRA begin name environment <emphasis>identifier</emphasis>
....
#pragma TenDRA end
</programlisting>

        <para>Checking scope names occupy a namespace distinct from any other
          namespace within the translation unit. A named scope defines a set of
          modifications to the current checking scope. These modifications may be
          reapplied within a different scope using:</para>
<programlisting>
#pragma TenDRA use environment <emphasis>identifier</emphasis>
</programlisting>

        <para>The default behaviour is not to allow checks set in the named
          checking scope to be reset in the current scope. This can however be
          modified using:</para>
<programlisting>
#pragma TenDRA use environment <emphasis>identifier</emphasis> reset <emphasis>allow</emphasis>
</programlisting>

        <para>Another use of a named checking scope is to associate a checking
          scope with a named include file directory. This is done using:</para>
<programlisting>
#pragma TenDRA directory <emphasis>identifier</emphasis> use environment <emphasis>identifier</emphasis>
</programlisting>

        <para>where the directory name is one introduced via a
          <link linkend='tcpplus-bigN-option'><literal>-N</literal> command-line
          option</link>. The
          effect of this directive, if a <literal>#include</literal> directive is
          found to resolve to a file from the given directory, is as if the file
          was enclosed in directives of the form:</para>
<programlisting>
#pragma TenDRA begin
#pragma TenDRA use environment <emphasis>identifier</emphasis> reset allow
....
#pragma TenDRA end
</programlisting>

        <para>The checks applied to the expansion of a macro definition are
          those from the scope in which the macro was defined, not that in which
          it was expanded. The macro arguments are checked in the scope in which
          they are specified, that is to say, the scope in which the macro is
          expanded. This enables macro definitions to remain localised with
          respect to checking scopes.</para>
      </sect2>

      <sect2 id='implementation-limits'>
        <title>Implementation limits</title>

        <para>This table gives the default implementation limits imposed by the
          C++ producer for the various implementation quantities listed in Annex
          B of the ISO C++ standard, together with the minimum limits allowed in
          ISO C and C++. A default limit of <emphasis>none</emphasis> means that
          the quantity is limited only by the size of the host machine (either
          <literal>ULONG_MAX</literal> or until it runs out of memory). A limit
          of <emphasis>target</emphasis> means that while no limits is imposed by
          the C++ front-end, particular target machines may impose such
          limits.</para>

        <table frame='all' id='impl-limits'>
          <title>Implementation Limits</title>

          <tgroup cols='4'>
            <thead>
              <row>
                <entry>Quantity identifier</entry>

                <entry>Min C limit</entry>

                <entry>Min C++ limit</entry>

                <entry>Default limit</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>statement_depth</entry>

                <entry>15</entry>

                <entry>256</entry>

                <entry>none</entry>
              </row>

              <row>
                <entry>hash_if_depth</entry>

                <entry>8</entry>

                <entry>256</entry>

                <entry>none</entry>
              </row>

              <row>
                <entry>declarator_max</entry>

                <entry>12</entry>

                <entry>256</entry>

                <entry>none</entry>
              </row>

              <row>
                <entry>paren_depth</entry>

                <entry>32</entry>

                <entry>256</entry>

                <entry>none</entry>
              </row>

              <row>
                <entry>name_limit</entry>

                <entry>31</entry>

                <entry>1024</entry>

                <entry>none</entry>
              </row>

              <row>
                <entry>extern_name_limit</entry>

                <entry>6</entry>

                <entry>1024</entry>

                <entry>target</entry>
              </row>

              <row>
                <entry>external_ids</entry>

                <entry>511</entry>

                <entry>65536</entry>

                <entry>target</entry>
              </row>

              <row>
                <entry>block_ids</entry>

                <entry>127</entry>

                <entry>1024</entry>

                <entry>none</entry>
              </row>

              <row>
                <entry>macro_ids</entry>

                <entry>1024</entry>

                <entry>65536</entry>

                <entry>none</entry>
              </row>

              <row>
                <entry>func_pars</entry>

                <entry>31</entry>

                <entry>256</entry>

                <entry>none</entry>
              </row>

              <row>
                <entry>func_args</entry>

                <entry>31</entry>

                <entry>256</entry>

                <entry>none</entry>
              </row>

              <row>
                <entry>macro_pars</entry>

                <entry>31</entry>

                <entry>256</entry>

                <entry>none</entry>
              </row>

              <row>
                <entry>macro_args</entry>

                <entry>31</entry>

                <entry>256</entry>

                <entry>none</entry>
              </row>

              <row>
                <entry>line_length</entry>

                <entry>509</entry>

                <entry>65536</entry>

                <entry>none</entry>
              </row>

              <row>
                <entry>string_length</entry>

                <entry>509</entry>

                <entry>65536</entry>

                <entry>none</entry>
              </row>

              <row>
                <entry>sizeof_object</entry>

                <entry>32767</entry>

                <entry>262144</entry>

                <entry>target</entry>
              </row>

              <row>
                <entry>include_depth</entry>

                <entry>8</entry>

                <entry>256</entry>

                <entry>256</entry>
              </row>

              <row>
                <entry>switch_cases</entry>

                <entry>257</entry>

                <entry>16384</entry>

                <entry>none</entry>
              </row>

              <row>
                <entry>data_members</entry>

                <entry>127</entry>

                <entry>16384</entry>

                <entry>none</entry>
              </row>

              <row>
                <entry>enum_consts</entry>

                <entry>127</entry>

                <entry>4096</entry>

                <entry>none</entry>
              </row>

              <row>
                <entry>nested_class</entry>

                <entry>15</entry>

                <entry>256</entry>

                <entry>none</entry>
              </row>

              <row>
                <entry>atexit_funcs</entry>

                <entry>32</entry>

                <entry>32</entry>

                <entry>target</entry>
              </row>

              <row>
                <entry>base_classes</entry>

                <entry>N/A</entry>

                <entry>16384</entry>

                <entry>none</entry>
              </row>

              <row>
                <entry>direct_bases</entry>

                <entry>N/A</entry>

                <entry>1024</entry>

                <entry>none</entry>
              </row>

              <row>
                <entry>class_members</entry>

                <entry>N/A</entry>

                <entry>4096</entry>

                <entry>none</entry>
              </row>

              <row>
                <entry>virtual_funcs</entry>

                <entry>N/A</entry>

                <entry>16384</entry>

                <entry>none</entry>
              </row>

              <row>
                <entry>virtual_bases</entry>

                <entry>N/A</entry>

                <entry>1024</entry>

                <entry>none</entry>
              </row>

              <row>
                <entry>static_members</entry>

                <entry>N/A</entry>

                <entry>1024</entry>

                <entry>none</entry>
              </row>

              <row>
                <entry>friends</entry>

                <entry>N/A</entry>

                <entry>4096</entry>

                <entry>none</entry>
              </row>

              <row>
                <entry>access_declarations</entry>

                <entry>N/A</entry>

                <entry>4096</entry>

                <entry>none</entry>
              </row>

              <row>
                <entry>ctor_initializers</entry>

                <entry>N/A</entry>

                <entry>6144</entry>

                <entry>none</entry>
              </row>

              <row>
                <entry>scope_qualifiers</entry>

                <entry>N/A</entry>

                <entry>256</entry>

                <entry>none</entry>
              </row>

              <row>
                <entry>external_specs</entry>

                <entry>N/A</entry>

                <entry>1024</entry>

                <entry>none</entry>
              </row>

              <row>
                <entry>template_pars</entry>

                <entry>N/A</entry>

                <entry>1024</entry>

                <entry>none</entry>
              </row>

              <row>
                <entry>instance_depth</entry>

                <entry>N/A</entry>

                <entry>17</entry>

                <entry>17</entry>
              </row>

              <row>
                <entry>exception_handlers</entry>

                <entry>N/A</entry>

                <entry>256</entry>

                <entry>none</entry>
              </row>

              <row>
                <entry>exception_specs</entry>

                <entry>N/A</entry>

                <entry>256</entry>

                <entry>none</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>It is possible to impose lower limits on most of the quantities
          listed above by means of the directive:</para>
<programlisting>
#pragma TenDRA++ option value <emphasis>string-literal integer-literal</emphasis>
</programlisting>

        <para>where <emphasis>string-literal</emphasis> gives one of the
          quantity identifiers listed above and
          <emphasis>integer-literal</emphasis> gives the limit to be imposed. An
          error is reported if the quantity exceeds this limit (note however that
          checks have not yet been implemented for all of the quantities listed).
          Note that the <link linkend='identifier-names'><literal>name_limit
          </literal></link> and
          <link linkend='inclusion-directives'><literal>include_depth</literal>
          </link> implementation
          limits can be set using dedicated directives.</para>

        <para>The maximum number of errors allowed before the producer bails
          out can be set using the directive:</para>
<programlisting>
#pragma TenDRA++ set error limit <emphasis>integer-literal</emphasis>
</programlisting>

        <para>The default value is 32.</para>
      </sect2>

      <sect2 id='lexical-analysis'>
        <title>Lexical analysis</title>

        <para>During lexical analysis, a source file which is not empty should
          end in a newline character. It is possible to relax this constraint
          using the directive:</para>
<programlisting>
#pragma TenDRA no nline after file end <emphasis>allow</emphasis>
</programlisting>
      </sect2>

      <sect2 id='keywords'>
        <title>Keywords</title>

        <para>In several places in this section it is described how to
          introduce keywords for TenDRA language extensions. By default, no such
          extra keywords are defined. There are also low-level directives for
          defining and undefining keywords. The directive:</para>
<programlisting>
#pragma TenDRA++ keyword <emphasis>identifier</emphasis> for keyword <emphasis>identifier</emphasis>
</programlisting>

        <para>can be used to introduce a keyword (the first identifier)
          standing for the standard C++ keyword given by the second identifier.
          The directive:</para>
<programlisting>
#pragma TenDRA++ keyword <emphasis>identifier</emphasis> for operator <emphasis>operator</emphasis>
</programlisting>

        <para>can similarly be used to introduce a keyword giving an
          alternative representation for the given operator or punctuator, as,
          for example, in:</para>
<programlisting>
#pragma TenDRA++ keyword and for operator &amp;&amp;
</programlisting>

        <para>Finally the directive:</para>
<programlisting>
#pragma TenDRA++ undef keyword <emphasis>identifier</emphasis>
</programlisting>

        <para>can be used to undefine a keyword.</para>
      </sect2>

      <sect2 id='comments'>
        <title>Comments</title>

        <para>C-style comments do not nest. The directive:</para>
<programlisting>
#pragma TenDRA nested comment analysis <emphasis>on</emphasis>
</programlisting>

        <para>enables a check for the characters <literal>/*</literal> within
          C-style comments.</para>

        <para>Whether <literal>//</literal> comments are recognised is
          controlled by the pragma:
<programlisting>
#pragma TenDRA line comment <emphasis>allow</emphasis>
</programlisting>
          They are enabled for C++ code and in the C99 environment.
      </sect2>

      <sect2 id='identifier-names'>
        <title>Identifier names</title>

        <para>During lexical analysis, each character in the source file has an
          associated look-up value which is used to determine whether the
          character can be used in an identifier name, is a white space character
          etc. These values are stored in a simple look-up table. It is possible
          to set the look-up value using:</para>
<programlisting>
#pragma TenDRA++ character <emphasis>character-literal</emphasis> as <emphasis>character-literal</emphasis> allow
</programlisting>

        <para>which sets the look-up for the first character to be the default
          look-up for the second character. The form:</para>
<programlisting>
#pragma TenDRA++ character <emphasis>character-literal</emphasis> disallow
</programlisting>

        <para>sets the look-up of the character to be that of an invalid
          character. The forms:</para>
<programlisting>
#pragma TenDRA++ character <emphasis>string-literal</emphasis> as <emphasis>character-literal</emphasis> allow
#pragma TenDRA++ character <emphasis>string-literal</emphasis> disallow
</programlisting>

        <para>can be used to modify the look-up values for the set of
          characters given by the string literal. For example:</para>
<programlisting>
#pragma TenDRA character '$' as 'a' allow
#pragma TenDRA character '\r' as ' ' allow
</programlisting>

        <para>allows <literal>$</literal> to be used in identifier names (like
          <literal>a</literal>) and carriage return to be a white space
          character. The former is a common dialect feature and can also be
          controlled by the directive:</para>
<programlisting>
#pragma TenDRA dollar as ident <emphasis>allow</emphasis>
</programlisting>

        <para>The maximum number of characters allowed in an identifier name
          can be set using the directives:</para>
<programlisting>
#pragma TenDRA set name limit <emphasis>integer-literal</emphasis>
#pragma TenDRA++ set name limit <emphasis>integer-literal</emphasis> warning
</programlisting>

        <para>This length is given by the <literal>name_limit</literal>
          implementation quantity <link linkend='implementation-limits'>
          mentioned above</link>. Identifiers
          which exceed this length raise an error or a warning, but are not
          truncated.</para>
      </sect2>

      <sect2 id='predefined-identifiers'>
        <title>Predefined identifiers</title>

        <para>The C99 standard introduces the concept of <emphasis>predefined
          identifiers</emphasis>, the only one of which currently is
          <literal>__func__ </literal>.  It behaves as if each function started
          with the declaration
<programlisting>
static const char __func__[] = <emphasis>"func-name"</emphasis>;
</programlisting>
          where <emphasis>func-name</emphasis> is the name of the current
          function.  The identifier <literal>__func__</literal> can be enabled
          with the directive:</para>
<programlisting>
#pragma TenDRA identifier __func__ <emphasis>allow</emphasis>
</programlisting>
        <para>The identifier <literal>__func__</literal> can also be used in
          C++ code with one limitation: within constructors, destructors,
          conversion functions and overloaded operators
          <literal>__func__</literal> is an empty string.</para>
      </sect2>

      <sect2 id='integer-literals'>
        <title>Integer literals</title>

        <para>The rules for finding the type of an integer literal can be
          described using directives of the form:</para>
<programlisting>
#pragma TenDRA integer literal <emphasis>literal-spec</emphasis>
</programlisting>

        <para>where:</para>
<programlisting>
<emphasis>literal-spec</emphasis> :
  <emphasis>literal-base literal-suffix<subscript>opt</subscript> literal-type-list</emphasis>

<emphasis>literal-base</emphasis> :
  octal
  decimal
  hexadecimal

<emphasis>literal-suffix</emphasis> :
  unsigned
  long
  unsigned long
  long long
  unsigned long long

<emphasis>literal-type-list</emphasis> :
  * <emphasis>literal-type-spec</emphasis>
  <emphasis>integer-literal literal-type-spec</emphasis> | <emphasis>literal-type-list</emphasis>
  ? <emphasis>literal-type-spec</emphasis> | <emphasis>literal-type-list</emphasis>

<emphasis>literal-type-spec</emphasis> :
  : <emphasis>type-id</emphasis>
  * <emphasis>allow<subscript>opt</subscript></emphasis> : <emphasis>identifier</emphasis>
  * * <emphasis>allow<subscript>opt</subscript></emphasis> :
</programlisting>

        <para>Each directive gives a literal base and suffix, describing the
          form of an integer literal, and a list of possible types for literals
          of this form. This list gives a mapping from the value of the literal
          to the type to be used to represent the literal. There are three cases
          for the literal type; it may be a given integral type, it may be
          calculated using a given <link linkend='integer-literal-types'>
          literal type token</link>, or
          it may cause an error to be raised. There are also three cases for
          describing a literal range; it may be given by values less than or
          equal to a given integer literal, it may be given by values which are
          guaranteed to fit into a given integral type, or it may be match any
          value. For example:</para>
<programlisting>
#pragma token PROC ( VARIETY c ) VARIETY l_i # ~lit_int
#pragma TenDRA integer literal decimal 32767 : int | ** : l_i
</programlisting>

        <para>describes how to find the type of a decimal literal with no
          suffix. Values less that or equal to 32767 have type
          <literal>int</literal>; larger values have target dependent type
          calculated using the token <literal>~lit_int</literal>. Introducing a
          <literal>warning</literal> into the directive will cause a warning to
          be printed if the token is used to calculate the value.</para>

        <para>Note that this scheme extends that implemented by the C producer,
          because of the need for more accurate information in the C++ producer.
          For example, the specification above does not fully express the ISO
          rule that the type of a decimal integer is the first of the types
          <literal>int</literal>, <literal>long</literal> and <literal>unsigned
          long</literal> which it fits into (it only expresses the first step).
          However with the C++ extensions it is possible to write:</para>
<programlisting>
#pragma token PROC ( VARIETY c ) VARIETY l_i # ~lit_int
#pragma TenDRA integer literal decimal ? : int | ? : long |\
? : unsigned long | ** : l_i
</programlisting>
      </sect2>

      <sect2 id='character-literals'>
        <title>Character literals and built-in types</title>

        <para>By default, a simple character literal has type
          <literal>int</literal> in C and type <literal>char</literal> in C++.
          The type of such literals can be controlled using the directive:</para>
<programlisting>
#pragma TenDRA++ set character literal : <emphasis>type-id</emphasis>
</programlisting>

        <para>The type of a wide character literal is given by the
          implementation defined type <literal>wchar_t</literal>. By default, the
          definition of this type is taken from the target machine's
          <literal>&lt;stddef.h&gt;</literal> C header (note that in ISO C++,
          <literal>wchar_t</literal> is actually a keyword, but its underlying
          representation must be the same as in C). This definition can be
          overridden in the producer by means of the directive:</para>
<programlisting>
#pragma TenDRA set wchar_t : <emphasis>type-id</emphasis>
</programlisting>

        <para>for an integral type <emphasis>type-id</emphasis>. Similarly, the
          definitions of the other implementation dependent integral types which
          arise naturally within the language - the type of the difference of two
          pointers, <literal>ptrdiff_t</literal>, and the type of the
          <literal>sizeof</literal> operator, <literal>size_t</literal> - given
          in the <literal>&lt;stddef.h&gt;</literal> header can be overridden
          using the directives:</para>
<programlisting>
#pragma TenDRA set ptrdiff_t : <emphasis>type-id</emphasis>
#pragma TenDRA set size_t : <emphasis>type-id</emphasis>
</programlisting>

        <para>These directives are useful when targeting a specific machine on
          which the definitions of these types are known; while they may not
          affect the code generated they can cut down on spurious conversion
          warnings. Note that although these types are built into the producer
          they are not visible to the user unless an appropriate header is
          included (with the exception of the keyword <literal>wchar_t</literal>
          in ISO C++), however the directives:</para>
<programlisting>
#pragma TenDRA++ type <emphasis>identifier</emphasis> for <emphasis>type-name</emphasis>
</programlisting>

        <para>can be used to make these types visible. They are equivalent to a
          <literal>typedef</literal> declaration of
          <emphasis>identifier</emphasis> as the given built-in type,
          <literal>ptrdiff_t</literal>, <literal>size_t</literal> or
          <literal>wchar_t</literal>.</para>

        <para>Whether plain <literal>char</literal> is signed or unsigned is
          implementation dependent. By default the implementation is determined
          by the definition of the <link linkend='arithmetic-types'>
          <literal>~char</literal></link>
          token, however this can be overridden in the producer either by means
          of the <link linkend='port-tables'>portability table</link> or by the
          directive:</para>
<programlisting>
#pragma TenDRA character <emphasis>character-sign</emphasis>
</programlisting>

        <para>where <emphasis>character-sign</emphasis> can be
          <literal>signed</literal>, <literal>unsigned</literal> or
          <literal>either</literal> (the default). Again this directive is useful
          primarily when targeting a specific machine on which the signedness of
          <literal>char</literal> is known.</para>
      </sect2>

      <sect2 id='string-literals-a'>
        <title>String literals</title>

        <para>By default, character string literals have type <literal>char
          [n]</literal> in C and older dialects of C++, but type <literal>const
          char [n]</literal> in ISO C++. Similarly wide string literals have type
          <literal>wchar_t [n]</literal> or <literal>const wchar_t [n]</literal>.
          Whether string literals are <literal>const</literal> or not can be
          controlled using the two directives:</para>
<programlisting>
#pragma TenDRA++ set string literal : const
#pragma TenDRA++ set string literal : no const
</programlisting>

        <para>In the case where literals are <literal>const</literal>, the
          array-to-pointer conversion is allowed to cast away the
          <literal>const</literal> to allow for a degree of backwards
          compatibility. The status of this deprecated conversion can be
          controlled using the directive:</para>
<programlisting>
#pragma TenDRA writeable string literal <emphasis>allow</emphasis>
</programlisting>

        <para>(yes, I know that that should be <literal>writable</literal>).
          Note that this directive has a slightly different meaning in the C
          producer.</para>

        <para>Adjacent string literals tokens of similar types (either both
          character string literals or both wide string literals) are
          concatenated at an early stage in parser, however it is unspecified
          what happens if a character string literal token is adjacent to a wide
          string literal token. By default this gives an error, but the
          directive:</para>
<programlisting>
#pragma TenDRA unify incompatible string literal <emphasis>allow</emphasis>
</programlisting>

        <para>can be used to enable the strings to be concatenated to give a
          wide string literal.</para>

        <para>If a <literal>'</literal> or <literal>&quot;</literal> character
          does not have a matching closing quote on the same line then it is
          undefined whether an implementation should report an unterminated
          string or treat the quote as a single unknown character. By default,
          the C++ producer treats this as an unterminated string, but this
          behaviour can be controlled using the directive:</para>
<programlisting>
#pragma TenDRA unmatched quote <emphasis>allow</emphasis>
</programlisting>
      </sect2>

      <sect2 id='escape-sequences'>
        <title>Escape sequences</title>

        <para>By default, if the character following the <literal>\</literal>
          in an escape sequence is not one of those listed in the ISO C or C++
          standards then an error is given. This behaviour, which is left
          unspecified by the standards, can be controlled by the
          directive:</para>
<programlisting>
#pragma TenDRA unknown escape <emphasis>allow</emphasis>
</programlisting>

        <para>The result is that the <literal>\</literal> in unknown escape
          sequences is ignored, so that <literal>\z</literal> is interpreted as
          <literal>z</literal>, for example. Individual escape sequences can be
          enabled or disabled using the directives:</para>
<programlisting>
#pragma TenDRA++ escape <emphasis>character-literal</emphasis> as <emphasis>character-literal</emphasis> allow
#pragma TenDRA++ escape <emphasis>character-literal</emphasis> disallow
</programlisting>

        <para>so that, for example:</para>
<programlisting>
#pragma TenDRA++ escape 'e' as '\033' allow
#pragma TenDRA++ escape 'a' disallow
</programlisting>

        <para>sets <literal>\e</literal> to be the ASCII escape character and
          disables the alert character <literal>\a</literal>.</para>

        <para>By default, if the value of a character, given for example by a
          <literal>\x</literal> escape sequence, does not fit into its type then
          an error is given. This implementation dependent behaviour can however
          be controlled by the directive:</para>
<programlisting>
#pragma TenDRA character escape overflow <emphasis>allow</emphasis>
</programlisting>

        <para>the value being converted to its type in the normal way.</para>
      </sect2>

      <sect2 id='preprocessing-directives'>
        <title>Preprocessing directives</title>

        <para>Non-standard preprocessing directives can be controlled using the
          directives:</para>
<programlisting>
#pragma TenDRA directive <emphasis>ppdir allow</emphasis>
#pragma TenDRA directive <emphasis>ppdir</emphasis> (ignore) <emphasis>allow</emphasis>
</programlisting>

        <para>where <emphasis>ppdir</emphasis> can be
          <literal>assert</literal>, <literal>file</literal>,
          <literal>ident</literal>, <literal>import</literal> (C++ only),
          <literal>include_next</literal> (C++ only),
          <literal>unassert</literal>, <literal>warning</literal> (C++ only) or
          <literal>weak</literal>. The second form causes the directive to be
          processed but ignored (note that there is no <literal>(ignore)
          disallow</literal> form). The treatment of other unknown preprocessing
          directives can be controlled using:</para>
<programlisting>
#pragma TenDRA unknown directive <emphasis>allow</emphasis>
</programlisting>

        <para>Cases where the token following the <literal>#</literal> in a
          preprocessing directive is not an identifier can be controlled
          using:</para>
<programlisting>
#pragma TenDRA no directive/nline after ident <emphasis>allow</emphasis>
</programlisting>

        <para>When permitted, unknown preprocessing directives are
          ignored.</para>

        <para>By default, unknown <literal>#pragma</literal> directives are
          ignored without comment, however this behaviour can be modified using
          the directive:</para>
<programlisting>
#pragma TenDRA unknown pragma <emphasis>allow</emphasis>
</programlisting>

        <para>Note that any unknown <literal>#pragma TenDRA</literal>
          directives always give an error.</para>

        <para>Older preprocessors allowed text after <literal>#else</literal>
          and <literal>#endif</literal> directives. The following directive can
          be used to enable such behaviour:</para>
<programlisting>
#pragma TenDRA text after directive <emphasis>allow</emphasis>
</programlisting>

        <para>Such text after a directive is ignored.</para>

        <para>Some older preprocessors have problems with white space in
          preprocessing directives - whether at the start of the line, before the
          initial <literal>#</literal>, or between the <literal>#</literal> and
          the directive identifier. Such white space can be detected using the
          directives:</para>
<programlisting>
#pragma TenDRA indented # directive <emphasis>allow</emphasis>
#pragma TenDRA indented directive after # <emphasis>allow</emphasis>
</programlisting>

        <para>respectively.</para>
      </sect2>

      <sect2 id='target-dep-conditional'>
        <title>Target dependent conditional inclusion</title>

        <para>One of the effects of trying to compile code in a target
          independent manner is that it is not always possible to completely
          evaluate the condition in a <literal>#if</literal> directive. Thus the
          conditional inclusion needs to be preserved until the installer phase.
          This can only be done if the target dependent <literal>#if</literal> is
          more structured than is normally required for preprocessing directives.
          There are two cases; in the first, where the <literal>#if</literal>
          appears in a statement, it is treated as if it were a
          <literal>if</literal> statement with braces including its branches;
          that is:</para>
<programlisting>
#if cond
  true_statements
#else
  false_statements
#endif
</programlisting>

        <para>maps to:</para>
<programlisting>
if ( cond ) {
  true_statements
} else {
  false_statements
}
</programlisting>

        <para>In the second case, where the <literal>#if</literal> appears in a
          list of declarations, normally gives an error. The can however be
          overridden by the directive:</para>
<programlisting>
#pragma TenDRA++ conditional declaration <emphasis>allow</emphasis>
</programlisting>

        <para>which causes both branches of the <literal>#if</literal> to be
          analysed.</para>
      </sect2>

      <sect2 id='inclusion-directives'>
        <title>File inclusion directives</title>

        <para>There is a maximum depth of nested <literal>#include</literal>
          directives allowed by the C++ producer. This depth is given by the
          <literal>include_depth</literal> implementation quantity
          <link linkend='implementation-limits'> 
          mentioned above</link>. Its value is fairly small in order to detect
          recursive inclusions. The maximum depth can be set using:</para>
<programlisting>
#pragma TenDRA includes depth <emphasis>integer-literal</emphasis>
</programlisting>

        <para>A further check, for full pathnames in
          <literal>#include</literal> directives (which may not be portable), can
          be enabled using the directive:</para>
<programlisting>
#pragma TenDRA++ complete file includes <emphasis>allow</emphasis>
</programlisting>
      </sect2>

      <sect2 id='macro-definitions'>
        <title>Macro definitions</title>

        <para>By default, multiple consistent definitions of a macro are
          allowed. This behaviour can be controlled using the directive:</para>
<programlisting>
#pragma TenDRA extra macro definition <emphasis>allow</emphasis>
</programlisting>

        <para>The ISO C/C++ rules for determining whether two macro definitions
          are consistent are fairly restrictive. A more relaxed rule allowing for
          consistent renaming of macro parameters can be enabled using:</para>
<programlisting>
#pragma TenDRA weak macro equality <emphasis>allow</emphasis>
</programlisting>

        <para>In the definition of macros with parameters, a
          <literal>#</literal> in the replacement list must be followed by a
          parameter name, indicating the stringising operation. This behaviour
          can be controlled by the directive:</para>
<programlisting>
#pragma TenDRA no ident after # <emphasis>allow</emphasis>
</programlisting>

        <para>which allows a <literal>#</literal> which is not followed by a
          parameter name to be treated as a normal preprocessing token.</para>

        <para>In a list of macro arguments, the effect of a sequence of
          preprocessing tokens which otherwise resembles a preprocessing
          directive is undefined. The C++ producer treats such directives as
          normal sequences of preprocessing tokens, but can be made to report
          such behaviour using:</para>
<programlisting>
#pragma TenDRA directive as macro argument <emphasis>allow</emphasis>
</programlisting>

        <para>Empty macro arguments invoke undefined behaviour according to
          the C90 and C++ standard.  The C99 standard allows them however.
          They can be allowed with the directive:
<programlisting>
#pragma TenDRA empty macro argument <emphasis>allow</emphasis>
</programlisting>

        <para>The C99 standard requires white space between an object macro and
          the replacement list in a macro definition (eg. the macro definition
          <literal>#define A{}</literal> is invalid).  The directive
<programlisting>
#pragma TenDRA no space after macro <emphasis>allow</emphasis>
</programlisting>
          can be used to specify if an error should be reported.

        <para>Another C99 feature are macros with a variable number of
          arguments.  If the last parameter of a function-like macro is
          <literal>...</literal>, it matches all remaining arguments (but there
          has to be at least one).  The identifier
          <literal>__VA_ARGS__</literal> can be used to refer to these
          arguments in the replacement list.  For example:</para>
<programlisting>
#define debug(lvl, ...) do { \
        if (lvl >= debuglvl) \
                fprintf(stderr, __VA_ARGS__); \
} while (0)
</programlisting>
        <para>Variadic macros are enabled with:</para>
<programlisting>
#pragma TenDRA variable argument macro <emphasis>allow</emphasis>
</programlisting>
      </sect2>

      <sect2 id='empty-source-files'>
        <title>Empty source files</title>

        <para>ISO C requires that a translation unit should contain at least
          one declaration. C++ and older dialects of C allow translation units
          which contain no declarations. This behaviour can be controlled using
          the directive:</para>
<programlisting>
#pragma TenDRA no external declaration <emphasis>allow</emphasis>
</programlisting>
      </sect2>

      <sect2 id='std-namespace'>
        <title>The <literal>std</literal> namespace</title>

        <para>Several classes declared in the <literal>std</literal> namespace
          arise naturally as part of the C++ language specification. These are as
          follows:</para>
<programlisting>
std::type_info      // type of typeid construct
std::bad_cast       // thrown by dynamic_cast construct
std::bad_typeid     // thrown by typeid construct
std::bad_alloc      // thrown by new construct
std::bad_exception  // used in exception specifications
</programlisting>

        <para>The definitions of these classes are found, when needed, by
          looking up the appropriate class name in the <literal>std</literal>
          namespace. Depending on the context, an error may be reported if the
          class is not found. It is possible to modify the namespace which is
          searched for these classes using the directive:</para>
<programlisting>
#pragma TenDRA++ set std namespace : <emphasis>scope-name</emphasis>
</programlisting>

        <para>where <emphasis>scope-name</emphasis> can be an identifier giving
          a namespace name or <literal>::</literal>, indicating the global
          namespace.</para>
      </sect2>

      <sect2 id='object-linkage'>
        <title>Object linkage</title>

        <para>If an object is declared with both external and internal linkage
          in the same translation unit then, by default, an error is given. This
          behaviour can be changed using the directive:</para>
<programlisting>
#pragma TenDRA incompatible linkage <emphasis>allow</emphasis>
</programlisting>

        <para>When incompatible linkages are allowed, whether the resultant
          identifier has external or internal linkage can be set using one of the
          directives:</para>
<programlisting>
#pragma TenDRA linkage resolution : off
#pragma TenDRA linkage resolution : (external) <emphasis>on</emphasis>
#pragma TenDRA linkage resolution : (internal) <emphasis>on</emphasis>
</programlisting>

        <para>It is possible to declare objects with external linkage in a
          block. C leaves it undefined whether declarations of the same object in
          different blocks, such as:</para>
<programlisting>
void f ()
{
  extern int a ;
  ....
}

void g ()
{
  extern double a ;
  ....
}

</programlisting>

        <para>are checked for compatibility. However in C++ the one definition
          rule implies that such declarations are indeed checked for
          compatibility. The status of this check can be set using the
          directive:</para>
<programlisting>
#pragma TenDRA unify external linkage <emphasis>on</emphasis>
</programlisting>

        <para>Note that it is not possible in ISO C or C++ to declare objects
          or functions with internal linkage in a block. While
          <literal>static</literal> object definitions in a block have a specific
          meaning, there is no real reason why <literal>static</literal>
          functions should not be declared in a block. This behaviour can be
          enabled using the directive:</para>
<programlisting>
#pragma TenDRA block function static <emphasis>allow</emphasis>
</programlisting>

        <para>Inline functions have external linkage by default in ISO C++, but
          internal linkage in older dialects. The default linkage can be set
          using the directive:</para>
<programlisting>
#pragma TenDRA++ inline linkage <emphasis>linkage-spec</emphasis>
</programlisting>

        <para>where <emphasis>linkage-spec</emphasis> can be
          <literal>external</literal> or <literal>internal</literal>. Similarly
          <literal>const</literal> objects have internal linkage by default in
          C++, but external linkage in C. The default linkage can be set using
          the directive:</para>
<programlisting>
#pragma TenDRA++ const linkage <emphasis>linkage-spec</emphasis>
</programlisting>

        <para>Older dialects of C treated all identifiers with external linkage
          as if they had been declared <literal>volatile</literal> (i.e. by being
          conservative in optimising such values). This behaviour can be enabled
          using the directive:</para>
<programlisting>
#pragma TenDRA external volatile_t
</programlisting>

        <para>It is possible to set the default language linkage using the
          directive:</para>
<programlisting>
#pragma TenDRA++ external linkage <emphasis>string-literal</emphasis>
</programlisting>

        <para>This is equivalent to enclosing the rest of the current checking
          scope in:</para>
<programlisting>
extern <emphasis>string-literal</emphasis> {
  ....
}
</programlisting>

        <para>It is unspecified what happens if such a directive is used within
          an explicit linkage specification and does not nest correctly. This
          directive is particularly useful when used in a
          <link linkend='scope-directive'>named environment</link>
          associated with an include directory. For example, it can
          be used to express the fact that all the objects declared in headers
          included from that directory have C linkage.</para>

        <para>A change in ISO C++ relative to older dialects is that the
          language linkage of a function now forms part of the function type. For
          example:</para>
<programlisting>
extern &quot;C&quot; int f ( int ) ;
int ( *pf ) ( int ) = f ;       // error
</programlisting>

        <para>The directive:</para>
<programlisting>
#pragma TenDRA++ external function linkage <emphasis>on</emphasis>
</programlisting>

        <para>can be used to control whether function types with differing
          language linkages, but which are otherwise compatible, are considered
          compatible or not.</para>
      </sect2>

      <sect2 id='static-identifers'>
        <title>Static identifiers</title>

        <para>By default, objects and functions with internal linkage are
          mapped to tags without external names in the output TDF capsule. Thus
          such names are not available to the installer and it needs to make up
          internal names to represent such objects in its output. This is not
          desirable in such operations as profiling, where a meaningful internal
          name is needed to make sense of the output. The directive:</para>
<programlisting>
#pragma TenDRA preserve <emphasis>identifier-list</emphasis>
</programlisting>

        <para>can be used to preserve the names of the given list of
          identifiers with internal linkage. This is done using the
          <literal>static_name_def</literal> TDF construct. The form:</para>
<programlisting>
#pragma TenDRA preserve *
</programlisting>

        <para>will preserve the names of all identifiers with internal linkage
          in this way.</para>
      </sect2>

      <sect2 id='empty-decl'>
        <title>Empty declarations</title>

        <para>ISO C++ requires every declaration or member declaration to
          introduce one or more names into the program. The directive:</para>
<programlisting>
#pragma TenDRA unknown struct/union <emphasis>allow</emphasis>
</programlisting>

        <para>can be used to relax one particular instance of this rule, by
          allowing anonymous class definitions (recall that anonymous unions are
          objects, not types, in C++ and so are not covered by this rule). The
          C++ grammar also allows a solitary semicolon as a declaration or member
          declaration; however such a declaration does not introduce a name and
          so contravenes the rule above. The rule can be relaxed in this case
          using the directive:</para>
<programlisting>
#pragma TenDRA extra ; <emphasis>allow</emphasis>
</programlisting>

        <para>Note that the C++ grammar explicitly allows for an extra
          semicolon following an inline member function definition, but that
          semicolons following other function definitions are actually empty
          declarations of the form above. A solitary semicolon in a statement is
          interpreted as an empty expression statement rather than an empty
          declaration statement.</para>
      </sect2>

      <sect2 id='mixed-decl'>
        <title>Mixed declarations and statements</title>

        <para>C90 allowed declarations only at the beginning of a compound
          statement.  In C++ and C99 code, declarations and statements can be
          mixed freely.  The directive
<programlisting>
#pragma TenDRA declaration after code <emphasis>allow</emphasis>
</programlisting>
          is used to switch reporting errors for mixed declarations and
          statements on or off.</para>
      </sect2>

      <sect2 id='implicit-int'>
        <title>Implicit <literal>int</literal></title>

        <para>The C &quot;implicit <literal>int</literal>&quot; rule, whereby a
          type of <literal>int</literal> is inferred in a list of type or
          declaration specifiers which does not contain a type name, has been
          removed in ISO C++, although it was supported in older dialects of C++.
          This check is controlled by the directive:</para>
<programlisting>
#pragma TenDRA++ implicit int type <emphasis>allow</emphasis>
</programlisting>

        <para>Partial relaxations of this rules are allowed. The
          directive:</para>
<programlisting>
#pragma TenDRA++ implicit int type for const/volatile <emphasis>allow</emphasis>
</programlisting>

        <para>will allow for implicit <literal>int</literal> when the list of
          type specifiers contains a cv-qualifier. Similarly the
          directive:</para>
<programlisting>
#pragma TenDRA implicit int type for function return <emphasis>allow</emphasis>
</programlisting>

        <para>will allow for implicit <literal>int</literal> in the return type
          of a function definition (this excludes constructors, destructors and
          conversion functions, where special rules apply). A function definition
          is the only kind of declaration in ISO C where a declaration specifier
          is not required. Older dialects of C allowed declaration specifiers to
          be omitted in other cases. Support for this behaviour can be enabled
          using:</para>
<programlisting>
#pragma TenDRA implicit int type for external declaration <emphasis>allow</emphasis>
</programlisting>

        <para>The four cases can be demonstrated in the following
          example:</para>
<programlisting>
extern a ;      // implicit int
const b = 1 ;       // implicit const int

f ()            // implicit function return
{
  return 2 ;
}

c = 3 ;         // error: not allowed in C++
</programlisting>
      </sect2>

      <sect2 id='extended-integral'>
        <title>Extended integral types</title>

        <para>The <literal>long long</literal> integral types are not part of
          ISO C or C++ by default, however support for them can be enabled using
          the directive:</para>
<programlisting>
#pragma TenDRA longlong type <emphasis>allow</emphasis>
</programlisting>

        <para>This support includes allowing <literal>long long</literal> in
          type specifiers and allowing <literal>LL</literal> and
          <literal>ll</literal> as integer literal suffixes.</para>

        <para>There is a further directive given by the two cases:</para>
<programlisting>
#pragma TenDRA set longlong type : long long
#pragma TenDRA set longlong type : long
</programlisting>

        <para>which can be used to control the implementation of the
          <literal>long long</literal> types. Either they can be mapped to the
          <link linkend='arithmetic-types'>default representation</link>,
          which is guaranteed to
          contain at least 64 bits, or they can be mapped to the corresponding
          <literal>long</literal> types.</para>

        <para>Because these <literal>long long</literal> types are not an
          intrinsic part of C++ the implementation does not integrate them into
          the language as fully as is possible. This is to prevent the presence
          or otherwise of <literal>long long</literal> types affecting the
          semantics of code which does not use them. For example, it would be
          possible to extend the rules for the types of integer literals, integer
          promotion types and arithmetic types to say that if the given value
          does not fit into the standard integral types then the extended types
          are tried. This has not been done, although these rules could be
          implemented by changing the definitions of the
          <link linkend='arithmetic-types'>standard tokens</link>
          used to determine these types. By default, only the
          rules for arithmetic types involving a <literal>long long</literal>
          operand and for <literal>LL</literal> integer literals mention
          <literal>long long</literal> types.</para>
      </sect2>

      <sect2 id='hex-float-lit'>
        <title>Hexadecimal floating constants</title>

        <para>The C99 standard allows floating point literals to be represented
          in a hexadecimal notation.  The format for them is:</para>
<programlisting>
<emphasis>hex-float:</emphasis>
        0x <emphasis>hex-digits<subscript>opt</subscript></emphasis> . <emphasis>hex-digits binary-exponent floating-suffix<subscript>opt</subscript></emphasis>
        0x <emphasis>hex-digits</emphasis> . <emphasis>binary-exponent floating-suffix<subscript>opt</subscript></emphasis>
        0x <emphasis>hex-digits binary-exponent floating-suffix<subscript>opt</subscript></emphasis>
<emphasis>binary-exponent:</emphasis>
        p <emphasis>sign<subscript>opt</subscript> digits</emphasis>
        P <emphasis>sign<subscript>opt</subscript> digits</emphasis>
</programlisting>
        <para>Note that the exponent uses a decimal representation.  The value
        of a hexadecimal float constant is <emphasis>sign * mantissa *
        2<superscript>exponent</superscript></emphasis>.</para>

        <para>This feature is controlled with the directive:</para>
<programlisting>
#pragma TenDRA hexadecimal float literal <emphasis>allow</emphasis>
</programlisting>
      </sect2>

      <sect2 id='bitfield-types-b'>
        <title>Bitfield types</title>

        <para>The C++ rules on bitfield types differ slightly from the C rules.
          Firstly any integral or enumeration type is allowed in a bitfield, and
          secondly the bitfield width may exceed the underlying type size (the
          extra bits being treated as padding). These properties can be
          controlled using the directives:</para>
<programlisting>
#pragma TenDRA extra bitfield int type <emphasis>allow</emphasis>
#pragma TenDRA bitfield overflow <emphasis>allow</emphasis>
</programlisting>

        <para>respectively.</para>
      </sect2>

      <sect2 id='elaborated-specifiers'>
        <title>Elaborated type specifiers</title>

        <para>In elaborated type specifiers, the class key
          (<literal>class</literal>, <literal>struct</literal>,
          <literal>union</literal> or <literal>enum</literal>) should agree with
          any previous declaration of the type (except that
          <literal>class</literal> and <literal>struct</literal> are
          interchangeable). This requirement can be relaxed using the
          directive:</para>
<programlisting>
#pragma TenDRA ignore struct/union/enum tag <emphasis>on</emphasis>
</programlisting>

        <para>In ISO C and C++ it is not possible to give a forward declaration
          of an enumeration type. This constraint can be relaxed using the
          directive:</para>
<programlisting>
#pragma TenDRA forward enum declaration <emphasis>allow</emphasis>
</programlisting>

        <para>Until the end of its definition, an enumeration type is treated
          as an incomplete type (as with class types). In enumeration
          definitions, and a couple of other contexts where comma-separated lists
          are required, the directive:</para>
<programlisting>
#pragma TenDRA extra , <emphasis>allow</emphasis>
</programlisting>

        <para>can be used to allow a trailing comma at the end of the
          list.</para>

        <para>The directive:</para>
<programlisting>
#pragma TenDRA complete struct/union analysis <emphasis>on</emphasis>
</programlisting>

        <para>can be used to enable a check that every class or union has been
          completed within each translation unit in which it is declared.</para>
      </sect2>

      <sect2 id='flex-array-members'>
        <title>Flexible array members</title>

        <para>The C99 standard introduces <emphasis>flexible array
          members</emphasis>.  This means that the last member of a (otherwise
          not empty) <literal>struct</literal> is allowed to be an array
          without an actual array size.</para>
<programlisting>
struct s {
        int i;
        char fam[];
};
</programlisting>
        <para>Additional memory following the <literal>i</literal> member
          (eg. if a larger chunk of memory has been allocated with
          <literal>malloc</literal>) can be legally accessed through the
          <literal>fam</literal> member.</para>
        <para>This feature is controlled with this directive:</para>
<programlisting>
#pragma TenDRA flexible array member <emphasis>on</emphasis>
</programlisting>
        <para>Note: Flexible array members have not really been tested yet with
          C++ code.</para>
      </sect2>

      <sect2 id='implicit-function-decl'>
        <title>Implicit function declarations</title>

        <para>C, but not C++, allows calls to undeclared functions, the
          function being declared implicitly. It is possible to enable support
          for implicit function declarations using the directive:</para>
<programlisting>
#pragma TenDRA implicit function declaration <emphasis>on</emphasis>
</programlisting>

        <para>Such implicitly declared functions have C linkage and type
          <literal>int ( ... )</literal>.</para>
      </sect2>

      <sect2 id='weak-function-prototypes'>
        <title>Weak function prototypes</title>

        <para>The C producer supports a concept, weak prototypes, whereby type
          checking can be applied to the arguments of a non-prototype function.
          This checking can be enabled using the directive:</para>
<programlisting>
#pragma TenDRA weak prototype analysis <emphasis>on</emphasis>
</programlisting>

        <para>The concept of weak prototypes is not applicable to C++, where
          all functions are prototyped. The C++ producer does allow the syntax
          for explicit weak prototype declarations, but treats them as if they
          were normal prototypes. These declarations are denoted by means of a
          keyword, <literal>WEAK</literal> say, introduced by the
          directive:</para>
<programlisting>
#pragma TenDRA keyword <emphasis>identifier</emphasis> for weak
</programlisting>

        <para>preceding the <literal>(</literal> of the function declarator.
          The directives:</para>
<programlisting>
#pragma TenDRA prototype <emphasis>allow</emphasis>
#pragma TenDRA prototype (weak) <emphasis>allow</emphasis>
</programlisting>

        <para>which can be used in the C producer to warn of prototype or weak
          prototype declarations, are similarly ignored by the C++
          producer.</para>

        <para>The C producer also allows the directives:</para>
<programlisting>
#pragma TenDRA argument <emphasis>type-id</emphasis> as <emphasis>type-id</emphasis>
#pragma TenDRA argument <emphasis>type-id</emphasis> as ...
#pragma TenDRA extra ... <emphasis>allow</emphasis>
#pragma TenDRA incompatible promoted function argument <emphasis>allow</emphasis>
</programlisting>

        <para>which control the compatibility of function types. These
          directives are ignored by the C++ producer (some of them would make
          sense in the context of C++ but would over-complicate function
          overloading).</para>
      </sect2>

      <sect2 id='printf-scanf-argument'>
        <title><literal>printf</literal> and <literal>scanf</literal> argument
        checking</title>

        <para>The C producer includes a number of checks that the arguments in
          a call to a function in the <literal>printf</literal> or
          <literal>scanf</literal> families match the given format string. The
          check is implemented by using the directives:</para>
<programlisting>
#pragma TenDRA type <emphasis>identifier</emphasis> for ... printf
#pragma TenDRA type <emphasis>identifier</emphasis> for ... scanf
</programlisting>

        <para>to introduce a type representing a <literal>printf</literal> or
          <literal>scanf</literal> format string. For most purposes this type is
          treated as <literal>const char *</literal>, but when it appears in a
          function declaration it alerts the producer that any extra arguments
          passed to that function should match the format string passed as the
          corresponding argument. The TenDRA API headers conditionally declare
          <literal>printf</literal>, <literal>scanf</literal> and similar
          functions in something like the form:</para>
<programlisting>
#ifdef __NO_PRINTF_CHECKS
typedef const char *__printf_string ;
#else
#pragma TenDRA type __printf_string for ... printf
#endif

int printf ( __printf_string, ... ) ;
int fprintf ( FILE *, __printf_string, ... ) ;
int sprintf ( char *, __printf_string, ... ) ;
</programlisting>

        <para>These declarations can be skipped, effectively disabling this
          check, by defining the <literal>__NO_PRINTF_CHECKS</literal>
          macro.</para>

        <warning>
          <para>
              <blockquote>
                <para>These <literal>printf</literal> and
                <literal>scanf</literal> format string checks have not yet been
                implemented in the C++ producer due to presence of an
                alternative, type checked, I/O package - namely
                <literal>&lt;iostream&gt;</literal>. The format string types are
                simply treated as <literal>const char *</literal>.</para>
            </blockquote>
          </para>
        </warning>
      </sect2>

      <sect2 id='decl'>
        <title>Type declarations</title>

        <para>C does not allow multiple definitions of a
          <literal>typedef</literal> name, whereas C++ allows multiple consistent
          definitions. This behaviour can be controlled using the
          directive:</para>
<programlisting>
#pragma TenDRA extra type definition <emphasis>allow</emphasis>
</programlisting>
      </sect2>

      <sect2 id='type-qualifiers'>
        <title>Type qualifiers</title>

        <para>The C99 standards allows multiple occurrences of the same
          type qualifiers in a declaration, as in:</para>
<programlisting>
const const int i;
</programlisting>
        <para>Whether an error should be reported in such a case can be
          controlled by:</para>
<programlisting>
#pragma TenDRA extra type qualifier <emphasis>allow</emphasis>
</programlisting>

        <para>Multiple occurrences of a type qualifier can also be caused
          indirectly by the usage of a <literal>typedef</literal>:</para>
<programlisting>
typedef const int t;
const t i;
</programlisting>
        <para>The directive
<programlisting>
#pragma TenDRA extra type qualifier (typedef) <emphasis>allow</emphasis>
</programlisting>
          is used to enable or disable this.</para>
      </sect2>

      <sect2 id='compat'>
        <title>Type compatibility</title>

        <para>The directive:</para>
<programlisting>
#pragma TenDRA incompatible type qualifier <emphasis>allow</emphasis>
</programlisting>

        <para>allows objects to be redeclared with different cv-qualifiers
          (normally such redeclarations would be incompatible). The composite
          type is qualified using the join of the cv-qualifiers in the various
          redeclarations.</para>

        <para>The directive:</para>
<programlisting>
#pragma TenDRA compatible type : <emphasis>type-id</emphasis> == <emphasis>type-id</emphasis> : <emphasis>allow</emphasis>
</programlisting>

        <para>asserts that the given two types are compatible. Currently the
          only implemented version is <literal>char * == void *</literal> which
          enables <literal>char *</literal> to be used as a generic pointer as it
          was in older dialects of C.</para>
      </sect2>

      <sect2 id='incomplete-types'>
        <title>Incomplete types</title>

        <para>Some dialects of C allow incomplete arrays as member types. These
          are generally used as a place-holder at the end of a structure to allow
          for the allocation of an arbitrarily sized array. Support for this
          feature can be enabled using the directive:</para>
<programlisting>
#pragma TenDRA incomplete type as object type <emphasis>allow</emphasis>
</programlisting>
      </sect2>

      <sect2 id='type-conversations'>
        <title>Type conversions</title>

        <para>There are a number of directives which allow various classes of
          type conversion to be checked. The directives:</para>
<programlisting>
#pragma TenDRA conversion analysis (int-int explicit) <emphasis>on</emphasis>
#pragma TenDRA conversion analysis (int-int implicit) <emphasis>on</emphasis>
</programlisting>

        <para>will check for unsafe explicit or implicit conversions between
          arithmetic types. Similarly conversions between pointers and arithmetic
          types can be checked using:</para>
<programlisting>
#pragma TenDRA conversion analysis (int-pointer explicit) <emphasis>on</emphasis>
#pragma TenDRA conversion analysis (int-pointer implicit) <emphasis>on</emphasis>
</programlisting>

        <para>or equivalently:</para>
<programlisting>
#pragma TenDRA conversion analysis (pointer-int explicit) <emphasis>on</emphasis>
#pragma TenDRA conversion analysis (pointer-int implicit) <emphasis>on</emphasis>
</programlisting>

        <para>Conversions between pointer types can be checked using:</para>
<programlisting>
#pragma TenDRA conversion analysis (pointer-pointer explicit) <emphasis>on</emphasis>
#pragma TenDRA conversion analysis (pointer-pointer implicit) <emphasis>on</emphasis>
</programlisting>

        <para>There are some further variants which can be used to enable
          useful sets of conversion checks. For example:</para>
<programlisting>
#pragma TenDRA conversion analysis (int-int) <emphasis>on</emphasis>
</programlisting>

        <para>enables both implicit and explicit arithmetic conversion checks.
          The directives:</para>
<programlisting>
#pragma TenDRA conversion analysis (int-pointer) <emphasis>on</emphasis>
#pragma TenDRA conversion analysis (pointer-int) <emphasis>on</emphasis>
#pragma TenDRA conversion analysis (pointer-pointer) <emphasis>on</emphasis>
</programlisting>

        <para>are equivalent to their corresponding explicit forms (because the
          implicit forms are illegal by default). The directive:</para>
<programlisting>
#pragma TenDRA conversion analysis <emphasis>on</emphasis>
</programlisting>

        <para>is equivalent to the four directives just given. It enables
          checks on implicit and explicit arithmetic conversions, explicit
          arithmetic to pointer conversions and explicit pointer
          conversions.</para>

        <para>The default settings for these checks are determined by the
          implicit and explicit conversions allowed in C++. Note that there are
          differences between the conversions allowed in C and C++. For example,
          an arithmetic type can be converted implicitly to an enumeration type
          in C, but not in C++. The directive:</para>
<programlisting>
#pragma TenDRA conversion analysis (int-enum implicit) <emphasis>on</emphasis>
</programlisting>

        <para>can be used to control the status of this conversion. The level
          of severity for an error message arising from such a conversion is the
          maximum of the severity set by this directive and that set by the
          <literal>int-int implicit</literal> directive above.</para>

        <para>The implicit pointer conversions described above do not include
          conversions to and from the generic pointer <literal>void *</literal>,
          which have their own controlling directives. A pointer of type
          <literal>void *</literal> can be converted implicitly to another
          pointer type in C but not in C++; this is controlled by the
          directive:</para>
<programlisting>
#pragma TenDRA++ conversion analysis (void*-pointer implicit) <emphasis>on</emphasis>
</programlisting>

        <para>The reverse conversion, from a pointer type to <literal>void
          *</literal> is allowed in both C and C++, and has a controlling
          directive:</para>
<programlisting>
#pragma TenDRA++ conversion analysis (pointer-void* implicit) <emphasis>on</emphasis>
</programlisting>

        <para>In ISO C and C++, a function pointer can only be cast to other
          function pointers, not to object pointers or <literal>void *</literal>.
          Many dialects however allow function pointers to be cast to and from
          other pointers. This behaviour can be controlled using the
          directive:</para>
<programlisting>
#pragma TenDRA function pointer as pointer <emphasis>allow</emphasis>
</programlisting>

        <para>which causes function pointers to be treated in the same way as
          all other pointers.</para>

        <para>The integer conversion checks described above only apply to
          unsafe conversions. A simple-minded check for shortening conversions is
          not adequate, as is shown by the following example:</para>
<programlisting>
char a = 1, b = 2 ;
char c = a + b ;

</programlisting>

        <para>the sum <literal>a + b</literal> is evaluated as an
          <literal>int</literal> which is then shortened to a
          <literal>char</literal>. Any check which does not distinguish this sort
          of &quot;safe&quot; shortening conversion from unsafe shortening
          conversions such as:</para>
<programlisting>
int a = 1, b = 2 ;
char c = a + b ;
</programlisting>

        <para>is not likely to be very useful. The producer therefore
          associates two types with each integral expression; the first is the
          normal, representation type and the second is the underlying, semantic
          type. Thus in the first example, the representation type of <literal>a
          + b</literal> is <literal>int</literal>, but semantically it is still a
          <literal>char</literal>. The conversion analysis is based on the
          semantic types.</para>

        <warning>
          <para>
              <blockquote>
                <para>The C producer supports a directive:</para>
<programlisting>
#pragma TenDRA keyword <emphasis>identifier</emphasis> for type representation
</programlisting>

              <para>whereby a keyword can be introduced which can be used to
                explicitly declare a type with given representation and semantic
                components. Unfortunately this makes the
                <link linkend='parsing-cpp'>C++ grammar</link>
                ambiguous, so it has not yet been implemented in the C++
                producer.</para>
            </blockquote>
          </para>
        </warning>

        <para>It is possible to allow individual conversions by means of
          conversion tokens. A <link linkend='procedure-tokens'>procedure
          token</link> which takes one
          rvalue expression program parameter and returns an rvalue expression,
          such as:</para>
<programlisting>
#pragma token PROC ( EXP : t : ) EXP : s : conv #
</programlisting>

        <para>can be regarded as mapping expressions of type
          <literal>t</literal> to expressions of type <literal>s</literal>. The
          directive:</para>
<programlisting>
#pragma TenDRA conversion <emphasis>identifier-list</emphasis> allow
</programlisting>

        <para>can be used to nominate such a token as a conversion token. That
          is to say, if the conversion, whether explicit or implicit, from
          <literal>t</literal> to <literal>s</literal> cannot be done by other
          means, it is done by applying the token <literal>conv</literal>,
          so:</para>
<programlisting>
t a ;
s b = a ;       // maps to conv ( a )
</programlisting>

        <note>
          <para>Unlike conversion functions, conversion tokens can be applied
            to any types.</para>
        </note>
      </sect2>

      <sect2 id='cast-expressions'>
        <title>Cast expressions</title>

        <para>ISO C++ introduces the constructs <literal>static_cast</literal>,
          <literal>const_cast</literal> and <literal>reinterpret_cast</literal>,
          which can be used in various contexts where an old style explicit cast
          would previously have been used. By default, an explicit cast can
          perform any combination of the conversions performed by these three
          constructs. To aid migration to the new style casts the
          directives:</para>
<programlisting>
#pragma TenDRA++ explicit cast as <emphasis>cast-state allow</emphasis>
#pragma TenDRA++ explicit cast <emphasis>allow</emphasis>
</programlisting>

        <para>where <emphasis>cast-state</emphasis> is defined as
          follows:</para>
<programlisting>
<emphasis>cast-state</emphasis> :
  static_cast
  const_cast
  reinterpret_cast
  static_cast | <emphasis>cast-state</emphasis>
  const_cast | <emphasis>cast-state</emphasis>
  reinterpret_cast | <emphasis>cast-state</emphasis>
</programlisting>

        <para>can be used to restrict the conversions which can be performed
          using explicit casts. The first form sets the interpretation of
          explicit cast to be combinations of the given constructs; the second
          resets the interpretation to the default. For example:</para>
<programlisting>
#pragma TenDRA++ explicit cast as static_cast | const_cast allow
</programlisting>

        <para>means that conversions requiring
          <literal>reinterpret_cast</literal> (the most unportable conversions)
          will not be allowed to be performed using explicit casts, but will have
          to be given as a <literal>reinterpret_cast</literal> construct.
          Changing <literal>allow</literal> to <literal>warning</literal> will
          also cause a warning to be issued for every explicit cast
          expression.</para>
      </sect2>

      <sect2 id='ellipsis-funct'>
        <title>Ellipsis functions</title>

        <para>The directive:</para>
<programlisting>
#pragma TenDRA ident ... <emphasis>allow</emphasis>
</programlisting>

        <para>may be used to enable or disable the use of
          <literal>...</literal> as a primary expression in a function defined
          with ellipsis. The type of such an expression is implementation
          defined. This expression is used in the definition of the
          <link linkend='ellipsis-functions'><literal>va_start</literal> macro
          </link>in the
          <literal>&lt;stdarg.h&gt;</literal> header. This header automatically
          enables this switch.</para>
      </sect2>

      <sect2 id='overloaded-funct'>
        <title>Overloaded functions</title>

        <para>Older dialects of C++ did not report ambiguous overloaded
          function resolutions, but instead resolved the call to the first of the
          most viable candidates to be declared. This behaviour can be controlled
          using the directive:</para>
<programlisting>
#pragma TenDRA++ ambiguous overload resolution <emphasis>allow</emphasis>
</programlisting>

        <para>There are occasions when the resolution of an overloaded function
          call is not clear. The directive:</para>
<programlisting>
#pragma TenDRA++ overload resolution <emphasis>allow</emphasis>
</programlisting>

        <para>can be used to report the resolution of any such call (whether
          explicit or implicit) where there is more than one viable
          candidate.</para>

        <para>An interesting consequence of compiling C++ in a target
          independent manner is that certain overload resolutions can only be
          determined at install-time. For example, in:</para>
<programlisting>
int f ( int ) ;
int f ( unsigned int ) ;
int f ( long ) ;
int f ( unsigned long ) ;

int a = f ( sizeof ( int ) ) ;  // which f?
</programlisting>

        <para>the type of the <literal>sizeof</literal> operator,
          <literal>size_t</literal>, is target dependent, but its promotion must
          be one of the types <literal>int</literal>, <literal>unsigned
          int</literal>, <literal>long</literal> or <literal>unsigned
          long</literal>. Thus the call to <literal>f</literal> always has a
          unique resolution, but what it is is target dependent. The equivalent
          directives:</para>
<programlisting>
#pragma TenDRA++ conditional overload resolution <emphasis>allow</emphasis>
#pragma TenDRA++ conditional overload resolution (complete) <emphasis>allow</emphasis>
</programlisting>

        <para>can be used to warn about such target dependent overload
          resolutions. By default, such resolutions are only allowed if there is
          a unique resolution for each possible implementation of the argument
          types (note that, for simplicity, the possibility of <literal>long
          long</literal> implementation types is ignored). The directive:</para>
<programlisting>
#pragma TenDRA++ conditional overload resolution (incomplete) <emphasis>allow</emphasis>
</programlisting>

        <para>can be used to allow target dependent overload resolutions which
          only have resolutions for some of the possible implementation types (if
          one of the <literal>f</literal> declarations above was removed, for
          example). If the implementation does not match one of these types then
          an install-time error is given.</para>

        <para>There are restrictions on the set of candidate functions involved
          in a target dependent overload resolution. Most importantly, it should
          be possible to bring their return types to a common type, as if by a
          series of <literal>?:</literal> operations. This common type is the
          type of the target dependent call. By this means, target dependent
          types are prevented from propagating further out into the program. Note
          that since sets of overloaded functions usually have the same
          semantics, this does not usually present a problem.</para>
      </sect2>

      <sect2 id='expressions'>
        <title>Expressions</title>

        <para>The directive:</para>
<programlisting>
#pragma TenDRA operator precedence analysis <emphasis>on</emphasis>
</programlisting>

        <para>can be used to enable a check for expressions where the operator
          precedence is not necessarily what might be expected. The intended
          precedence can be clarified by means of explicit parentheses. The
          precedence levels checked are as follows:</para>

        <itemizedlist>
          <listitem>
            <para><literal>&amp;&amp;</literal> versus
              <literal>||</literal>.</para>
          </listitem>

          <listitem>
            <para><literal>&lt;&lt;</literal> and <literal>&gt;&gt;</literal>
              versus binary <literal>+</literal> and <literal>-</literal>.</para>
          </listitem>

          <listitem>
            <para>Binary <literal>&amp;</literal> versus binary
              <literal>+</literal>, <literal>-</literal>, <literal>==</literal>,
              <literal>!=</literal>, <literal>&gt;</literal>,
              <literal>&gt;=</literal>, <literal>&lt;</literal> and
              <literal>&lt;=</literal>.</para>
          </listitem>

          <listitem>
            <para><literal>^</literal> versus binary <literal>&amp;</literal>,
              <literal>+</literal>, <literal>-</literal>, <literal>==</literal>,
              <literal>!=</literal>, <literal>&gt;</literal>,
              <literal>&gt;=</literal>, <literal>&lt;</literal> and
              <literal>&lt;=</literal>.</para>
          </listitem>

          <listitem>
            <para><literal>|</literal> versus binary <literal>^</literal>,
              <literal>&amp;</literal>, <literal>+</literal>,
              <literal>-</literal>, <literal>==</literal>, <literal>!=</literal>,
              <literal>&gt;</literal>, <literal>&gt;=</literal>,
              <literal>&lt;</literal> and <literal>&lt;=</literal> .</para>
          </listitem>
        </itemizedlist>

        <para>Also checked are expressions such as <literal>a &lt; b &lt;
          c</literal> which do not have their normal mathematical meaning. For
          example, in:</para>
<programlisting>
d = a &lt;&lt; b + c ;  // precedence is a &lt;&lt; ( b + c )
</programlisting>

        <para>the precedence is counter-intuitive, although strangely enough,
          it isn't in:</para>
<programlisting>
cout &lt;&lt; b + c ;       // precedence is cout &lt;&lt; ( b + c )
</programlisting>

        <para>Other dubious arithmetic operations can be checked for using the
          directive:</para>
<programlisting>
#pragma TenDRA integer operator analysis <emphasis>on</emphasis>
</programlisting>

        <para>This includes checks for operations, such as division by a
          negative value, which are implementation dependent, and those such as
          testing whether an unsigned value is less than zero, which serve no
          purpose. Similarly the directive:</para>
<programlisting>
#pragma TenDRA++ pointer operator analysis <emphasis>on</emphasis>
</programlisting>

        <para>checks for dubious pointer operations. This includes very simple
          bounds checking for arrays and checking that only the simple literal
          <literal>0</literal> is used in null pointer constants:</para>
<programlisting>
char *p = 1 - 1 ;   // valid, but weird
</programlisting>

        <para>The directive:</para>
<programlisting>
#pragma TenDRA integer overflow analysis <emphasis>on</emphasis>
</programlisting>

        <para>is used to control the treatment of overflows in the evaluation
          of integer constant expressions. This includes the detection of
          division by zero.</para>
      </sect2>

      <sect2 id='initialiser-expr'>
        <title>Initialiser expressions</title>

        <para>C, but not C++, only allows constant expressions in static
          initialisers. The directive:</para>
<programlisting>
#pragma TenDRA variable initialization <emphasis>allow</emphasis>
</programlisting>

        <para>can be enable support for C++-style dynamic initialisers.
          Conversely, it can be used in C++ to detect such dynamic
          initialisers.</para>

        <para>C90 also requires the initialisers for aggregates to be constant
          expressions, even for objects with automatic storage duration.  To
          allow non-constant initialisers the following directive can be
          used:</para>
<programlisting>
#pragma TenDRA variable initialization of struct/union (auto) <emphasis>allow</emphasis>
</programlisting>

        <para>In older dialects of C it was not possible to initialise an
          automatic variable of structure or union type at all. This can be
          checked for using the directive:</para>
<programlisting>
#pragma TenDRA initialization of struct/union (auto) <emphasis>allow</emphasis>
</programlisting>

        <para>The directive:</para>
<programlisting>
#pragma TenDRA++ complete initialization analysis <emphasis>on</emphasis>
</programlisting>

        <para>can be used to check aggregate initialisers. The initialiser
          should be fully bracketed (i.e. with no elision of braces), and should
          have an entry for each member of the structure or array.</para>
      </sect2>

      <sect2 id='lvalue-expressions'>
        <title>Lvalue expressions</title>

        <para>C++ defines the results of several operations to be lvalues,
          whereas they are rvalues in C. The directive:</para>
<programlisting>
#pragma TenDRA conditional lvalue <emphasis>allow</emphasis>
</programlisting>

        <para>is used to apply the C++ rules for lvalues in conditional
          (<literal>?:</literal>) expressions.</para>

        <para>Older dialects of C++ allowed <literal>this</literal> to be
          treated as an lvalue. It is possible to enable support for this dialect
          feature using the directive:</para>
<programlisting>
#pragma TenDRA++ this lvalue <emphasis>allow</emphasis>
</programlisting>

        <para>however it is recommended that programs using this feature should
          be modified.</para>
      </sect2>

      <sect2 id='discarded-expressions'>
        <title>Discarded expressions</title>

        <para>The directive:</para>
<programlisting>
#pragma TenDRA discard analysis <emphasis>on</emphasis>
</programlisting>

        <para>can be used to enable a check for values which are calculated but
          not used. There are three checks controlled by this directive, each of
          which can be controlled independently. The directive:</para>
<programlisting>
#pragma TenDRA discard analysis (function return) <emphasis>on</emphasis>
</programlisting>

        <para>checks for functions which return a value which is not used. The
          check needs to be enabled for both the declaration and the call of the
          function in order for a discarded function return to be reported.
          Discarded returns for overloaded operator functions are never reported.
          The directive:</para>
<programlisting>
#pragma TenDRA discard analysis (value) <emphasis>on</emphasis>
</programlisting>

        <para>checks for other expressions which are not used. Finally, the
          directive:</para>
<programlisting>
#pragma TenDRA discard analysis (static) <emphasis>on</emphasis>
</programlisting>

        <para>checks for variables with internal linkage which are defined but
          not used.</para>

        <para>An unused function return or other expression can be asserted to
          be deliberately discarded by explicitly casting it to
          <literal>void</literal> or, equivalently, preceding it by a keyword
          introduced using the directive:</para>
<programlisting>
#pragma TenDRA keyword <emphasis>identifier</emphasis> for discard value
</programlisting>

        <para>A static variable can be asserted to be deliberately unused by
          including it in list of identifiers in a directive of the form:</para>
<programlisting>
#pragma TenDRA suspend static <emphasis>identifier-list</emphasis>
</programlisting>
      </sect2>

      <sect2 id='conditional-iteration'>
        <title>Conditional and iteration statements</title>

        <para>The directive:</para>
<programlisting>
#pragma TenDRA const conditional <emphasis>allow</emphasis>
</programlisting>

        <para>can be used to enable a check for constant expressions used in
          conditional contexts. A literal constant is allowed in the condition of
          a <literal>while</literal> , <literal>for</literal> or
          <literal>do</literal> statement to allow for such common constructs
          as:</para>
<programlisting>
while ( true ) {
// while statement body
}
</programlisting>

        <para>and target dependent constant expressions are allowed in the
          condition of an <literal>if</literal> statement, but otherwise constant
          conditions are reported according to the status of this check.</para>

        <para>The common error of writing <literal>=</literal> rather than
          <literal>==</literal> in conditions can be detected using the
          directive:</para>
<programlisting>
#pragma TenDRA assignment as bool <emphasis>allow</emphasis>
</programlisting>

        <para>which can be used to disallow such assignment expressions in
          contexts where a boolean is expected. The error message can be
          suppressed by enclosing the assignment within parentheses.</para>

        <para>Another common error associated with iteration statements,
          particularly with certain brace styles, is
          the accidental insertion of an extra semicolon as in:</para>
<programlisting>
for ( init ; cond ; step ) ;
{
// for statement body
}
</programlisting>

        <para>The directive:</para>
<programlisting>
#pragma TenDRA extra ; after conditional <emphasis>allow</emphasis>
</programlisting>

        <para>can be used to enable a check for such suspicious empty iteration
          statement bodies (it actually checks for <literal>;{</literal>).</para>
      </sect2>

      <sect2 id='switch-statements'>
        <title>Switch statements</title>

        <para>A <literal>switch</literal> statement is said to be exhaustive if
          its control statement is guaranteed to take one of the values of its
          <literal>case</literal> labels, or if it has a
          <literal>default</literal> label. The TenDRA C and C++ producers allow
          a <literal>switch</literal> statement to be asserted to be exhaustive
          using the syntax:</para>
<programlisting>
switch ( cond ) EXHAUSTIVE {
// switch statement body
}

</programlisting>

        <para>where <literal>EXHAUSTIVE</literal> is either the
          directive:</para>
<programlisting>
#pragma TenDRA exhaustive
</programlisting>

        <para>or a keyword introduced using:</para>
<programlisting>
#pragma TenDRA keyword <emphasis>identifier</emphasis> for exhaustive
</programlisting>

        <para>Knowing whether a <literal>switch</literal> statement is
          exhaustive or not means that checks relying on flow analysis (including
          variable usage checks) can be applied more precisely.</para>

        <para>In certain circumstances it is possible to deduce whether a
          <literal>switch</literal> statement is exhaustive or not. For example,
          the directive:</para>
<programlisting>
#pragma TenDRA enum switch analysis <emphasis>on</emphasis>
</programlisting>

        <para>enables a check on <literal>switch</literal> statements on values
          of enumeration type. Such statements should be exhaustive, either
          explicitly by using the <literal>EXHAUSTIVE</literal> keyword or
          declaring a <literal>default</literal> label, or implicitly by having a
          <literal>case</literal> label for each enumerator. Conversely, the
          value of each <literal>case</literal> label should equal the value of
          an enumerator. For the purposes of this check, boolean values are
          treated as if they were declared using an enumeration type of the
          form:</para>
<programlisting>
enum bool { false = 0, true = 1 } ;
</programlisting>

        <para>A common source of errors in <literal>switch</literal> statements
          is the fall-through from one <literal>case</literal> or
          <literal>default</literal> statement to the next. A check for this can
          be enabled using:</para>
<programlisting>
#pragma TenDRA fall into case <emphasis>allow</emphasis>
</programlisting>

        <para><literal>case</literal> or <literal>default</literal> labels
          where fall-through from the previous statement is intentional can be
          marked by preceding them by a keyword, <literal>FALL_THRU</literal>
          say, introduced using the directive:</para>
<programlisting>
#pragma TenDRA keyword <emphasis>identifier</emphasis> for fall into case
</programlisting>
      </sect2>

      <sect2 id='for-statements'>
        <title>For statements</title>

        <para>In ISO C++ the scope of a variable declared in a
          for-init-statement is the body of the <literal>for</literal> statement;
          in older dialects it extended to the end of the enclosing block.
          So:</para>
<programlisting>
for ( int i = 0 ; i &lt; 10 ; i++ ) {
// for statement body
}
return i ;  // OK in older dialects, error in ISO C++
</programlisting>

        <para>This behaviour is controlled by the directive:</para>
<programlisting>
#pragma TenDRA++ for initialization block <emphasis>on</emphasis>
</programlisting>

        <para>a state of <literal>on</literal> corresponding to the ISO rules
          and <literal>off</literal> to the older rules. Perhaps most useful is
          the <literal>warning</literal> state which implements the old rules but
          gives a warning if a variable declared in a for-init-statement is used
          outside the corresponding <literal>for</literal> statement body. A
          program which does not give such warnings should compile correctly
          under either set of rules.</para>

        <para>C++ always allowed using a declaration as the first part of a
          for-statement.  The C99 standard introduces this usage also for the C
          language.  Using the directive
<programlisting>
#pragma TenDRA++ for declaration <emphasis>allow</emphasis>
</programlisting>
          declarations in for-statements can be made legal in C code.</para>
      </sect2>

      <sect2 id='return-statements'>
        <title>Return statements</title>

        <para>In C, but not in C++, it is possible to have a
          <literal>return</literal> statement without an expression in a function
          which does not return <literal>void</literal>. It is possible to enable
          this behaviour using the directive:</para>
<programlisting>
#pragma TenDRA incompatible void return <emphasis>allow</emphasis>
</programlisting>

        <para>Note that this check includes the implicit
          <literal>return</literal> caused by falling off the end of a function.
          The effect of such a <literal>return</literal> statement is undefined.
          The C++ rule that falling off the end of <literal>main</literal> is
          equivalent to returning a value of 0 overrides this check.</para>
      </sect2>

      <sect2 id='unreached-code-analysis'>
        <title>Unreached code analysis</title>

        <para>The directive:</para>
<programlisting>
#pragma TenDRA unreachable code <emphasis>allow</emphasis>
</programlisting>

        <para>enables a flow analysis check to detect unreachable code. It is
          possible to assert that a statement is reached or not reached by
          preceding it by a keyword introduced by one of the directives:</para>
<programlisting>
#pragma TenDRA keyword <emphasis>identifier</emphasis> for set reachable
#pragma TenDRA keyword <emphasis>identifier</emphasis> for set unreachable
</programlisting>

        <para>The fact that certain functions, such as <literal>exit</literal>,
          do not return a value can be exploited in the flow analysis routines.
          The equivalent directives:</para>
<programlisting>
#pragma TenDRA bottom <emphasis>identifier</emphasis>
#pragma TenDRA++ type <emphasis>identifier</emphasis> for bottom
</programlisting>

        <para>can be used to introduce a <literal>typedef</literal> declaration
          for the type, bottom, returned by such functions. The TenDRA API
          headers declare <literal>exit</literal> and similar functions in this
          way, for example:</para>
<programlisting>
#pragma TenDRA bottom __bottom
__bottom exit ( int ) ;
__bottom abort ( void ) ;
</programlisting>

        <para>The bottom type is compatible with <literal>void</literal> in
          function declarations to allow such functions to be redeclared in their
          conventional form.</para>
      </sect2>

      <sect2 id='variable-flow-analysis'>
        <title>Variable flow analysis</title>

        <para>The directive:</para>
<programlisting>
#pragma TenDRA variable analysis <emphasis>on</emphasis>
</programlisting>

        <itemizedlist>
          <listitem>
            <para>enables checks on the uses of automatic variables and
              function parameters. These checks detect:</para>
          </listitem>

          <listitem>
            <para>If a variable is not used in its scope.</para>
          </listitem>

          <listitem>
            <para>If the value of a variable is used before it has been
              assigned to.</para>
          </listitem>

          <listitem>
            <para>If a variable is assigned to twice without an intervening
              use.</para>
          </listitem>

          <listitem>
            <para>If a variable is assigned to twice without an intervening
              sequence point.</para>
          </listitem>
        </itemizedlist>

        <para>as illustrated by the variables <literal>a</literal>,
          <literal>b</literal>, <literal>c</literal> and <literal>d</literal>
          respectively in:</para>
<programlisting>
void f ()
{
  int a ;         // a never used
  int b ;
  int c = b ;     // b not initialised
  c = 0 ;         // c assigned to twice
  int d = 0 ;
  d = ++d ;       // d assigned to twice
}
</programlisting>

        <para>The second, and more particularly the third, of these checks
          requires some fairly sophisticated flow analysis, so any hints which
          can be picked up from <link linkend='switch-statements'>exhaustive
          <literal>switch</literal> statements</link> etc. is likely to
          increase the accuracy of the errors detected.</para>

        <para>In a non-static member function the various non-static data
          members are analysed as if they were automatic variables. It is checked
          that each member is initialised in a constructor. A common source of
          initialisation problems in a constructor is that the base classes and
          members are initialised in the canonical order of virtual bases,
          non-virtual direct bases and members in the order of their declaration,
          rather than in the order in which their initialisers appear in the
          constructor definition. Therefore a check that the initialisers appear
          in the canonical order is also applied.</para>

        <para>It is possible to change the state of a variable during the
          variable analysis using the directives:</para>
<programlisting>
#pragma TenDRA set <emphasis>expression</emphasis>
#pragma TenDRA discard <emphasis>expression</emphasis>
</programlisting>

        <para>The first asserts that the variable given by the
          <emphasis>expression</emphasis> has been assigned to; the second
          asserts that the variable is not used. An alternative way of expressing
          this is by means of keywords:</para>
<programlisting>
SET ( <emphasis>expression</emphasis> )
DISCARD ( <emphasis>expression</emphasis> )
</programlisting>

        <para>introduced using the directives.</para>
<programlisting>
#pragma TenDRA keyword <emphasis>identifier</emphasis> for set
#pragma TenDRA keyword <emphasis>identifier</emphasis> for discard variable
</programlisting>

        <para>respectively. These expressions can appear in expression
          statements and as the first argument of a comma expression.</para>

        <warning>
          <para>
              <blockquote>
                <para>The variable flow analysis checks have not yet been
                completely implemented. They may not detect errors in certain
                circumstances and for extremely convoluted code may occasionally
                give incorrect errors.</para>
            </blockquote>
          </para>
        </warning>
      </sect2>

      <sect2 id='variable-hiding'>
        <title>Variable hiding</title>

        <para>The directive:</para>
<programlisting>
#pragma TenDRA variable hiding analysis <emphasis>on</emphasis>
</programlisting>

        <para>can be used to enable a check for hiding of other variables and,
          in member functions, data members, by local variable
          declarations.</para>
      </sect2>

      <sect2 id='exception-analysis'>
        <title>Exception analysis</title>

        <para>The ISO C++ rules do not require exception specifications to be
          checked statically. This is to facilitate the integration of large
          systems where a single change in an exception specification could have
          ramifications throughout the system. However it is often useful to
          apply such checks, which can be enabled using the directive:</para>
<programlisting>
#pragma TenDRA++ throw analysis <emphasis>on</emphasis>
</programlisting>

        <para>This detects any potentially uncaught exceptions and other
          exception problems. In the error messages arising from this check, an
          uncaught exception of type <literal>...</literal> means that an
          uncaught exception of an unknown type (arising, for example, from a
          function without an exception specification) may be thrown. For
          example:</para>
<programlisting>
void f ( int ) throw ( int ) ;
void g ( int ) throw ( long ) ;
void h ( int ) ;

void e () throw ( int )
{
  f ( 1 ) ;           // OK
  g ( 2 ) ;           // uncaught 'long' exception
  h ( 3 ) ;           // uncaught '...' exception
}
</programlisting>
      </sect2>

      <sect2 id='template-compilation'>
        <title>Template compilation</title>

        <para>The C++ producer makes the distinction between exported
          templates, which may be used in one module and defined in another, and
          non-exported templates, which must be defined in every module in which
          they are used. As in the ISO C++ standard, the
          <literal>export</literal> keyword is used to distinguish between the
          two cases. In the past, different compilers have had different template
          compilation models; either all templates were exported or no templates
          were exported. The latter is easily emulated - if the
          <literal>export</literal> keyword is not used then no templates will be
          exported. To emulate the former behaviour the directive:</para>
<programlisting>
#pragma TenDRA++ implicit export template <emphasis>on</emphasis>
</programlisting>

        <para>can be used to treat all templates as if they had been declared
          using the <literal>export</literal> keyword.</para>

        <warning>
          <para>
              <blockquote>
                <para>The automatic instantiation of exported templates has not
                yet been implemented correctly. It is intended that such
                instantiations will be generated during
                <link linkend='intermodule-analysis'>intermodule
                analysis</link> (where they conceptually belong). At present
                it is necessary to work round this using explicit
                instantiations.</para>
            </blockquote>
          </para>
        </warning>
      </sect2>

      <sect2 id='other-checks'>
        <title>Other checks</title>

        <para>Several checks of varying utility have been implemented in the
          C++ producer but do not as yet have individual directives controlling
          their use. These can be enabled <emphasis>en masse</emphasis> using the
          directive:</para>
<programlisting>
#pragma TenDRA++ catch all <emphasis>allow</emphasis>
</programlisting>

        <para>It is intended that this directive will be phased out as these
          checks are assigned controlling directives. It is possible to achieve
          finer control over these checks by enabling their individual error
          messages <link linkend='low-level-directive'> as described above
          </link>.</para>
      </sect2>
    </sect1>

    <sect1 id='token-syntax'>
      <title>Token syntax</title>

      <para>The C and C++ producers allow place-holders for various categories
        of syntactic classes to be expressed using directives of the form:</para>
<programlisting>
#pragma TenDRA token <emphasis>token-spec</emphasis>
</programlisting>

      <para>or simply:</para>
<programlisting>
#pragma token <emphasis>token-spec</emphasis>
</programlisting>

      <para>These place-holders are represented as TDF tokens and hence are
        called tokens. These tokens stand for a certain type, expression or
        whatever which is to be represented by a certain named TDF token in the
        producer output. This mechanism is used, for example, to allow C API
        specifications to be represented target independently. The types,
        functions and expressions comprising the API can be described using
        <literal>#pragma token</literal> directives and the target dependent
        definitions of these tokens, representing the implementation of the API
        on a particular machine, can be linked in later. This mechanism is
        described in detail elsewhere.</para>

      <para>A <link linkend='token-directive'>summary of the grammar</link>
        for the <literal>#pragma token</literal> directives accepted by the C++
        producer is given as an annex.</para>

      <sect2 id='token-specifcations'>
        <title>Token specifications</title>

        <para>A token specification is divided into two components, a
          <emphasis>token-introduction</emphasis> giving the token sort, and a
          <emphasis>token-identification</emphasis> giving the internal and
          external token names:</para>
<programlisting>
<emphasis>token-spec</emphasis> :
  <emphasis>token-introduction token-identification</emphasis>

<emphasis>token-introduction</emphasis> :
  <emphasis>exp-token</emphasis>
  <emphasis>statement-token</emphasis>
  <emphasis>type-token</emphasis>
  <emphasis>member-token</emphasis>
  <emphasis>procedure-token</emphasis>

<emphasis>token-identification</emphasis> :
  <emphasis>token-namespace<subscript>opt</subscript> identifier</emphasis> # <emphasis>external-identifier<subscript>opt</subscript></emphasis>

<emphasis>token-namespace</emphasis> :
  TAG

<emphasis>external-identifier</emphasis> :
  -
  <emphasis>preproc-token-list</emphasis>
</programlisting>

        <para>The <literal>TAG</literal> qualifier is used to indicate that the
          internal name lies in the C tag namespace. This only makes sense for
          structure and union types. The external token name can be given by any
          sequence of preprocessing tokens. These tokens are not macro expanded.
          If no external name is given then the internal name is used. The
          special external name <literal>-</literal> is used to indicate that the
          token does not have an associated external name, and hence is local to
          the current translation unit. Such a local token must be defined. White
          space in the external name (other than at the start or end) is used to
          indicate that a TDF unique name should be used. The white space serves
          as a separator for the unique name components.</para>

        <sect3 id='expression-tokens'>
          <title>Expression tokens</title>

          <para>Expression tokens are specified as follows:</para>
<programlisting>
<emphasis>exp-token</emphasis> :
  EXP <emphasis>exp-storage<subscript>opt</subscript></emphasis> : <emphasis>type-id</emphasis> :
  NAT
  INTEGER
</programlisting>

          <para>representing a expression of the given type, a non-negative
            integer constant and general integer constant, respectively. Each
            expression has an associated storage class:</para>
<programlisting>
<emphasis>exp-storage</emphasis> :
  lvalue
  rvalue
  const
</programlisting>

          <para>indicating whether it is an lvalue, an rvalue or a compile-time
            constant expression. An absent <emphasis>exp-storage</emphasis> is
            equivalent to <literal>rvalue</literal>. All expression tokens lie in
            the macro namespace; that is, they may potentially be defined as
            macros.</para>

          <para>For backwards compatibility with the C producer, the
            directive:</para>
<programlisting>
#pragma TenDRA++ rvalue token as const <emphasis>allow</emphasis>
</programlisting>

          <para>causes <literal>rvalue</literal> tokens to be treated as
            <literal>const</literal> tokens.</para>
        </sect3>

        <sect3 id='statement-tokens'>
          <title>Statement tokens</title>

          <para>Statement tokens are specified as follows:</para>
<programlisting>
<emphasis>statement-token</emphasis> :
  STATEMENT
</programlisting>

          <para>All statement tokens lie in the macro namespace.</para>
        </sect3>

        <sect3 id='type-tokens'>
          <title>Type tokens</title>

          <para>Type tokens are specified as follows:</para>
<programlisting>
<emphasis>type-token</emphasis> :
  TYPE
  VARIETY
  VARIETY signed
  VARIETY unsigned
  FLOAT
  ARITHMETIC
  SCALAR
  CLASS
  STRUCT
  UNION
</programlisting>

          <para>representing a generic type, an integral type, a signed
            integral type, an unsigned integral type, a floating point type, an
            arithmetic (integral or floating point) type, a scalar (arithmetic or
            pointer) type, a class type, a structure type and a union type
            respectively.</para>

          <warning>
            <para>
                <blockquote>
                  <para>Floating-point, arithmetic and scalar token types have
                  not yet been implemented correctly in either the C or C++
                  producers.</para>
              </blockquote>
            </para>
          </warning>
        </sect3>

        <sect3 id='member-tokens'>
          <title>Member tokens</title>

          <para>Member tokens are specified as follows:</para>
<programlisting>
<emphasis>member-token</emphasis> :
  MEMBER <emphasis>access-specifier<subscript>opt</subscript> member-type-id</emphasis> : <emphasis>type-id</emphasis> :
</programlisting>

          <para>where an <emphasis>access-specifier</emphasis> of
            <literal>public</literal> is assumed if none is given. The member
            type is given by:</para>
<programlisting>
<emphasis>member-type-id</emphasis> :
  <emphasis>type-id</emphasis>
  <emphasis>type-id</emphasis> % <emphasis>constant-expression</emphasis>
</programlisting>

          <para>where <literal>%</literal> is used to denote bitfield members
            (since <literal>:</literal> is used as a separator). The second type
            denotes the structure or union the given member belongs to. Different
            types can have members with the same internal name, but the external
            token name must be unique. Note that only non-static data members can
            be represented in this form.</para>

          <para>Two declarations for the same <literal>MEMBER</literal> token
            (including token definitions) should have the same type, however the
            directive:</para>
<programlisting>
#pragma TenDRA++ incompatible member declaration <emphasis>allow</emphasis>
</programlisting>

          <para>allows declarations with different types, provided these types
            have the same size and alignment requirements.</para>
        </sect3>

        <sect3 id='procedure-tokens'>
          <title>Procedure tokens</title>

          <para>Procedure, or high-level, tokens are specified in one of three
            ways:</para>
<programlisting>
<emphasis>procedure-token</emphasis> :
  <emphasis>general-procedure</emphasis>
  <emphasis>simple-procedure</emphasis>
  <emphasis>function-procedure</emphasis>
</programlisting>

          <para>All procedure tokens (except ellipsis functions - see below)
            lie in the macro namespace. The most general form of procedure token
            specifies two sets of parameters. The bound parameters are those
            which are used in encoding the actual TDF output, and the program
            parameters are those which are <link linkend='token-arguments'>
            specified in the program</link>.
            The program parameters are expressed in terms of the bound
            parameters. A program parameter can be an expression token parameter,
            a statement token parameter, a member token parameter, a procedure
            token parameter or any type. The bound parameters are deduced from
            the program parameters by a similar process to that used in template
            argument deduction.</para>
<programlisting>
<emphasis>general-procedure</emphasis> :
  PROC { <emphasis>bound-toks<subscript>opt</subscript></emphasis> | <emphasis>prog-pars<subscript>opt</subscript></emphasis> } <emphasis>token-introduction</emphasis>

<emphasis>bound-toks</emphasis> :
  <emphasis>bound-token</emphasis>
  <emphasis>bound-token</emphasis> , <emphasis>bound-toks</emphasis>

<emphasis>bound-token</emphasis> :
  <emphasis>token-introduction token-namespace<subscript>opt</subscript> identifier</emphasis>

<emphasis>prog-pars</emphasis> :
  <emphasis>program-parameter</emphasis>
  <emphasis>program-parameter</emphasis> , <emphasis>prog-pars</emphasis>

<emphasis>program-parameter</emphasis> :
  EXP <emphasis>identifier</emphasis>
  STATEMENT <emphasis>identifier</emphasis>
  TYPE <emphasis>type-id</emphasis>
  MEMBER <emphasis>type-id</emphasis> : <emphasis>identifier</emphasis>
  PROC <emphasis>identifier</emphasis>
</programlisting>

          <para>The simplest form of a <emphasis>general-procedure</emphasis>
            is one in which the <emphasis>prog-pars</emphasis> correspond
            precisely to the <emphasis>bound-toks</emphasis>. In this case the
            syntax:</para>
<programlisting>
<emphasis>simple-procedure</emphasis> :
  PROC ( <emphasis>simple-toks<subscript>opt</subscript></emphasis> ) <emphasis>token-introduction</emphasis>

<emphasis>simple-toks</emphasis> :
  <emphasis>simple-token</emphasis>
  <emphasis>simple-token</emphasis> , <emphasis>simple-toks</emphasis>

<emphasis>simple-token</emphasis> :
  <emphasis>token-introduction token-namespace<subscript>opt</subscript> identifier<subscript>opt</subscript></emphasis>
</programlisting>

          <para>may be used. Note that the parameter names are optional.</para>

          <para>A function token is specified as follows:</para>
<programlisting>
<emphasis>function-procedure</emphasis> :
  FUNC <emphasis>type-id</emphasis> :
</programlisting>

          <para>where the given type is a function type. This has two effects:
            firstly a function with the given type is declared; secondly, if the
            function type has the form:</para>
<programlisting>
r ( p1, ...., pn )
</programlisting>

          <para>a procedure token with sort:</para>
<programlisting>
PROC ( EXP rvalue : p1 :, ...., EXP rvalue : pn : ) EXP rvalue : r :
</programlisting>

          <para>is declared. For ellipsis function types only the function, not
            the token, is declared. Note that the token behaves like a macro
            definition of the corresponding function. Unless explicitly enclosed
            in a linkage specification, a function declared using a
            <literal>FUNC</literal> token has C linkage. Note that it is possible
            for two <literal>FUNC</literal> tokens to have the same internal
            name, because of function overloading, however external names must be
            unique.</para>

          <para>The directive:</para>
<programlisting>
#pragma TenDRA incompatible interface declaration <emphasis>allow</emphasis>
</programlisting>

          <para>can be used to allow incompatible redeclarations of functions
            declared using <literal>FUNC</literal> tokens. The token declaration
            takes precedence.</para>

          <warning>
            <para>
                <blockquote>
                  <para>Certain of the more complex examples of
                  <literal>PROC</literal> tokens such as, for example, tokens
                  with <literal>PROC</literal> parameters, have not been
                  implemented in either the C or C++ producers.</para>
              </blockquote>
            </para>
          </warning>
        </sect3>
      </sect2>

      <sect2 id='token-arguments'>
        <title>Token arguments</title>

        <para>As mentioned above, the program parameters for a
          <literal>PROC</literal> token are those specified in the program
          itself. These arguments are expressed as a comma-separated list
          enclosed in brackets, the form of each argument being determined by the
          corresponding program parameter.</para>

        <para>An <literal>EXP</literal> argument is an assignment expression.
          This must be an lvalue for <literal>lvalue</literal> tokens and a
          constant expression for <literal>const</literal> tokens. The argument
          is converted to the token type (for <literal>lvalue</literal> tokens
          this is essentially a conversion between the corresponding reference
          types). A <literal>NAT</literal> or <literal>INTEGER</literal> argument
          is an integer constant expression. In the former case this must be
          non-negative.</para>

        <para>A <literal>STATEMENT</literal> argument is a statement. This
          statement should not contain any labels or any <literal>goto</literal>
          or <literal>return</literal> statements.</para>

        <para>A type argument is a type identifier. This must name a type of
          the correct category for the corresponding token. For example, a
          <literal>VARIETY</literal> token requires an integral type.</para>

        <para>A member argument must describe the offset of a
          member or nested member of the given structure or union type. The type
          of the member should agree with that of the <literal>MEMBER</literal>
          token. The general form of a member offset can be described in terms of
          member selectors and array indexes as follows:</para>
<programlisting>
<emphasis>member-offset</emphasis> :
  ::<emphasis><subscript>opt</subscript> id-expression</emphasis>
  <emphasis>member-offset</emphasis> . ::<emphasis><subscript>opt</subscript> id-expression</emphasis>
  <emphasis>member-offset</emphasis> [ <emphasis>constant-expression</emphasis> ]
</programlisting>

        <para>A <literal>PROC</literal> argument is an identifier. This
          identifier must name a <literal>PROC</literal> token of the appropriate
          sort.</para>
      </sect2>

      <sect2 id='defining-tokens'>
        <title>Defining tokens</title>

        <para>Given a token specification of a syntactic object and a normal
          language definition of the same object (including macro definitions if
          the token lies in the macro namespace), the producers attempt to unify
          the two by defining the TDF token in terms of the given definition.
          Whether the token specification occurs before or after the language
          definition is immaterial. Unification also takes place in situations
          where, for example, two types are known to be compatible. Multiple
          consistent explicit token definitions are allowed by default when
          allowed by the language; this is controlled by the directive:</para>
<programlisting>
#pragma TenDRA compatible token <emphasis>allow</emphasis>
</programlisting>

        <para>The default unification behaviour may be modified using the
          directives:</para>
<programlisting>
#pragma TenDRA no_def <emphasis>token-list</emphasis>
#pragma TenDRA define <emphasis>token-list</emphasis>
#pragma TenDRA reject <emphasis>token-list</emphasis>
</programlisting>

        <para>or equivalently:</para>
<programlisting>
#pragma no_def <emphasis>token-list</emphasis>
#pragma define <emphasis>token-list</emphasis>
#pragma ignore <emphasis>token-list</emphasis>
</programlisting>

        <para>which set the state of the tokens given in
          <emphasis>token-list</emphasis>. A state of <literal>no_def</literal>
          means that no unification is attempted and that any attempt to
          explicitly define the token results in an error. A state of
          <literal>define</literal> means that unification takes place and that
          the token must be defined somewhere in the translation unit. A state of
          <literal>reject</literal> means that unification takes place as normal,
          but any resulting token definition is discarded and not output to the
          TDF capsule.</para>

        <para>If a token with the state <literal>define</literal> is not
          defined, then the behaviour depends on the sort of the token. A
          <literal>FUNC</literal> token is implicitly defined in terms of its
          underlying function, such as:</para>
<programlisting>
#define f( a1, ...., an )   ( f ) ( a1, ...., an )
</programlisting>

        <para>Other undefined tokens cause an error. This behaviour can be
          modified using the directives:</para>
<programlisting>
#pragma TenDRA++ implicit token definition <emphasis>allow</emphasis>
#pragma TenDRA++ no token definition <emphasis>allow</emphasis>
</programlisting>

        <para>respectively.</para>

        <para>The primitive operations, <literal>no_def</literal>,
          <literal>define</literal> and <literal>reject</literal>, can also be
          expressed using the context sensitive directive:</para>
<programlisting>
#pragma TenDRA interface <emphasis>token-list</emphasis>
</programlisting>

        <para>or equivalently:</para>
<programlisting>
#pragma interface <emphasis>token-list</emphasis>
</programlisting>

        <para>By default this is equivalent to <literal>no_def</literal>, but
          may be modified by inclusion using one of the directives:</para>
<programlisting>
#pragma TenDRA extend <emphasis>header-name</emphasis>
#pragma TenDRA implement <emphasis>header-name</emphasis>
</programlisting>

        <para>or equivalently:</para>
<programlisting>
#pragma extend interface <emphasis>header-name</emphasis>
#pragma implement interface <emphasis>header-name</emphasis>
</programlisting>

        <para>These are equivalent to:</para>
<programlisting>
#include <emphasis>header-name</emphasis>
</programlisting>

        <para>except that the form <literal>[....]</literal> is allowed as a
          header name. This is equivalent to <literal>&lt;....&gt;</literal>
          except that it starts the directory search after the point at which the
          including file was found, rather than at the start of the path (i.e. it
          is equivalent to the <literal>#include_next</literal> directive found
          in some preprocessors). The effect of the <literal>extend</literal>
          directive on the state of the <literal>interface</literal> directive is
          as follows:</para>
<programlisting>
no_def -&gt; no_def
define -&gt; reject
reject -&gt; reject
</programlisting>

        <para>The effect of the <literal>implement</literal> directive is as
          follows:</para>
<programlisting>
no_def -&gt; define
define -&gt; define
reject -&gt; reject
</programlisting>

        <para>That is to say, a <literal>implement</literal> directive will
          cause all the tokens in the given header to be defined and their
          definitions output. Any tokens included in this header by
          <literal>extend</literal> may be defined, but their definitions will
          not be output. This is precisely the behaviour which is required to
          ensure that each token is defined exactly once in an API library
          build.</para>

        <para>The lists of tokens in the directives above are expressed in the
          form:</para>
<programlisting>
<emphasis>token-list</emphasis> :
<emphasis>token-id token-list<subscript>opt</subscript></emphasis>
# <emphasis>preproc-token-list</emphasis>
</programlisting>

        <para>where a <emphasis>token-id</emphasis> represents an internal
          token name:</para>
<programlisting>
<emphasis>token-id</emphasis> :
<emphasis>token-namespace<subscript>opt</subscript> identifier</emphasis>
<emphasis>type-id</emphasis> . <emphasis>identifier</emphasis>
</programlisting>

        <para>Note that member tokens are specified by means of both the member
          name and its parent type. In this type specifier,
          <literal>TAG</literal>, rather than <literal>class</literal>,
          <literal>struct</literal> or <literal>union</literal>, may be used in
          elaborated type specifiers for structure and union tokens. If the
          <emphasis>token-id</emphasis> names an overloaded function then the
          directive is applied to all <literal>FUNC</literal> tokens of that
          name. It is possible to be more selective using the
          <literal>#</literal> form which allows the external token name to be
          specified. Such an entry must be the last in a
          <emphasis>token-list</emphasis>.</para>

        <para>A related directive has the form:</para>
<programlisting>
#pragma TenDRA++ undef token <emphasis>token-list</emphasis>
</programlisting>

        <para>which undefines all the given tokens so that they are no longer
          visible.</para>

        <para>As noted above, a macro is only considered as a token definition
          if the token lies in the macro namespace. Tokens which are not in the
          macro namespace, such as types and members, cannot be defined using
          macros. Occasionally API implementations do define member selector as
          macros in terms of other member selectors. Such a token needs to be
          explicitly defined using a directive of the form:</para>
<programlisting>
#pragma TenDRA member definition <emphasis>type-id</emphasis> : <emphasis>identifier member-offset</emphasis>
</programlisting>

        <para>where <emphasis>member-offset</emphasis> is
          <link linkend='offset'>as above</link>.</para>
      </sect2>
    </sect1>

    <sect1 id='symbol-table-dump'>
      <title>Symbol table dump</title>

      <para>The symbol table dump provides a method whereby third party tools
        can interface with the C and C++ producers. The producer outputs
        information on the identifiers declared within a source file, their uses
        etc. into a file which can then be post-processed by a separate tool. Any
        error messages and warnings can also be included in this file, allowing
        more sophisticated error presentation tools to be written.</para>

      <para>The file to be used as the symbol table output file, plus details
        of what information is to be included in the dump file can be specified
        using the <link linkend='tccplus-d-option'><literal>-d</literal>
        command-line option</link>.
        The format of the dump file is described below; a
        <link linkend='symbol-table-dump-syntax'>summary of the syntax</link>
        is given as an annex.</para>

      <sect2 id='lexical-elements'>
        <title>Lexical elements</title>

        <para>A symbol table dump file consists of a sequence of characters
          giving information on identifiers, errors etc. arising from a
          translation unit. The fundamental lexical tokens are a
          <emphasis>number</emphasis>, consisting of a sequence of decimal
          digits, and a <emphasis>string</emphasis>, consisting of a sequence of
          characters enclosed in angle braces. A <emphasis>string</emphasis> can
          have one of two forms:</para>
<programlisting>
<emphasis>string</emphasis> :
  &lt;<emphasis>characters</emphasis>&gt;
  &amp;<emphasis>number</emphasis>&lt;<emphasis>characters</emphasis>&gt;
</programlisting>

        <para>In the first form, the <emphasis>characters</emphasis> are
          terminated by the first <literal>&gt;</literal> character encountered.
          In the second form, the number of characters is given by the preceding
          <emphasis>number</emphasis>. No white space is allowed either before or
          after the <emphasis>number</emphasis>. To aid parsers, the C++ producer
          always uses the second form for strings containing more than 100
          characters. There are no escape characters in strings; the
          <emphasis>characters</emphasis> can contain any characters, including
          newlines and <literal>#</literal>, except that the first form cannot
          contain a <literal>&gt;</literal> character.</para>

        <para>Space, tab and newline characters are white space. Comments begin
          with <literal>#</literal> and run to the end of the line. Comments are
          treated as white space. All other characters are treated as distinct
          lexical tokens.</para>
      </sect2>

      <sect2 id='overall-syntax'>
        <title>Overall syntax</title>

        <para>A symbol table dump file takes the form of a list of commands of
          various kinds conveying information on the analysed file. This can be
          represented as follows:</para>
<programlisting>
<emphasis>dump-file</emphasis> :
  <emphasis>command-list<subscript>opt</subscript></emphasis>

<emphasis>command-list</emphasis> :
  <emphasis>command command-list<subscript>opt</subscript></emphasis>

<emphasis>command</emphasis> :
  <emphasis>version-command</emphasis>
  <emphasis>identifier-command</emphasis>
  <emphasis>scope-command</emphasis>
  <emphasis>override-command</emphasis>
  <emphasis>base-command</emphasis>
  <emphasis>api-command</emphasis>
  <emphasis>template-command</emphasis>
  <emphasis>promotion-command</emphasis>
  <emphasis>error-command</emphasis>
  <emphasis>path-command</emphasis>
  <emphasis>file-command</emphasis>
  <emphasis>include-command</emphasis>
  <emphasis>string-command</emphasis>
</programlisting>

        <para>The various kinds of command are discussed below. The first
          command in the dump file should be of the form:</para>
<programlisting>
<emphasis>version-command</emphasis> :
  V <emphasis>number number string</emphasis>
</programlisting>

        <para>where the two numbers give the version of the dump file format
          (the version described here is 1.1 so both numbers should be 1) and the
          string gives the language being represented, for example,
          <literal>&lt;C++&gt;</literal>.</para>
      </sect2>

      <sect2 id='file-locations'>
        <title>File locations</title>

        <para>A location within a source file can be specified using three
          <emphasis>number</emphasis>s and two <emphasis>string</emphasis>s.
          These give respectively, the column number, the line number taking
          <literal>#line</literal> directives into account, the line number not
          taking <literal>#line</literal> directives into account, the file name
          taking <literal>#line</literal> directives into account, and the file
          name not taking <literal>#line</literal> directives into account. Any
          or all of the trailing elements can be replaced by <literal>*</literal>
          to indicate that they have not changed relative to the last
          <emphasis>location</emphasis> given. Note that for the two line
          numbers, unchanged means that the difference of the line numbers,
          taking <literal>#line</literal> directives into account or not, is
          unchanged. Thus:</para>
<programlisting>
 <emphasis>location</emphasis> :
  <emphasis>number number number string string</emphasis>
  <emphasis>number number number string</emphasis> *
  <emphasis>number number number</emphasis> *
  <emphasis>number number</emphasis> *
  <emphasis>number</emphasis> *
  *
</programlisting>

        <anchor id='crt-loc'>
        <para>Note that there is a concept of the current file
          location, relative to which other locations are given. The initial
          value of the current file location is undefined. Unless otherwise
          stated, all <emphasis>location</emphasis> elements update the current
          file location.</para>
      </sect2>

      <sect2 id='identifers'>
        <title>Identifiers</title>

        <para>Each identifier is represented in the symbol table dump by a
          unique number. The same number always represents the same
          identifier.</para>

        <sect3 id='indentifer-names'>
          <title>Identifier names</title>

          <para>The number representing an identifier is introduced in the
            first declaration or use of that identifier and thereafter the number
            alone is used to denote the identifier:</para>
<programlisting>
<emphasis>identifier</emphasis> :
  <emphasis>number</emphasis> = <emphasis>identifier-name access<subscript>opt</subscript> scope-identifier</emphasis>

  <emphasis>number</emphasis>
</programlisting>

          <para>The identifier name is given by:</para>
<programlisting>
<emphasis>identifier-name</emphasis> :
<emphasis>string</emphasis>
  C <emphasis>type</emphasis>
  D <emphasis>type</emphasis>
  O <emphasis>string</emphasis>
  T <emphasis>type</emphasis>

</programlisting>

          <para>denoting respectively, a simple identifier name, a constructor
            for a type, a destructor for a type, an overloaded operator function
            name, and a conversion function name. The empty string is used for
            anonymous identifiers.</para>

          <para>The optional identifier access is given by:</para>
<programlisting>
<emphasis>access</emphasis> :
  N
  B
  P
</programlisting>

          <para>denoting <literal>public</literal>,
            <literal>protected</literal> and <literal>private</literal>
            respectively. An absent <emphasis>access</emphasis> is equivalent to
            <literal>public</literal>. Note that all identifiers, not just class
            members, can have access specifiers; however the access of a
            non-member is always <literal>public</literal>.</para>

          <para>The <link linkend='scope-directive'>scope</link>(i.e. class,
            namespace, block etc.) in
            which an identifier is declared is given by:</para>
<programlisting>
<emphasis>scope-identifier</emphasis> :
  <emphasis>identifier</emphasis>
  *
</programlisting>

          <para>denoting either a named or an unnamed scope.</para>
        </sect3>

        <sect3 id='identifer-uses'>
          <title>Identifier uses</title>

          <para>Each declaration or use of an identifier is represented by a
            command of the form:</para>
<programlisting>
<emphasis>identifier-command</emphasis> :
  D <emphasis>identifier-info type-info</emphasis>
  M <emphasis>identifier-info type-info</emphasis>
  T <emphasis>identifier-info type-info</emphasis>
  Q <emphasis>identifier-info</emphasis>
  U <emphasis>identifier-info</emphasis>
  L <emphasis>identifier-info</emphasis>
  C <emphasis>identifier-info</emphasis>
  W <emphasis>identifier-info type-info</emphasis>
</programlisting>

          <para>where:</para>
<programlisting>
<emphasis>identifier-info</emphasis> :
<emphasis>identifier-key location identifier</emphasis>
</programlisting>

          <para>gives the kind of identifier being declared or used, the
            location of the declaration or use, and the number associated with
            the identifier. Each declaration may, depending on the
            <emphasis>identifier-key</emphasis>, associate various
            <emphasis>type-info</emphasis> with the identifier, giving its type
            etc.</para>

          <para>The various kinds of <emphasis>identifier-command</emphasis>
            are described below. Any can be preceded by <literal>I</literal> to
            indicate an implicit declaration or use. <literal>D</literal> denotes
            a definition. <literal>M</literal> (make) denotes a declaration.
            <literal>T</literal> denotes a tentative definition (C only).
            <literal>Q</literal> denotes the end of a definition, for those
            identifiers such as classes and functions whose definitions may be
            spread over several lines. <literal>U</literal> denotes an undefine
            operation (such as <literal>#undef</literal> for macro identifiers).
            <literal>C</literal> denotes a call to a function identifier;
            <literal>L</literal> (load) denotes other identifier uses. Finally
            <literal>W</literal> denotes implicit type information such as the C
            producer gleans from its <link linkend='weak-function-prototypes'>
            weak prototype analysis</link>.</para>

          <para>The various <emphasis>identifier-key</emphasis>s are their
            associated <emphasis>type-info</emphasis> fields are given by the
            following table:</para>

          <table frame='all' id='identifer-keys'>
            <title>Identifier Keys</title>

            <tgroup cols='3'>
              <thead>
                <row>
                  <entry>Key</entry>

                  <entry>Type Information</entry>

                  <entry>Description</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry><literal>K</literal></entry>

                  <entry><literal>*</literal></entry>

                  <entry>keyword</entry>
                </row>

                <row>
                  <entry><literal>MO</literal></entry>

                  <entry><emphasis>sort</emphasis></entry>

                  <entry>object macro</entry>
                </row>

                <row>
                  <entry><literal>MF</literal></entry>

                  <entry><emphasis>sort</emphasis></entry>

                  <entry>function macro</entry>
                </row>

                <row>
                  <entry><literal>MB</literal></entry>

                  <entry><emphasis>sort</emphasis></entry>

                  <entry>built-in macro</entry>
                </row>

                <row>
                  <entry><literal>TC</literal></entry>

                  <entry><emphasis>type</emphasis></entry>

                  <entry>class tag</entry>
                </row>

                <row>
                  <entry><literal>TS</literal></entry>

                  <entry><emphasis>type</emphasis></entry>

                  <entry>structure tag</entry>
                </row>

                <row>
                  <entry><literal>TU</literal></entry>

                  <entry><emphasis>type</emphasis></entry>

                  <entry>union tag</entry>
                </row>

                <row>
                  <entry><literal>TE</literal></entry>

                  <entry><emphasis>type</emphasis></entry>

                  <entry>enumeration tag</entry>
                </row>

                <row>
                  <entry><literal>TA</literal></entry>

                  <entry><emphasis>type</emphasis></entry>

                  <entry><literal>typedef</literal> name</entry>
                </row>

                <row>
                  <entry><literal>NN</literal></entry>

                  <entry><literal>*</literal></entry>

                  <entry>namespace name</entry>
                </row>

                <row>
                  <entry><literal>NA</literal></entry>

                  <entry><emphasis>scope-identifier</emphasis></entry>

                  <entry>namespace alias</entry>
                </row>

                <row>
                  <entry><literal>VA</literal></entry>

                  <entry><emphasis>type</emphasis></entry>

                  <entry>automatic variable</entry>
                </row>

                <row>
                  <entry><literal>VP</literal></entry>

                  <entry><emphasis>type</emphasis></entry>

                  <entry>function parameter</entry>
                </row>

                <row>
                  <entry><literal>VE</literal></entry>

                  <entry><emphasis>type</emphasis></entry>

                  <entry><literal>extern</literal> variable</entry>
                </row>

                <row>
                  <entry><literal>VS</literal></entry>

                  <entry><emphasis>type</emphasis></entry>

                  <entry><literal>static</literal> variable</entry>
                </row>

                <row>
                  <entry><literal>FE</literal></entry>

                  <entry><emphasis>type
                  identifier<subscript>opt</subscript></emphasis></entry>

                  <entry><literal>extern</literal> function</entry>
                </row>

                <row>
                  <entry><literal>FS</literal></entry>

                  <entry><emphasis>type
                  identifier<subscript>opt</subscript></emphasis></entry>

                  <entry><literal>static</literal> function</entry>
                </row>

                <row>
                  <entry><literal>FB</literal></entry>

                  <entry><emphasis>type
                  identifier<subscript>opt</subscript></emphasis></entry>

                  <entry>built-in operator function</entry>
                </row>

                <row>
                  <entry><literal>CF</literal></entry>

                  <entry><emphasis>type
                  identifier<subscript>opt</subscript></emphasis></entry>

                  <entry>member function</entry>
                </row>

                <row>
                  <entry><literal>CS</literal></entry>

                  <entry><emphasis>type
                  identifier<subscript>opt</subscript></emphasis></entry>

                  <entry><literal>static</literal> member function</entry>
                </row>

                <row>
                  <entry><literal>CV</literal></entry>

                  <entry><emphasis>type
                  identifier<subscript>opt</subscript></emphasis></entry>

                  <entry>virtual member function</entry>
                </row>

                <row>
                  <entry><literal>CM</literal></entry>

                  <entry><emphasis>type</emphasis></entry>

                  <entry>data member</entry>
                </row>

                <row>
                  <entry><literal>CD</literal></entry>

                  <entry><emphasis>type</emphasis></entry>

                  <entry><literal>static</literal> data member</entry>
                </row>

                <row>
                  <entry><literal>E</literal></entry>

                  <entry><emphasis>type</emphasis></entry>

                  <entry>enumerator</entry>
                </row>

                <row>
                  <entry><literal>L</literal></entry>

                  <entry><literal>*</literal></entry>

                  <entry>label</entry>
                </row>

                <row>
                  <entry><literal>XO</literal></entry>

                  <entry><emphasis>sort</emphasis></entry>

                  <entry>object token</entry>
                </row>

                <row>
                  <entry><literal>XF</literal></entry>

                  <entry><emphasis>sort</emphasis></entry>

                  <entry>procedure token</entry>
                </row>

                <row>
                  <entry><literal>XP</literal></entry>

                  <entry><emphasis>sort</emphasis></entry>

                  <entry>token parameter</entry>
                </row>

                <row>
                  <entry><literal>XT</literal></entry>

                  <entry><emphasis>sort</emphasis></entry>

                  <entry>template parameter</entry>
                </row>
              </tbody>
            </tgroup>
          </table>

          <para>The function identifier keys can optionally be followed by
            <literal>C</literal> indicating that the function has C linkage, and
            <literal>I</literal> indicating that the function is inline. By
            default, functions declared in a C++ dump file have C++ linkage and
            functions declared in a C dump file have C linkage. The optional
            <emphasis>identifier</emphasis> which forms part of the
            <emphasis>type-info</emphasis> of these functions is used to form
            linked lists of overloaded functions.</para>
        </sect3>

        <sect3 id='identifier-scopes'>
          <title>Identifier scopes</title>

          <para>Each identifier belongs to a scope, called its parent scope, in
            which it is declared. For example, the parent of a member of a class
            is the class itself. This information is expressed in an identifier
            declaration using a <emphasis>scope-identifier</emphasis>. In
            addition to the obvious scopes such as classes and namespaces, there
            are other scopes such as blocks in function definitions. It is
            possible to introduce dummy identifiers to name such scopes. The
            parent of such a dummy identifier will be the enclosing scope
            identifier, so these dummy identifiers naturally represent the block
            structure. The parent of the top-level block in a function definition
            can be considered to be the function itself.</para>

          <para>Information on the start and end of such scopes is given
            by:</para>
<programlisting>
<emphasis>scope-command</emphasis> :
  SS <emphasis>scope-key location identifier</emphasis>
  SE <emphasis>scope-key location identifier</emphasis>
</programlisting>

          <para>where:</para>
<programlisting>
<emphasis>scope-key</emphasis> :
  N
  S
  B
  D
  H
  CT
  CF
  CC
</programlisting>

          <para>gives the kind of scope involved: a namespace, a class, a
            block, some other declarative scope, a declaration block (see below),
            a true conditional scope, a false conditional scope or a target
            dependent conditional scope.</para>

          <para>A declaration block is a sequence of declarations enclosed in
            directives of the form:</para>
<programlisting>
#pragma TenDRA declaration block <emphasis>identifier</emphasis> begin
....
#pragma TenDRA declaration block end
</programlisting>

          <para>This allows the sequence of declarations to be associated with
            the given <emphasis>identifier</emphasis> in the symbol dump file.
            This technique is used in the API description files to aid analysis
            tools in determining which declarations are part of the API.</para>
        </sect3>

        <sect3 id='other-identifier-info'>
          <title>Other identifier information</title>

          <para>Other information associated with an identifier may be
            expressed using other dump commands. For example:</para>
<programlisting>
<emphasis>override-command</emphasis> :
  O <emphasis>identifier identifier</emphasis>
</programlisting>

          <para>is used to express the fact that the two
            <emphasis>identifier</emphasis>s are virtual member functions, the
            first of which overrides the second.</para>

          <para>The command:</para>
<programlisting>
<emphasis>base-command</emphasis> :
  B <emphasis>identifier-key identifier base-graph</emphasis>

<emphasis>base-graph</emphasis> :
  <emphasis>base-class</emphasis>
  <emphasis>base-class</emphasis> ( <emphasis>base-list</emphasis> )

<emphasis>base-class</emphasis> :
  <emphasis>number</emphasis> = V<emphasis><subscript>opt</subscript> access<subscript>opt</subscript> type-name</emphasis>
  <emphasis>number</emphasis> :

<emphasis>base-list</emphasis> :
  <emphasis>base-graph base-list<subscript>opt</subscript></emphasis>

</programlisting>

          <para>associates a base class graph with a class identifier. Any
            class which does not have an associated
            <emphasis>base-command</emphasis> can be assumed to have no base
            classes. Each node in the graph is a <emphasis>type-name</emphasis>
            with an associated list of base classes. A <literal>V</literal> is
            used to indicate a virtual base class. Each node is numbered;
            duplicate numbers are used to indicate bases identified via the
            virtual base class structure. Any base class can then be referred to
            as:</para>
<programlisting>
<emphasis>base-number</emphasis> :
  <emphasis>number</emphasis> : <emphasis>type-name</emphasis>
</programlisting>

          <para>indicating the base class with the given number in the given
            class.</para>

          <para>The command:</para>
<programlisting>
<emphasis>api-command</emphasis> :
  X <emphasis>identifier-key identifier string</emphasis>
</programlisting>

          <para>associates the external token name given by the
            <emphasis>string</emphasis> with the given tokenised
            identifier.</para>

          <para>The command:</para>
<programlisting>
<emphasis>template-command</emphasis> :
  Z <emphasis>identifier-key identifier token-application specialise-info</emphasis>
</programlisting>

          <para>is used to introduce an identifier corresponding to an instance
            of a template, <emphasis>token-application</emphasis>. This instance
            may correspond to a specialisation of the primary template; this
            information is represented by:</para>
<programlisting>
<emphasis>specialise-info</emphasis> :
  <emphasis>identifier</emphasis>
  <emphasis>token-application</emphasis>
  *
</programlisting>

          <para>where <literal>*</literal> indicates a non-specialised
            instance.</para>
        </sect3>
      </sect2>

      <sect2 id='types'>
        <title>Types</title>

        <para>The built-in types are represented in the symbol
          table dump as follows:</para>

        <table frame='all' id='symbol-table-dump-b'>
          <title>Symbol Table Dump</title>

          <tgroup cols='4'>
            <thead>
              <row>
                <entry>Type</entry>

                <entry>Encoding</entry>

                <entry>Type</entry>

                <entry>Encoding</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>char</entry>

                <entry><literal>c</literal></entry>

                <entry>float</entry>

                <entry><literal>f</literal></entry>
              </row>

              <row>
                <entry>signed char</entry>

                <entry><literal>Sc</literal></entry>

                <entry>double</entry>

                <entry><literal>d</literal></entry>
              </row>

              <row>
                <entry>unsigned char</entry>

                <entry><literal>Uc</literal></entry>

                <entry>long double</entry>

                <entry><literal>r</literal></entry>
              </row>

              <row>
                <entry>signed short</entry>

                <entry><literal>s</literal></entry>

                <entry>void</entry>

                <entry><literal>v</literal></entry>
              </row>

              <row>
                <entry>unsigned short</entry>

                <entry><literal>Us</literal></entry>

                <entry>(bottom)</entry>

                <entry><literal>u</literal></entry>
              </row>

              <row>
                <entry>signed int</entry>

                <entry><literal>i</literal></entry>

                <entry>bool</entry>

                <entry><literal>b</literal></entry>
              </row>

              <row>
                <entry>unsigned int</entry>

                <entry><literal>Ui</literal></entry>

                <entry>ptrdiff_t</entry>

                <entry><literal>y</literal></entry>
              </row>

              <row>
                <entry>signed long</entry>

                <entry><literal>l</literal></entry>

                <entry>size_t</entry>

                <entry><literal>z</literal></entry>
              </row>

              <row>
                <entry>unsigned long</entry>

                <entry><literal>Ul</literal></entry>

                <entry>wchar_t</entry>

                <entry><literal>w</literal></entry>
              </row>

              <row>
                <entry>signed long long</entry>

                <entry><literal>x</literal></entry>

                <entry>-</entry>

                <entry>-</entry>
              </row>

              <row>
                <entry>unsigned long long</entry>

                <entry><literal>Ux</literal></entry>

                <entry>-</entry>

                <entry>-</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>Named types (classes, enumeration types etc.) can be represented
          by the corresponding identifier or token application:</para>
<programlisting>
<emphasis>type-name</emphasis> :
<emphasis>identifier</emphasis>
<emphasis>token-application</emphasis>
</programlisting>

        <anchor id='composite-qual-types'>
        <para>Composite and qualified types are represented in
          terms of their subtypes as follows:</para>

        <table frame='all' id='subtypes'>
          <title>Subtypes</title>

          <tgroup cols='2'>
            <thead>
              <row>
                <entry>Type</entry>

                <entry>Encoding</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>const</literal> type</entry>

                <entry><literal>C</literal> <emphasis>type</emphasis></entry>
              </row>

              <row>
                <entry><literal>volatile</literal> type</entry>

                <entry><literal>V</literal> <emphasis>type</emphasis></entry>
              </row>

              <row>
                <entry>pointer type</entry>

                <entry><literal>P</literal> <emphasis>type</emphasis></entry>
              </row>

              <row>
                <entry>reference type</entry>

                <entry><literal>R</literal> <emphasis>type</emphasis></entry>
              </row>

              <row>
                <entry>pointer to member type</entry>

                <entry><literal>M</literal> <emphasis>type-name</emphasis>
                <literal>:</literal> <emphasis>type</emphasis></entry>
              </row>

              <row>
                <entry>function type</entry>

                <entry><literal>F</literal> <emphasis>type
                parameter-types</emphasis></entry>
              </row>

              <row>
                <entry>array type</entry>

                <entry><literal>A</literal>
                <emphasis>nat<subscript>opt</subscript></emphasis>
                <literal>:</literal> <emphasis>type</emphasis></entry>
              </row>

              <row>
                <entry>bitfield type</entry>

                <entry><literal>B</literal> <emphasis>nat</emphasis>
                <literal>:</literal> <emphasis>type</emphasis></entry>
              </row>

              <row>
                <entry>template type</entry>

                <entry><literal>t</literal>
                <emphasis>parameter-list<subscript>opt</subscript></emphasis>
                <literal>:</literal> <emphasis>type</emphasis></entry>
              </row>

              <row>
                <entry>promotion type</entry>

                <entry><literal>p</literal> <emphasis>type</emphasis></entry>
              </row>

              <row>
                <entry>arithmetic type</entry>

                <entry><literal>a</literal> <emphasis>type</emphasis>
                <literal>:</literal> <emphasis>type</emphasis></entry>
              </row>

              <row>
                <entry>integer literal type</entry>

                <entry><literal>n</literal>
                <emphasis>lit-base<subscript>opt</subscript>
                lit-suffix<subscript>opt</subscript></emphasis></entry>
              </row>

              <row>
                <entry>weak function prototype (C only)</entry>

                <entry><literal>W</literal> <emphasis>type
                parameter-types</emphasis></entry>
              </row>

              <row>
                <entry>weak parameter type (C only)</entry>

                <entry><literal>q</literal> <emphasis>type</emphasis></entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>Other types can be represented by their textual representation
          using the form <literal>Q</literal> <emphasis>string</emphasis>, or by
          <literal>*</literal>, indicating an unknown type.</para>

        <para>The parameter types for a function type are represented as
          follows:</para>
<programlisting>
<emphasis>parameter-types</emphasis> :
  : <emphasis>exception-spec<subscript>opt</subscript> func-qualifier<subscript>opt</subscript></emphasis> :
  . <emphasis>exception-spec<subscript>opt</subscript> func-qualifier<subscript>opt</subscript></emphasis> :
  . <emphasis>exception-spec<subscript>opt</subscript> func-qualifier<subscript>opt</subscript></emphasis> .
  , <emphasis>type parameter-types</emphasis>
</programlisting>

        <para>where the <literal>::</literal> form indicates that there are no
          further parameters, the <literal>.:</literal> form indicates that the
          parameters are terminated by an ellipsis, and the <literal>..</literal>
          form indicates that no information is available on the further
          parameters (this can only happen with non-prototyped functions in C).
          The function qualifiers are given by:</para>
<programlisting>
<emphasis>func-qualifier</emphasis> :
  C <emphasis>func-qualifier<subscript>opt</subscript></emphasis>
  V <emphasis>func-qualifier<subscript>opt</subscript></emphasis>
</programlisting>

        <para>representing <literal>const</literal> and
          <literal>volatile</literal> member functions. The function exception
          specifier is given by:</para>
<programlisting>
<emphasis>exception-spec</emphasis> :
  ( <emphasis>exception-list<subscript>opt</subscript></emphasis> )

<emphasis>exception-list</emphasis> :
  <emphasis>type</emphasis>
  <emphasis>type</emphasis> , <emphasis>exception-list</emphasis>
</programlisting>

        <para>with an absent exception specifier, as in C++, indicating that
          any exception may be thrown.</para>

        <para>Array and bitfield sizes are represented as follows:</para>
<programlisting>
<emphasis>nat</emphasis> :
  + <emphasis>number</emphasis>
  - <emphasis>number</emphasis>
  <emphasis>identifier</emphasis>
  <emphasis>token-application</emphasis>
  <emphasis>string</emphasis>
</programlisting>

        <para>where a <emphasis>string</emphasis> is used to hold a textual
          representation of complex values.</para>

        <para>Template types are represented by a list of template parameters,
          which will have previously been declared using the
          <literal>XT</literal> identifier key, followed by the underlying type
          expressed in terms of these parameters. The parameters are represented
          as follows:</para>
<programlisting>
<emphasis>parameter-list</emphasis> :
  <emphasis>identifier</emphasis>
  <emphasis>identifier</emphasis> , <emphasis>parameter-list</emphasis>
</programlisting>

        <para>Integer literal types are represented by the value of the literal
          followed by a representation of the literal base and suffix. These are
          given by:</para>
<programlisting>
<emphasis>lit-base</emphasis> :
  O
  X
</programlisting>

        <para>representing octal and hexadecimal literals respectively (decimal
          is the default), and:</para>
<programlisting>
<emphasis>lit-suffix</emphasis> :
  U
  l
  Ul
  x
  Ux
</programlisting>

        <para>representing the <literal>U</literal>, <literal>L</literal>,
          <literal>UL</literal>, <literal>LL</literal> and <literal>ULL</literal>
          suffixes respectively.</para>

        <para>Target dependent integral promotion types are represented using
          <literal>p</literal>, so for example the promotion of <literal>unsigned
          short</literal> is represented as <literal>pUs</literal>. Information
          on the other cases, where the promotion type is known, can be given in
          a command of the form:</para>
<programlisting>
<emphasis>promotion-command</emphasis> :
P <emphasis>type</emphasis> : <emphasis>type</emphasis>
</programlisting>

        <para>Thus the fact that the promotion of <literal>short</literal> is
          <literal>int</literal> would be expressed by the command
          <literal>Ps:i</literal>.</para>
      </sect2>

      <sect2 id='sorts'>
        <title>Sorts</title>

        <para>A <emphasis>sort</emphasis> in the symbol table dump corresponds
          to the sort of a token declared in the
          <link linkend='token-specifcations'><literal>#pragma token</literal>
          syntax</link>. Expression tokens are
          represented as follows:</para>
<programlisting>
<emphasis>expression-sort</emphasis> :
  ZEL <emphasis>type</emphasis>
  ZER <emphasis>type</emphasis>
  ZEC <emphasis>type</emphasis>
  ZN
</programlisting>

        <para>corresponding to <literal>lvalue</literal>,
          <literal>rvalue</literal> and <literal>const</literal>
          <literal>EXP</literal> tokens of the given type, and
          <literal>NAT</literal> or <literal>INTEGER</literal> tokens,
          respectively. Statement tokens are represent by:</para>
<programlisting>
<emphasis>statement-sort</emphasis> :
  ZS
</programlisting>

        <para>Type tokens are represented as follows:</para>
<programlisting>
<emphasis>type-sort</emphasis> :
  ZTO
  ZTI
  ZTF
  ZTA
  ZTP
  ZTS
  ZTU
</programlisting>

        <para>corresponding to <literal>TYPE</literal>,
          <literal>VARIETY</literal>, <literal>FLOAT</literal>,
          <literal>ARITHMETIC</literal>, <literal>SCALAR</literal>,
          <literal>STRUCT</literal> or <literal>CLASS</literal>, and
          <literal>UNION</literal> token respectively. There are corresponding
          <literal>TAG</literal> forms:</para>
<programlisting>
<emphasis>tag-type-sort</emphasis> :
  ZTTS
  ZTTU
</programlisting>

        <para>Member tokens are represented using:</para>
<programlisting>
<emphasis>member-sort</emphasis> :
  ZM <emphasis>type</emphasis> : <emphasis>type-name</emphasis>
</programlisting>

        <para>where the first type gives the member type and the second gives
          the parent structure or union type.</para>

        <para>Procedure tokens can be represented using:</para>
<programlisting>
<emphasis>proc-sort</emphasis> :
  ZPG <emphasis>parameter-list<subscript>opt</subscript></emphasis> ; <emphasis>parameter-list<subscript>opt</subscript></emphasis> : <emphasis>sort</emphasis>
  ZPS <emphasis>parameter-list<subscript>opt</subscript></emphasis> : <emphasis>sort</emphasis>
</programlisting>

        <para>The first form corresponds to the more general form of
          <literal>PROC</literal> token, that expressed using <literal>{ .... |
          .... }</literal>, which has separate lists of bound and program
          parameters. These token parameters will have previously been declared
          using the <literal>XP</literal> identifier key. The second form
          corresponds to the case where the bound and program parameter lists are
          equal, that expressed as a <literal>PROC</literal> token using
          <literal>( .... )</literal>. A more specialised version of this second
          form is a <literal>FUNC</literal> token, which is represented
          as:</para>
<programlisting>
<emphasis>func-sort</emphasis> :
  ZF <emphasis>type</emphasis>
</programlisting>

        <para>As noted above, template parameters are represented by a
          <emphasis>sort</emphasis>. Template type parameters are represented by
          <literal>ZTO</literal>, while template expression parameters are
          represent by <literal>ZEC</literal> (recall that such parameters are
          always constant expressions). The remaining case, template template
          parameters, can be represented as:</para>
<programlisting>
<emphasis>template-sort</emphasis> :
  ZTt <emphasis>parameter-list<subscript>opt</subscript></emphasis> :
</programlisting>

        <para>Finally, the number of parameters in a macro definition is
          represented by a <emphasis>sort</emphasis> of the form:</para>
<programlisting>
<emphasis>macro-sort</emphasis> :
  ZUO
  ZUF <emphasis>number</emphasis>
</programlisting>

        <para>corresponding to a object-like macro and a function-like macro
          with the given number of parameters, respectively.</para>
      </sect2>

      <sect2 id='token-applications'>
        <title>Token applications</title>

        <para>Given an identifier representing a <literal>PROC</literal> token
          or a template, an application of that token or an instance of that
          template can be represented using:</para>
<programlisting>
<emphasis>token-application</emphasis> :
  T <emphasis>identifier</emphasis> , <emphasis>token-argument-list</emphasis> :
</programlisting>

        <para>where the token or template arguments are given by:</para>
<programlisting>
<emphasis>token-argument-list</emphasis> :
  <emphasis>token-argument</emphasis>
  <emphasis>token-argument</emphasis> , <emphasis>token-argument-list</emphasis>
</programlisting>

        <para>Note that the case where there are no arguments is generally just
          represented by <emphasis>identifier</emphasis>; this case is specified
          separately in the rest of the grammar.</para>

        <para>A <emphasis>token-argument</emphasis> can represent a value of
          any of the sorts listed above: expressions, integer constants,
          statements, types, members, functions and templates. These are given
          respectively by:</para>
<programlisting>
<emphasis>token-argument</emphasis> :
  E <emphasis>expression</emphasis>
  N <emphasis>nat</emphasis>
  S <emphasis>statement</emphasis>
  T <emphasis>type</emphasis>
  M <emphasis>member</emphasis>
  F <emphasis>identifier</emphasis>
  C <emphasis>identifier</emphasis>
</programlisting>

        <para>where:</para>
<programlisting>
<emphasis>expression</emphasis> :
  <emphasis>nat</emphasis>

<emphasis>statement</emphasis> :
  <emphasis>expression</emphasis>

<emphasis>member</emphasis> :
  <emphasis>identifier</emphasis>
  <emphasis>string</emphasis>
</programlisting>
      </sect2>

      <sect2 id='errors'>
        <title>Errors</title>

        <para>Each error in the C++ <link linkend='error-catalogue'>error
          catalogue</link> is
          represented by a number. These numbers happen to correspond to the
          position of the error within the catalogue, but in general this need
          not be the case. The first use of each error introduces the error
          number by associating it with a <emphasis>string</emphasis> giving the
          error name. This has the form
          <literal>cpp.</literal><emphasis>error</emphasis> where
          <emphasis>error</emphasis> gives an error name from the C++
          (<literal>cpp</literal>) error catalogue. Thus:</para>
<programlisting>
<emphasis>error-name</emphasis> :
  <emphasis>number</emphasis> = <emphasis>string</emphasis>
  <emphasis>number</emphasis>
</programlisting>

        <para>Each error message written to the symbol table dump has the
          form:</para>
<programlisting>
<emphasis>error-command</emphasis> :
  ES <emphasis>location error-info</emphasis>
  EW <emphasis>location error-info</emphasis>
  EI <emphasis>location error-info</emphasis>
  EF <emphasis>location error-info</emphasis>
  EC <emphasis>error-info</emphasis>
  EA <emphasis>error-argument</emphasis>
</programlisting>

        <para>denoting constraint errors, warnings, internal errors, fatal
          errors, continuation errors and error arguments respectively. Note that
          an error message may consist of several components; the initial error
          plus a number of continuation errors. Each error message may also have
          a number of error argument associated with it. This error information
          is given by:</para>
<programlisting>
<emphasis>error-info</emphasis> :
  <emphasis>error-name number number</emphasis>
</programlisting>

        <para>where the first <emphasis>number</emphasis> gives the number of
          error arguments which should be read, and the second is nonzero to
          indicate that a continuation error should be read.</para>

        <para>Each error argument has one of the forms:</para>
<programlisting>
<emphasis>error-argument</emphasis> :
  B <emphasis>base-number</emphasis>
  C <emphasis>scope-identifier</emphasis>
  E <emphasis>expression</emphasis>
  H <emphasis>identifier-name</emphasis>
  I <emphasis>identifier</emphasis>
  L <emphasis>location</emphasis>
  N <emphasis>nat</emphasis>
  S <emphasis>string</emphasis>
  T <emphasis>type</emphasis>
  V <emphasis>number</emphasis>
  V - <emphasis>number</emphasis>
</programlisting>

        <para>corresponding to the various syntactic categories described
          above. Note that a <emphasis>location</emphasis> error argument, while
          expressed relative to the <link linkend='crt-loc'>current file
          location</link>, does not change this location.</para>
      </sect2>

      <sect2 id='file-inclusions'>
        <title>File inclusions</title>

        <para>It is possible to include information on header files within the
          symbol table dump. Firstly a number is associated with each directory
          on the <literal>#include</literal> search path:</para>
<programlisting>
<emphasis>path-command</emphasis> :
  FD <emphasis>number</emphasis> = <emphasis>string string<subscript>opt</subscript></emphasis>
</programlisting>

        <para>The first <emphasis>string</emphasis> gives the directory
          pathname; the second, if present, gives the associated directory name
          as specified in the <link linkend='tcpplus-bigN-option'><literal>-N
          </literal> command-line option</link>.</para>

        <para>Now the start and end of each file are marked using:</para>
<programlisting>
<emphasis>file-command</emphasis> :
  FS <emphasis>location directory</emphasis>
  FE <emphasis>location</emphasis>
</programlisting>

        <para>where <emphasis>directory</emphasis> gives the number of the
          directory in the search path where the file was found, or
          <literal>*</literal> if the file was found by other means. It is worth
          noting that if, for example, a function definition is the last item in
          a file, the <literal>FE</literal> command will appear in the symbol
          table dump before the <literal>QFE</literal> command for the end of the
          function definition. This is because lexical analysis, where the end of
          file is detected, takes place before parsing, where the end of function
          is detected.</para>

        <para>A <literal>#include</literal> directive, whether explicit or
          implicit, can be represented using:</para>
<programlisting>
<emphasis>include-command</emphasis> :
  FIA <emphasis>location string</emphasis>
  FIQ <emphasis>location string</emphasis>
  FIN <emphasis>location string</emphasis>
  FIS <emphasis>location string</emphasis>
  FIE <emphasis>location string</emphasis>
  FIR <emphasis>location</emphasis>
</programlisting>

        <para>the first three corresponding to header names of the forms
          <literal>&lt;....&gt;</literal>, <literal>&quot;....&quot;</literal>
          and <literal>[....]</literal> respectively, the next two corresponding
          to <link linkend='tcpplus-f-option'>start-up</link> and
          <link linkend='tcpplus-e-option'>end-up</link>
          files, and the final form being used to resume the original file after
          the <literal>#include</literal> directive has been processed.</para>
      </sect2>

      <sect2 id='string-literals-b'>
        <title>String literals</title>

        <para>It is possible to dump information on string literals to the
          symbol table dump file using the commands:</para>
<programlisting>
<emphasis>string-command</emphasis> :
  A <emphasis>location string</emphasis>
  AC <emphasis>location string</emphasis>
  AL <emphasis>location string</emphasis>
  ACL <emphasis>location string</emphasis>
</programlisting>

        <para>representing string literals, character literals, wide string
          literals and wide character literals respectively. The given
          <emphasis>string</emphasis> gives the string text.</para>
      </sect2>
    </sect1>

    <sect1 id='intermodule-analysis'>
      <title>Intermodule analysis</title>

      <warning>
        <para>
            <blockquote>
              <para>The C++ spec linking routines have not yet been completely
              implemented, and so are disabled in the current version of the C++
              producer.</para>
          </blockquote>
        </para>
      </warning>

      <anchor id='cpp-spec-file'>
      <para>A C++ spec file is a dump of the C++ producer's
        <link linkend='primitive-types'> internal representation</link> of a
        translation unit. Such files can be written
        to, and read from, disk to perform such operations as intermodule
        analysis.</para>

      <para>Note that the format of a C++ spec file is specific to the C++
        producer and may change between releases to reflect modifications in the
        internal type system. The C producer has a similar dump format, called a
        C spec file, however the two are incompatible. If intermodule analysis
        between C and C++ source files is required then the
        <link linkend='symbol-table-dump'>symbol table dump</link> format
        should be used.</para>
    </sect1>

    <sect1 id='implementation-details'>
      <title>Implementation Details</title>

      <para>This section describes various of the implementation details of the
        C++ producer TDF output. In particular it describes the standard TDF
        tokens used to represent the target dependent aspects of the language and
        to provide links into the run-time system. Many of these tokens are
        common to the C and C++ producers. Those which are unique to the C++
        producer have names of the form <literal>~cpp.*</literal>. Note that the
        description is in terms of TDF tokens, not the internal tokens introduced
        by the <link linkend='token-syntax'><literal>#pragma token</literal>
        syntax</link>.</para>

      <para>There are two levels of implementation in the run-time system. The
        actual interface between the producer and the run-time system is given by
        the standard tokens. The provided implementation defines these tokens in
        a way appropriate to itself. An alternative implementation would have to
        define the tokens differently. It is intended that the standard tokens
        are sufficiently generic to allow a variety of implementations to hook
        into the producer output in the manner they require.</para>

      <sect2 id='arithmetic-types'>
        <title>Arithmetic types</title>

        <para>The representations of the basic arithmetic types are target
          dependent, so, for example, an <literal>int</literal> may contain 16,
          32, 64 or some other number of bits. Thus it is necessary to introduce
          a token to stand for each of the built-in arithmetic types (including
          the <link linkend='extended-integral'><literal>long long</literal>
          types</link>). Each
          integral type is represented by a <literal>VARIETY</literal> token as
          follows:</para>

        <table frame='all' id='variety-tokens'>
          <title>Variety Tokens</title>

          <tgroup cols='3'>
            <thead>
              <row>
                <entry>Type</entry>

                <entry>Token</entry>

                <entry>Encoding</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>char</entry>

                <entry>~char</entry>

                <entry>0</entry>
              </row>

              <row>
                <entry>signed char</entry>

                <entry>~signed_char</entry>

                <entry>0 | 4 = 4</entry>
              </row>

              <row>
                <entry>unsigned char</entry>

                <entry>~unsigned_char</entry>

                <entry>0 | 8 = 8</entry>
              </row>

              <row>
                <entry>signed short</entry>

                <entry>~signed_short</entry>

                <entry>1 | 4 = 5</entry>
              </row>

              <row>
                <entry>unsigned short</entry>

                <entry>~unsigned_short</entry>

                <entry>1 | 8 = 9</entry>
              </row>

              <row>
                <entry>signed int</entry>

                <entry>~signed_int</entry>

                <entry>2 | 4 = 6</entry>
              </row>

              <row>
                <entry>unsigned int</entry>

                <entry>~unsigned_int</entry>

                <entry>2 | 8 = 10</entry>
              </row>

              <row>
                <entry>signed long</entry>

                <entry>~signed_long</entry>

                <entry>3 | 4 = 7</entry>
              </row>

              <row>
                <entry>unsigned long</entry>

                <entry>~unsigned_long</entry>

                <entry>3 | 8 = 11</entry>
              </row>

              <row>
                <entry>signed long long</entry>

                <entry>~signed_longlong</entry>

                <entry>3 | 4 | 16 = 23</entry>
              </row>

              <row>
                <entry>unsigned long long</entry>

                <entry>~unsigned_longlong</entry>

                <entry>3 | 8 | 16 = 27</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>Similarly each floating point type is represent by a
          <literal>FLOATING_VARIETY</literal> token:</para>

        <table frame='all' id='floating-var-tokens'>
          <title>Floating Variety Tokens</title>

          <tgroup cols='2'>
            <thead>
              <row>
                <entry>Type</entry>

                <entry>Token</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>float</entry>

                <entry>~float</entry>
              </row>

              <row>
                <entry>double</entry>

                <entry>~double</entry>
              </row>

              <row>
                <entry>long double</entry>

                <entry>~long_double</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>Each integral type also has an encoding as a
          <literal>SIGNED_NAT</literal> as shown above. This number is a bit
          pattern built up from the following values:</para>

        <table frame='all' id='bit-pattern'>
          <title>Signed Bit Pattern</title>

          <tgroup cols='2'>
            <thead>
              <row>
                <entry>Type</entry>

                <entry>Encoding</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>char</entry>

                <entry>0</entry>
              </row>

              <row>
                <entry>short</entry>

                <entry>1</entry>
              </row>

              <row>
                <entry>int</entry>

                <entry>2</entry>
              </row>

              <row>
                <entry>long</entry>

                <entry>3</entry>
              </row>

              <row>
                <entry>signed</entry>

                <entry>4</entry>
              </row>

              <row>
                <entry>unsigned</entry>

                <entry>8</entry>
              </row>

              <row>
                <entry>long long</entry>

                <entry>16</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>Any target dependent integral type can be represented by a
          <literal>SIGNED_NAT</literal> token using this encoding. This
          representation, rather than one based on <literal>VARIETY</literal>s,
          is used for ease of manipulation. The token:</para>
<programlisting>
~convert : ( SIGNED_NAT ) -&gt; VARIETY
</programlisting>

        <para>gives the mapping from the integral encoding to the representing
          variety. For example, it will map <literal>6</literal> to
          <literal>~signed_int</literal>.</para>

        <para>The token:</para>
<programlisting>
~promote : ( SIGNED_NAT ) -&gt; SIGNED_NAT
</programlisting>

        <para>describes how to form the promotion of an integral type according
          to the ISO C/C++ value preserving rules, and is used by the producer to
          represent target dependent promotion types. For example, the promotion
          of <literal>unsigned short</literal> may be <literal>int</literal> or
          <literal>unsigned int</literal> depending on the representation of
          these types; that is to say, <literal>~promote ( 9 )</literal> will be
          <literal>6</literal> on some machines and <literal>10</literal> on
          others. Although <literal>~promote</literal> is used by default, a
          program may specify another token with the same sort signature to be
          used in its place by means of the directive:</para>
<programlisting>
#pragma TenDRA compute promote <emphasis>identifier</emphasis>
</programlisting>

        <para>For example, a standard token <literal>~sign_promote</literal> is
          defined which gives the older C sign preserving promotion rules. In
          addition, the promotion of an individual type can be specified
          using:</para>
<programlisting>
#pragma TenDRA promoted <emphasis>type-id</emphasis> : <emphasis>promoted-type-id</emphasis>
</programlisting>

        <para>The token:</para>
<programlisting>
~arith_type : ( SIGNED_NAT, SIGNED_NAT ) -&gt; SIGNED_NAT
</programlisting>

        <para>similarly describes how to form the usual arithmetic result type
          from two promoted integral operand types. For example, the arithmetic
          type of <literal>long</literal> and <literal>unsigned int</literal> may
          be <literal>long</literal> or <literal>unsigned long</literal>
          depending on the representation of these types; that is to say,
          <literal>~arith_type ( 7, 10 )</literal> will be <literal>7</literal>
          on some machines and <literal>11</literal> on others.</para>

        <para>Any tokenised type declared using:</para>
<programlisting>
#pragma token VARIETY v # tv
</programlisting>

        <para>will be represented by a <literal>SIGNED_NAT</literal> token with
          external name <literal>tv</literal> corresponding to the encoding of
          <literal>v</literal>. Special cases of this are the implementation
          dependent integral types which arise naturally within the language. The
          external token names for these types are given below:</para>

        <table frame='all' id='external-tokens'>
          <title>External Tokens</title>

          <tgroup cols='2'>
            <thead>
              <row>
                <entry>Type</entry>

                <entry>Token</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>bool</entry>

                <entry>~cpp.bool</entry>
              </row>

              <row>
                <entry>ptrdiff_t</entry>

                <entry>ptrdiff_t</entry>
              </row>

              <row>
                <entry>size_t</entry>

                <entry>size_t</entry>
              </row>

              <row>
                <entry>wchar_t</entry>

                <entry>wchar_t</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>So, for example, a <literal>sizeof</literal> expression has shape
          <literal>~convert ( size_t )</literal>. The token
          <literal>~cpp.bool</literal> is defined in the default implementation,
          but the other tokens are defined according to their definitions on the
          target machine in the normal API library building mechanism.</para>
      </sect2>

      <sect2 id='integer-literal-types'>
        <title>Integer literal types</title>

        <para>The <link linkend='integer-literals'>type of an integer literal
          </link>is defined in
          terms of the first in a list of possible integral types. The first type
          in which the literal value can be represented gives the type of the
          literal. For small literals it is possible to work out the type
          exactly, however for larger literals the result is target dependent.
          For example, the literal <literal>50000</literal> will have type
          <literal>int</literal> on machines in which <literal>50000</literal>
          fits into an <literal>int</literal>, and <literal>long</literal>
          otherwise. This target dependent mapping is given by a series of tokens
          of the form:</para>
<programlisting>
~lit_* : ( SIGNED_NAT ) -&gt; SIGNED_NAT
</programlisting>

        <para>which map a literal value to the representation of an integral
          type. The token used depends on the list of possible types, which in
          turn depends on the base used to represent the literal and the integer
          suffix used, as given in the following table:</para>

        <table frame='all' id='int-literal-types'>
          <title>Integer Literal Types</title>

          <tgroup cols='4'>
            <thead>
              <row>
                <entry>Base</entry>

                <entry>Suffix</entry>

                <entry>Token</entry>

                <entry>Types</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>decimal</entry>

                <entry>none</entry>

                <entry>~lit_int</entry>

                <entry>int, long, unsigned long</entry>
              </row>

              <row>
                <entry>octal</entry>

                <entry>none</entry>

                <entry>~lit_hex</entry>

                <entry>int, unsigned int, long, unsigned long</entry>
              </row>

              <row>
                <entry>hexadecimal</entry>

                <entry>none</entry>

                <entry>~lit_hex</entry>

                <entry>int, unsigned int, long, unsigned long</entry>
              </row>

              <row>
                <entry>any</entry>

                <entry>U</entry>

                <entry>~lit_unsigned</entry>

                <entry>unsigned int, unsigned long</entry>
              </row>

              <row>
                <entry>any</entry>

                <entry>L</entry>

                <entry>~lit_long</entry>

                <entry>long, unsigned long</entry>
              </row>

              <row>
                <entry>any</entry>

                <entry>UL</entry>

                <entry>~lit_ulong</entry>

                <entry>unsigned long</entry>
              </row>

              <row>
                <entry>any</entry>

                <entry>LL</entry>

                <entry>~lit_longlong</entry>

                <entry>long long, unsigned long long</entry>
              </row>

              <row>
                <entry>any</entry>

                <entry>ULL</entry>

                <entry>~lit_ulonglong</entry>

                <entry>unsigned long long</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>Thus, for example, the shape of the integer literal 50000
          is:</para>
<programlisting>
~convert ( ~lit_int ( 50000 ) )
</programlisting>
      </sect2>

      <sect2 id='bitfield-types-a'>
        <title>Bitfield types</title>

        <para>The sign of a plain bitfield type, declared without using
          <literal>signed</literal> or <literal>unsigned</literal>, is left
          unspecified in C and C++. The token:</para>
<programlisting>
~cpp.bitf_sign : ( SIGNED_NAT ) -&gt; BOOL
</programlisting>

        <para>is used to give a mapping from integral types to the sign of a
          plain bitfield of that type, in a form suitable for use in the TDF
          <literal>bfvar_bits</literal> construct.</para>

        <note>
          <para><literal>~cpp.bitf_sign</literal> should have been a standard C
            token but was omitted.</para>
        </note>
      </sect2>

      <sect2 id='generic-pointers'>
        <title>Generic pointers</title>

        <para>TDF has no concept of a generic pointer type, so tokens are used
          to defer the representation of <literal>void *</literal> and the basic
          operations on it to the target machine. The fundamental token
          is:</para>
<programlisting>
~ptr_void : () -&gt; SHAPE
</programlisting>

        <para>which gives the representation of <literal>void *</literal>. This
          shape will be denoted by <literal>pv</literal> in the description of
          the following tokens. It is not guaranteed that <literal>pv</literal>
          is a TDF <literal>pointer</literal> shape, although normally it will be
          implemented as a pointer to a suitable alignment.</para>

        <para>The token:</para>
<programlisting>
~null_pv : () -&gt; EXP pv
</programlisting>

        <para>gives the value of a null pointer of type <literal>void
          *</literal>. Generic pointers can also be converted to and from other
          pointers. These conversions are represented by the tokens:</para>
<programlisting>
~to_ptr_void : ( ALIGNMENT a, EXP POINTER a ) -&gt; EXP pv
~from_ptr_void : ( ALIGNMENT a, EXP pv ) -&gt; EXP POINTER a
</programlisting>

        <para>where the given alignment describes the destination or source
          pointer type. Finally a generic pointer may be tested against the null
          pointer or two generic pointers may be compared. These operations are
          represented by the tokens:</para>
<programlisting>
~pv_test : ( EXP pv, LABEL, NTEST ) -&gt; EXP TOP
~cpp.pv_compare : ( EXP pv, EXP pv, LABEL, NTEST ) -&gt; EXP TOP
</programlisting>

        <para>where the given <literal>NTEST</literal> gives the comparison to
          be applied and the given label gives the destination to jump to if the
          test fails. (Note that <literal>~cpp.pv_compare</literal> should have
          been a standard C token but was omitted.)</para>
      </sect2>

      <sect2 id='undefined-conversions'>
        <title>Undefined conversions</title>

        <para>Several conversions in C and C++ can only be represented by
          undefined TDF. For example, converting a pointer to an integer can only
          be represented in TDF by forming a union of the pointer and integer
          shapes, putting the pointer into the union and pulling the integer out.
          Such conversions are tokenised. Undefined conversions not mentioned
          below may be performed by combining those given with the standard,
          well-defined, conversions.</para>

        <para>The token:</para>
<programlisting>
~ptr_to_ptr : ( ALIGNMENT a, ALIGNMENT b, EXP POINTER a ) -&gt; EXP POINTER b
</programlisting>

        <para>is used to convert between two incompatible pointer types. The
          first alignment describes the source pointer shape while the second
          describes the destination pointer shape. Note that if the destination
          alignment is greater than the source alignment then the source pointer
          can be used in most TDF constructs in place of the destination pointer,
          so the use of <literal>~ptr_to_ptr</literal> can be omitted (the
          exception is <literal>pointer_test</literal> which requires equal
          alignments). Base class pointer conversions are examples of these
          well-behaved, alignment preserving conversions.</para>

        <para>The tokens:</para>
<programlisting>
~f_to_pv : ( EXP PROC ) -&gt; EXP pv
~pv_to_f : ( EXP pv ) -&gt; EXP PROC
</programlisting>

        <para>are used to convert pointers to functions to and from
          <literal>void *</literal></para>

        <note>
          <para>these conversions are not allowed in ISO C/C++ but are in older
            dialects</para>
        </note>

        <para>The tokens:</para>
<programlisting>
~i_to_p : ( VARIETY v, ALIGNMENT a, EXP INTEGER v ) -&gt; EXP POINTER a
~p_to_i : ( ALIGNMENT a, VARIETY v, EXP POINTER a ) -&gt; EXP INTEGER v
~i_to_pv : ( VARIETY v, EXP INTEGER v ) -&gt; EXP pv
~pv_to_i : ( VARIETY v, EXP pv ) -&gt; EXP INTEGER v
</programlisting>

        <para>are used to convert integers to and from <literal>void
          *</literal> and other pointers.</para>
      </sect2>

      <sect2 id='integer-division'>
        <title>Integer division</title>

        <para>The precise form of the integer division and remainder operations
          in C and C++ is left unspecified with respect to the sign of the result
          if either operand is negative. The tokens:</para>
<programlisting>
~div : ( EXP INTEGER v, EXP INTEGER v ) -&gt; EXP INTEGER v
~rem : ( EXP INTEGER v, EXP INTEGER v ) -&gt; EXP INTEGER v
</programlisting>

        <para>are used to represent integer division and remainder. They will
          map onto one of the pairs of TDF constructs, <literal>div0</literal>
          and <literal>rem0</literal>, <literal>div1</literal> and
          <literal>rem1</literal> or <literal>div2</literal> and
          <literal>rem2</literal>.</para>
      </sect2>

      <sect2 id='calling-conventions'>
        <title>Calling conventions</title>

        <para>The function calling conventions used by the C++ producer are
          essentially the same as those used by the C producer with one
          exception. That is to say, all types except arrays are passed by value
          (note that individual installers may modify these conventions to
          conform to their own ABIs).</para>

        <para>The exception concerns classes with a non-trivial constructor,
          destructor or assignment operator. These classes are passed as function
          arguments by taking a reference to a copy of the object (although it is
          often possible to eliminate the copy and pass a reference to the object
          directly). They are passed as function return values by adding an extra
          parameter to the start of the function parameters giving a reference to
          a location into which the return value should be copied.</para>

        <sect3 id='member-functions'>
          <title>Member functions</title>

          <para>Non-static member functions are implemented in the obvious
            fashion, by passing a pointer to the object the method is being
            applied to as the first argument (or the second argument if the
            method has an extra argument for its return value).</para>
        </sect3>

        <sect3 id='ellipsis-functions'>
          <title>Ellipsis functions</title>

          <para>Calls to functions declared with ellipses are via the
            <literal>apply_proc</literal> TDF construct, with all the arguments
            being treated as non-variable. However the definition of such a
            function uses the <literal>make_proc</literal> construct with a
            variable parameter. This parameter can be referred to within the
            program using the <link linkend='ellipsis-functions'><literal>...
            </literal> expression</link>.  The type of this expression is given
            by the built-in token:</para>
<programlisting>
~__va_t : () -&gt; SHAPE
</programlisting>

          <para>The <literal>va_start</literal> macro declared in the
            <literal>&lt;stdarg.h&gt;</literal> header then describes how the
            variable parameter (expressed as <literal>...</literal>) can be
            converted to an expression of type <literal>va_list</literal>
            suitable for use in the <literal>va_arg</literal> macro.</para>

          <note>
            <para>The variable parameter is in effect only being used to
              determine where the first optional parameter is defined. The
              assumption is that all such parameters are located contiguously on
              the stack, however the fact that calls to such functions do not use
              the variable parameter mechanism means that this is not
              automatically the case. Strictly speaking this means that the
              implementation of ellipsis functions uses undefined behaviour in
              TDF, however given the non-type-safe function calling rules in C
              this is unavoidable and installers need to make provision for such
              calls (by dumping any parameters from registers to the stack if
              necessary). Given the theoretically type-safe nature of C++ it
              would be possible to avoid such undefined behaviour, but the need
              for C-compatible calling conventions prevents this.</para>
          </note>
        </sect3>
      </sect2>

      <sect2 id='pointers-to-data-mem'>
        <title>Pointers to data members</title>

        <para>The representation of, and operations on, pointers to data
          members are represented by tokens to allow for a variety of
          implementations. It is assumed that all pointers to data members (as
          opposed to pointers to function members) are represented by the same
          shape:</para>
<programlisting>
~cpp.pm.type : () -&gt; SHAPE
</programlisting>

        <para>This shape will be denoted by <literal>pm</literal> in the
          description of the following tokens.</para>

        <para>There are two basic methods of constructing a pointer to a data
          member. The first is to take the address of a data member of a class. A
          data member is represented in TDF by an expression which gives the
          offset of the member from the start of its enclosing
          <literal>compound</literal> shape (note that it is not possible to take
          the address of a member of a virtual base). The mapping from this
          offset to a pointer to a data member is given by:</para>
<programlisting>
~cpp.pm.make : ( EXP OFFSET ) -&gt; EXP pm
</programlisting>

        <para>The second way of constructing a pointer to a data member is to
          use a null pointer to member:</para>
<programlisting>
~cpp.pm.null : () -&gt; EXP pm
</programlisting>

        <para>The other fundamental operation on a pointer to data member is to
          turn it back into an offset expression which can be added to a pointer
          to a class to access a member of that class in a <literal>.*</literal>
          or <literal>-&gt;*</literal> operation. This is done by the
          token:</para>
<programlisting>
~cpp.pm.offset : ( EXP pm, ALIGNMENT a ) -&gt; EXP OFFSET ( a, a )
</programlisting>

        <note>
          <para>It is necessary to specify an alignment in order to describe
            the shape of the result. The value of this token is undefined if the
            given expression is a null pointer to data member.</para>
        </note>

        <para>A pointer to a data member of a non-virtual base class can be
          converted to a pointer to a data member of a derived class. The reverse
          conversion is also possible using <literal>static_cast</literal>. If
          the base is a <link linkend='primary-base-class'>primary base class
          </link>then these conversions
          are trivial and have no effect. Otherwise null pointers to data members
          are converted to null pointers to data members, and the non-null cases
          are handled by the tokens:</para>
<programlisting>
~cpp.pm.cast : ( EXP pm, EXP OFFSET ) -&gt; EXP pm
~cpp.pm.uncast : ( EXP pm, EXP OFFSET ) -&gt; EXP pm
</programlisting>

        <para>where the given offset is the offset of the base class within the
          derived class. It is also possible to convert between any two pointers
          to data members using <literal>reinterpret_cast</literal>. This
          conversion is implied by the equality of representation between any two
          pointers to data members and has no effect.</para>

        <para>The only remaining operations on pointer to data members are to
          test one against the null pointer to data member and to compare two
          pointer to data members. These are represented by the tokens:</para>
<programlisting>
~cpp.pm.test : ( EXP pm, LABEL, NTEST ) -&gt; EXP TOP
~cpp.pm.compare : ( EXP pm, EXP pm, LABEL, NTEST ) -&gt; EXP TOP
</programlisting>

        <para>where the given <literal>NTEST</literal> gives the comparison to
          be applied and the given label gives the destination to jump to if the
          test fails.</para>

        <para>In the default implementation, pointers to data members are
          implemented as <literal>int</literal>. The null pointer to member is
          represented by 0 and the address of a class member is represented by 1
          plus the offset of the member (in bytes). Casting to and from a derived
          class then correspond to adding or subtracting the base class offset
          (in bytes), and pointer to member comparisons correspond to integer
          comparisons.</para>
      </sect2>

      <sect2 id='pointers-to-funct-mem'>
        <title>Pointers to function members</title>

        <para>As with pointers to data members, pointers to function members
          and the operations on them are represented by tokens to allow for a
          range of implementations. All pointers to function members are
          represented by the same shape:</para>
<programlisting>
~cpp.pmf.type : () -&gt; SHAPE
</programlisting>

        <para>This shape will be denoted by <literal>pmf</literal> in the
          description of the following tokens. Many of the tokens take an
          expression which has a shape which is a pointer to the alignment of
          <literal>pmf</literal>. This will be denoted by
          <literal>ppmf</literal>.</para>

        <para>There are two basic methods for constructing a pointer to a
          function member. The first is to take the address of a non-static
          member function of a class. There are two cases, depending on whether
          or not the member function is virtual. The non-virtual case is given by
          the token:</para>
<programlisting>
~cpp.pmf.make : ( EXP PROC, EXP OFFSET, EXP OFFSET ) -&gt; EXP pmf
</programlisting>

        <para>where the first argument is the address of the corresponding
          function, the second argument gives any base class offset which is to
          be added when calling this function (to deal with inherited member
          functions), and the third argument is a zero offset.</para>

        <para>For virtual functions, a pointer to function member of the form
          above is entered in the <link linkend='virt-funct-tables'>virtual
          function table</link> for the
          corresponding class. The actual pointer to the virtual function member
          then gives a reference into the virtual function table as
          follows:</para>
<programlisting>
~cpp.pmf.vmake : ( SIGNED_NAT, EXP OFFSET, EXP, EXP ) -&gt; EXP pmf
</programlisting>

        <para>where the first argument gives the index of the function within
          the virtual function table, the second argument gives the offset of the
          <emphasis>vptr</emphasis> field within the class, and the third and
          fourth arguments are zero offsets.</para>

        <para>The second way of constructing a pointer to a function member is
          to use a null pointer to function member:</para>
<programlisting>
~cpp.pmf.null : () -&gt; EXP pmf
~cpp.pmf.null2 : () -&gt; EXP pmf
</programlisting>

        <para>For technical reasons there are two versions of this token,
          although they have the same value. The first token is used in static
          initialisers; the second token is used in other expressions.</para>

        <para>The cast operations on pointers to function members are more
          complex than those on pointers to data members. The value to be cast is
          copied into a temporary and one of the tokens:</para>
<programlisting>
~cpp.pmf.cast : ( EXP ppmf, EXP OFFSET, EXP, EXP OFFSET ) -&gt; EXP TOP
~cpp.pmf.uncast : ( EXP ppmf, EXP OFFSET, EXP, EXP OFFSET ) -&gt; EXP TOP
</programlisting>

        <para>is applied to modify the value of the temporary according to the
          given cast. The first argument gives the address of the temporary, the
          second gives the base class offset to be added or subtracted, the third
          gives the number to be added or subtracted to convert virtual function
          indexes for the base class into virtual function indexes for the
          derived class, and the fourth gives the offset of the
          <emphasis>vptr</emphasis> field within the class. Again, the ability to
          use <literal>reinterpret_cast</literal> to convert between any two
          pointer to function member types arises because of the uniform
          representation of these types.</para>

        <para>As with pointers to data members, there are tokens implementing
          comparisons on pointers to function members:</para>
<programlisting>
~cpp.pmf.test : ( EXP ppmf, LABEL, NTEST ) -&gt; EXP TOP
~cpp.pmf.compare : ( EXP ppmf, EXP ppmf, LABEL, NTEST ) -&gt; EXP TOP
</programlisting>

        <note>
          <para>The arguments are passed by reference.</para>
        </note>

        <para>The most important, and most complex, operation is calling a
          function through a pointer to function member. The first step is to
          copy the pointer to function member into a temporary. The token:</para>
<programlisting>
~cpp.pmf.virt : ( EXP ppmf, EXP, ALIGNMENT ) -&gt; EXP TOP
</programlisting>

        <para>is then applied to the temporary to convert a pointer to a
          virtual function member to a normal pointer to function member by
          looking it up in the corresponding virtual function table. The first
          argument gives the address of the temporary, the second gives the
          object to which the function is to be applied, and the third gives the
          alignment of the corresponding class. Now the base class conversion to
          be applied to the object can be determined by applying the
          token:</para>
<programlisting>
~cpp.pmf.delta : ( ALIGNMENT a, EXP ppmf ) -&gt; EXP OFFSET ( a, a )
</programlisting>

        <para>to the temporary to find the offset to be added. Finally the
          function to be called can be extracted from the temporary using the
          token:</para>
<programlisting>
~cpp.pmf.func : ( EXP ppmf ) -&gt; EXP PROC
</programlisting>

        <para>The function call then procedes as normal.</para>

        <para>The default implementation is that described in the ARM, where
          each pointer to function member is represented in the form:</para>
<programlisting>
struct PTR_MEM_FUNC {
  short delta ;
  short index ;
  union {
  void ( *func ) () ;
  short off ;
  } u ;
} ;
</programlisting>

        <para>The <literal>delta</literal> field gives the base class offset
          (in bytes) to be added before applying the function. The
          <literal>index</literal> field is 0 for null pointers, -1 for
          non-virtual function pointers and the index into the virtual function
          table for virtual function pointers (as described below these indexes
          start from 1). For non-virtual function pointers the function itself is
          given by the <literal>u.func</literal> field. For virtual function
          pointers the offset of the <emphasis>vptr</emphasis> field within the
          class is given by the <literal>u.off</literal> field.</para>
      </sect2>

      <sect2 id='class-layout'>
        <title>Class layout</title>

        <para>Consider a class with no base classes:</para>
<programlisting>
class A {
  // A's members
} ;
</programlisting>

        <para>Each object of class <emphasis>A</emphasis> needs its own copy of
          the non-static data members of <emphasis>A</emphasis> and, for
          polymorphic types, a means of referencing the virtual function table
          and run-time type information for <emphasis>A</emphasis>. This is
          accomplished using a layout of the form:</para>

        <figure id="class-layout1c">
          <title>Class Layout</title>

          <mediaobject>
            <imageobject><imagedata fileref="class" format="PNG"></imageobject>
          </mediaobject>
        </figure>

        <para>where the <emphasis>A</emphasis> component consists of the
          non-static data members and <emphasis>vptr A</emphasis> is a pointer to
          the virtual function table for <emphasis>A</emphasis>. For
          non-polymorphic classes the <emphasis>vptr A</emphasis> field is
          omitted; otherwise space for <emphasis>vptr A</emphasis> needs to be
          allocated within the class and the pointer needs to be initialised in
          each constructor for <emphasis>A</emphasis>. The precise layout of the
          <link linkend='virt-funct-tables'>virtual function table</link> and
          the <link linkend='run-time-type-info'>run-time type
          information</link> is given below.</para>

        <para>Two alternative ways of laying out the non-static data members
          within the class are implemented. The first, which is default, gives
          them in the order in which they are declared in the class definition.
          The second lays out the <literal>public</literal>, the
          <literal>protected</literal>, and the <literal>private</literal>
          members in three distinct sections, the members within each section
          being given in the order in which they are declared. The latter can be
          enabled using the <literal>-jo</literal> command-line option.</para>

        <para>The offset of each member within the class (including
          <emphasis>vptr A</emphasis>) can be calculated in terms of the offset
          of the previous member. The first member has offset zero. The offset of
          any other member is given by the offset of the previous member plus the
          size of the previous member, rounded up to the alignment of the current
          member. The overall size of the class is given by the offset of the
          last member plus the size of the last member, rounded up using the
          token:</para>
<programlisting>
~comp_off : ( EXP OFFSET ) -&gt; EXP OFFSET
</programlisting>

        <para>which allows for any target dependent padding at the end of the
          class. The shape of the class is then a <literal>compound</literal>
          shape with this offset.</para>

        <para>Classes with no members need to be treated slightly differently.
          The shape of such a class is given by the token:</para>
<programlisting>
~cpp.empty.shape : () -&gt; SHAPE
</programlisting>

        <para>(recall that an empty class still has a nonzero size). The
          token:</para>
<programlisting>
~cpp.empty.offset : () -&gt; EXP OFFSET
</programlisting>

        <para>is used to represent the offset required for an empty class when
          it is used as a base class. This may be a zero offset.</para>

        <para>Bitfield members provide a slight complication to the picture
          above. The offset of a bitfield is additionally padded using the
          token:</para>
<programlisting>
~pad : ( EXP OFFSET, SHAPE, SHAPE ) -&gt; EXP OFFSET
</programlisting>

        <para>where the two shapes give the type underlying the bitfield and
          the bitfield itself.</para>

        <para>The layout of unions is similar to that of classes except that
          all members have zero offset, and the size of the union is the maximum
          of the sizes of its members, suitably padded. Of course unions cannot
          be polymorphic and cannot have base classes.</para>

        <para>Pointers to incomplete classes are represented by means of the
          alignment:</para>
<programlisting>
~cpp.empty.align : () -&gt; ALIGNMENT
</programlisting>

        <para>This token is also used for the alignment of a complete class if
          that class is never used in the generated TDF in a manner which
          requires it to be complete. This can lead to savings on the size of the
          generated code by preventing the need to define all the member offset
          tokens in order to find the shape of the class.</para>
      </sect2>

      <sect2 id='derived-class-layout'>
        <title>Derived class layout</title>

        <para>The description of the implementation of derived classes will be
          given in terms of the example class hierarchy given by:</para>
<programlisting>
class A {
  // A's members
} ;

class B : public A {
  // B's members
} ;

class C : public A {
  // C's members
} ;

class D : public B, public C {
  // D's members
} ;
</programlisting>

        <para>or, as a directed acyclic graph:</para>

        <figure id="class-layouta">
          <title>Class Layout</title>

          <mediaobject>
            <imageobject><imagedata fileref="graph" format="PNG"></imageobject>
          </mediaobject>
        </figure>

        <sect3 id='single-inheritance'>
          <title>Single inheritance</title>

          <para>The layout of class <emphasis>A</emphasis> is given by:</para>

          <figure id="class-a">
            <title>Single Inheritance - Class A</title>

            <mediaobject>
              <imageobject><imagedata fileref="classa" format=
              "PNG"></imageobject>
            </mediaobject>
          </figure>

          <para>as above. Class <emphasis>B</emphasis> inherits all the members
            of class <emphasis>A</emphasis> plus those members explicitly
            declared within class <emphasis>B</emphasis>. In addition, class
            <emphasis>B</emphasis> inherits all the virtual member functions of
            <emphasis>A</emphasis>, some of which may be overridden in
            <emphasis>B</emphasis>, extended by any additional virtual functions
            declared in <emphasis>B</emphasis>. This may be represented as
            follows:</para>

          <figure id="class-b">
            <title>Single Inheritance - Class B</title>

            <mediaobject>
              <imageobject><imagedata fileref="classb" format=
              "PNG"></imageobject>
            </mediaobject>
          </figure>

          <para>where <emphasis>A</emphasis> denotes those members inherited
            from the base class and <emphasis>B</emphasis> denotes those members
            added in the derived class. Note that an object of class
            <emphasis>B</emphasis> contains a sub-object of class
            <emphasis>A</emphasis>. The fact that this sub-object is located at
            the start of <emphasis>B</emphasis> means that the base class
            conversion from <emphasis>B</emphasis> to <emphasis>A</emphasis> is
            trivial.
            <anchor id='primary-base-class'>
            Any base class with this property is called a
            primary base class.</para>

          <note>
            <para>In theory two virtual function tables are required, the
              normal virtual function table for <emphasis>B</emphasis>, denoted
              by <emphasis>vtbl B</emphasis>, and a modified virtual function
              table for <emphasis>A</emphasis>, denoted by <emphasis>vtbl
              B::A</emphasis>, taking into account any overriding virtual
              functions within <emphasis>B</emphasis>, and pointing to
              <emphasis>B</emphasis>'s run-time type information. This latter
              means that the dynamic type information for the
              <emphasis>A</emphasis> sub-object relates to <emphasis>B</emphasis>
              rather than <emphasis>A</emphasis>. However these two tables can
              usually be combined - if the virtual functions added in
              <emphasis>B</emphasis> are listed in the virtual function table
              after those inherited from <emphasis>A</emphasis> and the form of
              the overriding is <link linkend='override'>suitably well</link>
              behaved (in the
              sense defined below) then <emphasis>vptr B::A</emphasis> is an
              initial segment of <emphasis>vptr B</emphasis>. It is also possible
              to remove the <emphasis>vptr B</emphasis> field and use
              <emphasis>vptr B::A</emphasis> in its place in this case (it has to
              be this way round to preserve the <emphasis>A</emphasis>
              sub-object). Thus the items shaded in the diagram can be
              removed.</para>
          </note>

          <para>The class <emphasis>C</emphasis> is similarly given by:</para>

          <figure id="class-c">
            <title>Single Inheritance - Class C</title>

            <mediaobject>
              <imageobject><imagedata fileref="classc" format=
              "PNG"></imageobject>
            </mediaobject>
          </figure>
        </sect3>

        <sect3 id='multiple-inheritance'>
          <title>Multiple inheritance</title>

          <para>Class <emphasis>D</emphasis> is more complex because of the
            presence of multiple inheritance. <emphasis>D</emphasis> inherits all
            the members of <emphasis>B</emphasis>, including those which
            <emphasis>B</emphasis> inherits from <emphasis>A</emphasis>, plus all
            the members of <emphasis>C</emphasis>, including those which
            <emphasis>C</emphasis> inherits from <emphasis>A</emphasis>. It also
            inherits all of the virtual member functions from
            <emphasis>B</emphasis> and <emphasis>C</emphasis>, some of which may
            be overridden in <emphasis>D</emphasis>, extended by any additional
            virtual functions declared in <emphasis>D</emphasis>. This may be
            represented as follows:</para>

          <figure id="class-d">
            <title>Multiple Inheritance - Class D</title>

            <mediaobject>
              <imageobject><imagedata fileref="classd" format=
              "PNG"></imageobject>
            </mediaobject>
          </figure>

          <para>Note that there are two copies of <emphasis>A</emphasis> in
            <emphasis>D</emphasis> because virtual inheritance has not been
            used.</para>

          <para>The <emphasis>B</emphasis> base class of <emphasis>D</emphasis>
            is essentially similar to the single inheritance case already
            discussed; the <emphasis>C</emphasis> base class is different
            however. Note firstly that the <emphasis>C</emphasis> sub-object of
            <emphasis>D</emphasis> is located at a non-zero offset,
            <emphasis>delta D::C</emphasis>, from the start of the object. This
            means that the base class conversion from <emphasis>D</emphasis> to
            <emphasis>C</emphasis> consists of adding this offset (for pointer
            conversions things are further complicated by the need to allow for
            null pointers). Also <emphasis>vtbl D::C</emphasis> is not an initial
            segment of <emphasis>vtbl D</emphasis> because this contains the
            virtual functions inherited from <emphasis>B</emphasis> first,
            followed by those inherited from <emphasis>C</emphasis>, followed by
            those first declared in <emphasis>D</emphasis> (there are
            <link linkend='override'>other reasons</link> as well). Thus
            <emphasis>vtbl D::C</emphasis> cannot be eliminated.</para>
        </sect3>

        <sect3 id='virtual-inheritance'>
          <title>Virtual inheritance</title>

          <para>Virtual inheritance introduces a further complication. Now
            consider the class hierarchy given by:</para>
<programlisting>
class A {
  // A's members
} ;

class B : virtual public A {
  // B's members
} ;

class C : virtual public A {
  // C's members
} ;

class D : public B, public C {
  // D's members
} ;
</programlisting>

          <para>or, as a directed acyclic graph:</para>

          <figure id="acyclic-graph">
            <title>Acyclic Graph</title>

            <mediaobject>
              <imageobject><imagedata fileref="diamond" format=
              "PNG"></imageobject>
            </mediaobject>
          </figure>

          <para>As before <emphasis>A</emphasis> is given by:</para>

          <figure id="class-a1">
            <title>Single Inheritance - Class A</title>

            <mediaobject>
              <imageobject><imagedata fileref="classa" format=
              "PNG"></imageobject>
            </mediaobject>
          </figure>

          <para>but now <emphasis>B</emphasis> is given by:</para>

          <figure id="virtual-b">
            <title>Virtual B</title>

            <mediaobject>
              <imageobject><imagedata fileref="virtualb" format=
              "PNG"></imageobject>
            </mediaobject>
          </figure>

          <para>Rather than having the sub-object of class
            <emphasis>A</emphasis> directly as part of <emphasis>B</emphasis>,
            the class now contains a pointer, <emphasis>ptr A</emphasis>, to this
            sub-object. The virtual sub-objects are always located at the end of
            a class layout; their offset may therefore vary for different
            objects, however the offset for <emphasis>ptr A</emphasis> is always
            fixed. The <emphasis>ptr A</emphasis> field is initialised in each
            constructor for <emphasis>B</emphasis>. In order to perform the base
            class conversion from <emphasis>B</emphasis> to
            <emphasis>A</emphasis>, the contents of <emphasis>ptr A</emphasis>
            are taken (again provision needs to be made for null pointers in
            pointer conversions). In cases when the dynamic type of the
            <emphasis>B</emphasis> object can be determined statically it is
            possible to access the <emphasis>A</emphasis> sub-object directly by
            adding a suitable offset. Because this conversion is non-trivial (see
            <link linkend='override'>below</link>) the virtual function table
            <emphasis>vtbl
            B::A</emphasis> is not an initial segment of <emphasis>vtbl
            B</emphasis> and cannot be eliminated.</para>

          <para>The class <emphasis>C</emphasis> is similarly given by:</para>

          <figure id="virtual-c">
            <title>Virtual C</title>

            <mediaobject>
              <imageobject><imagedata fileref="virtualc" format=
              "PNG"></imageobject>
            </mediaobject>
          </figure>

          <para>Now the class <emphasis>D</emphasis> is given by:</para>

          <figure id="virtual-d">
            <title>Virtual D</title>

            <mediaobject>
              <imageobject><imagedata fileref="virtuald" format=
              "PNG"></imageobject>
            </mediaobject>
          </figure>

          <para>Note that there is a single <emphasis>A</emphasis> sub-object
            of <emphasis>D</emphasis> referenced by the <emphasis>ptr
            A</emphasis> fields in both the <emphasis>B</emphasis> and
            <emphasis>C</emphasis> sub-objects. The elimination of <emphasis>vtbl
            D::B</emphasis> is as above.</para>
        </sect3>
      </sect2>

      <sect2 id='const-and-destructors'>
        <title>Constructors and destructors</title>

        <para>The implementation of constructors and destructors, whether
          explicitly or implicitly defined, is slightly more complex than that of
          other member functions. For example, the constructors need to set up
          the internal <emphasis>vptr</emphasis> and <emphasis>ptr</emphasis>
          fields mentioned above.</para>

        <para>The order of initialisation in a constructor is as
          follows:</para>

        <orderedlist>
          <listitem>
            <para>The internal <emphasis>ptr</emphasis> fields giving the
              locations of the virtual base classes are initialised.</para>
          </listitem>

          <listitem>
            <para>The constructors for the virtual base classes are
              called.</para>
          </listitem>

          <listitem>
            <para>The constructors for the non-virtual direct base classes are
              called.</para>
          </listitem>

          <listitem>
            <para>The internal <emphasis>vptr</emphasis> fields giving the
              locations of the virtual function tables are initialised.</para>
          </listitem>

          <listitem>
            <para>The constructors for the members of the class are
              called.</para>
          </listitem>

          <listitem>
            <para>The main constructor body is executed.</para>
          </listitem>
        </orderedlist>

        <para>To ensure that each virtual base is only initialised once, if a
          class has a virtual base class then all its constructors have an
          implicit extra parameter of type <literal>int</literal>. The first two
          steps above are then only applied if this flag is nonzero. In normal
          applications of the constructor this argument will be 1, however in
          base class initialisations such as those in the third and fourth steps
          above, it will be 0.</para>

        <para>Note that similar steps to protect virtual base classes are not
          taken in an implicitly declared <literal>operator=</literal> function.
          The order of assignment in this case is as follows:</para>

        <orderedlist>
          <listitem>
            <para>The assignment operators for the direct base classes (both
              virtual and non-virtual) are called.</para>
          </listitem>

          <listitem>
            <para>The assignment operators for the members of the class are
              called.</para>
          </listitem>

          <listitem>
            <para>A reference to the object assigned to (i.e.
              <literal>*this</literal>) is returned.</para>
          </listitem>
        </orderedlist>

        <para>The order of destruction in a destructor is essentially the
          reverse of the order of construction:</para>

        <orderedlist>
          <listitem>
            <para>The main destructor body is executed.</para>
          </listitem>

          <listitem>
            <para>The destructor for the members of the class are
              called.</para>
          </listitem>

          <listitem>
            <para>The internal <emphasis>vptr</emphasis> fields giving the
              locations of the virtual function tables are re-initialised.</para>
          </listitem>

          <listitem>
            <para>The destructors for the non-virtual direct base classes are
              called.</para>
          </listitem>

          <listitem>
            <para>The destructors for the virtual base classes are
              called.</para>
          </listitem>

          <listitem>
            <para>If necessary the space occupied by the object is
              deallocated.</para>
          </listitem>
        </orderedlist>

        <para>All destructors have an extra parameter of type
          <literal>int</literal>. The virtual base classes are only destroyed if
          this flag is nonzero when and-ed with 2. The space occupied by the
          object is only deallocated if this flag is nonzero when and-ed with 1.
          This deallocation is equivalent to inserting:</para>
<programlisting>
delete this ;
</programlisting>

        <para>in the destructor. The <literal>operator delete</literal>
          function is called via the destructor in this way in order to implement
          the pseudo-virtual nature of these deallocation functions. Thus for
          normal destructor calls the extra argument is 2, for base class
          destructor calls it is 0, and for calls arising from a
          <literal>delete</literal> expression it is 3.</para>

        <para>The point at which the virtual function tables are initialised in
          the constructor, and the fact that they are re-initialised in the
          destructor, is to ensure that virtual functions called from base class
          initialisers are handled correctly (see ISO C++ 12.7).</para>

        <anchor id='partial'>
        <para>A further complication arises from the need to destroy
          partially constructed objects if an exception is thrown in
          a constructor. A count is maintained of the number of base classes and
          members constructed within a constructor. If an exception is thrown
          then it is caught in the constructor, the constructed base classes and
          members are destroyed, and the exception is re-thrown. The count
          variable is used to determine which bases and members need to be
          destroyed.</para>

        <warning>
          <para>
              <blockquote>
                <para>These partial destructors currently do not interact
                correctly with any exception specification on the constructor.
                Exceptions thrown within destructors are not correctly handled
                either.</para>
            </blockquote>
          </para>
        </warning>
      </sect2>

      <sect2 id='virt-funct-tables'>
        <title>Virtual function tables</title>

        <para>The virtual functions in a polymorphic class are given in its
          virtual function table in the following order: firstly those virtual
          functions inherited from its direct base classes (which may be
          overridden in the derived class) followed by those first declared in
          the derived class in the order in which they are declared. Note that
          this can result in virtual functions inherited from virtual base
          classes appearing more than once. The virtual functions are numbered
          from 1 (this is slightly more convenient than numbering from 0 in the
          default implementation).</para>

        <para>The virtual function table for this class has shape:</para>
<programlisting>
~cpp.vtab.type : ( NAT ) -&gt; SHAPE
</programlisting>

        <para>the argument being <emphasis>n + 1</emphasis> where
          <emphasis>n</emphasis> is the number of virtual functions in the class
          (there is also a token:</para>
<programlisting>
~cpp.vtab.diag : () -&gt; SHAPE
</programlisting>

        <para>which is used in the diagnostic output for a generic virtual
          function table). The table is created using the token:</para>
<programlisting>
~cpp.vtab.make : ( EXP pti, EXP OFFSET, NAT, EXP NOF ) -&gt; EXP vt
</programlisting>

        <para>where the first expression gives the address of the
          <link linkend='run-time-type-info'>run-time type information
          structure</link> for the class, the
          second expression gives the offset of the <emphasis>vptr</emphasis>
          field within the class (i.e. <emphasis>voff</emphasis>), the integer
          constant is <emphasis>n + 1</emphasis>, and the final expression is a
          <literal>make_nof</literal> construct giving information on each of the
          <emphasis>n</emphasis> virtual functions.</para>

        <para>The information given on each virtual function in this table has
          the form of a <link linkend='pointers-to-funct-mem'>pointer to
          function member</link> formed using the token:</para>
<programlisting>
~cpp.pmf.make : ( EXP PROC, EXP OFFSET, EXP OFFSET ) -&gt; EXP pmf
</programlisting>

        <para>as above, except that the third argument gives the offset of the
          base class in virtual function tables such as <emphasis>vtbl
          B::A</emphasis>. For pure virtual functions the function pointer in
          this token is given by:</para>
<programlisting>
~cpp.vtab.pure : () -&gt; EXP PROC
</programlisting>

        <para>In the default implementation this gives a function
          <literal>__TCPPLUS_pure</literal> which just calls
          <literal>abort</literal>.</para>

        <para>To avoid duplicate copies of virtual function tables and run-time
          type information structures being created, the ARM algorithm is used.
          The virtual function table and run-time type information structure for
          a class are defined in the module containing the definition of the
          first non-inline, non-pure virtual function declared in that class. If
          such a function does not exist then duplicate copies are created in
          every module which requires them. In the former case the virtual
          function table will have an <link linkend='other-mangled-names'>
          external tag name</link>; in the
          latter case it will be an internal tag. This scheme can be overridden
          using the <literal>-jv</literal> command-line option, which causes
          local virtual function tables to be output for all classes.</para>

        <anchor id='override'>
        <para>Note that the discussion above applies to both simple virtual
          function tables, such as <emphasis>vtbl B</emphasis> above, and to
          those arising from base classes, such as <emphasis>vtbl
          B::A</emphasis>. We are now in a position to precisely
          determine when <emphasis>vtbl B::A</emphasis> is an initial segment of
          <emphasis>vtbl B</emphasis> and hence can be eliminated. Firstly,
          <emphasis>A</emphasis> must be the first direct base class of
          <emphasis>B</emphasis> and cannot be virtual. This is to ensure both
          that there are no virtual functions in <emphasis>vtbl B</emphasis>
          before those inherited from <emphasis>A</emphasis>, and that the
          corresponding base class conversion is trivial so that the pointers to
          function members of <emphasis>B</emphasis> comprising the virtual
          function table can be equally regarded as pointers to function members
          of <emphasis>A</emphasis>. The second requirement is that if a virtual
          function for <emphasis>A</emphasis>, <emphasis>f</emphasis>, is
          overridden in <emphasis>B</emphasis> then the return type for
          <emphasis>B::f</emphasis> cannot differ from the return type for
          <emphasis>A::f</emphasis> by a non-trivial conversion (recall that ISO
          C++ allows the return types to differ by a base class conversion). In
          the non-trivial conversion case the function entered in <emphasis>vtbl
          B::A</emphasis> needs to be, not <emphasis>B::f</emphasis> as in
          <emphasis>vtbl B</emphasis>, but a stub function which calls
          <emphasis>B::f</emphasis> and converts its return value to the return
          type of <emphasis>A::f</emphasis>.</para>

        <sect3 id='calling-virt-funct'>
          <title>Calling virtual functions</title>

          <para>The virtual function call mechanism is implemented using the
            token:</para>
<programlisting>
~cpp.vtab.func : ( EXP ppvt, SIGNED_NAT ) -&gt; EXP ppmf
</programlisting>

          <para>which has as its arguments a reference to the
            <emphasis>vptr</emphasis> field of the object the function is to be
            called for, and the number of the virtual function to be called. It
            returns a reference to the corresponding pointer to function member
            within the object's virtual function table. The function is then
            called by extracting the base class offset to be added, and the
            function to be called, from this reference using the tokens:</para>
<programlisting>
~cpp.pmf.delta : ( ALIGNMENT a, EXP ppmf ) -&gt; EXP OFFSET ( a, a )
~cpp.pmf.func : ( EXP ppmf ) -&gt; EXP PROC
</programlisting>

          <para>described as part of the <link linkend='pointers-to-funct-mem'>
            pointer to function member call mechanism</link> above.</para>
        </sect3>
      </sect2>

      <sect2 id='run-time-type-info'>
        <title>Run-time type information</title>

        <para>Each C++ type can be associated with a run-time type information
          structure giving information about that type. These type information
          structures have shape given by the token:</para>
<programlisting>
~cpp.typeid.type : () -&gt; SHAPE
</programlisting>

        <para>which corresponds to the representation for the standard type
          <literal>std::type_info</literal> declared in the header
          <literal>&lt;typeinfo&gt;</literal>. Each type information structure
          consists of a tag number, giving information on the kind of type
          represented, a string literal, giving the name of the type, and a
          pointer to a list of base type information structures. These are
          combined to give a type information structure using the token:</para>
<programlisting>
~cpp.typeid.make : ( SIGNED_NAT, EXP, EXP ) -&gt; EXP ti
</programlisting>

        <para>Each base type information structure has shape given by the
          token:</para>
<programlisting>
~cpp.baseid.type : () -&gt; SHAPE
</programlisting>

        <para>It consists of a pointer to a type information structure, an
          expression used to describe the offset of a base class, a pointer to
          the next base type information structure in the list, and two integers
          giving information on type qualifiers etc. These are combined to give a
          base type information structure using the token:</para>
<programlisting>
~cpp.baseid.make : ( EXP, EXP, EXP, SIGNED_NAT, SIGNED_NAT ) -&gt; EXP bi
</programlisting>

        <para>The following table gives the various tag numbers used in type
          information structures plus a list of the base type information
          structures associated with each type. Macros giving these tag numbers
          are provided in the default implementation in a header,
          <literal>interface.h</literal>, which is shared by the C++
          producer.</para>

        <table frame='all' id='info-struct-tag-num'>
          <title>Information Structure Tag Numbers</title>

          <tgroup cols='4'>
            <thead>
              <row>
                <entry>Type</entry>

                <entry>Form</entry>

                <entry>Tag</entry>

                <entry>Base Information</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>integer</entry>

                <entry>-</entry>

                <entry>0</entry>

                <entry>-</entry>
              </row>

              <row>
                <entry>floating point</entry>

                <entry>-</entry>

                <entry>1</entry>

                <entry>-</entry>
              </row>

              <row>
                <entry>void</entry>

                <entry>-</entry>

                <entry>2</entry>

                <entry>-</entry>
              </row>

              <row>
                <entry>class or struct</entry>

                <entry>class T</entry>

                <entry>3</entry>

                <entry>[base,access,virtual], ....</entry>
              </row>

              <row>
                <entry>union</entry>

                <entry>union T</entry>

                <entry>4</entry>

                <entry>-</entry>
              </row>

              <row>
                <entry>enumeration</entry>

                <entry>enum T</entry>

                <entry>5</entry>

                <entry>-</entry>
              </row>

              <row>
                <entry>pointer</entry>

                <entry>cv T *</entry>

                <entry>6</entry>

                <entry>[T,cv,0]</entry>
              </row>

              <row>
                <entry>reference</entry>

                <entry>cv T &amp;</entry>

                <entry>7</entry>

                <entry>[T,cv,0]</entry>
              </row>

              <row>
                <entry>pointer to member</entry>

                <entry>cv T S::*</entry>

                <entry>8</entry>

                <entry>[S,0,0], [T,cv,0]</entry>
              </row>

              <row>
                <entry>array</entry>

                <entry>cv T [n]</entry>

                <entry>9</entry>

                <entry>[T,cv,n]</entry>
              </row>

              <row>
                <entry>bitfield</entry>

                <entry>cv T : n</entry>

                <entry>10</entry>

                <entry>[T,cv,n]</entry>
              </row>

              <row>
                <entry>C++ function</entry>

                <entry>cv T ( S1, ...., Sn )</entry>

                <entry>11</entry>

                <entry>[T,cv,0], [S1,0,0], ...., [Sn,0,0]</entry>
              </row>

              <row>
                <entry>C function</entry>

                <entry>cv T ( S1, ...., Sn )</entry>

                <entry>12</entry>

                <entry>[T,cv,0], [S1,0,0], ...., [Sn,0,0]</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>In the form column <literal>cv T</literal> is used to denote not
          only the normal cv-qualifiers but, when <literal>T</literal> is a
          function type, the member function cv-qualifiers. Arrays with an
          unspecified bound are treated as if their bound was zero. Functions
          with ellipsis are treated as if they had an extra parameter of a dummy
          type named <literal>...</literal> (see below). Note the distinction
          between C++ and C function types.</para>

        <para>Each base type information structure is described as a triple
          consisting of a type and two integers. One of these integers may be
          used to encode a type qualifier, <literal>cv</literal>, as
          follows:</para>

        <table frame='all' id='info-struct-base-types'>
          <title>Information Structure Base Types</title>

          <tgroup cols='2'>
            <thead>
              <row>
                <entry>Qualifier</entry>

                <entry>Encoding</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>none</entry>

                <entry>0</entry>
              </row>

              <row>
                <entry>const</entry>

                <entry>1</entry>
              </row>

              <row>
                <entry>volatile</entry>

                <entry>2</entry>
              </row>

              <row>
                <entry>const volatile</entry>

                <entry>3</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>The base type information for a class consists of information on
          each of its direct base classes. The includes the offset of this base
          within the class (for a virtual base class this is the offset of the
          corresponding <emphasis>ptr</emphasis> field), whether the base is
          virtual (1) or not (0), and the base class access, encoded as
          follows:</para>

        <table frame='all' id='base-class-access'>
          <title>Base Class Access Encoding</title>

          <tgroup cols='2'>
            <thead>
              <row>
                <entry>Access</entry>

                <entry>Encoding</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>public</entry>

                <entry>0</entry>
              </row>

              <row>
                <entry>protected</entry>

                <entry>1</entry>
              </row>

              <row>
                <entry>private</entry>

                <entry>2</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>For example, the run-time type information structures for the
          classes declared in the <link linkend='acyclic-graph'>diamond
          lattice</link> above can be
          represented as follows:</para>

        <figure id="run-time">
          <title>Run-time Type Information Structures</title>

          <mediaobject>
            <imageobject><imagedata fileref="rttid" format="PNG"></imageobject>
          </mediaobject>
        </figure>

        <sect3 id='defining-info-struct'>
          <title>Defining run-time type information structures</title>

          <para>For built-in types, the run-time type information structure may
            be referenced by the token:</para>
<programlisting>
~cpp.typeid.basic : ( SIGNED_NAT ) -&gt; EXP pti
</programlisting>

          <para>where the argument gives the encoding of the type as given in
            the following table:</para>

          <table frame='all' id='type-encodings'>
            <title>Type Encodiing</title>

            <tgroup cols='4'>
              <thead>
                <row>
                  <entry>Type</entry>

                  <entry>Encoding</entry>

                  <entry>Type</entry>

                  <entry>Encoding</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry>char</entry>

                  <entry>0</entry>

                  <entry>unsigned long</entry>

                  <entry>11</entry>
                </row>

                <row>
                  <entry>(error)</entry>

                  <entry>1</entry>

                  <entry>float</entry>

                  <entry>12</entry>
                </row>

                <row>
                  <entry>void</entry>

                  <entry>2</entry>

                  <entry>double</entry>

                  <entry>13</entry>
                </row>

                <row>
                  <entry>(bottom)</entry>

                  <entry>3</entry>

                  <entry>long double</entry>

                  <entry>14</entry>
                </row>

                <row>
                  <entry>signed char</entry>

                  <entry>4</entry>

                  <entry>wchar_t</entry>

                  <entry>16</entry>
                </row>

                <row>
                  <entry>signed short</entry>

                  <entry>5</entry>

                  <entry>bool</entry>

                  <entry>17</entry>
                </row>

                <row>
                  <entry>signed int</entry>

                  <entry>6</entry>

                  <entry>(ptrdiff_t)</entry>

                  <entry>18</entry>
                </row>

                <row>
                  <entry>signed long</entry>

                  <entry>7</entry>

                  <entry>(size_t)</entry>

                  <entry>19</entry>
                </row>

                <row>
                  <entry>unsigned char</entry>

                  <entry>8</entry>

                  <entry>(...)</entry>

                  <entry>20</entry>
                </row>

                <row>
                  <entry>unsigned short</entry>

                  <entry>9</entry>

                  <entry>signed long long</entry>

                  <entry>23</entry>
                </row>

                <row>
                  <entry>unsigned int</entry>

                  <entry>10</entry>

                  <entry>unsigned long long</entry>

                  <entry>27</entry>
                </row>
              </tbody>
            </tgroup>
          </table>

          <para>Note that the encoding for the basic integral types is the same
            as that <link linkend='arithmetic-types'>given above</link>.
            The other types are assigned to
            unused values. Note that the encodings for
            <literal>ptrdiff_t</literal> and <literal>size_t</literal> are not
            used, instead that for their implementation is used (using the
            standard tokens <literal>ptrdiff_t</literal> and
            <literal>size_t</literal>). The encodings for <literal>bool</literal>
            and <literal>wchar_t</literal> are used because they are conceptually
            distinct types even though they are implemented as one of the basic
            integral types. The type labelled <literal>...</literal> is the dummy
            used in the representation of ellipsis functions. The default
            implementation uses an array of type information structures,
            <literal>__TCPPLUS_typeid</literal>, to implement
            <literal>~cpp.typeid.basic</literal>.</para>

          <para>The run-time type information structures for classes are
            defined in the same place as their
            <link linkend='virt-funct-tables'>virtual function tables</link>.
            Other run-time type information structures are defined in
            whatever modules require them. In the former case the type
            information structure will have an
            <link linkend='other-mangled-names'>external tag name</link>; in
            the latter case it will be an internal tag.</para>
        </sect3>

        <sect3 id='accessing-run-info'>
          <title>Accessing run-time type information</title>

          <para>The primary means of accessing the run-time type information
            for an object is using the <literal>typeid</literal> construct. In
            cases where the operand type can be determined statically, the
            address of the corresponding type information structure is returned.
            In other cases the token:</para>
<programlisting>
~cpp.typeid.ref : ( EXP ppvt ) -&gt; EXP pti
</programlisting>

          <para>is used, where the argument gives a reference to the
            <emphasis>vptr</emphasis> field of the object being checked. From
            this information it is trivial to trace the corresponding type
            information.</para>

          <para>Another means of querying the run-time type information for an
            object is using the <literal>dynamic_cast</literal> construct. When
            the result cannot be determined statically, this is implemented using
            the token:</para>
<programlisting>
~cpp.dynam.cast : ( EXP ppvt, EXP pti ) -&gt; EXP pv
</programlisting>

          <para>where the first expression gives a reference to the
            <emphasis>vptr</emphasis> field of the object being cast and the
            second gives the run-time type information for the type being cast
            to. In the default implementation this token is implemented by the
            procedure <literal>__TCPPLUS_dynamic_cast</literal>. The key point to
            note is that the virtual function table contains the offset,
            <emphasis>voff</emphasis>, of the <emphasis>vptr</emphasis> field
            from the start of the most complete object. Thus it is possible to
            find the address of the most complete object. The run-time type
            information contains enough information to determine whether this
            object has a sub-object of the type being cast to, and if so, how to
            find the address of this sub-object. The result is returned as a
            <literal>void *</literal>, with the null pointer indicating that the
            conversion is not possible.</para>
        </sect3>
      </sect2>

      <sect2 id='dynamic-init'>
        <title>Dynamic initialisation</title>

        <para>The dynamic initialisation of variables with static storage
          duration in C++ is implemented by means of the TDF
          <literal>initial_value</literal> construct. However in order for the
          producer to maintain control over the order of initialisation, rather
          than each variable being initialised separately using
          <literal>initial_value</literal>, a single expression is created which
          initialises all the variables in a module, and this initialiser
          expression is used to initialise a single dummy variable using
          <literal>initial_value</literal>. Note that, while this enables the
          variables within a single module to be initialised in the order in
          which they are defined, the order of initialisation between different
          modules is unspecified.</para>

        <para>The implementation needs to keep a list of those variables with
          static storage duration which have been initialised so that it can call
          the destructors for these objects at the end of the program. This is
          done by declaring a variable of shape:</para>
<programlisting>
~cpp.destr.type : () -&gt; SHAPE
</programlisting>

        <para>for each such object with a non-trivial destructor. Each element
          of an array is considered a distinct object. Immediately after the
          variable has been initialised the token:</para>
<programlisting>
~cpp.destr.global : ( EXP pd, EXP POINTER c, EXP PROC ) -&gt; EXP TOP
</programlisting>

        <para>is called to add the variable to the list of objects to be
          destroyed. The first argument is the address of the dummy variable just
          declared, the second is the address of the object to be destroyed, and
          the third is the destructor to be used. In this way a list giving the
          objects to be destroyed, and the order in which to destroy them, is
          built up. Note that partially constructed objects are destroyed within
          their constructors (see <link linkend='partial'>above</link>) so that
          only completely constructed objects need to be considered.</para>

        <para>The implementation also needs to ensure that it calls the
          destructors in this list at the end of the program, including calls of
          <literal>exit</literal>. This is done by calling the token:</para>
<programlisting>
~cpp.destr.init : () -&gt; EXP TOP
</programlisting>

        <para>at the start of each <literal>initial_value</literal> construct.
          In the default implementation this uses <literal>atexit</literal> to
          register a function, <literal>__TCPPLUS_term</literal>, which calls the
          destructors. To aid alternative implementations the token:</para>
<programlisting>
~cpp.start : () -&gt; EXP TOP
</programlisting>

        <para>is called at the start of the <literal>main</literal> function,
          however this has no effect in the default implementation.</para>
      </sect2>

      <sect2 id='exception-handling'>
        <title>Exception handling</title>

        <para>Conceptually, exception handling can be described in terms of the
          following diagram:</para>

        <figure id="exeption-handling">
          <title>Exception Handling</title>

          <mediaobject>
            <imageobject><imagedata fileref="try" format="PNG"></imageobject>
          </mediaobject>
        </figure>

        <para>At any point in the execution of the program there is a stack of
          currently active <literal>try</literal> blocks and currently active
          local variables. A <literal>try</literal> block is pushed onto the
          stack as it is entered and popped from the stack when it is left
          (whether directly or via a jump). A local variable with a non-trivial
          destructor is pushed onto the stack just after its constructor has been
          called at the start of its scope, and popped from the stack just before
          its destructor is called at the end of its scope (including before
          jumps out of its scope). Each element of an array is considered a
          separate object. Each <literal>try</literal> block has an associated
          list of handlers. Each local variable has an associated
          destructor.</para>

        <para>Provided no exception is thrown this stack grows and shrinks in a
          well-behaved manner as execution proceeds. When an exception is thrown
          an exception manager is invoked to find a matching exception handler.
          The exception manager proceeds to execute a loop to unwind the stack as
          follows. If the stack is empty then the exception cannot be caught and
          <literal>std::terminate</literal> is called. Otherwise the top element
          is popped from the stack. If this is a local variable then the
          associated destructor is called for the variable. If the top element is
          a <literal>try</literal> block then the current exception is compared
          in turn to each of the associated handlers. If a match is found then
          execution jumps to the handler body, otherwise the exception manager
          continues to the next element of the stack.</para>

        <para>Note that this description is purely conceptual. There is no need
          for exception handling to be implemented by a stack in this way
          (although the default implementation uses a similar technique). It does
          however serve to illustrate the various stages which must exist in any
          implementation.</para>

        <sect3 id='try-blocks'>
          <title>Try blocks</title>

          <para>At the start of a <literal>try</literal> block a variable of
            shape:</para>
<programlisting>
~cpp.try.type : () -&gt; SHAPE
</programlisting>

          <para>is declared corresponding to the stack element for this block.
            This is then initialised using the token:</para>
<programlisting>
~cpp.try.begin : ( EXP ptb, EXP POINTER fa, EXP POINTER ca ) -&gt; EXP TOP
</programlisting>

          <para>where the first argument is a pointer to this variable, the
            second argument is the TDF <literal>current_env</literal> construct,
            and the third argument is the result of the TDF
            <literal>make_local_lv</literal> construct on the label which is used
            to mark the first handler associated with the block. Note that the
            last two arguments enable a TDF <literal>long_jump</literal>
            construct to be applied to transfer control to the first
            handler.</para>

          <para>When control exits from a <literal>try</literal> block, whether
            by reaching the end of the block or jumping out of it, the block is
            removed from the stack using the token:</para>
<programlisting>
~cpp.try.end : ( EXP ptb ) -&gt; EXP TOP
</programlisting>

          <para>where the argument is a pointer to the <literal>try</literal>
            block variable.</para>
        </sect3>

        <sect3>
          <title>Local variables</title>

          <para>The technique used to add a local variable with a non-trivial
            destructor to the stack is similar to that used in the dynamic
            initialisation of global variables. A local variable of shape
            <literal>~cpp.destr.type</literal> is declared at the start of the
            variable scope. This is initialised just after the constructor for
            the variable is called using the token:</para>
<programlisting>
~cpp.destr.local : ( EXP pd, EXP POINTER c, EXP PROC ) -&gt; EXP TOP
</programlisting>

          <para>where the first argument is a pointer to the variable being
            initialised, the second is a pointer to the local variable to be
            destroyed, and the third is the destructor to be called. At the end
            of the variable scope, just before its destructor is called, the
            token:</para>
<programlisting>
~cpp.destr.end : ( EXP pd ) -&gt; EXP TOP
</programlisting>

          <para>where the argument is a pointer to destructor variable, is
            called to remove the local variable destructor from the stack. Note
            that partially constructed objects are destroyed within their
            constructors (see <link linkend='partial'>above</link>) so that
            only completely constructed objects need to be considered.</para>

          <para>In cases where the local variable may be conditionally
            initialised (for example a temporary variable in the second operand
            of a <literal>||</literal> operation) the local variable of shape
            <literal>~cpp.destr.type</literal> is initialised to the value given
            by the token:</para>
<programlisting>
~cpp.destr.null : () -&gt; EXP d
</programlisting>

          <para>(normally it is left uninitialised). Before the destructor for
            this variable is called the value of the token:</para>
<programlisting>
~cpp.destr.ptr : ( EXP pd ) -&gt; EXP POINTER c
</programlisting>

          <para>is tested. If <literal>~cpp.destr.local</literal> has been
            called for this variable then this token returns a pointer to the
            variable, otherwise it returns a null pointer. The token
            <literal>~cpp.destr.end</literal> and the destructor are only called
            if this token indicates that the variable has been
            initialised.</para>
        </sect3>

        <sect3 id='throwing-an-exception'>
          <title>Throwing an exception</title>

          <para>When a <literal>throw</literal> expression with an argument is
            encountered a number of steps performed. Firstly, space is allocated
            to hold the exception value using the token:</para>
<programlisting>
~cpp.except.alloc : ( EXP VARIETY size_t ) -&gt; EXP pv
</programlisting>

          <para>the argument of which gives the size of the value. The space
            allocated is returned as an expression of type <literal>void
            *</literal>. Secondly, the exception value is copied into the space
            allocated, using a copy constructor if appropriate. Finally the
            exception is raised using the token:</para>
<programlisting>
~cpp.except.throw : ( EXP pv, EXP pti, EXP PROC ) -&gt; EXP BOTTOM
</programlisting>

          <para>The first argument gives the pointer to the exception value,
            returned by <literal>~cpp.except.alloc</literal>, the second argument
            gives a pointer to the run-time type information for the exception
            type, and the third argument gives the destructor to be called to
            destroy the exception value (if any). This token sets the current
            exception to the given values and invokes the exception manager as
            above.</para>

          <para>A <literal>throw</literal> expression without an argument
            results in a call to the token:</para>
<programlisting>
~cpp.except.rethrow : () -&gt; EXP BOTTOM
</programlisting>

          <para>which re-invokes the exception manager with the current
            exception. If there is no current exception then the implementation
            should call <literal>std::terminate</literal>.</para>
        </sect3>

        <sect3 id='handling-an-exception'>
          <title>Handling an exception</title>

          <para>The exception manager proceeds to find an exception in the
            manner described above, unwinding the stack and calling destructors
            for local variables. When a <literal>try</literal> block is popped
            from the stack a TDF <literal>long_jump</literal> is applied to
            transfer control to its list of handlers. For each handler in turn it
            is checked whether the handler can catch the current exception. For
            <literal>...</literal> handlers this is always true; for other
            handlers it is checked using the token:</para>
<programlisting>
~cpp.except.catch : ( EXP pti ) -&gt; EXP VARIETY int
</programlisting>

          <para>where the argument is a pointer to the run-time type
            information for the handler type. This token gives 1 if the exception
            is caught by this handler, and 0 otherwise. If the exception is not
            caught by the handler then the next handler is checked, until there
            are no more handlers associated with the <literal>try</literal>
            block. In this case control is passed back to the exception manager
            by re-throwing the current exception using
            <literal>~cpp.except.rethrow</literal>.</para>

          <para>If an exception is caught by a handler then a number of steps
            are performed. Firstly, if appropriate, the handler variable is
            initialised by copying the current exception value. A pointer to the
            current exception value can be obtained using the token:</para>
<programlisting>
~cpp.except.value : () -&gt; EXP pv
</programlisting>

          <para>Once this initialisation is complete the token:</para>
<programlisting>
~cpp.except.caught : () -&gt; EXP TOP
</programlisting>

          <para>is called to indicate that the exception has been caught. The
            handler body is then executed. When control exits from the handler,
            whether by reaching the end of the handler or by jumping out of it,
            the token:</para>
<programlisting>
~cpp.except.end : () -&gt; EXP TOP
</programlisting>

          <para>is called to indicate that the exception has been completed.
            Note that the implementation should call the destructor for the
            current exception and free the space allocated by
            <literal>~cpp.except.alloc</literal> at this point. Execution then
            continues with the statement following the handler.</para>

          <para>To conclude, the TDF generated for a <literal>try</literal>
            block and its associated list of handlers has the form:</para>
<programlisting>
variable (
  long_jump_access,
  stack_tag,
  make_value ( ~cpp.try.type ),
  conditional (
  handler_label,
  sequence (
   ~cpp.try.begin (
   obtain_tag ( stack_tag ),
   current_env,
   make_local_lv ( handler_label ) ),
   <emphasis>try-block-body</emphasis>,
   ~cpp.try.end ),
   conditional (
   catch_label_1,
   sequence (
 integer_test (
 not_equal,
 catch_label_1,
 ~cpp.except.catch (
   <emphasis>handler-1-typeid</emphasis> ) )
 variable (
 handler_tag_1,
 <emphasis>handler-1-init</emphasis> (
   ~cpp.except.value ),
 sequence (
   ~cpp.except.caught,
   <emphasis>handler-1-body</emphasis> ) )
 ~cpp.except.end )
   conditional (
 catch_label_2,
 <emphasis>further-handlers</emphasis>,
 ~cpp.except.rethrow ) ) ) )
</programlisting>

          <para>Note that for a local variable to maintain its previous value
            when an exception is caught in this way it is necessary to declare it
            using the TDF <literal>long_jump_access</literal> construct. Any
            local variable which contains a <literal>try</literal> block in its
            scope is declared in this way.</para>

          <para>To aid implementations in the writing of exception managers the
            following standard tokens are provided:</para>
<programlisting>
~cpp.ptr.code : () -&gt; SHAPE POINTER ca
~cpp.ptr.frame : () -&gt; SHAPE POINTER fa
~cpp.except.jump : ( EXP POINTER fa, EXP POINTER ca ) -&gt; EXP BOTTOM
</programlisting>

          <para>These give the shape of the TDF
            <literal>make_local_lv</literal> construct, the shape of the TDF
            <literal>current_env</literal> construct, and direct access to the
            TDF <literal>long_jump</literal> access. The exception manager in the
            default implementation is a function called
            <literal>__TCPPLUS_throw</literal>.</para>
        </sect3>

        <sect3 id='exception-spec'>
          <title>Exception specifications</title>

          <para>If a function is declared with an exception specification then
            extra code needs to be generated in the function definition to catch
            any unexpected exceptions thrown by the function and to call
            <literal>std::unexpected</literal> . Since this is a potentially high
            overhead for small functions, this extra code is not generated if it
            can be proved that such unexpected exceptions can never be thrown
            (the analysis is essentially the same as that in the
            <link linkend='exception-analysis'>exception analysis</link>
            check).</para>

          <para>The implementation of exception specification is to enclose the
            entire function definition in a <literal>try</literal> block. The
            handler for this block uses <literal>~cpp.except.catch</literal> to
            check whether the current exception can be caught by any of the types
            listed in the exception specification. If so the current exception is
            re-thrown. If none of these types catch the current exception then
            the token:</para>
<programlisting>
~cpp.except.bad : ( SIGNED_NAT ) -&gt; EXP TOP
</programlisting>

          <para>is called. The argument is 1 if the exception specification
            includes the special type <literal>std::bad_exception</literal>, and
            0 otherwise. The implementation should call
            <literal>std::unexpected</literal>, but how any exceptions thrown
            during this call are to be handled depends on the value of the
            argument.</para>
        </sect3>
      </sect2>

      <sect2 id='mangled-indentifer-names'>
        <title>Mangled identifier names</title>

        <para>In a similar fashion to other C++ compilers, the C++ producer
          needs a method of mapping C++ identifiers to a form suitable for
          further processing, namely TDF tag names. This mangled name contains an
          encoding of the identifier name, its parent namespace or class and its
          type. Identifiers with C linkage are not mangled. The producer contains
          a built-in <link linkend='tcpplus-u-option'>name unmangler</link>
          which performs the
          reverse operation of transforming the mangled form of an identifier
          name back to the underlying identifier. This can be useful when
          analysing system linker errors.</para>

        <para>Note that the type of an identifier forms part of its mangled
          name not only for functions, but also for variables. Many other
          compilers do not mangle variable names, however the ISO C++ rules on
          namespaces and variables with C linkage make it necessary (this can be
          suppressed using the <literal>-j-n</literal> command-line option).
          Declaring the language linkage of a variable inconsistently can
          therefore lead to linking errors with the C++ producer which are not
          detected by other compilers. A common example is:</para>
<programlisting>
extern int errno ;
</programlisting>

        <para>which, leaving aside whether <literal>errno</literal> is actually
          an external variable, should be:</para>
<programlisting>
extern &quot;C&quot; int errno ;
</programlisting>

        <para>As described above, the mangled form of an identifier has three
          components; the identifier name, the identifier namespace and the
          identifier type. Two underscores (<literal>__</literal>) are used to
          separate the name component from the namespace and type components. The
          mangling scheme used is based on that described in the ARM. The
          description below is not complete; the mangling and unmangling routines
          themselves should be consulted for a complete description.</para>

        <sect3 id='mangling-identifer-names'>
          <title>Mangling identifier names</title>

          <para>Simple identifier names are mapped to themselves. Unicode
            characters of the forms
            <literal>\u</literal><emphasis>xxxx</emphasis> and
            <literal>\U</literal><emphasis>xxxxxxxx</emphasis> are mapped to
            <literal>__k</literal><emphasis>xxxx</emphasis> and
            <literal>__K</literal><emphasis>xxxxxxxx</emphasis> respectively,
            where the hex digits are output in their canonical lower-case form.
            Constructors are mapped to <literal>__ct</literal> and destructors to
            <literal>__dt</literal>. Conversions functions are mapped to
            <literal>__op</literal><emphasis>type</emphasis> where
            <emphasis>type</emphasis> is the mangled form of the conversion type.
            Overloaded operator functions, <literal>operator@</literal>, are
            mapped as follows:</para>

          <table frame='all' id='overloaded-oper-funct'>
            <title>Overloaded Operator Functions</title>

            <tgroup cols='6'>
              <thead>
                <row>
                  <entry>Operator</entry>

                  <entry>Mapping</entry>

                  <entry>Operator</entry>

                  <entry>Operator</entry>

                  <entry>Mapping</entry>

                  <entry>Operator</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry>&amp;</entry>

                  <entry>__ad</entry>

                  <entry>&amp;=</entry>

                  <entry>__aad</entry>

                  <entry>[]</entry>

                  <entry>__vc</entry>
                </row>

                <row>
                  <entry>-&gt;</entry>

                  <entry>__rf</entry>

                  <entry>-&gt;*</entry>

                  <entry>__rm</entry>

                  <entry>=</entry>

                  <entry>__as</entry>
                </row>

                <row>
                  <entry>,</entry>

                  <entry>__cm</entry>

                  <entry>~</entry>

                  <entry>__co</entry>

                  <entry>/</entry>

                  <entry>__dv</entry>
                </row>

                <row>
                  <entry>/=</entry>

                  <entry>__adv</entry>

                  <entry>==</entry>

                  <entry>__eq</entry>

                  <entry>()</entry>

                  <entry>__cl</entry>
                </row>

                <row>
                  <entry>&gt;</entry>

                  <entry>__gt</entry>

                  <entry>&gt;=</entry>

                  <entry>__ge</entry>

                  <entry>&lt;</entry>

                  <entry>__lt</entry>
                </row>

                <row>
                  <entry>&lt;=</entry>

                  <entry>__le</entry>

                  <entry>&amp;&amp;</entry>

                  <entry>__aa</entry>

                  <entry>||</entry>

                  <entry>__oo</entry>
                </row>

                <row>
                  <entry>&lt;&lt;</entry>

                  <entry>__ls</entry>

                  <entry>&lt;&lt;=</entry>

                  <entry>__als</entry>

                  <entry>-</entry>

                  <entry>__mi</entry>
                </row>

                <row>
                  <entry>-=</entry>

                  <entry>__ami</entry>

                  <entry>--</entry>

                  <entry>__mm</entry>

                  <entry>!</entry>

                  <entry>__nt</entry>
                </row>

                <row>
                  <entry>!=</entry>

                  <entry>__ne</entry>

                  <entry>|</entry>

                  <entry>__or</entry>

                  <entry>|=</entry>

                  <entry>__aor</entry>
                </row>

                <row>
                  <entry>+</entry>

                  <entry>__pl</entry>

                  <entry>+=</entry>

                  <entry>__apl</entry>

                  <entry>++</entry>

                  <entry>__pp</entry>
                </row>

                <row>
                  <entry>%</entry>

                  <entry>__md</entry>

                  <entry>%=</entry>

                  <entry>__amd</entry>

                  <entry>&gt;&gt;</entry>

                  <entry>__rs</entry>
                </row>

                <row>
                  <entry>&gt;&gt;=</entry>

                  <entry>__ars</entry>

                  <entry>*</entry>

                  <entry>__ml</entry>

                  <entry>*=</entry>

                  <entry>__aml</entry>
                </row>

                <row>
                  <entry>^</entry>

                  <entry>__er</entry>

                  <entry>^=</entry>

                  <entry>__aer</entry>

                  <entry>delete</entry>

                  <entry>__dl</entry>
                </row>

                <row>
                  <entry>delete []</entry>

                  <entry>__vd</entry>

                  <entry>new</entry>

                  <entry>__nw</entry>

                  <entry>new []</entry>

                  <entry>__vn</entry>
                </row>

                <row>
                  <entry>?:</entry>

                  <entry>__cn</entry>

                  <entry>:</entry>

                  <entry>__cs</entry>

                  <entry>::</entry>

                  <entry>__cc</entry>
                </row>

                <row>
                  <entry>.</entry>

                  <entry>__df</entry>

                  <entry>.*</entry>

                  <entry>__dm</entry>

                  <entry>abs</entry>

                  <entry>__ab</entry>
                </row>

                <row>
                  <entry>max</entry>

                  <entry>__mx</entry>

                  <entry>min</entry>

                  <entry>__mn</entry>

                  <entry>sizeof</entry>

                  <entry>__sz</entry>
                </row>

                <row>
                  <entry>typeid</entry>

                  <entry>__td</entry>

                  <entry>vtable</entry>

                  <entry>__tb</entry>

                  <entry>-</entry>

                  <entry>-</entry>
                </row>
              </tbody>
            </tgroup>
          </table>

          <para>Note that this table contains a number of operators which are
            not part of C++ or cannot be overloaded in C++. These are used in the
            representation of target dependent integer constants.</para>
        </sect3>

        <sect3 id='mangling-namespace-names'>
          <title>Mangling namespace names</title>

          <para>The global namespace is mapped to an empty string. Simple
            namespace and class names are mapped as above, but are preceded by a
            series of decimal digits giving the length of the mangled name.
            Nested namespaces and classes are represented by a sequence of such
            namespace names, preceded by the number of elements in the sequence.
            This takes the form <literal>Q</literal><emphasis>digit</emphasis> if
            there are less than 10 elements, or
            <literal>Q_</literal><emphasis>digits</emphasis><literal>_</literal>
            if there are more than 10. Note that members of anonymous classes or
            namespaces are local to their translation unit, and so do not have
            external tag names.</para>
        </sect3>

        <sect3 id='mangling-types'>
          <title>Mangling types</title>

          <para>The mangling of types is essentially similar to that used in
            the <link linkend='symbol-table-dump'>symbol table dump</link>
            format. The type used in the
            mangled name for an identifier ignores the return type for a function
            and ignores the most significant bound for an array.</para>

          <para>The built-in types are mapped in precisely the same way as in
            the <link linkend='types'>symbol table dump</link>. Class and
            enumeration
            types are mapped to their type names mangled in the same way as the
            namespace names above. The exception to this is that in a class
            member, the parent class is mapped to <literal>X</literal>.</para>

          <para>The composite types are again mapped in a similar fashion to
            that in the <link linkend='composite-qual-types'>dump file</link>.
            For example,
            <literal>PCc</literal> represents <literal>const char *</literal>.
            The only difficult case concerns function parameter types where the
            ARM <literal>T</literal> and <literal>N</literal> encodings are used
            for duplicate parameter types. The function return type is included
            in the mangled form except for function identifier types. In the
            cases where the identifier is known always to represent a function
            (constructors, destructors etc.) the initial <literal>F</literal>
            indicating a function type is also omitted.</para>

          <para>The types of template functions and classes are represented by
            the underlying template and the template arguments giving rise to the
            instance. Template classes are preceded by <literal>t</literal>;
            template functions are preceded by <literal>G</literal> rather than
            <literal>F</literal>. Type arguments are represented by
            <literal>Z</literal> followed by the type value; non-type arguments
            are represented by the argument type followed by the argument value.
            In the underlying type the template parameters are represented by
            <literal>m0</literal>, <literal>m1</literal> etc. An alternative
            scheme, in which the mangled form of a template function includes the
            type of that instance, rather than the underlying template, can be
            enabled using the <literal>-j-f</literal> command-line option.</para>
        </sect3>

        <sect3 id='other-mangled-names'>
          <title>Other mangled names</title>

          <para>The <link linkend='virt-funct-tables'>virtual function
            table</link> for a class, when this
            is a variable with external linkage, is named
            <literal>__vt__</literal><emphasis>type</emphasis> , where
            <emphasis>type</emphasis> is the mangled form of the class name. The
            virtual function table for a base class is named
            <literal>__vt__</literal><emphasis>base</emphasis> where
            <emphasis>base</emphasis> is a sequence of mangled class names
            specifying the base class. The <link linkend='run-time-type-info'>
            run-time type information structure</link>
            for a type, when this is a variable with external linkage,
            is named <literal>__ti__</literal><emphasis>type</emphasis>, where
            <emphasis>type</emphasis> is the mangled form of the type
            name.</para>
        </sect3>

        <sect3 id='mangled-name-examples'>
          <title>Mangled name examples</title>

          <para>The following gives some examples of the name mangling
            scheme:</para>
<programlisting>
class A {
  static int a ;          // a__1Ai
public :
  A () ;              // __ct__1A
  A ( int ) ;             // __ct__1Ai
  A ( const A &amp; ) ;           // __ct__1ARCX
  virtual ~A () ;         // __dt__1A
  operator bool () ;          // __opb__1A
  bool operator! () ;         // __nt__1A
} ;

// virtual function table   __vt__1A
// run-time type information    __ti__1A

int f ( A *, int, A * ) ;       // f__FP1AiT1
int b = 2 ;             // b__i
int c [3] ;             // c__A_i

namespace N {
  int *p = 0 ;            // p__1NPi
}
</programlisting>
        </sect3>
      </sect2>
    </sect1>

    <sect1 id='standard-lib'>
      <title>Standard library</title>

      <para>At present the default implementation contains only a very small
        fraction of the ISO C++ library, namely those headers -
        <literal>&lt;exception&gt;</literal>, <literal>&lt;new&gt;</literal> and
        <literal>&lt;typeinfo&gt;</literal> - which are an integral part of the
        language specification. These headers are also those which require the
        most cooperation between the producer and the library implementation, as
        described in the <link linkend='implementation-details'>implementation
        details</link>.</para>

      <para>It is suggested that if further library components are required
        then they be acquired from third parties. It should be noted however that
        such libraries may require <link linkend='common-porting-prob'>some
        effort</link> to be ported to an
        ISO compliant compiler; for example, some information on porting the
        <literal>libio</literal> component of <literal>libg++</literal>, which
        contains some very compiler-dependent code, are <link
        linkend='porting-libio'>given below</link>.
        Libraries compiled with other C++ compilers may not link correctly with
        modules compiled using <literal>tcc</literal>.</para>

      <sect2 id='common-porting-prob'>
        <title>Common porting problems</title>

        <para>Experience in porting pre-ISO C++ programs has shown that the
          following new ISO C++ features tend to cause the most problems:</para>

        <orderedlist>
          <listitem>
            <para><link linkend='implicit-int'>Implicit <literal>int</literal>
              </link>has been banned.</para>
          </listitem>

          <listitem>
            <para><link linkend='string-literals-a'>String literals are now
              <literal>const</literal></link>, although in simple assignments
              the <literal>const</literal> is implicitly removed.</para>
          </listitem>

          <listitem>
            <para>The scope of a <link linkend='for-statements'>variable
              declared in a for-init-statement</link> is the
              <literal>for</literal> statement itself.</para>
          </listitem>

          <listitem>
            <para><link linkend='mangled-indentifer-names'>Variables have
              linkage</link> and so should be
              declared <literal>extern &quot;C&quot;</literal> if
              appropriate.</para>
          </listitem>

          <listitem>
            <para>The standard C library is now declared in the
              <literal>std</literal> namespace.</para>
          </listitem>

          <listitem>
            <para>The <link linkend='template-compilation'>template compilation
              model</link> has
              been clarified. The notation for explicit instantiation and
              specialisation has changed.</para>
          </listitem>

          <listitem>
            <para>Templates are analysed at their point of definition as well
              as their point of instantiation.</para>
          </listitem>

          <listitem>
            <para><link linkend='keywords'>New keywords</link> have been
              introduced.</para>
          </listitem>
        </orderedlist>

        <note>
          <para>Many of these features have controlling
            <literal>#pragma</literal> directives, so that it is possible to
            switch to using the pre-ISO features.</para>
        </note>
      </sect2>

      <sect2 id='porting-libio'>
        <title>Porting <literal>libio</literal></title>

        <para>Perhaps the library component which is most likely to be required
          is <literal>&lt;iostream&gt;</literal>. A readily available freeware
          implementation of a pre-ISO (i.e. non-template)
          <literal>&lt;iostream&gt;</literal> package is given by the
          <literal>libio</literal> component of <literal>libg++</literal>. This
          section describes some of the problems encountered in porting this
          package (version 2.7.1).</para>

        <para>The &man.tendra.tcc; compiler flags used
          in porting <literal>libio</literal> were:</para>
<programlisting>
tcc -Yposix -Yc++ -sC:cc
</programlisting>

        <para>indicating that the POSIX API is to be used and that the
          <literal>.cc</literal> suffix is used to identify C++ source
          files.</para>

        <para>In <literal>iostream.h</literal>, <literal>cin</literal>,
          <literal>cout</literal>, <literal>cerr</literal> and
          <literal>clog</literal> should be declared with C linkage, otherwise
          the C++ producer includes the type in the
          <link linkend='mangled-indentifer-names'>mangled name</link>
          and the fake <literal>iostream</literal> hacks in
          <literal>stdstream.cc</literal> don't work. The definition of
          <literal>EOF</literal> in this header can cause problems if both
          <literal>iostream.h</literal> and <literal>stdio.h</literal> are
          included. In this case <literal>stdio.h</literal> should be included
          first.</para>

        <para>In <literal>stdstream.cc</literal>, the
          <link linkend='derived-class-layout'>correct definitions</link> for
          the fake
          <literal>iostream</literal> structures are as follows:</para>
<programlisting>
struct _fake_istream::myfields {
  _ios_fields *vb ;       // pointer to virtual base class ios
  _IO_ssize_t _gcount ;   // istream fields
  void *vptr ;        // pointer to virtual function table
} ;

struct _fake_ostream::myfields {
  _ios_fields *vb ;       // pointer to virtual base class ios
  void *vptr ;        // pointer to virtual function table
} ;
</programlisting>

        <para>The fake definition macros are then defined as follows:</para>
<programlisting>
#define OSTREAM_DEF( NAME, SBUF, TIE, EXTRA_FLAGS )\
  extern &quot;C&quot; _fake_ostream NAME = { { &amp;NAME.base, 0 }, .... } ;

#define ISTREAM_DEF( NAME, SBUF, TIE, EXTRA_FLAGS )\
  extern &quot;C&quot; _fake_istream NAME = { { &amp;NAME.base, 0, 0 }, .... } ;
</programlisting>

        <note>
          <para>These are declared with C linkage as above.</para>
        </note>

        <para>In <literal>stdstrbufs.cc</literal>, the
          <link linkend='other-mangled-names'>correct definitions</link> for
          the virtual function table
          names are as follows:</para>
<programlisting>
#define filebuf_vtable      __vt__7filebuf
#define stdiobuf_vtable     __vt__8stdiobuf
</programlisting>

        <note>
          <para>The <literal>_G_VTABLE_LABEL_PREFIX</literal> macro is
            incorrectly defined by the configuration process (it should be
            <literal>__vt__</literal>), but the <literal>##</literal> directives
            in which it is used don't work on an ISO compliant preprocessor
            anyway (token concatenation takes place after replacement of macro
            parameters, but before further macro expansion). The dummy virtual
            function tables should also be declared with C linkage to suppress
            name mangling.</para>
        </note>

        <para>In addition, the initialisation of the standard streams relies on
          the file pointers <literal>stdout</literal> etc. being constant
          expressions, which in general they are not. The directive:</para>
<programlisting>
#pragma TenDRA++ rvalue token as const allow
</programlisting>

        <para>will cause the C++ producer to assume that all
          <link linkend='expression-tokens'>tokenised rvalue expressions</link>
          are constant.</para>

        <para>In <literal>streambuf.cc</literal>, if <literal>errno</literal>
          is to be explicitly declared it should have C linkage or be declared in
          the <literal>std</literal> namespace.</para>

        <para>In <literal>iomanip.cc</literal>, the explicit template
          instantiations should be prefixed by <literal>template</literal>. The
          corresponding template declarations in <literal>iomanip.h</literal>
          should be declared using
          <link linkend='template-compilation'><literal>export</literal></link>
          (note that the
          <literal>__GNUG__</literal> version uses <literal>extern</literal>,
          which may yet win out over <literal>export</literal>).</para>
      </sect2>
    </sect1>
  </chapter>

  <chapter id='program-overview'>
    <title>Program Overview</title>

    <para>The C++ producer is a large program (over 200000 lines, including
      automatically generated code) written in C. A description of the
      <link linkend='api-usage-target-dep'>API</link> observed and the basic
      organisation of the <link linkend='source-code-modules'>source
      code</link> are described in the first section.</para>

    <para>One of the design methods used in the C++ producer is the extensive
      use of automatic code generation tools. The type system is based around the
      <literal>calculus</literal> tool, which allows complex type systems to be
      described in a simple format. The interface generated by
      <literal>calculus</literal> allows for rigorous static type checking,
      generic type constructors for lists, stacks etc., encapsulation of the
      operations on the types within the system, and optional run-time checking
      for null pointers and discriminated union tags. An overview is given of the
      <link linkend='primitive-types'>type system</link> used as the basis of
      the C++ producer design.
      Also see the &doc.calculus; <literal>calculus</literal>
      users' guide.</para>

    <para>The other general purpose code generation tool used in the C++
      producer is the parser generator, <literal>sid</literal>. A brief
      description of the problems in writing a <link linkend='parsing-cpp'>
      C++ parser</link> is
      given. Also see the &doc.sid;.</para>

    <para>The other code generation tools used were written specifically for
      the C++ producer. The error reporting routines within the producer are
      based on an <link linkend='error-catalogue'>error catalogue</link>, from
      which code for constructing and printing errors is generated. The
      <link linkend='tdf-generation'>TDF output routines</link> are based on
      primitives automatically generated from a
      standard database describing the TDF specification.</para>

    <para>The program itself is well commented, so no lower level program
      documentation has been provided. When performing development work the
      producer should be compiled with the <literal>DEBUG</literal> macro
      defined. This enables the <literal>calculus</literal> run-time checks,
      along with other assertions, and makes available the debugging routines,
      <literal>DEBUG_</literal><emphasis>type</emphasis>, which can be used to
      print an object from the internal type system.</para>

    <sect1 id='source-code-org-style'>
      <title>Source Code Organisation / Style Guide</title>

      <para>This section describes the basic organisation of the source code
        for the C++ producer. This includes the application programming
        interface (API) observed and the division of the code into separate
        modules.</para>

      <sect2 id='api-usage-target-dep'>
        <title>API usage and target dependencies</title>

        <para>Most of the API features used in the C++ producer are to be found
          in the ISO C API, with just a couple of extensions from POSIX required.
          These POSIX features can be disabled with minimal loss of functionality
          by defining the macro <literal>FS_POSIX</literal> to be false.</para>

        <para>The following features are used from the ISO
          <literal>&lt;stdio.h&gt;</literal> header:</para>
<programlisting>
BUFSIZ      EOF     FILE        SEEK_SET
fclose      fflush      fgetc       fgets
fopen       fprintf     fputc       fputs
fread       fseek       fwrite      rewind
sprintf     stderr      stdin       stdout
vfprintf
</programlisting>

        <para>from the ISO <literal>&lt;stdlib.h&gt;</literal> header:</para>
<programlisting>
EXIT_SUCCESS    EXIT_FAILURE    NULL        abort
exit        free        malloc      realloc
size_t
</programlisting>

        <para>and from the ISO <literal>&lt;string.h&gt;</literal>
          header:</para>
<programlisting>
memcmp      memcpy      strchr      strcmp
strcpy      strlen      strncmp     strrchr
</programlisting>

        <para>The three headers just mentioned are included in all source files
          via the <literal>ossg_api.h</literal> header file (included by
          <literal>config.h</literal>). The remaining headers are only included
          as and when they are needed. The following features are used from the
          ISO <literal>&lt;ctype.h&gt;</literal> header:</para>
<programlisting>
isalpha     isprint
</programlisting>

        <para>from the ISO <literal>&lt;limits.h&gt;</literal> header:</para>
<programlisting>
UCHAR_MAX   UINT_MAX    ULONG_MAX
</programlisting>

        <para>from the ISO <literal>&lt;stdarg.h&gt;</literal> header:</para>
<programlisting>
va_arg      va_end      va_list     va_start
</programlisting>

        <note>
          <para>note that if <literal>FS_STDARG</literal> is false the XPG3
            <literal>&lt;varargs.h&gt;</literal> header is used instead</para>
        </note>

        <para>From the ISO <literal>&lt;time.h&gt;</literal> header:</para>
<programlisting>
localtime   time        time_t      struct tm
tm::tm_hour tm::tm_mday tm::tm_min  tm::tm_mon
tm::tm_sec  tm::tm_year
</programlisting>

        <para>The following features are used from the POSIX
          <literal>&lt;sys/stat.h&gt;</literal> header:</para>
<programlisting>
stat        struct stat stat::st_dev    stat::st_ino
stat::st_mtime
</programlisting>

        <para>The <literal>&lt;sys/types.h&gt;</literal> header is also
          included to provide the necessary types for
          <literal>&lt;sys/stat.h&gt;</literal>.</para>

        <para>There are a couple of target dependencies in the producer which
          can overridden using command-line options:</para>

        <orderedlist>
          <listitem>
            <para>It assumes that if a count of the number of characters read
              from an input file is maintained, then that count value can be used
              as an argument to <literal>fseek</literal>. This may not be true on
              machines where the end of line marker consists of both a newline
              and a carriage return. In this case the <literal>-m-f</literal>
              command-line option can be used to switch to a slower, but more
              portable, algorithm for setting file positions.</para>
          </listitem>

          <listitem>
            <para>It assumes that a file is uniquely determined by the
              <literal>st_dev</literal> and <literal>st_ino</literal> fields of
              its corresponding <literal>stat</literal> value. This is used when
              processing <literal>#include</literal> directives to prevent a file
              being read more than once if this is not necessary. This assumption
              may not be true on machines with a small <literal>ino_t</literal>
              type which have file systems mounted from machines with a larger
              <literal>ino_t</literal> type. In this case the
              <literal>-m-i</literal> command-line option can be used to disable
              this check.</para>
          </listitem>
        </orderedlist>
      </sect2>

      <sect2 id='source-code-modules'>
        <title>Source code modules</title>

        <para>For convenience, the source code is divided between a number of
          directories:</para>

        <orderedlist>
          <listitem>
            <para>The base directory contains only the module containing the
              <literal>main</literal> function, the basic type descriptions and
              the <literal>Makefile</literal>.</para>
          </listitem>

          <listitem>
            <para>The directories <literal>obj_c</literal> and
              <literal>obj_tok</literal> contain respectively the C and
              <literal>#pragma token</literal> headers generated from the type
              algebra by &doc.calculus; <literal>calculus</literal>
              . The directory <literal>obj_templ</literal> contains certain
              <literal>calculus</literal> template files.</para>
          </listitem>

          <listitem>
            <para>The directory <literal>utility</literal> contains routines
              for such utility operations as memory allocation and error
              reporting, including the <link linkend='error-catalogue'>error
              catalogue</link>.</para>
          </listitem>

          <listitem>
            <para>The directory <literal>parse</literal> contains routines
              concerned with parsing and preprocessing the input, including the
              &doc.sid; <literal>sid</literal> grammar.</para>
          </listitem>

          <listitem>
            <para>The directory <literal>construct</literal> contains routines
              for building up and analysing the internal representation of the
              parsed code.</para>
          </listitem>

          <listitem>
            <para>The directory <literal>output</literal> contains routines for
              outputting the internal representation in various formats including
              as a <link linkend='tdf-generation'>TDF capsule</link>, a
              <link linkend='cpp-spec-file'>C++ spec file</link>, or a
              <link linkend='symbol-table-dump'>symbol table dump</link>
              file.</para>
          </listitem>
        </orderedlist>

        <para>Each module consists of a C source file,
          <literal>file.c</literal> say, containing function definitions, and a
          corresponding header file <literal>file.h</literal> containing the
          declarations of these functions. The header is included within its
          corresponding source file to check these declarations; it is protected
          against multiple inclusions by a macro of the form
          <literal>FILE_INCLUDED</literal>. The header contains a brief comment
          describing the purpose of the module; each function in the source file
          contains a comment describing its purpose, its inputs and its
          output.</para>

        <para>The following table lists all the source modules in the C++
          producer with a brief description of the purpose of each:</para>

        <table frame='all' id='cpp-prod-modules'>
          <title>C++ Producer Modules</title>

          <tgroup cols='3'>
            <thead>
              <row>
                <entry>Module</entry>

                <entry>Directory</entry>

                <entry>Purpose</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>access</entry>

                <entry>construct</entry>

                <entry>member access control</entry>
              </row>

              <row>
                <entry>allocate</entry>

                <entry>construct</entry>

                <entry><literal>new</literal> and <literal>delete</literal>
                expressions</entry>
              </row>

              <row>
                <entry>assign</entry>

                <entry>construct</entry>

                <entry>assignment expressions</entry>
              </row>

              <row>
                <entry>basetype</entry>

                <entry>construct</entry>

                <entry>basic type operations</entry>
              </row>

              <row>
                <entry>buffer</entry>

                <entry>utility</entry>

                <entry>buffer reading and writing routines</entry>
              </row>

              <row>
                <entry>c_class</entry>

                <entry>obj_c</entry>

                <entry><literal>calculus</literal> support routines</entry>
              </row>

              <row>
                <entry>capsule</entry>

                <entry>output</entry>

                <entry>top-level TDF encoding routines</entry>
              </row>

              <row>
                <entry>cast</entry>

                <entry>construct</entry>

                <entry>cast expressions</entry>
              </row>

              <row>
                <entry>catalog</entry>

                <entry>utility</entry>

                <entry>error catalogue definition</entry>
              </row>

              <row>
                <entry>char</entry>

                <entry>parse</entry>

                <entry>character sets</entry>
              </row>

              <row>
                <entry>check</entry>

                <entry>construct</entry>

                <entry>expression checking</entry>
              </row>

              <row>
                <entry>chktype</entry>

                <entry>construct</entry>

                <entry>type checking</entry>
              </row>

              <row>
                <entry>class</entry>

                <entry>construct</entry>

                <entry>class and enumeration definitions</entry>
              </row>

              <row>
                <entry>compile</entry>

                <entry>output</entry>

                <entry>TDF tag definition encoding routines</entry>
              </row>

              <row>
                <entry>constant</entry>

                <entry>parse</entry>

                <entry>integer constant evaluation</entry>
              </row>

              <row>
                <entry>construct</entry>

                <entry>construct</entry>

                <entry>constructors and destructors</entry>
              </row>

              <row>
                <entry>convert</entry>

                <entry>construct</entry>

                <entry>standard type conversions</entry>
              </row>

              <row>
                <entry>copy</entry>

                <entry>construct</entry>

                <entry>expression copying</entry>
              </row>

              <row>
                <entry>debug</entry>

                <entry>utility</entry>

                <entry>development aids</entry>
              </row>

              <row>
                <entry>declare</entry>

                <entry>construct</entry>

                <entry>variable and function declarations</entry>
              </row>

              <row>
                <entry>decode</entry>

                <entry>output</entry>

                <entry>bitstream reading routines</entry>
              </row>

              <row>
                <entry>derive</entry>

                <entry>construct</entry>

                <entry>base class graphs; inherited members</entry>
              </row>

              <row>
                <entry>destroy</entry>

                <entry>construct</entry>

                <entry>garbage collection routines</entry>
              </row>

              <row>
                <entry>diag</entry>

                <entry>output</entry>

                <entry>TDF diagnostic output routines</entry>
              </row>

              <row>
                <entry>dump</entry>

                <entry>output</entry>

                <entry>symbol table dump routines</entry>
              </row>

              <row>
                <entry>encode</entry>

                <entry>output</entry>

                <entry>bitstream writing routines</entry>
              </row>

              <row>
                <entry>error</entry>

                <entry>utility</entry>

                <entry>error output routines</entry>
              </row>

              <row>
                <entry>exception</entry>

                <entry>construct</entry>

                <entry>exception handling</entry>
              </row>

              <row>
                <entry>exp</entry>

                <entry>output</entry>

                <entry>TDF expression encoding routines</entry>
              </row>

              <row>
                <entry>expression</entry>

                <entry>construct</entry>

                <entry>expression processing</entry>
              </row>

              <row>
                <entry>file</entry>

                <entry>parse</entry>

                <entry>low-level I/O routines</entry>
              </row>

              <row>
                <entry>function</entry>

                <entry>construct</entry>

                <entry>function definitions and calls</entry>
              </row>

              <row>
                <entry>hash</entry>

                <entry>parse</entry>

                <entry>hash table and identifier name routines</entry>
              </row>

              <row>
                <entry>identifier</entry>

                <entry>construct</entry>

                <entry>identifier expressions</entry>
              </row>

              <row>
                <entry>init</entry>

                <entry>output</entry>

                <entry>TDF initialiser expression encoding routines</entry>
              </row>

              <row>
                <entry>initialise</entry>

                <entry>construct</entry>

                <entry>variable initialisers</entry>
              </row>

              <row>
                <entry>instance</entry>

                <entry>construct</entry>

                <entry>template instances and specialisations</entry>
              </row>

              <row>
                <entry>inttype</entry>

                <entry>construct</entry>

                <entry>integer and floating point type routines</entry>
              </row>

              <row>
                <entry>label</entry>

                <entry>construct</entry>

                <entry>labels and jumps</entry>
              </row>

              <row>
                <entry>lex</entry>

                <entry>parse</entry>

                <entry>lexical analysis</entry>
              </row>

              <row>
                <entry>literal</entry>

                <entry>parse</entry>

                <entry>integer and string literals</entry>
              </row>

              <row>
                <entry>load</entry>

                <entry>output</entry>

                <entry>C++ spec reading routines</entry>
              </row>

              <row>
                <entry>macro</entry>

                <entry>parse</entry>

                <entry>macro expansion</entry>
              </row>

              <row>
                <entry>main</entry>

                <entry>-</entry>

                <entry>main routine; command-line arguments</entry>
              </row>

              <row>
                <entry>mangle</entry>

                <entry>output</entry>

                <entry>identifier name mangling</entry>
              </row>

              <row>
                <entry>member</entry>

                <entry>construct</entry>

                <entry>member selector expressions</entry>
              </row>

              <row>
                <entry>merge</entry>

                <entry>construct</entry>

                <entry>intermodule merge routines</entry>
              </row>

              <row>
                <entry>namespace</entry>

                <entry>construct</entry>

                <entry>namespaces; name look-up</entry>
              </row>

              <row>
                <entry>operator</entry>

                <entry>construct</entry>

                <entry>overloaded operators</entry>
              </row>

              <row>
                <entry>option</entry>

                <entry>utility</entry>

                <entry>compiler options</entry>
              </row>

              <row>
                <entry>overload</entry>

                <entry>construct</entry>

                <entry>overload resolution</entry>
              </row>

              <row>
                <entry>parse</entry>

                <entry>parse</entry>

                <entry>low-level parser routines</entry>
              </row>

              <row>
                <entry>pragma</entry>

                <entry>parse</entry>

                <entry><literal>#pragma</literal> directives</entry>
              </row>

              <row>
                <entry>predict</entry>

                <entry>parse</entry>

                <entry>parser look-ahead routines</entry>
              </row>

              <row>
                <entry>preproc</entry>

                <entry>parse</entry>

                <entry>preprocessing directives</entry>
              </row>

              <row>
                <entry>print</entry>

                <entry>utility</entry>

                <entry>error argument printing routines</entry>
              </row>

              <row>
                <entry>quality</entry>

                <entry>construct</entry>

                <entry>extra expression checks</entry>
              </row>

              <row>
                <entry>redeclare</entry>

                <entry>construct</entry>

                <entry>variable and function redeclarations</entry>
              </row>

              <row>
                <entry>rewrite</entry>

                <entry>construct</entry>

                <entry>inline member function definitions</entry>
              </row>

              <row>
                <entry>save</entry>

                <entry>output</entry>

                <entry>C++ spec writing routines</entry>
              </row>

              <row>
                <entry>shape</entry>

                <entry>output</entry>

                <entry>TDF shape encoding routines</entry>
              </row>

              <row>
                <entry>statement</entry>

                <entry>construct</entry>

                <entry>statement processing</entry>
              </row>

              <row>
                <entry>stmt</entry>

                <entry>output</entry>

                <entry>TDF statement encoding routines</entry>
              </row>

              <row>
                <entry>struct</entry>

                <entry>output</entry>

                <entry>TDF structure encoding routines</entry>
              </row>

              <row>
                <entry>syntax[0-9]*</entry>

                <entry>parse</entry>

                <entry><literal>sid</literal> parser output</entry>
              </row>

              <row>
                <entry>system</entry>

                <entry>utility</entry>

                <entry>system dependent routines</entry>
              </row>

              <row>
                <entry>table</entry>

                <entry>parse</entry>

                <entry>portability table reading</entry>
              </row>

              <row>
                <entry>template</entry>

                <entry>construct</entry>

                <entry>template declarations and checks</entry>
              </row>

              <row>
                <entry>throw</entry>

                <entry>output</entry>

                <entry>TDF exception handling encoding routines</entry>
              </row>

              <row>
                <entry>tok</entry>

                <entry>output</entry>

                <entry>TDF standard tokens encoding</entry>
              </row>

              <row>
                <entry>tokdef</entry>

                <entry>construct</entry>

                <entry>token definitions</entry>
              </row>

              <row>
                <entry>token</entry>

                <entry>construct</entry>

                <entry>token declarations and expansion</entry>
              </row>

              <row>
                <entry>typeid</entry>

                <entry>construct</entry>

                <entry>run-time type information</entry>
              </row>

              <row>
                <entry>unmangle</entry>

                <entry>output</entry>

                <entry>identifier name unmangling</entry>
              </row>

              <row>
                <entry>variable</entry>

                <entry>construct</entry>

                <entry>variable analysis</entry>
              </row>

              <row>
                <entry>virtual</entry>

                <entry>construct</entry>

                <entry>virtual functions</entry>
              </row>

              <row>
                <entry>xalloc</entry>

                <entry>utility</entry>

                <entry>memory allocation routines</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </sect2>
    </sect1>

    <sect1 id='type-system'>
      <title>Type System</title>

      <para>This section describes the type system used in the C++ producer.
        Unless otherwise stated the types are declared using the
        &doc.calculus; <literal>calculus</literal> tool as part of
        the algebra, <literal>c_class.alg</literal>. The design of this type
        algebra was clearly largely based on the concepts underlying the C++
        language; however TDF provided an important influence, not merely as the
        intended target language, but also because of its clear presentation of
        essential language features.</para>

      <sect2 id='primitive-types'>
        <title>Primitive types</title>

        <para>The primitive types used within the algebra
          <literal>c_class</literal> are defined as follows:</para>
<programlisting>
int = &quot;int&quot; ;
unsigned = &quot;unsigned&quot; ;
string = &quot;character *&quot; ;
ulong_type (ulong) = &quot;unsigned long&quot; ;
BITSTREAM_P (bits) = &quot;BITSTREAM *&quot; ;
PPTOKEN_P (pptok) = &quot;PPTOKEN *&quot; ;
</programlisting>

        <para>The integral types are self-explanatory. All string literals used
          in the C++ producer are based on the character type:</para>
<programlisting>
typedef unsigned char character ;
</programlisting>

        <para>hence the definition of <literal>string</literal>. The remaining
          primitive give links to those portions of the type system which are
          defined outside of the algebra. The types
          <link linkend='bitstream'><literal>BITSTREAM</literal></link> and
          <link linkend='pptoken'><literal>PPTOKEN</literal></link> are
          described below.</para>
      </sect2>

      <sect2 id='cv-spec'>
        <title><literal>CV_SPEC</literal></title>

        <para>The enumeration type <literal>CV_SPEC</literal> (short name
          <literal>cv</literal>) is used to represent a C++ type qualifier. It
          takes the form of a bitfield, the elements of which can be or-ed
          together to represent combinations of type qualifiers. The
          cv-qualifiers are represented by <literal>cv_const</literal> and
          <literal>cv_volatile</literal> in the obvious manner. The value
          <literal>cv_lvalue</literal> is used as a qualifier to indicate whether
          a type is an lvalue or an rvalue. Other values are used in function
          types to represent the function language linkage.</para>
      </sect2>

      <sect2 id='builtin-type'>
        <title><literal>BUILTIN_TYPE</literal></title>

        <para>The enumeration type <literal>BUILTIN_TYPE</literal>
          (<literal>ntype</literal>) is used to represent the built-in C++ types
          (<literal>char</literal>, <literal>float</literal>,
          <literal>void</literal> etc.). It is used chiefly as an index into
          tables of type information.</para>
      </sect2>

      <sect2 id='base-type'>
        <title><literal>BASE_TYPE</literal></title>

        <para>The enumeration type <literal>BASE_TYPE</literal>
          (<literal>btype</literal>) is used to represent a C++ simple type
          specifier such as <literal>signed</literal>, <literal>short</literal>
          or <literal>int</literal>. It takes the form of a bitfield, the
          elements of which can be or-ed together to represent combinations of
          type specifiers. Its chief use is when reading a type from the input
          file; the various simple type specifiers are combined to give a value
          of this type, which is then mapped to an actual
          <link linkend='type-directive'>C++ type</link>.</para>
      </sect2>

      <sect2 id='int-type'>
        <title><literal>INT_TYPE</literal></title>

        <para>The union type <literal>INT_TYPE</literal>
          (<literal>itype</literal>) is used to represent an integral or bitfield
          C++ type. The basic integral types are given by the
          <literal>basic</literal> field. Bitfield types are represented by the
          <literal>bitfield</literal> field. There are also fields representing
          target dependent integral promotion, arithmetic and integer literal
          types, plus <literal>VARIETY</literal> tokens. Only one
          <literal>INT_TYPE</literal> object is created for each integral
          type.</para>
      </sect2>

      <sect2 id='float-type'>
        <title><literal>FLOAT_TYPE</literal></title>

        <para>The union type <literal>FLOAT_TYPE</literal>
          (<literal>ftype</literal>) is used to represent a floating point C++
          type. The basic floating point types are given by the
          <literal>basic</literal> field. There are also fields representing
          target dependent argument promotion and arithmetic types, plus
          <literal>FLOAT</literal> tokens. Only one <literal>FLOAT_TYPE</literal>
          object is created for each floating point type.</para>
      </sect2>

      <sect2 id='class-info'>
        <title><literal>CLASS_INFO</literal></title>

        <para>The enumeration type <literal>CLASS_INFO</literal>
          (<literal>cinfo</literal>) is used to represent information relating to
          a class or enumeration definition. It takes the form of a bitfield, the
          elements of which can be or-ed together to represent various
          combinations of properties.</para>
      </sect2>

      <sect2 id='class-usage'>
        <title><literal>CLASS_USAGE</literal></title>

        <para>The enumeration type <literal>CLASS_USAGE</literal>
          (<literal>cusage</literal>) is used to represent information relating
          to the way a class is used. It takes the form of a bitfield, the
          elements of which can be or-ed together to represent various
          combinations of properties.</para>
      </sect2>

      <sect2 id='class-type'>
        <title><literal>CLASS_TYPE</literal></title>

        <para>The union type <literal>CLASS_TYPE</literal>
          (<literal>ctype</literal>) is used to represent a C++ class or union.
          The main components are an
          <link linkend='identifier'>identifier</link> giving the class name,
          <link linkend='class-info'>class information</link> and
          <link linkend='class-usage'>class usage</link> fields, a
          <link linkend='namespace'>namespace</link> giving the class members, a
          <link linkend='graph'>graph</link>
          representing the base class structure, and a <link linkend='virtual'>
          virtual function table</link>. Only one <literal>CLASS_TYPE</literal>
          object is created for each class or union.</para>

        <para>Each class maintains a list, <literal>pals</literal>, of class
          and function identifiers which are declared as friends of that class.
          It also maintains a list, <literal>chums</literal>, of those class
          types which declare it to be a friend (this is what is actually used in
          the access checks). Similarly each function identifier maintains a
          list, <literal>chums</literal>, of those class types which declare it
          to be a friend.</para>

        <para>Each class maintains a list of its constructors, destructors and
          conversion functions (included inherited conversion functions). It also
          maintains a list of its virtual base classes. This information can be
          obtained by other means but it is more convenient to record it within
          the class type itself.</para>
      </sect2>

      <sect2 id='graph'>
        <title><literal>GRAPH</literal></title>

        <para>The union type <literal>GRAPH</literal>
          (<literal>graph</literal>) is used to represent a directed acyclic
          graph arising from the base classes of a class. Each node of the graph
          has a <literal>head</literal> which is a <link linkend='class-type'>
          class type</link>, and
          several <literal>tails</literal> which give the base class graphs for
          that class. Each node has pointers, <literal>top</literal>, to the top
          of the graph (i.e. the most derived class), and <literal>up</literal>,
          to the node of which the current node is a direct base. Each node also
          has an <literal>access</literal> field which gives information on the
          base access, whether it is virtual or not, and so on, in the form of a
          <link linkend='decl-spec'><literal>DECL_SPEC</literal></link>.
          Virtual bases are handled by
          the <literal>equal</literal> field which defines an equivalence
          relation on the graph which identifies equivalent virtual bases.</para>
      </sect2>

      <sect2 id='virtual'>
        <title><literal>VIRTUAL</literal></title>

        <para>The union type <literal>VIRTUAL</literal>
          (<literal>virt</literal>) is used to represent the virtual functions
          declared in a class. The <literal>table</literal> field is used to
          represent a virtual function table, and consists primarily of a list of
          <literal>VIRTUAL</literal> objects giving the virtual functions for the
          associated class. These virtual functions are of four kinds, each
          represented by a union field. A virtual function first declared in a
          class is represented by the <literal>simple</literal> field; a virtual
          function in a class which overrides an inherited virtual function is
          represented by the <literal>override</literal> field; an inherited,
          non-overridden virtual function which is not overridden in a base class
          is represented by the <literal>inherit</literal> field; a inherited,
          non-overridden virtual function which is overridden in some base class
          is represented by the <literal>complex</literal> field.</para>
      </sect2>

      <sect2 id='enum-type'>
        <title><literal>ENUM_TYPE</literal></title>

        <para>The union type <literal>ENUM_TYPE</literal>
          (<literal>etype</literal>) is used to represent a C++ enumeration type.
          This consists primarily of an
          <link linkend='identifier'>identifier</link> giving the
          enumeration name, a <link linkend='class-info'>class
          information</link> field, a
          <link linkend='type-directive'>type</link> giving the underlying
          representation of the enumeration
          type, and a list of <link linkend='identifier'>identifier</link>
          giving the enumerators
          comprising the enumeration.</para>
      </sect2>

      <sect2 id='type'>
        <title><literal>TYPE</literal></title>

        <para>The union type <literal>TYPE</literal> (<literal>type</literal>)
          is used to represent a C++ type. Every type has an associated
          <link linkend='cv-spec'>type qualifier</link>,
          <literal>qual</literal>, which determines
          whether the type is <literal>const</literal>,
          <literal>volatile</literal> or an lvalue. A type may also have an
          associated <link linkend='identifier'>identifier</link>,
          <literal>name</literal>, giving the
          corresponding type name (the null identifier being used for unnamed
          types). The other type components are determined by the union tag. Each
          of the type constructs above has a corresponding field in the
          <literal>TYPE</literal> union: <literal>integer</literal> for
          <link linkend='int-type'>integral types</link>,
          <literal>floating</literal> for <link linkend='float-type'>floating
          point types</link>, <literal>bitfield</literal> for
          <link linkend='int-type'>bitfield types</link>,
          <literal>compound</literal> for <link linkend='class-type'>class or
          union types</link>, and <literal>enumerate</literal> for
          <link linkend='enum-type'>enumeration types</link>. There are also
          fields <literal>top</literal> and <literal>bottom</literal>
          corresponding to
          <literal>void</literal> and bottom (the type used to represent values
          which never return).</para>

        <para>Other fields of the <literal>TYPE</literal> union represent
          composite types; for example, the <literal>array</literal> field,
          representing array types, comprises a base type,
          <literal>sub</literal>, and an <link linkend='nat'>integer
          constant</link> giving the
          array bound, <literal>size</literal>. These are generally simple, apart
          from <literal>func</literal>, representing a function type. This has
          the obvious components: a return type, <literal>ret</literal>, a list
          of parameter types, <literal>ptypes</literal>, and a flag indicating
          ellipsis functions, <literal>ellipsis</literal>. It also has an
          associated <link linkend='namespace'>namespace</link>,
          <literal>pars</literal>, in which
          the function parameters are declared. The parameter identifiers are
          extracted from this as a list, <literal>pids</literal>. Member function
          qualifiers and language linkage information are represented by a
          <link linkend='cv-spec'><literal>CV_QUAL</literal></link>,
          <literal>mqual</literal>. The
          implicit extra parameter for member functions is recorded in the list
          <literal>mtypes</literal>, which adds this extra type to the start of
          <literal>ptypes</literal>. Finally <literal>except</literal> gives any
          exception specifiers; the case where the exception specifier is absent
          being represented by the special value,
          <literal>univ_type_set</literal>.</para>
      </sect2>

      <sect2 id='decl-spec'>
        <title><literal>DECL_SPEC</literal></title>

        <para>The enumeration type <literal>DECL_SPEC</literal>
          (<literal>dspec</literal>) is used to represent information on the
          declaration and usage of an identifier. It takes the form of a
          bitfield, the elements of which can be or-ed together to represent
          various combinations of properties. The 32 bits in this bitfield (the
          maximum which can be represented portably) are a significant
          restriction. This means that the same member of
          <literal>DECL_SPEC</literal> is often used to mean different things in
          different contexts. This can prove confusing on occasions.</para>
      </sect2>

      <sect2 id='hashid'>
        <title><literal>HASHID</literal></title>

        <para>The union type <literal>HASHID</literal>
          (<literal>hashid</literal>) is used to represent a C++ identifier name.
          The simplest form of identifier name, <literal>name</literal>, consists
          of just a string of characters, such as <literal>foo</literal>.
          Extended identifier names, <literal>ename</literal>, are similar, but
          may contain Unicode characters. There are however other forms of
          identifier name in C++: conversion function names
          (<literal>conv</literal> ) such as <literal>operator int</literal>,
          overloaded operator names (<literal>op</literal>) such as
          <literal>operator+</literal>, constructor names
          (<literal>constr</literal>), and destructor names
          (<literal>destr</literal>). There are also names which are used for
          anonymous identifiers (<literal>anon</literal>).</para>

        <para>Note the distinction between an identifier name and an actual
          <link linkend='identifier'>identifier</link>. The latter is a meaning
          associated with a name in
          a particular context. Every identifier name has an associated
          underlying meaning, <literal>id</literal>. This is used to handle
          keywords and macros, but for most identifier names this will be a dummy
          identifier. Nested underlying meanings (such as a macro hiding a
          keyword) are handled by linking the <literal>alias</literal> fields of
          the corresponding identifiers. Every identifier name also has a
          <literal>cache</literal> field which is used to record the look-up of
          this name as an unqualified identifier. This may be set to the null
          identifier to indicate that the look-up needs to be
          re-evaluated.</para>

        <para>Identifier names are stored in one of a small number of hash
          tables, linked using their <literal>next</literal> field. Each name has
          only one entry in these tables, allowing equality of names to be
          implemented as <literal>EQ_hashid</literal>.</para>
      </sect2>

      <sect2 id='qualifier'>
        <title><literal>QUALIFIER</literal></title>

        <para>The enumeration type <literal>QUALIFIER</literal>
          (<literal>qual</literal>) is used to represent the various ways in
          which an identifier name can be qualified. For example,
          <literal>::A::a</literal> is represented by
          <literal>qual_full</literal>. The value <literal>qual_mark</literal> is
          used in the representation of function identifier expressions to
          indicate that overload resolution has been performed.</para>
      </sect2>

      <sect2 id='identifier'>
        <title><literal>IDENTIFIER</literal></title>

        <para>The union type <literal>IDENTIFIER</literal>
          (<literal>id</literal>) is used to represent the various kinds of C++
          identifiers. Every identifier has an associated
          <link linkend='hashid'>identifier name</link>, a parent
          <link linkend='namespace'>namespace</link>, a
          <link linkend='decl-spec'>declaration</link>
          information field, and a <link linkend='location'>location</link> for
          its declaration or
          definition. Each identifier also has an <literal>alias</literal> field
          which is normally used to represent the aliasing which can occur in
          inheritance or <literal>using</literal> declarations.</para>

        <para>The various fields of the <literal>IDENTIFIER</literal> union
          correspond to the various kinds of identifier which can arise in C++ -
          class names, functions, variables, class members, macros, keywords etc.
          Each field has appropriate components giving its type, its definition
          or whatever other information is required. For example, the
          <literal>variable</literal> field has a
          <link linkend='type-directive'>type</link> and two
          <link linkend='exp'>expressions</link>, giving the constructor and
          destructor values for
          the object.</para>

        <para>Most of these identifier components are self-explanatory, however
          the treatment of overloaded functions bears discussion. The various
          fields representing functions have an <literal>over</literal> component
          which is used to link overloaded functions together. A set of
          overloaded functions is treated as if it were a single
          <literal>IDENTIFIER</literal> - the first in the list - for the
          purposes of storing in a <link linkend='namespace'>member
          namespace</link> member; the other
          overloaded meanings are accessed by chasing down the
          <literal>over</literal> components. In other situations, whether a
          function identifier represents a single function or a set of overloaded
          functions can be worked out from the context. For example, in
          identifier expressions the <link linkend='qualifier'>identifier
          qualifier</link> is used to
          mark whether overload resolution has taken place.</para>
      </sect2>

      <sect2 id='member'>
        <title><literal>MEMBER</literal></title>

        <para>The union type <literal>MEMBER</literal>
          (<literal>member</literal>) is used to represent a member of a
          <link linkend='namespace'>namespace</link>. Each member contains two
          identifiers,
          <literal>id</literal> and <literal>alt</literal>. The
          <literal>id</literal> field gives the meaning associated with a
          particular name in this namespace; the <literal>alt</literal> field is
          used to represent a type name which may be hidden by a non-type
          name.</para>

        <para>There are two kinds of member, <literal>small</literal> and
          <literal>large</literal>, corresponding to whether the namespace holds
          its members in a simple linked list or in a hash table.</para>
      </sect2>

      <sect2 id='namespace'>
        <title><literal>NAMESPACE</literal></title>

        <para>The union type <literal>NAMESPACE</literal>
          (<literal>nspace</literal>) is used to represent the set of identifiers
          declared in a particular scope. For example, the members declared in a
          C++ class or namespace, the parameters declared in a function
          declarator and the local variables declared in a block all form scopes.
          The various kinds of scope are distinguished as different fields of the
          union, but there are basically two categories. The first, such as
          function blocks, which have relatively small numbers of elements, store
          their members as a simple linked lists. The second, such as classes,
          which have larger numbers of elements, store their members in hash
          tables. In both cases the elements are stored using the
          r<literal>MEMBER</literal> type.</para>

        <para>The key operation on a namespace is to look up a particular
          <link linkend='hashid'>identifier name</link> in its linked list or hash table of
          members to find the meaning, if any, associated with that name in the
          namespace. This can be a complex operation because of the need to take
          base classes and <literal>using</literal> directives (as stored in the
          <literal>use</literal> component) into account.</para>
      </sect2>

      <sect2 id='nat'>
        <title><literal>NAT</literal></title>

        <para>The union type <literal>NAT</literal> (<literal>nat</literal>) is
          used to represent an integer constant expression. Values are
          represented as lists of 16 bit 'digits'. Values which fit into a single
          digit are represented by the <literal>small</literal> field; larger
          values by the <literal>large</literal> field. Negated values can be
          represented by the <literal>neg</literal> field. Folding of integer
          constant expressions is performed in the producer, however the result
          can only be represented as described above if its value is target
          independent. Target dependent values are represented by the
          <literal>calc</literal> field which contains an <link linkend='exp'>
          expression</link>
          describing how to calculate the value. The <literal>token</literal>
          field is used to represent <literal>NAT</literal> tokens.</para>

        <para>Objects representing small integer constants are created at the
          start of the program and stored in a table for ease of access. Larger
          constants are created as and when they are required.</para>
      </sect2>

      <sect2 id='float'>
        <title><literal>FLOAT</literal></title>

        <para>The union type <literal>FLOAT</literal> (<literal>flt</literal>)
          is used to represent a floating point constant expression. There is
          only one field, <literal>simple</literal> , which corresponds to a
          floating point literal. No folding of floating point constant
          expressions is attempted in the producer (it is virtually impossible to
          do so in a target independent manner).</para>

        <para>Objects representing useful floating point constants (0.0, 1.0
          etc.) are created for each floating point type and stored as part of
          the corresponding <link linkend='float-type'><literal>FLOAT_TYPE
          </literal></link>. Other
          values are created as and when they are required.</para>
      </sect2>

      <sect2 id='string'>
        <title><literal>STRING</literal></title>

        <para>The union type <literal>STRING</literal> (<literal>str</literal>)
          is used to represent a string constant expression. There is only one
          field, <literal>simple</literal>, which corresponds to a character
          string literal, however the <literal>kind</literal> field can be used
          to modify the interpretation put on the characters appearing in the
          <literal>text</literal> field. By default, each character in
          <literal>text</literal> corresponds to a single character in the
          literal; however an alternative representation, in which
          <literal>text</literal> consists of a sequence of multibyte characters
          - one control character plus four value characters - is used in more
          complex cases.</para>

        <para>All strings are stored in a hash table intended to ensure that
          the same <literal>STRING</literal> object is used for equal string
          literals. This not only saves space during the processing of the input
          file, but also facilitates the output of shared string literals in the
          TDF capsule.</para>

        <para>Note that the terminal zero character does not form part of the
          <literal>STRING</literal> object. Instead information on this is stored
          as part of the type of a <link linkend='exp'>string literal
          expression</link>. The text
          of the string literal is either truncated or padded with zeros until
          its length matches the size of the array bound in the type of the
          corresponding literal expression.</para>
      </sect2>

      <sect2 id='ntext'>
        <title><literal>NTEST</literal></title>

        <para>The enumeration type <literal>NTEST</literal>
          (<literal>ntest</literal>) is used to represent the various C++
          relational operators (<literal>==</literal>, <literal>!=</literal>,
          <literal>&gt;</literal> etc.). The values correspond to the encoding of
          the TDF <literal>NTEST</literal> sort, which facilitates code
          generation. The values also have the property that the values for
          complementary operators (such as <literal>&lt;</literal> and
          <literal>&gt;=</literal>) always add up to the same value,
          <literal>ntest_negate</literal>, allowing operators to be complemented
          in a straightforward manner.</para>
      </sect2>

      <sect2 id='rmode'>
        <title><literal>RMODE</literal></title>

        <para>The enumeration type <literal>RMODE</literal>
          (<literal>rmode</literal>) is used to represent the various C++
          rounding modes (towards zero, towards smaller etc.). The values
          correspond to the encoding of the TDF <literal>RMODE</literal> sort,
          which facilitates code generation.</para>
      </sect2>

      <sect2 id='exp'>
        <title><literal>EXP</literal></title>

        <para>The union type <literal>EXP</literal> (<literal>exp</literal>) is
          used to represent a C++ expression or statement. Each expression has an
          associated <link linkend='type-directive'>type</link>,
          <literal>type</literal>, but most of the
          information about an expression is stored in one of the large number of
          fields of the <literal>EXP</literal> union. Most of these fields are
          fairly simple. For example, there are fields corresponding to
          <link linkend='nat'>integer literals</link>, <link linkend='float'>
          floating point literals</link>,
          <link linkend='string'>string literals</link> and
          <link linkend='identifier'>identifiers</link>. Composite
          expressions are formed in the normal way; for example, there are
          various binary operators comprising two argument expressions. The
          <literal>EXP</literal> fields corresponding to statements are slightly
          more complex. They each have a <literal>parent</literal> field which
          points to the enclosing statement. A couple of cases bear additional
          discussion.</para>

        <para>The <literal>sequence</literal> field represents a compound
          statement or block. This contains a <link linkend='namespace'>
          namespace</link>, in which
          any local variables are declared, and a list of expressions, giving the
          statements comprising the block. The null namespace is used if the
          block does not constitute a scope. The first statement in the list is
          always a dummy to enable <literal>first</literal> and
          <literal>last</literal> pointers to be maintained to the start and end
          of the list without having to worry about null lists.</para>

        <para>The <literal>solve_stmt</literal> field corresponds to
          the TDF <literal>labelled</literal> construct (in early versions of TDF
          this construct was called <literal>solve</literal>, hence the
          terminology). The problem is that C and C++ labels and
          <literal>goto</literal>s are totally unstructured, whereas the TDF
          label constructs are structured. Any statement which contains
          unstructured labels is enclosed in a <literal>solve_stmt</literal>
          construct, enclosing both the labelled statement and all jumps to it
          (in general this cannot be done until the end of the function). Any
          labels or variables which are bypassed by such unstructured jumps also
          need to be pulled out to the <literal>solve_stmt</literal> construct.
          It is not just explicit labels which can cause such problems; complex
          <literal>switch</literal> statements have the same effect.</para>
      </sect2>

      <sect2 id='offset'>
        <title><literal>OFFSET</literal></title>

        <para>The union type <literal>OFFSET</literal> (<literal>off</literal>)
          is used to represent an offset expression. This is used as an adjunct
          to the normal <link linkend='exp'>expression</link> representation.
          The
          <literal>OFFSET</literal> union has fields corresponding to a type
          offset (used in pointer arithmetic), the offset of a member of a class
          and the offset of a base class. There are also simple operations on
          offsets, such as multiplication by an expression.</para>
      </sect2>

      <sect2 id='token'>
        <title><literal>TOKEN</literal></title>

        <para>The union type <literal>TOKEN</literal> (<literal>tok</literal>)
          is used to represent one of a number of different categories within the
          C++ language. It corresponds to the sort of a token declared using the
          <link linkend='token-syntax'><literal>#pragma token</literal>
          syntax</link>. Thus there are
          fields corresponding to expression, statement, integer constant, type,
          function, member and procedure tokens. The similarities between
          <literal>PROC</literal> tokens and templates have been remarked above;
          for example, the parameters of the template:</para>
<programlisting>
template &lt; class T, int n &gt; class A {
  T a [n] ;
  // ....
} ;
</programlisting>

        <para>are essentially equivalent to those in the procedure
          token:</para>
<programlisting>
PROC ( TYPE T, EXP const : int : n ) ....
</programlisting>

        <para>(recall that non-type template arguments are always constant
          expressions). Thus a field, <literal>templ</literal>, of the
          <literal>TOKEN</literal> union is used to represent lists of template
          parameters. Note that a further field, <literal>class</literal>, is
          also required to represent template template parameters. A
          <link linkend='type-directive'>template type</link> is represented by
          a field,
          <literal>templ</literal>, of the union <literal>TYPE</literal>, which
          comprises a template sort and a sub-type expressed in terms of the
          template parameters.</para>

        <para>In addition to representing token and template sorts in this way,
          the <literal>TOKEN</literal> union is used to represent token and
          template arguments. Each of the parameter sorts listed above has an
          appropriate <literal>value</literal> component which can store a value
          of that sort. Many of the union types in the algebra, including
          <link linkend='type-directive'>types</link> and <link linkend='exp'>
          expressions</link>, have a field of the
          form:</para>
<programlisting>
token -&gt; {
  IDENTIFIER tok ;
  LIST TOKEN args ;
}
</programlisting>

        <para>representing the given token <link linkend='identifier'>identifier</link>applied to the
          given list of arguments.</para>

        <anchor id='template-form'>
        <para>Template instances are represented slightly differently
          from token applications. Each instance of a template class or a
          template function gives rise to a new class or function
          <link linkend='identifier'>identifier</link> This identifier has an underlying form giving the
          template identifier and the template arguments. This is expressed as a
          <literal>token</literal> member of the
          <link linkend='type-directive'><literal>TYPE</literal></link> union
          (although it is not
          technically a type, this happens to be the most convenient
          representation). Each such form has an associated
          <link linkend='instance'><literal>INSTANCE</literal></link> component
          which gives further
          information about the template instance. The form for a template
          function instance is stored in the <literal>form</literal> component of
          the corresponding <link linkend='identifier'>identifier</link>. The
          form for a template class
          instance is stored in the <literal>form</literal> component of the
          corresponding <link linkend='class-type'>class type</link>.</para>

        <para>Members of instances of template classes also have a form type,
          but in this case the form is an <literal>instance</literal> type. This
          gives a link back to the corresponding member of the template
          class.</para>
      </sect2>

      <sect2 id='instance'>
        <title><literal>INSTANCE</literal></title>

        <para>The union type <literal>INSTANCE</literal>
          (<literal>inst</literal>) is used to represent a particular instance of
          a template or token. Each <link linkend='token'>template sort</link>
          has an associated
          list of all the instances of that template, which is used to ensure
          that the same template applied with the same arguments always has the
          same value. Information on partial or explicit specialisations and
          usage information are stored as part of the corresponding
          <literal>INSTANCE</literal>. Each template instance identifier has a
          link back to its corresponding <literal>INSTANCE</literal> via its
          <link linkend='template-form'><literal>form</literal>
          component</link>.</para>
      </sect2>

      <sect2 id='error'>
        <title><literal>ERROR</literal></title>

        <para>The union type <literal>ERROR</literal> (<literal>err</literal>)
          is used to represent an error arising during the compilation of a C++
          program. Errors are first class objects within the producer and can be
          passed to and from procedures. Each error has an associated
          <literal>severity</literal> (error, warning, none etc.). Simple
          errors are represented by the <literal>simple</literal> field, which
          consists of an index, <literal>number</literal>, into the error
          catalogue, plus a variable length list of error arguments. Errors can
          be combined into composite errors using the <literal>compound</literal>
          field, which represents the join of two errors -
          <literal>head</literal> followed by <literal>tail</literal>.</para>

        <para>The chief operation on an error after it has been built up is to
          report it. Each error report consists of an error object and a
          <link linkend='file-locations'>file location</link> indicating where
          the error occurred.</para>
      </sect2>

      <sect2 id='variable'>
        <title><literal>VARIABLE</literal></title>

        <para>The structure type <literal>VARIABLE</literal>
          (<literal>var</literal>) is used to represent a variable state and is
          used in the variable analysis checks.</para>
      </sect2>

      <sect2 id='location'>
        <title><literal>LOCATION</literal></title>

        <para>The structure type <literal>LOCATION</literal>
          (<literal>loc</literal>) is used to represent a location in an input
          file. It comprises a pointer to an <link linkend='position'>input
          file position</link>,
          <literal>posn</literal>, modified by a line number, taking
          <literal>#line</literal> directives into account,
          <literal>line</literal>. Note that character positions within the line
          are not currently recorded.</para>
      </sect2>

      <sect2 id='position'>
        <title><literal>POSITION</literal></title>

        <para>The structure type <literal>POSITION</literal>
          (<literal>posn</literal>) is used to represent a position in an input
          file. It consists of two file names, <literal>file</literal> taking
          <literal>#line</literal> directives into account, and
          <literal>input</literal> giving the actual file name, plus a line
          number offset, <literal>offset</literal>, which gives the difference
          between the line number taking <literal>#line</literal> directives into
          account and the actual line number. Other information stored includes
          the datestamp on the input file, <literal>datestamp</literal>, and a
          pointer to a <link linkend='file-locations'>file location</link>
          which, for files included using
          <literal>#include</literal>, gives the location the file was included
          from.</para>
      </sect2>

      <sect2 id='bitstream'>
        <title><literal>BITSTREAM</literal></title>

        <para>The structure <literal>BITSTREAM</literal> is not part of the
          <literal>calculus</literal> type system. It is used to represent a
          sequence of bits such as is used, for example, in the encoding of
          TDF.</para>
      </sect2>

      <sect2 id='buffer'>
        <title><literal>BUFFER</literal></title>

        <para>The structure <literal>BUFFER</literal> is not part of the
          <literal>calculus</literal> type system. It is used to represent a
          sequence of characters.</para>
      </sect2>

      <sect2 id='options'>
        <title><literal>OPTIONS</literal></title>

        <para>The structure <literal>OPTIONS</literal> is not part of the
          <literal>calculus</literal> type system. It is used to represent the
          state of the <link linkend='low-level-conf'>compiler options</link>
          at a particular point in the input file.</para>
      </sect2>

      <sect2 id='pptoken'>
        <title><literal>PPTOKEN</literal></title>

        <para>The structure <literal>PPTOKEN</literal> is not part of the
          <literal>calculus</literal> type system. It is used to represent a
          linked list of preprocessing tokens. Each token has an associated
          <literal>sid</literal> lexical token number, <literal>tok</literal>,
          plus additional data dependent on the token type. Each token also
          records a pointer to the current <link linkend='options'>
          <literal>OPTIONS</literal></link>
          value.</para>
      </sect2>
    </sect1>

    <sect1 id='error-catalogue'>
      <title>Error catalogue</title>

      <para>This section describes the error catalogue which lies at the heart
        of the C++ producer's error reporting routines. The full
        <link linkend='error-catalogue-syntax'>error catalogue syntax</link> is
        given as an annex. A typical entry in the catalogue is as
        follows:</para>
<programlisting>
class_union_deriv(CLASS_TYPE: ct)
{
  USAGE:      error
  PROPERTIES: iso
  KEY (ISO)   &quot;9.5&quot;
  KEY (STD)   &quot;The union '&quot;ct&quot;' can't have base classes&quot;
}
</programlisting>

      <para>This defines an error, <literal>class_union_deriv</literal>, which
        takes a single parameter <literal>ct</literal> of type
        <literal>CLASS_TYPE</literal>. The severity of this error is
        <literal>error</literal>; that is to say, a constraint error. The error
        property <literal>iso</literal> indicates that the error arises from the
        ISO C++ standard (in the actual file <literal>iso</literal> is the
        default and thus omitted), the associated <literal>ISO</literal> key
        indicating
        section 9.5. Finally the text to be printed for this error, including a
        reference to <literal>ct</literal>, is given. Looking up section 9.5 in
        the ISO C++ standard reveals the corresponding constraint in paragraph
        1:</para>

      <blockquote>
        <para><emphasis>A union shall not have base classes.</emphasis></para>
      </blockquote>

      <para>Each constraint within the ISO C++ standard has a corresponding
        error in this way. The errors are named in a systematic fashion using the
        section names used in the draft standard. For example, section 9.5 is
        called <literal>class.union</literal>, so all the constraint errors
        arising from this section have names of the form
        <literal>class_union_*</literal>. These error names can be used in the
        <link linkend='low-level-conf'>low level directives</link> such
        as:</para>
<programlisting>
#pragma TenDRA++ error &quot;class_union_deriv&quot; <emphasis>allow</emphasis>
</programlisting>

      <para>to modify the error severity. The effect of reducing the severity
        of a constraint error in this way is undefined.</para>

      <para>In addition to the obvious error severity levels,
        <literal>error</literal>, <literal>warning</literal> and
        <literal>none</literal>, the error catalogue specifies a list of optional
        severity levels along with their default values. For example, the
        entry:</para>
<programlisting>
link_incompat = error
</programlisting>

      <para>sets up an option named <literal>link_incompat</literal> which is a
        constraint error by default. Errors with this severity, such as:</para>
<programlisting>
dcl_stc_internal(LONG_ID: id, PTR_LOC: loc)
{
  USAGE:      link_incompat
  KEY (ISO)   &quot;7.1.1&quot;
  KEY (STD)   &quot;'&quot;id&quot;' previously declared with internal linkage (at &quot;loc&quot;)&quot;
}
</programlisting>

      <para>are therefore constraint errors. The severity associated with
        <literal>link_incompat</literal> can be modified either
        <link linkend='low-level-conf'>directly</link>, using the
        directive:</para>
<programlisting>
#pragma TenDRA++ option &quot;link_incompat&quot; <emphasis>allow</emphasis>
</programlisting>

      <para>or <link linkend='object-linkage'>indirectly</link> using the
      directive:</para>
<programlisting>
#pragma TenDRA incompatible linkage <emphasis>allow</emphasis>
</programlisting>

      <para>the effect being to modify the severity of the associated error
        messages.</para>

      <para>The error catalogue is processed by a simple tool,
        <literal>make_err</literal>, which generates C code which is compiled
        into the C++ producer. Each error in the catalogue is assigned a number
        (there are currently 984 errors in the catalogue) which gives an index
        into an automatically generated table of error information. It is this
        error number, together with a list of error arguments, which forms the
        associated <link linkend='primitive-types'><literal>ERROR</literal>
        object</link>.
        <literal>make_err</literal> generates a macro for each error in the
        catalogue which takes arguments of the appropriate types (which may be
        statically checked) and creates an <literal>ERROR</literal> object. For
        example, for the entry above this macro takes the form:</para>
<programlisting>
ERROR ERR_class_union_deriv(CLASS_TYPE);
</programlisting>

      <para>These macros hide the error catalogue numbers from the rest of the
        C++ producer.</para>

      <para>It is also possible to join a number of simple
        <literal>ERROR</literal> objects to form a single composite
        <literal>ERROR</literal>. The severity of the composite error is the
        maximum of the severities of the component errors. To this purpose a
        dummy error severity level <literal>whatever</literal> is introduced
        which is less severe than any other level. This is intended for use with
        error messages which are only ever used to add information to existing
        errors, and which inherit their severity level from the main
        error.</para>

      <para>The text of a simple error message can be found in the table of
        error information. The text contains certain escape sequences indicating
        where the error arguments are to be printed. For example,
        <literal>%1</literal> indicates the second argument. The error argument
        sorts - what is referred to as the error signature - is also stored in
        the table of error information as an array of characters, each
        corresponding to an <literal>ERR_KEY_</literal><emphasis>type</emphasis>
        macro. The producer defines printing routines for each of the types given
        by these values, and calls the appropriate routine to print the
        argument.</para>

      <para>There are several command-line options which can be used to modify
        the form in which the error message is printed. The default format is as
        follows:</para>
<programlisting>
&quot;file.C&quot;, line 42: Error:
  [ISO C++98 9.5]: The union 'U' can't have base classes.
</programlisting>

      <para>The ISO section number can be suppressed using
        <literal>-m-s</literal>. The <literal>-mc</literal> option causes the
        source code line giving rise to the error to be printed as part of the
        message, with <literal>!!!!</literal> marking the position of the error
        within the line. The <literal>-me</literal> option causes the error name,
        <literal>class_union_deriv</literal>, to be printed as part of the
        message. The <literal>-ml</literal> option causes the full file location,
        including the list of <literal>#include</literal> directives used in
        reaching the file, to be printed. The <literal>-mt</literal> option
        causes <literal>typedef</literal> names to be used when printing types,
        rather than expanding to the type definition.</para>
    </sect1>

    <sect1 id='parsing-cpp'>
      <title>Parsing C++</title>

      <para>The parser used in the C++ producer is generated using the
        &doc.sid; <literal>sid</literal> tool. Because of the
        large size of the generated code (650kB), <literal>sid</literal>
        splits the output into a number of more manageable modules.</para>

      <para><literal>sid</literal> is designed as a parser for grammars which
        can be transformed into LL(1) grammars. The distinguishing feature of
        these grammars is that the parser can always decide what to do next based
        on the current terminal. This is not the case in C++; in some
        circumstances a potentially unlimited look-ahead is required to
        distinguish, for example, declaration statements from expression
        statements. In the technical phrase, C++ is an LL(k) grammar. Fortunately
        there are relatively few such situations, and <literal>sid</literal>
        provides a mechanism, predicates,
        for bypassing the normal parsing mechanism in these cases. Thus it is
        possible, although difficult, to express C++ as a <literal>sid</literal>
        grammar.</para>

      <para>The <literal>sid</literal> grammar file,
        <literal>syntax.sid</literal>, is closely based on the ISO C++ grammar.
        In particular, the same production names have been used. The grammar has
        been extended slightly to allow common syntactic errors to be detected
        elegantly. Other parsing errors are handled by <literal>sid</literal>'s
        exception mechanism. At present there is only limited recovery after such
        errors.</para>

      <para>The lexical analysis routines in the C++ producer are hand-crafted,
        based on an initial version generated by the simple lexical analyser
        generator, <literal>lexi</literal>. <literal>lexi</literal> has been used
        more directly to generate the lexical analysers for certain of the other
        automatic code generating tools, including <literal>calculus</literal>,
        used in the producer.</para>

      <para>The <literal>sid</literal> grammar contains a number of entry
        points. The most important is <literal>parse_file</literal>, which is
        used to parse a complete C++ translation unit. The syntax for the
        <link linkend='configuration'><literal>#pragma TenDRA</literal></link>
        directives is included
        within the same grammar with two entry points,
        <literal>parse_tendra</literal> in normal use, and
        <literal>parse_preproc</literal> for use in preprocessing mode. There are
        also entry points in the grammar for each of the kinds of
        <link linkend='token-arguments'>token argument</link>. The parsing
        routines for token and
        template arguments are largely hand-crafted, based on these
        primitives.</para>

      <para>Certain parsing operations are performed before control passes to
        the <literal>sid</literal> grammar. As mentioned above, these include the
        processing of token and template applications. The other important case
        concerns nested name specifiers. For example, in:</para>
<programlisting>
class A {
  class B {
static int c ;
  } ;
} ;

int A::B::c = 0 ;
</programlisting>

      <para>the qualified identifier <literal>A::B::c</literal> is split into
        two terminals, a nested name specifier, <literal>A::B::</literal>, and an
        identifier, <literal>c</literal>, which is looked up in the corresponding
        namespace. Note that it is at this stage that name look-up occurs. An
        identifier can be mapped to one of a number of terminals, including
        keywords, type names, namespace names and other identifiers, according to
        the result of this look-up. If the look-up gives a macro then this is
        expanded at this stage.</para>
    </sect1>

    <sect1 id='tdf-generation'>
      <title>TDF generation</title>

      <para>The TDF encoding as a bitstream is expressed as a series of macros
        generated by the <literal>make_tdf</literal> tool from the TDF
        specification database. Note that the version of the TDF database used
        contains a couple of corrections from the standard version:</para>

      <orderedlist>
        <listitem>
          <para>A construct <literal>make_token_def</literal> has been added to
            represent a token definition.</para>
        </listitem>

        <listitem>
          <para>The sort <literal>diag_tag</literal> has been added to the edge
            constructors.</para>
        </listitem>
      </orderedlist>

      <para>The macros generated only handle the encoding of the construct -
        the construct parameters need to be encoded by hand (the C producer does
        something similar, but including the construct parameters). For example,
        <literal>make_tdf</literal> generates a macro:</para>
<programlisting>
void ENC_plus ( BITSTREAM * ) ;
</programlisting>

      <para>which encodes the <literal>plus</literal> construct (91 as 7 bits
        in extended format). A typical use of this macro, for adding the
        expressions <literal>a</literal> and <literal>b</literal> would
        be:</para>
<programlisting>
ENC_plus ( bs ) ;
ENC_impossible ( bs ) ;
bs = enc_exp ( bs, a ) ;
bs = enc_exp ( bs, b ) ;
</programlisting>

      <para>Each function or variable is compiled to TDF as its definition is
        encountered. For some definitions, such as inline functions, the
        compilation may be deferred until it is clear whether or not the
        identifier has been used. There is a final pass over all identifiers
        during the variable analysis routines which incorporates this check.
        Because of the organisation of a TDF capsule it is necessary to store all
        of the compiled TDF in memory until the end of the program, when the
        complete capsule, including external tag and token names and linkage
        information, is written to the output file.</para>
    </sect1>
  </chapter>


  <chapter id='manpages'>
    <title>Manual Pages</title>
      <refentry id='tcpplus-manpage'>
        &tcpplus.manpage;
      </refentry>
  </chapter>



  <appendix id='pragma-directive-syntax'>
    <title><literal>#pragma</literal> directive syntax</title>


    <para>The following gives a summary of the syntax for the
      <literal>#pragma</literal> directives used for
      <link linkend='configuration'>compiler configuration</link>
      and <link linkend='token-syntax'>token specification</link>:</para>

    <informaltable frame="none" id='pragma-directive' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>pragma-directive:</emphasis></entry>
          </row>
          
          <row>
            <entry></entry>
            <entry><literal>#pragma TenDRA ++<subscript>opt</subscript></literal>
              <link linkend='tendra-directive'><emphasis>tendra-directive</emphasis></link></entry>
          </row>

          <row>
            <entry></entry>
            <entry><literal>#pragma</literal>
              <link linkend='token-directive'><emphasis>token-directive</emphasis></link></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='tendra-directive' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>tendra-directive:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><link linkend='scope-directive'><emphasis>scope-directive</emphasis></link></entry>
          </row>

          <row>
            <entry></entry>
            <entry><link linkend='low-level-directive'><emphasis>low-level-directive</emphasis></link></entry>
          </row>

          <row>
            <entry></entry>
            <entry><link linkend='analysis-directive'><emphasis>analysis-directive</emphasis></link>
              <link linkend='on'><emphasis>on</emphasis></link></entry>
          </row>

          <row>
            <entry></entry>
            <entry><link linkend='check-directive'><emphasis>check-directive</emphasis></link>
              <link linkend='allow'><emphasis>allow</emphasis></link></entry>
          </row>

          <row>
            <entry></entry>
            <entry><link linkend='keyword-directive'><emphasis>keyword-directive</emphasis></link></entry>
          </row>

          <row>
            <entry></entry>
            <entry><link linkend='type-directive'><emphasis>type-directive</emphasis></link></entry>
          </row>

          <row>
            <entry></entry>
            <entry><link linkend='linkage-directive'><emphasis>linkage-directive</emphasis></link></entry>
          </row>

          <row>
            <entry></entry>
            <entry><link linkend='misc-directive'><emphasis>misc-directive</emphasis></link></entry>
          </row>

          <row>
            <entry></entry>
            <entry><link linkend='tendra-token-directive'><emphasis>tendra-token-directive</emphasis></link></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='on' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>on:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><literal>on</literal></entry>
          </row>

          <row>
            <entry></entry>
            <entry><literal>warning</literal></entry>
          </row>

          <row>
            <entry></entry>
            <entry><literal>off</literal></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='allow' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>allow:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><literal>allow</literal></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>warning</literal></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>disallow</literal></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='scope-directive' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>scope-directive:</emphasis></entry>
            <entry><link linkend='checking-scopes'>Description</link></entry>
          </row>

          <row>
            <entry></entry>
            <entry><literal>begin</literal></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>begin name environment</literal> <emphasis>identifier</emphasis></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>end</literal></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>directory</literal> <emphasis>identifier</emphasis>
              <literal>use environment</literal> <emphasis>identifier</emphasis></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>use environment</literal> <emphasis>identifier</emphasis></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>use environment</literal> <emphasis>identifier</emphasis>
              <literal>reset</literal> <link linkend='allow'><emphasis>allow</emphasis></link></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='low-level-directive' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>low-devel-directive:</emphasis></entry>
            <entry><link linkend='low-level-conf'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>error</literal> <emphasis>string-literal</emphasis>
              <link linkend='allow'><emphasis>allow</emphasis></link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>error</literal> <emphasis>string-literal</emphasis>
               <link linkend='on'><emphasis>on</emphasis></link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>error</literal> <emphasis>string-literal</emphasis>
              <literal>as option</literal> <emphasis>string-literal</emphasis></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>option</literal> <emphasis>string-literal</emphasis>
              <link linkend='allow'><emphasis>allow</emphasis></link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>option</literal> <emphasis>string-literal</emphasis>
              <link linkend='on'><emphasis>on</emphasis></link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>option value</literal> <emphasis>string-literal integer-literal</emphasis></entry>
            <entry><link linkend='implementation-limits'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>use error</literal> <emphasis>string-literal</emphasis></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='analysis-directive' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>analysis-directive:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><literal>complete initialization analysis</literal></entry>
            <entry><link linkend='initialiser-expr'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>complete struct / union analysis</literal></entry>
            <entry><link linkend='elaborated-specifiers'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>conversion analysis</literal> <link linkend='conversion-spec'>
              <emphasis>conversion-spec<subscript>opt</subscript></emphasis></link></entry>
            <entry><link linkend='type-conversations'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>discard analysis</literal> <link linkend='discard-spec'>
              <emphasis>discard-spec<subscript>opt</subscript></emphasis></link></entry>
            <entry><link linkend='discarded-expressions'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>enum switch analysis</literal></entry>
            <entry><link linkend='switch-statements'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>external function linkage</literal></entry>
            <entry><link linkend='object-linkage'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>for initialization block</literal></entry>
            <entry><link linkend='for-statements'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>ignore struct / union / enum tag</literal></entry>
            <entry><link linkend='elaborated-specifiers'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>implicit export template</literal></entry>
            <entry><link linkend='template-compilation'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>implicit function declaration</literal></entry>
            <entry><link linkend='implicit-function-decl'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>integer operator analysis</literal></entry>
            <entry><link linkend='expressions'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>integer overflow analysis</literal></entry>
            <entry><link linkend='expressions'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>nested comment analysis</literal></entry>
            <entry><link linkend='comments'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>operator precedence analysis</literal></entry>
            <entry><link linkend='expressions'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>pointer operator analysis</literal></entry>
            <entry><link linkend='expressions'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>throw analysis</literal></entry>
            <entry><link linkend='configuration'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>unify external linkage</literal></entry>
            <entry><link linkend='object-linkage'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>variable analysis</literal></entry>
            <entry><link linkend='variable-flow-analysis'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>variable hiding analysis</literal></entry>
            <entry><link linkend='variable-hiding'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>weak prototype analysis</literal></entry>
            <entry><link linkend='weak-function-prototypes'>Description</link></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='conversion-spec' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>conversion-spec:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><literal>( int - int</literal> <link linkend='implicit-spec'>
              <emphasis>implicit-spec<subscript>opt</subscript></emphasis></link> <literal>)</literal></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>( int - pointer</literal> <link linkend='implicit-spec'>
              <emphasis>implicit-spec<subscript>opt</subscript></emphasis></link> <literal>)</literal></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>( pointer - int</literal> <link linkend='implicit-spec'>
              <emphasis>implicit-spec<subscript>opt</subscript></emphasis></link> <literal>)</literal></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>( pointer - pointer</literal> <link linkend='implicit-spec'>
              <emphasis>implicit-spec<subscript>opt</subscript></emphasis></link> <literal>)</literal></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>( int - enum implicit )</literal></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>( pointer - void * implicit )</literal></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>( void * - pointer implicit )</literal></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='implicit-spec' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>implicit-spec:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><literal>implicit</literal></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>explicit</literal></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='discard-spec' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>discard-spec:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><literal>( function return )</literal></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>( static )</literal></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>( value )</literal></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='check-directive' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>check-directive:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><literal>ambiguous overload resolution</literal></entry>
            <entry><link linkend='overloaded-funct'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>assignment as bool</literal></entry>
            <entry><link linkend='conditional-iteration'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>bitfield overflow</literal></entry>
            <entry><link linkend='bitfield-types-b'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>block function static</literal></entry>
            <entry><link linkend='object-linkage'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>catch all</literal></entry>
            <entry><link linkend='other-checks'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>character escape overflow</literal></entry>
            <entry><link linkend='escape-sequences'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>compatible token</literal></entry>
            <entry><link linkend='defining-tokens'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>complete file includes</literal></entry>
            <entry><link linkend='inclusion-directives'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>conditional declaration</literal></entry>
            <entry><link linkend='target-dep-conditional'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>conditional lvalue</literal></entry>
            <entry><link linkend='lvalue-expressions'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>conditional overload resolution</literal>
              <link linkend='overload-spec'><emphasis>overload-spec<subscript>opt</subscript></emphasis>
              </link></entry>
            <entry><link linkend='overloaded-funct'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>const conditional</literal></entry>
            <entry><link linkend='conditional-iteration'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>declaration after code</literal></entry>
            <entry><link linkend='mixed-decl'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>directive as macro argument</literal></entry>
            <entry><link linkend='macro-definitions'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>dollar as ident</literal></entry>
            <entry><link linkend='identifier-names'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>empty macro argument</literal></entry>
            <entry><link linkend='macro-definitions'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>extra ,</literal></entry>
            <entry><link linkend='elaborated-specifiers'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>extra ;</literal></entry>
            <entry><link linkend='empty-decl'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>extra ; after conditional</literal></entry>
            <entry><link linkend='conditional-iteration'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>extra ...</literal></entry>
            <entry><link linkend='weak-function-prototypes'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>extra bitfield int type</literal></entry>
            <entry><link linkend='bitfield-types-b'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>extra macro definition</literal></entry>
            <entry><link linkend='macro-definitions'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>extra type definition</literal></entry>
            <entry><link linkend='decl'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>extra type qualifier</literal></entry>
            <entry><link linkend='type-qualifiers'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>extra type qualifier (typedef)</literal></entry>
            <entry><link linkend='type-qualifiers'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>fall into case</literal></entry>
            <entry><link linkend='switch-statements'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>flexible array member</literal></entry>
            <entry><link linkend='flex-array-members'>Description</link></entry>
          </row>

          <row>
            <entry></entry>
            <entry><literal>for declaration</literal></entry>
            <entry><link linkend='for-statements'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>forward enum declaration</literal></entry>
            <entry><link linkend='elaborated-specifiers'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>function pointer as pointer</literal></entry>
            <entry><link linkend='type-conversations'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>hexadecimal float literal</literal></entry>
            <entry><link linkend='hex-float-lit'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>ident ...</literal></entry>
            <entry><link linkend='ellipsis-functions'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>identifier __func__</literal></entry>
            <entry><link linkend='predefined-identifiers'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>implicit int type</literal>
              <link linkend='inttype-spec'><emphasis>inttype-spec<subscript>opt</subscript></emphasis>
              </link></entry>
            <entry><link linkend='implicit-int'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>implicit token definition</literal></entry>
            <entry><link linkend='defining-tokens'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>incompatible interface declaration</literal></entry>
            <entry><link linkend='token-specifcations'>Description</link> </entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>incompatible member declaration</literal></entry>
            <entry><link linkend='member-tokens'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>incompatible linkage</literal></entry>
            <entry><link linkend='object-linkage'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>incompatible promoted function argument</literal></entry>
            <entry><link linkend='weak-function-prototypes'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>incompatible type qualifier</literal></entry>
            <entry><link linkend='compat'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>incompatible void return</literal></entry>
            <entry><link linkend='return-statements'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>incomplete type as object type</literal></entry>
            <entry><link linkend='incomplete-types'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>indented # directive</literal></entry>
            <entry><link linkend='preprocessing-directives'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>indented directive after #</literal></entry>
            <entry><link linkend='preprocessing-directives'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>initialization of struct / union ( auto )</literal></entry>
            <entry><link linkend='initialiser-expr'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>line comment</literal></entry>
            <entry><link linkend='comments'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>longlong type</literal></entry>
            <entry><link linkend='extended-integral'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>no directive / nline after ident</literal></entry>
            <entry><link linkend='preprocessing-directives'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>no external declaration</literal></entry>
            <entry><link linkend='empty-source-files'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>no ident after #</literal></entry>
            <entry><link linkend='macro-definitions'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>no nline after file end</literal></entry>
            <entry><link linkend='lexical-analysis'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>no space after macro</literal></entry>
            <entry><link linkend='macro-definitions'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>no token definition</literal></entry>
            <entry><link linkend='defining-tokens'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>overload resolution</literal></entry>
            <entry><link linkend='overloaded-funct'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>prototype</literal></entry>
            <entry><link linkend='weak-function-prototypes'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>prototype ( weak )</literal></entry>
            <entry><link linkend='weak-function-prototypes'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>rvalue token as const</literal></entry>
            <entry><link linkend='expression-tokens'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>text after directive</literal></entry>
            <entry><link linkend='preprocessing-directives'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>this lvalue</literal></entry>
            <entry><link linkend='lvalue-expressions'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>unify incompatible string literal</literal></entry>
            <entry><link linkend='string-literals-a'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>unknown directive</literal></entry>
            <entry><link linkend='preprocessing-directives'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>unknown escape</literal></entry>
            <entry><link linkend='escape-sequences'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>unknown pragma</literal></entry>
            <entry><link linkend='preprocessing-directives'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>unknown struct / union</literal></entry>
            <entry><link linkend='empty-decl'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>unmatched quote</literal></entry>
            <entry><link linkend='string-literals-a'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>unreachable code</literal></entry>
            <entry><link linkend='unreached-code-analysis'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>variable argument macro</literal></entry>
            <entry><link linkend='macro-definitions'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>variable initialization</literal></entry>
            <entry><link linkend='initialiser-expr'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>variable initialization of struct/union
              (auto)</literal></entry>
            <entry><link linkend='initialiser-expr'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>weak macro equality</literal></entry>
            <entry><link linkend='macro-definitions'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>writeable string literal</literal></entry>
            <entry><link linkend='string-literals-a'>Description</link></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='inttype-spec' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>inttype-spec:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><literal>for const / volatile</literal></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>for external declaration</literal></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>for function return</literal></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='overload-spec' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>overload-spec:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><literal>( complete )</literal></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>( incomplete )</literal></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='keyword-directive' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>keyword-directive:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><literal>keyword</literal> <emphasis>identifier</emphasis> <literal>for</literal>
              <link linkend='keyword-spec'><emphasis>keyword-spec</emphasis></link></entry>
            <entry><link linkend='keyword-directive'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>undef keyword</literal> <emphasis>identifier</emphasis></entry>
            <entry><link linkend='keyword-spec'>Description</link></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='keyword-spec' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>keyword-spec:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><literal>discard value</literal></entry>
            <entry><link linkend='discarded-expressions'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>discard variable</literal></entry>
            <entry><link linkend='variable-flow-analysis'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>exhaustive</literal></entry>
            <entry><link linkend='switch-statements'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>fall into case</literal></entry>
            <entry><link linkend='switch-statements'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>keyword</literal> <emphasis>identifier</emphasis></entry>
            <entry><link linkend='keywords'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>operator</literal> <emphasis>operator</emphasis></entry>
            <entry><link linkend='keywords'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>set</literal></entry>
            <entry><link linkend='variable-flow-analysis'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>set reachable</literal></entry>
            <entry><link linkend='unreached-code-analysis'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>set unreachable</literal></entry>
            <entry><link linkend='unreached-code-analysis'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>type representation</literal></entry>
            <entry><link linkend='type-conversations'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>weak</literal></entry>
            <entry><link linkend='weak-function-prototypes'>Description</link></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='type-directive' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>type-directive:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><literal>bottom</literal> <emphasis>identifier</emphasis></entry>
            <entry><link linkend='unreached-code-analysis'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>character</literal>
              <link linkend='character-sign'><emphasis>character-sign</emphasis></link></entry>
            <entry><link linkend='character-literals'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>character</literal> <emphasis>character-literal</emphasis>
              <link linkend='character-mapping'><emphasis>character-mapping</emphasis></link></entry>
            <entry><link linkend='identifier-names'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>character</literal> <emphasis>string-literal</emphasis>
              <link linkend='character-mapping'><emphasis>character-mapping</emphasis></link></entry>
            <entry><link linkend='identifier-names'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>compute promote</literal> <emphasis>identifier</emphasis></entry>
            <entry><link linkend='arithmetic-types'>Description</link> </entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>escape</literal> <emphasis>character-literal</emphasis>
              <link linkend='character-mapping'><emphasis>character-mapping</emphasis></link></entry>
            <entry><link linkend='escape-sequences'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>integer literal</literal>
              <link linkend='literal-spec'><emphasis>literal-spec</emphasis></link></entry>
            <entry><link linkend='integer-literals'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>promoted</literal> <emphasis>type-id</emphasis> <literal>:</literal>
              <emphasis>type-id</emphasis></entry>
            <entry><link linkend='arithmetic-types'>Description</link> </entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>set character literal :</literal> <emphasis>type-id</emphasis></entry>
            <entry><link linkend='character-literals'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>set longlong type :</literal>
              <link linkend='longlong-spec'><emphasis>longlong-spec</emphasis></link></entry>
            <entry><link linkend='extended-integral'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>set ptrdiff_t :</literal> <emphasis>type-id</emphasis></entry>
            <entry><link linkend='character-literals'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>set size_t :</literal> <emphasis>type-id</emphasis></entry>
            <entry><link linkend='character-literals'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>set wchar_t :</literal> <emphasis>type-id</emphasis></entry>
            <entry><link linkend='character-literals'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>set string literal :</literal>
              <link linkend='string-const'><emphasis>string-const</emphasis></link></entry>
            <entry><link linkend='string-literals-a'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>set std namespace :</literal>
              <link linkend='scope-name'><emphasis>scope-name</emphasis></link></entry>
            <entry><link linkend='std-namespace'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>type</literal> <emphasis>identifier</emphasis> <literal>for</literal>
              <link linkend='type-spec'><emphasis>type-spec</emphasis></link></entry>
            <entry><link linkend='type-spec'>Description</link></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='character-sign' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>character-sign:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><literal>signed</literal></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>unsigned</literal></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>either</literal></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='character-mapping' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>character-mapping:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><literal>as</literal> <emphasis>character-literal</emphasis>
              <literal>allow</literal></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>disallow</literal></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='literal-spec' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>literal-spec:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><link linkend='literal-base'><emphasis>literal-base</emphasis></link>
              <link linkend='literal-suffix'><emphasis>literal-suffix<subscript>opt</subscript>
              </emphasis></link> <link linkend='literal-type-list'><emphasis>literal-type-list
              </emphasis></link></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='literal-base' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>literal-base:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><literal>decimal</literal></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>octal</literal></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>hexadecimal</literal></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='literal-suffix' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>literal-suffix:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><literal>unsigned</literal></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>long</literal></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>unsigned long</literal></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>long long</literal></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>unsigned long long</literal></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='literal-type-list' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>literal-type-list:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><literal>*</literal> <link linkend='literal-type-spec'>
              <emphasis>literal-type-spec</emphasis></link></entry>
            <entry></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><emphasis>integer-literal</emphasis>
              <link linkend='literal-type-spec'><emphasis>literal-type-spec</emphasis></link>
              <literal>|</literal> <link linkend='literal-type-list'><emphasis>literal-type-list
              </emphasis></link></entry>
            <entry></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>?</literal> <link linkend='literal-type-spec'><emphasis>literal-type-spec
              </emphasis></link> <literal>|</literal>
              <link linkend='literal-type-list'><emphasis>literal-type-list</emphasis></link></entry>
            <entry></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='literal-type-spec' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>literal-type-spec:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><literal>:</literal> <emphasis>type-id</emphasis></entry>
            <entry></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>*</literal> <link linkend='allow'><emphasis>allow<subscript>opt</subscript>
              </emphasis></link> <literal>:</literal> <emphasis>identifier</emphasis></entry>
            <entry></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>* *</literal> <link linkend='allow'><emphasis>allow<subscript>opt</subscript>
              </emphasis></link> <literal>:</literal></entry>
            <entry></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='longlong-spec' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>longlong-spec:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><literal>long</literal></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>long long</literal></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='string-const' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>string-const:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><literal>const</literal></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>no const</literal></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='scope-name' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>scope-name:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><emphasis>identifier</emphasis></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>::</literal></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='type-spec' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>type-spec:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><literal>bottom</literal></entry>
            <entry><link linkend='unreached-code-analysis'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>ptrdiff_t</literal></entry>
            <entry><link linkend='character-literals'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>size_t</literal></entry>
            <entry><link linkend='character-literals'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>wchar_t</literal></entry>
            <entry><link linkend='character-literals'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>... printf</literal></entry>
            <entry><link linkend='printf-scanf-argument'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>... scanf</literal></entry>
            <entry><link linkend='printf-scanf-argument'>Description</link></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='linkage-directive' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>linkage-directive:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><literal>const linkage</literal>
              <link linkend='linkage'><emphasis>linkage</emphasis></link></entry>
            <entry><link linkend='object-linkage'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>external linkage</literal> <emphasis>string-literal</emphasis></entry>
            <entry><link linkend='object-linkage'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>external volatile_t</literal></entry>
            <entry><link linkend='object-linkage'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>inline linkage</literal>
              <link linkend='linkage'><emphasis>linkage</emphasis></link></entry>
            <entry><link linkend='object-linkage'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>linkage resolution :</literal>
              <link linkend='linkage-spec'><emphasis>linkage-spec</emphasis></link></entry>
            <entry><link linkend='object-linkage'>Description</link></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='linkage' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>linkage:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><literal>external</literal></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>internal</literal></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='linkage-spec' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>linkage-spec:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><literal>(</literal> <link linkend='linkage'><emphasis>linkage</emphasis></link>
              <literal>) on</literal></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>(</literal> <link linkend='linkage'><emphasis>linkage</emphasis></link>
              <literal>) warning</literal></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>off</literal></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='misc-directive' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>misc-directive:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><literal>argument</literal> <emphasis>type-id</emphasis>
              <literal>as ...</literal></entry>
            <entry><link linkend='weak-function-prototypes'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>argument</literal> <emphasis>type-id</emphasis> <literal>as</literal>
              <emphasis>type-id</emphasis></entry>
            <entry><link linkend='weak-function-prototypes'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>compatible type :</literal> <emphasis>type-id</emphasis>
              <literal>==</literal> <emphasis>type-id</emphasis> <literal>:</literal>
              <link linkend='allow'><emphasis>allow</emphasis></link></entry>
            <entry><link linkend='compat'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>conversion</literal>
              <link linkend='identifier-list'><emphasis>identifier-list</emphasis></link>
              <literal>allow</literal></entry>
            <entry><link linkend='type-conversations'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>declaration block</literal> <emphasis>identifier</emphasis>
              <literal>begin</literal></entry>
            <entry><link linkend='identifier-scopes'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>declaration block end</literal></entry>
            <entry><link linkend='identifier-scopes'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>directive</literal>
              <link linkend='directive-spec'><emphasis>directive-spec</emphasis></link>
              <link linkend='directive-state'><emphasis>directive-state</emphasis></link></entry>
            <entry><link linkend='preprocessing-directives'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>discard</literal> <emphasis>expression</emphasis></entry>
            <entry><link linkend='variable-flow-analysis'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>exhaustive</literal></entry>
            <entry><link linkend='switch-statements'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>explicit cast</literal>
              <link linkend='cast-spec'><emphasis>cast-spec<subscript>opt</subscript></emphasis></link>
              <link linkend='allow'><emphasis>allow</emphasis></link></entry>
            <entry><link linkend='cast-expressions'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>includes depth</literal> <emphasis>integer-literal</emphasis></entry>
            <entry><link linkend='inclusion-directives'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>preserve</literal>
              <link linkend='preserve-list'><emphasis>preserve-list</emphasis></link></entry>
            <entry><link linkend='static-identifers'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>set</literal> <emphasis>expression</emphasis></entry>
            <entry><link linkend='variable-flow-analysis'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>set error limit</literal> <emphasis>integer-literal</emphasis></entry>
            <entry><link linkend='implementation-limits'>Description</link> </entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>set name limit</literal> <emphasis>integer-literal</emphasis>
              <literal>warning</literal><emphasis><subscript>opt</subscript></emphasis></entry>
            <entry><link linkend='identifier-names'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>suspend static</literal>
              <link linkend='identifier-list'><emphasis>identifier-list</emphasis></link></entry>
            <entry><link linkend='discarded-expressions'>Description</link></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='directive-spec' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>directive-spec:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><literal>assert</literal></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>file</literal></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>ident</literal></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>import</literal></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>include_next</literal></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>unassert</literal></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>warning</literal></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>weak</literal></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='directive-state' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>directive-state:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><literal>allow</literal></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>warning</literal></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>disallow</literal></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>( ignore ) allow</literal></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>( ignore ) warning</literal></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='cast-operator' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>cast-operator:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><literal>static_cast</literal></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>const_cast</literal></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>reinterpret_cast</literal></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='cast-spec' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>cast-spec:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><literal>as</literal>
              <link linkend='cast-operator'><emphasis>cast-operator</emphasis></link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><link linkend='cast-spec'><emphasis>cast-spec</emphasis></link>
              <literal>|</literal> <link linkend='cast-operator'><emphasis>cast-operator
              </emphasis></link></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='preserve-list' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>preserve-list:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><link linkend='identifier-list'><emphasis>identifier-list</emphasis></link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>*</literal></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='identifier-list' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>identifier-list:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><emphasis>identifier</emphasis>
              <link linkend='identifier-list'><emphasis>identifier-list<subscript>opt</subscript>
              </emphasis></link></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='token-directive' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>token-directive:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><literal>token</literal>
              <link linkend='token-spec'><emphasis>token-spec</emphasis></link></entry>
            <entry><link linkend='token-specifcations'>Description</link> </entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>no_def</literal>
              <link linkend='token-list'><emphasis>token-list</emphasis></link></entry>
            <entry><link linkend='defining-tokens'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>define</literal>
              <link linkend='token-list'><emphasis>token-list</emphasis></link></entry>
            <entry><link linkend='defining-tokens'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>ignore</literal>
              <link linkend='token-list'><emphasis>token-list</emphasis></link></entry>
            <entry><link linkend='defining-tokens'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>interface</literal>
              <link linkend='token-list'><emphasis>token-list</emphasis></link></entry>
            <entry><link linkend='defining-tokens'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>undef token</literal>
              <link linkend='token-list'><emphasis>token-list</emphasis></link></entry>
            <entry><link linkend='defining-tokens'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>extend interface</literal> <emphasis>header-name</emphasis></entry>
            <entry><link linkend='defining-tokens'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>implement interface</literal> <emphasis>header-name</emphasis></entry>
            <entry><link linkend='defining-tokens'>Description</link></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='tendra-token-directive' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>tendra-token-directive:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><literal>token</literal>
              <link linkend='token-spec'><emphasis>token-spec</emphasis></link></entry>
            <entry><link linkend='token-specifcations'>Description</link> </entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>no_def</literal>
              <link linkend='token-list'><emphasis>token-list</emphasis></link></entry>
            <entry><link linkend='defining-tokens'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>define</literal>
              <link linkend='token-list'><emphasis>token-list</emphasis></link></entry>
            <entry><link linkend='defining-tokens'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>reject</literal>
              <link linkend='token-list'><emphasis>token-list</emphasis></link></entry>
            <entry><link linkend='defining-tokens'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>interface</literal>
              <link linkend='token-list'><emphasis>token-list</emphasis></link></entry>
            <entry><link linkend='defining-tokens'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>undef token</literal>
              <link linkend='token-list'><emphasis>token-list</emphasis></link></entry>
            <entry><link linkend='defining-tokens'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>extend</literal> <emphasis>header-name</emphasis></entry>
            <entry><link linkend='defining-tokens'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>implement</literal> <emphasis>header-name</emphasis></entry>
            <entry><link linkend='defining-tokens'>Description</link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>member definition</literal> <emphasis>type-id</emphasis>
              <literal>:</literal> <emphasis>identifier</emphasis>
              <link linkend='member-offset'><emphasis>member-offset</emphasis></link></entry>
            <entry><link linkend='defining-tokens'>Description</link></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='member-offset' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>member-offset:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><literal>::</literal><emphasis><subscript>opt</subscript></emphasis>
              <emphasis>id-expression</emphasis></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><link linkend='member-offset'><emphasis>member-offset</emphasis></link>
              <literal>. ::</literal><emphasis><subscript>opt</subscript></emphasis>
              <emphasis>id-expression</emphasis></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><link linkend='member-offset'><emphasis>member-offset</emphasis></link>
              <literal>[</literal> <emphasis>constant-expression</emphasis> <literal>]</literal></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='token-list' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>token-list:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><link linkend='token-id'><emphasis>token-id</emphasis></link>
              <link linkend='token-list'><emphasis>token-list<subscript>opt</subscript></emphasis>
              </link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>#</literal> <emphasis>preproc-token-list</emphasis></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='token-id' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>token-id:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><link linkend='token-namespace'><emphasis>token-namespace<subscript>opt</subscript>
              </emphasis></link><emphasis>identifier</emphasis></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><emphasis>type-id</emphasis> <literal>.</literal> <emphasis>identifier</emphasis></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='token-spec' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>token-spec:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><link linkend='token-introduction'><emphasis>token-introduction</emphasis></link>
              <link linkend='token-identification'><emphasis>token-identification</emphasis></link></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='token-introduction' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>token-introduction:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><link linkend='exp-token'><emphasis>exp-token</emphasis></link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><link linkend='statement-token'><emphasis>statement-token</emphasis></link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><link linkend='type-token'><emphasis>type-token</emphasis></link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><link linkend='member-token'><emphasis>member-token</emphasis></link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><link linkend='procedure-token'><emphasis>procedure-token</emphasis></link></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='token-identification' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>token-identification:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><link linkend='token-namespace'><emphasis>token-namespace<subscript>opt</subscript>
              </emphasis></link> <emphasis>identifier</emphasis> <literal>#</literal>
              <link linkend='external-identifier'><emphasis>external-identifier<subscript>opt</subscript>
              </emphasis></link></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='token-namespace' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>token-namespace:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><literal>TAG</literal></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='external-identifier' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>external-identifier:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><literal>-</literal></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><emphasis>preproc-token-list</emphasis></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='exp-token' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>exp-token:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><literal>EXP</literal> <link linkend='exp-storage'><emphasis>exp-storage
              <subscript>opt</subscript></emphasis></link> <literal>:</literal>
              <emphasis>type-id</emphasis> :</entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>NAT</literal></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>INTEGER</literal></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='exp-storage' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>exp-storage:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><literal>lvalue</literal></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>rvalue</literal></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>const</literal></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='statement-token' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>statement-token:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><literal>STATEMENT</literal></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='type-token' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>type-token:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><literal>TYPE</literal></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>VARIETY</literal></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>VARIETY signed</literal></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>VARIETY unsigned</literal></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>FLOAT</literal></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>ARITHMETIC</literal></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>SCALAR</literal></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>CLASS</literal></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>STRUCT</literal></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>UNION</literal></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='member-token' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>member-token:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><literal>MEMBER</literal>
              <link linkend='access-specifier'><emphasis>access-specifier<subscript>opt</subscript>
              </emphasis></link> <link linkend='member-type-id'><emphasis>member-type-id</emphasis></link>
              <literal>:</literal> <emphasis>type-id</emphasis> <literal>:</literal></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='member-type-id' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>member-type-id:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><emphasis>type-id</emphasis></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><emphasis>type-id</emphasis> <literal>%</literal>
              <emphasis>constant-expression</emphasis></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='access-specifier' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>access-specifier:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><literal>public</literal></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>protected</literal></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>private</literal></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='procedure-token' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>procedure-token:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><link linkend='general-procedure'><emphasis>general-procedure</emphasis></link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><link linkend='simple-procedure'><emphasis>simple-procedure</emphasis></link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><link linkend='function-procedure'><emphasis>function-procedure</emphasis></link></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='general-procedure' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>general-procedure:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><literal>PROC {</literal>
              <link linkend='bound-toks'><emphasis>bound-toks<subscript>opt</subscript></emphasis></link>
              <literal>|</literal>
              <link linkend='prog-pars'><emphasis>prog-pars<subscript>opt</subscript></emphasis></link>
              <literal>}</literal> <link linkend='token-introduction'><emphasis>token-introduction
              </emphasis></link></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='bound-toks' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>bound-toks:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><link linkend='bound-token'><emphasis>bound-token</emphasis></link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><link linkend='bound-token'><emphasis>bound-token</emphasis></link>
              <literal>,</literal> <link linkend='bound-toks'><emphasis>bound-toks</emphasis></link></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='bound-token' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>bound-token:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><link linkend='token-introduction'><emphasis>token-introduction</emphasis></link>
              <link linkend='token-namespace'><emphasis>token-namespace<subscript>opt</subscript>
              </emphasis></link> <emphasis>identifier</emphasis></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='prog-pars' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>prog-pars:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><link linkend='program-parameter'><emphasis>program-parameter</emphasis></link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><link linkend='program-parameter'><emphasis>program-parameter</emphasis></link>
              <literal>,</literal> <link linkend='prog-pars'><emphasis>prog-pars</emphasis></link></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='program-parameter' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>program-parameter:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><literal>EXP</literal> <emphasis>identifier</emphasis></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>STATEMENT</literal> <emphasis>identifier</emphasis></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>TYPE</literal> <emphasis>type-id</emphasis></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>MEMBER</literal> <emphasis>type-id</emphasis> <literal>:</literal>
              <emphasis>identifier</emphasis></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><literal>PROC</literal> <emphasis>identifier</emphasis></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='simple-procedure' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>simple-procedure:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><literal>PROC (</literal>
              <link linkend='simple-toks'><emphasis>simple-toks<subscript>opt</subscript></emphasis></link>
              <literal>)</literal> <link linkend='token-introduction'><emphasis>token-introduction
              </emphasis></link></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='simple-toks' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>simple-toks:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><link linkend='simple-token'><emphasis>simple-token</emphasis></link></entry>
          </row>
  
          <row>
            <entry></entry>
            <entry><link linkend='simple-token'><emphasis>simple-token</emphasis></link>
              <literal>,</literal> <link linkend='simple-toks'><emphasis>simple-toks</emphasis></link></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='simple-token' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>simple-token:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><link linkend='token-introduction'><emphasis>token-introduction</emphasis></link>
              <link linkend='token-namespace'><emphasis>token-namespace<subscript>opt</subscript>
              </emphasis></link> <emphasis>identifier<subscript>opt</subscript></emphasis></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>


    <informaltable frame="none" id='function-procedure' pgwide='1'>
      <tgroup cols="3">
        <colspec colname='c1' colwidth='1*'>
        <colspec colname='c2' colwidth='5*'>
        <colspec colname='c3' colwidth='2*'>

        <tbody>
          <row>
            <entry namest="c1" nameend="c2"><emphasis>function-procedure:</emphasis></entry>
          </row>

          <row>
            <entry></entry>
            <entry><literal>FUNC</literal> <emphasis>type-id</emphasis> <literal>:</literal></entry>
          </row>
        </tbody>
      </tgroup>
    </informaltable>



</appendix>
  <appendix id='symbol-table-dump-syntax'>
    <title>Symbol table dump syntax</title>

    <para>The following gives a summary of the syntax for the
      <link linkend='symbol-table-dump'>symbol table dump</link> file (version
      1.1):</para>
<programlisting>
<emphasis>dump-file</emphasis> :
<emphasis>command-list<subscript>opt</subscript></emphasis>

<emphasis>command-list</emphasis> :
<emphasis>command command-list<subscript>opt</subscript></emphasis>

<emphasis>command</emphasis> :
<emphasis>version-command</emphasis>
<emphasis>identifier-command</emphasis>
<emphasis>scope-command</emphasis>
<emphasis>override-command</emphasis>
<emphasis>base-command</emphasis>
<emphasis>api-command</emphasis>
<emphasis>template-command</emphasis>
<emphasis>promotion-command</emphasis>
<emphasis>error-command</emphasis>
<emphasis>path-command</emphasis>
<emphasis>file-command</emphasis>
<emphasis>include-command</emphasis>
<emphasis>string-command</emphasis>

<emphasis>version-command</emphasis> :
V <emphasis>number number string</emphasis>

</programlisting>
<programlisting>
<emphasis>location</emphasis> :
<emphasis>number number number string string</emphasis>
<emphasis>number number number string</emphasis> *
<emphasis>number number number</emphasis> *
<emphasis>number number</emphasis> *
<emphasis>number</emphasis> *
*

</programlisting>
<programlisting>
<emphasis>identifier</emphasis> :
<emphasis>number</emphasis> = <emphasis>identifier-name access<subscript>opt</subscript> scope-identifier</emphasis>
<emphasis>number</emphasis>

<emphasis>identifier-name</emphasis> :
<emphasis>string</emphasis>
C <emphasis>type</emphasis>
D <emphasis>type</emphasis>
O <emphasis>string</emphasis>
T <emphasis>type</emphasis>

<emphasis>access</emphasis> :
N
B
P

<emphasis>scope-identifier</emphasis> :
<emphasis>identifier</emphasis>
*

<emphasis>identifier-command</emphasis> :
D <emphasis>identifier-info type-info</emphasis>
M <emphasis>identifier-info type-info</emphasis>
T <emphasis>identifier-info type-info</emphasis>
Q <emphasis>identifier-info</emphasis>
U <emphasis>identifier-info</emphasis>
L <emphasis>identifier-info</emphasis>
C <emphasis>identifier-info</emphasis>
W <emphasis>identifier-info type-info</emphasis>
I <emphasis>identifier-command</emphasis>

<emphasis>identifier-info</emphasis> :
<emphasis>identifier-key location identifier</emphasis>

<emphasis>identifier-key</emphasis> :
K
MO
MF
MB
TC
TS
TU
TE
TA
NN
NA
VA
VP
VE
VS
FE <emphasis>function-key<subscript>opt</subscript></emphasis>
FS <emphasis>function-key<subscript>opt</subscript></emphasis>
FB <emphasis>function-key<subscript>opt</subscript></emphasis>
CF <emphasis>function-key<subscript>opt</subscript></emphasis>
CS <emphasis>function-key<subscript>opt</subscript></emphasis>
CV <emphasis>function-key<subscript>opt</subscript></emphasis>
CM
CD
E
L
XO
XF
XP
XT

<emphasis>function-key</emphasis> :
C <emphasis>function-key<subscript>opt</subscript></emphasis>
I <emphasis>function-key<subscript>opt</subscript></emphasis>

<emphasis>type-info</emphasis> :
<emphasis>type identifier<subscript>opt</subscript></emphasis>
<emphasis>sort</emphasis>
<emphasis>scope-identifier</emphasis>
*

</programlisting>
<programlisting>
<emphasis>scope-command</emphasis> :
SS <emphasis>scope-key location identifier</emphasis>
SE <emphasis>scope-key location identifier</emphasis>

<emphasis>scope-key</emphasis> :
N
S
B
D
H
CT
CF
CC

</programlisting>
<programlisting>
<emphasis>override-command</emphasis> :
O <emphasis>identifier identifier</emphasis>

</programlisting>
<programlisting>
<emphasis>base-command</emphasis> :
B <emphasis>identifier-key identifier base-graph</emphasis>

<emphasis>base-graph</emphasis> :
<emphasis>base-class</emphasis>
<emphasis>base-class</emphasis> ( <emphasis>base-list</emphasis> )

<emphasis>base-class</emphasis> :
<emphasis>number</emphasis> = V<emphasis><subscript>opt</subscript> access<subscript>opt</subscript> type-name</emphasis>
<emphasis>number</emphasis> :

<emphasis>base-list</emphasis> :
<emphasis>base-graph base-list<subscript>opt</subscript></emphasis>

<emphasis>base-number</emphasis> :
<emphasis>number</emphasis> : <emphasis>type-name</emphasis>

</programlisting>
<programlisting>
<emphasis>api-command</emphasis> :
X <emphasis>identifier-key identifier string</emphasis>

</programlisting>
<programlisting>
<emphasis>template-command</emphasis> :
Z <emphasis>identifier-key identifier token-application specialise-info</emphasis>

<emphasis>specialise-info</emphasis> :
<emphasis>identifier</emphasis>
<emphasis>token-application</emphasis>
*

</programlisting>
<programlisting>
<emphasis>type</emphasis> :
<emphasis>type-name</emphasis>
c
s
i
l
x
b
w
y
z
f
d
r
v
u
Sc
Uc
Us
Ui
Ul
Ux
C <emphasis>type</emphasis>
V <emphasis>type</emphasis>
P <emphasis>type</emphasis>
R <emphasis>type</emphasis>
M <emphasis>type-name</emphasis> : <emphasis>type</emphasis>
F <emphasis>type parameter-types</emphasis>
A <emphasis>nat<subscript>opt</subscript></emphasis> : <emphasis>type</emphasis>
B <emphasis>nat</emphasis> : <emphasis>type</emphasis>
t <emphasis>parameter-list<subscript>opt</subscript></emphasis> : <emphasis>type</emphasis>
p <emphasis>type</emphasis>
a <emphasis>type</emphasis> : <emphasis>type</emphasis>
n <emphasis>lit-base<subscript>opt</subscript> lit-suffix<subscript>opt</subscript></emphasis>
W <emphasis>type parameter-types</emphasis>
q <emphasis>type</emphasis>
Q <emphasis>string</emphasis>
*

<emphasis>type-name</emphasis> :
<emphasis>identifier</emphasis>
<emphasis>token-application</emphasis>

<emphasis>parameter-types</emphasis> :
: <emphasis>exception-spec<subscript>opt</subscript> func-qualifier<subscript>opt</subscript></emphasis> :
. <emphasis>exception-spec<subscript>opt</subscript> func-qualifier<subscript>opt</subscript></emphasis> :
. <emphasis>exception-spec<subscript>opt</subscript> func-qualifier<subscript>opt</subscript></emphasis> .
, <emphasis>type parameter-types</emphasis>

<emphasis>func-qualifier</emphasis> :
C <emphasis>func-qualifier<subscript>opt</subscript></emphasis>
V <emphasis>func-qualifier<subscript>opt</subscript></emphasis>

<emphasis>exception-spec</emphasis> :
( <emphasis>exception-list<subscript>opt</subscript></emphasis> )

<emphasis>exception-list</emphasis> :
<emphasis>type</emphasis>
<emphasis>type</emphasis> , <emphasis>exception-list</emphasis>

<emphasis>nat</emphasis> :
+ <emphasis>number</emphasis>
- <emphasis>number</emphasis>
<emphasis>identifier</emphasis>
<emphasis>token-application</emphasis>
<emphasis>string</emphasis>

<emphasis>parameter-list</emphasis> :
<emphasis>identifier</emphasis>
<emphasis>identifier</emphasis> , <emphasis>parameter-list</emphasis>

<emphasis>lit-base</emphasis> :
O
X

<emphasis>lit-suffix</emphasis> :
U
l
Ul
x
Ux

</programlisting>
<programlisting>
<emphasis>promotion-command</emphasis> :
P <emphasis>type</emphasis> : <emphasis>type</emphasis>

</programlisting>
<programlisting>
<emphasis>sort</emphasis> :
<emphasis>expression-sort</emphasis>
<emphasis>statement-sort</emphasis>
<emphasis>type-sort</emphasis>
<emphasis>tag-type-sort</emphasis>
<emphasis>member-sort</emphasis>
<emphasis>proc-sort</emphasis>
<emphasis>func-sort</emphasis>
<emphasis>template-sort</emphasis>
<emphasis>macro-sort</emphasis>

<emphasis>expression-sort</emphasis> :
ZEL <emphasis>type</emphasis>
ZER <emphasis>type</emphasis>
ZEC <emphasis>type</emphasis>
ZN

<emphasis>statement-sort</emphasis> :
ZS

<emphasis>type-sort</emphasis> :
ZTO
ZTI
ZTF
ZTA
ZTP
ZTS
ZTU

<emphasis>tag-type-sort</emphasis> :
ZTTS
ZTTU

<emphasis>member-sort</emphasis> :
ZM <emphasis>type</emphasis> : <emphasis>type-name</emphasis>

<emphasis>proc-sort</emphasis> :
ZPG <emphasis>parameter-list<subscript>opt</subscript></emphasis> ; <emphasis>parameter-list<subscript>opt</subscript></emphasis> : <emphasis>sort</emphasis>
ZPS <emphasis>parameter-list<subscript>opt</subscript></emphasis> : <emphasis>sort</emphasis>

<emphasis>func-sort</emphasis> :
ZF <emphasis>type</emphasis>

<emphasis>template-sort</emphasis> :
ZTt <emphasis>parameter-list<subscript>opt</subscript></emphasis> :

<emphasis>macro-sort</emphasis> :
ZUO
ZUF <emphasis>number</emphasis>

<emphasis>token-application</emphasis> :
T <emphasis>identifier</emphasis> , <emphasis>token-argument-list</emphasis> :

<emphasis>token-argument-list</emphasis> :
<emphasis>token-argument</emphasis>
<emphasis>token-argument</emphasis> , <emphasis>token-argument-list</emphasis>

<emphasis>token-argument</emphasis> :
E <emphasis>expression</emphasis>
N <emphasis>nat</emphasis>
S <emphasis>statement</emphasis>
T <emphasis>type</emphasis>
M <emphasis>member</emphasis>
F <emphasis>identifier</emphasis>
C <emphasis>identifier</emphasis>

<emphasis>expression</emphasis> :
<emphasis>nat</emphasis>

<emphasis>statement</emphasis> :
<emphasis>expression</emphasis>

<emphasis>member</emphasis> :
<emphasis>identifier</emphasis>
<emphasis>string</emphasis>

</programlisting>
<programlisting>
<emphasis>error-name</emphasis> :
<emphasis>number</emphasis> = <emphasis>string</emphasis>
<emphasis>number</emphasis>

<emphasis>error-command</emphasis> :
ES <emphasis>location error-info</emphasis>
EW <emphasis>location error-info</emphasis>
EI <emphasis>location error-info</emphasis>
EF <emphasis>location error-info</emphasis>
EC <emphasis>error-info</emphasis>
EA <emphasis>error-argument</emphasis>

<emphasis>error-info</emphasis> :
<emphasis>error-name number number</emphasis>

<emphasis>error-argument</emphasis> :
B <emphasis>base-number</emphasis>
C <emphasis>scope-identifier</emphasis>
E <emphasis>expression</emphasis>
H <emphasis>identifier-name</emphasis>
I <emphasis>identifier</emphasis>
L <emphasis>location</emphasis>
N <emphasis>nat</emphasis>
S <emphasis>string</emphasis>
T <emphasis>type</emphasis>
V <emphasis>number</emphasis>
V - <emphasis>number</emphasis>

</programlisting>
<programlisting>
<emphasis>path-command</emphasis> :
FD <emphasis>number</emphasis> = <emphasis>string string<subscript>opt</subscript></emphasis>

<emphasis>directory</emphasis> :
<emphasis>number</emphasis>
*

<emphasis>file-command</emphasis> :
FS <emphasis>location directory</emphasis>
FE <emphasis>location</emphasis>

<emphasis>include-command</emphasis> :
FIA <emphasis>location string</emphasis>
FIQ <emphasis>location string</emphasis>
FIN <emphasis>location string</emphasis>
FIS <emphasis>location string</emphasis>
FIE <emphasis>location string</emphasis>
FIR <emphasis>location</emphasis>

</programlisting>
<programlisting>
<emphasis>string-command</emphasis> :
A <emphasis>location string</emphasis>
AC <emphasis>location string</emphasis>
AL <emphasis>location string</emphasis>
ACL <emphasis>location string</emphasis>
</programlisting>
  </appendix>

  <appendix id='error-catalogue-syntax'>
    <title>Error catalogue syntax</title>

    <para>The following gives a summary of the syntax for the
      <link linkend='error-catalogue'>error catalogue</link> accepted by the
      <literal>make_err</literal>
      tool. Identifiers are normal C-style identifiers, strings consist of any
      sequence of characters enclosed inside <literal>&quot;....&quot;</literal>.
      The escape sequences <literal>\&quot;</literal> and <literal>\\</literal>
      are allowed in strings; other characters (including newline characters) map
      to themselves. C-style comments are allowed.</para>
<programlisting>
<emphasis>error-database</emphasis> :
<emphasis>header types<subscript>opt</subscript> properties<subscript>opt</subscript> keys<subscript>opt</subscript> usages<subscript>opt</subscript> entries<subscript>opt</subscript></emphasis>

<emphasis>header</emphasis> :
<emphasis>database-name<subscript>opt</subscript> rig-name<subscript>opt</subscript> prefixes<subscript>opt</subscript></emphasis>

</programlisting>
<programlisting>
<emphasis>database-name</emphasis> :
DATABASE_NAME : <emphasis>identifier</emphasis>

<emphasis>rig-name</emphasis> :
RIG : <emphasis>identifier</emphasis>

</programlisting>
<programlisting>
<emphasis>prefixes</emphasis> :
PREFIX : <emphasis>output-prefix<subscript>opt</subscript> compiler-prefix<subscript>opt</subscript> error-prefix<subscript>opt</subscript></emphasis>

<emphasis>output-prefix</emphasis> :
compiler_output -&gt; <emphasis>identifier</emphasis>

<emphasis>compiler-prefix</emphasis> :
from_compiler -&gt; <emphasis>identifier</emphasis>

<emphasis>error-prefix</emphasis> :
from_database -&gt; <emphasis>identifier</emphasis>

</programlisting>
<programlisting>
<emphasis>types</emphasis> :
TYPES : <emphasis>name-list<subscript>opt</subscript></emphasis>

<emphasis>properties</emphasis> :
PROPERTIES : <emphasis>name-list<subscript>opt</subscript></emphasis>

<emphasis>keys</emphasis> :
KEYS : <emphasis>name-list<subscript>opt</subscript></emphasis>

<emphasis>usages</emphasis> :
USAGE : <emphasis>name-list<subscript>opt</subscript></emphasis>

<emphasis>name</emphasis> :
<emphasis>identifier</emphasis>
<emphasis>identifier</emphasis> = <emphasis>identifier</emphasis>
<emphasis>identifier</emphasis> = <emphasis>identifier</emphasis> | <emphasis>identifier</emphasis>

<emphasis>name-list</emphasis> :
<emphasis>name</emphasis>
<emphasis>name</emphasis> , <emphasis>name-list</emphasis>

</programlisting>
<programlisting>
<emphasis>type-name</emphasis> :
<emphasis>identifier</emphasis>

<emphasis>property-name</emphasis> :
<emphasis>identifier</emphasis>

<emphasis>key-name</emphasis> :
<emphasis>identifier</emphasis>

<emphasis>usage-name</emphasis> :
<emphasis>identifier</emphasis>

</programlisting>
<programlisting>
<emphasis>entries</emphasis> :
ENTRIES : <emphasis>entries-list<subscript>opt</subscript></emphasis>

<emphasis>entry-list</emphasis> :
<emphasis>entry entry-list<subscript>opt</subscript></emphasis>

<emphasis>entry</emphasis> :
<emphasis>identifier</emphasis> ( <emphasis>param-list<subscript>opt</subscript></emphasis> ) { <emphasis>entry-body</emphasis> }

<emphasis>entry-body</emphasis> :
<emphasis>alt-name<subscript>opt</subscript> entry-usage<subscript>opt</subscript> entry-properties<subscript>opt</subscript> map-list<subscript>opt</subscript></emphasis>

</programlisting>
<programlisting>
<emphasis>parameter</emphasis> :
<emphasis>type-name</emphasis> : <emphasis>identifier</emphasis>

<emphasis>param-list</emphasis> :
<emphasis>parameter</emphasis>
<emphasis>parameter</emphasis> , <emphasis>param-list</emphasis>

<emphasis>param-name</emphasis> :
<emphasis>identifier</emphasis>

</programlisting>
<programlisting>
<emphasis>alt-name</emphasis> :
ALT_NAME : <emphasis>identifier</emphasis>

<emphasis>entry-usage</emphasis> :
USAGE : <emphasis>usage-name</emphasis>
USAGE : <emphasis>usage-name</emphasis> | <emphasis>usage-name</emphasis>

<emphasis>entry-properties</emphasis> :
PROPERTIES : <emphasis>property-list<subscript>opt</subscript></emphasis>

<emphasis>property-list</emphasis> :
<emphasis>property-name</emphasis>
<emphasis>property-name</emphasis> , <emphasis>property-list</emphasis>

</programlisting>
<programlisting>
<emphasis>map</emphasis> :
KEY ( <emphasis>key-name</emphasis> ) <emphasis>message-list<subscript>opt</subscript></emphasis>
KEY ( <emphasis>key-name</emphasis> ) <emphasis>message-list<subscript>opt</subscript></emphasis> | <emphasis>message-list<subscript>opt</subscript></emphasis>

<emphasis>map-list</emphasis> :
<emphasis>map map-list<subscript>opt</subscript></emphasis>

<emphasis>message-list</emphasis> :
<emphasis>string message-list<subscript>opt</subscript></emphasis>
<emphasis>param-name message-list<subscript>opt</subscript></emphasis>
</programlisting>
  </appendix>

  <chapter id='revision'>
    <title>Revision History</title>

    <para>This chapter describes revisions to this document.</para>

    <para>Only major changes are listed in the revision history.  Please see
      <ulink url="http://cvsweb.ten15.org/cgi/cvsweb.cgi/doc/en/tcpplus/book.sgml">http://cvsweb.ten15.org/cgi/cvsweb.cgi/doc/en/tcpplus/book.sgml</ulink>
      for a complete list of changes.</para>

    <note><para>CVS revision numbers are located behind the date in the format
      <literal>r</literal><emphasis>XX</emphasis></para></note>

    <para>
    <revhistory>
      <revision>
        <revnumber>1.1</revnumber>
        <date>2004/03/18 r1.14</date>
        <authorinitials>verm</authorinitials>
        <revremark>Cross references were fixed.</revremark>
      </revision>

      <revision>
        <revnumber>1.0</revnumber>
        <date>2003/07/30 r1.1</date>
        <authorinitials>verm</authorinitials>
        <revremark>Converted to SGML from the &doc.original;.</revremark>
      </revision>
    </revhistory>
  </para>
  </chapter>



</book>
