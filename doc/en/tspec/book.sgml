<!DOCTYPE BOOK PUBLIC "-//FreeBSD//DTD DocBook V4.1-Based Extension//EN">

<book>
  <bookinfo>
    <title>tspec API Specification Tool</title>
    <pubdate>$TenDRA$</pubdate>
    <corpauthor>The TenDRA Documentation Team</corpauthor>
    <copyright>
      <year>2002</year>
      <holder>TenDRA Documentation Team</holder>
    </copyright>
    <copyright>
      <year>1997</year>
      <year>1998</year>
      <holder>Defence Evaluation and Research Agency (DERA)</holder>
    </copyright>
    <abstract>
      <para>Please email us at <email>docs@tendra.org</email> if you see any
        errors</para>
    </abstract>
  </bookinfo>

  <preface id="preface">
    <title>Introduction</title>

    <para>As explained in reference 1, TDF may be regarded as an abstract
      target machine which can be used to facilitate the separation of target
      independent and target dependent code which characterises portable
      programs. An important aspect of this separation is the Application
      Programming Interface, or API, of the program. Just as, for a
      conventional machine, the API needs to be implemented on that machine
      before the program can be ported to it, so for that program to be ported
      to the abstract TDF machine, an "abstract implementation" of the API
      needs to be provided.</para>

    <para>But of course, an "abstract implementation" is precisely what is
      provided by the API specification - it is an abstraction of all the
      possible API implementations. Therefore the TDF representation of an API
      must reflect the API specification. As a consequence, compiling a
      program to the abstract TDF machine is to check it against the API
      specification rather than, as with compiling to a conventional machine,
      against at best a particular implementation of that API.</para>

    <para>In this document we address the problem of how to translate a
      standard API specification into its TDF representation, by describing a
      tool, <literal>tspec</literal>, which has been developed for this
      purpose.</para>

    <para>The low level form which is used to represent APIs to the C to TDF
      producer is the <literal>#pragma token</literal> syntax described in
      reference 3. However this is not a suitable form in which to describe
      API specifications. The <literal>#pragma token</literal> syntax is
      necessarily complex, and can only be checked through extensive testing
      using the producer. Instead an alternative form, close to C, has been
      developed for this purpose. API specifications in this form are
      transformed by <literal>tspec</literal> into the corresponding
      <literal>#pragma token</literal> statements, while it applies various
      internal checks to the API description.</para>

    <para>Another reason for introducing <literal>tspec</literal> is that the
      <literal>#pragma token</literal> syntax is currently limited in some
      areas. For example, at present it has very limited support for
      expressing constancy of expressions. By allowing the
      <literal>tspec</literal> syntax to express this information, the API
      description will contain all the information which may be needed in
      future upgrades to the <literal>#pragma token</literal> syntax. Thus
      describing an API using <literal>tspec</literal> is hopefully a one off
      process, whereas describing it directly to the <literal>#pragma
      token</literal> syntax could require periodic reworkings. Improvements
      in the <literal>#pragma token</literal> syntax will be reflected in the
      translations produced by future versions of <literal>tspec</literal>.
      </para>

    <para>The <literal>tspec</literal> syntax is not designed to be a formal
      specification language. Instead it is a pragmatic attempt to capture the
      common specification idioms of standard API specifications. A glance at
      these specifications shows that they are predominantly C based, but with
      an added layer of abstraction - instead of saying that
      <literal>t</literal> is a specific C type, they say, there exists a type
      <literal>t</literal>, and so on. The <literal>tspec</literal> syntax is
      designed to reflect this.</para>

  </preface>

  <chapter id="c1">
    <title>Overview of <literal>tspec</literal></title>

    <sect1 id="speclevel">
      <title>Specification Levels</title>

      <para>Let us begin by examining the various levels of specification with
        which <literal>tspec</literal> is concerned. At the lowest level it is
        concerned with objects - the types, expressions, constants etc. which
        comprise the API - and indeed most of this document is concerned with
        how <literal>tspec</literal> describes these objects. At the highest
        level, <literal>tspec</literal> is concerned with APIs. We could just
        describe an API as being a set of objects, however this is to ignore
        the internal structure of APIs.</para>

      <para>At the most obvious level the objects in an API are spread over a
        number of different system headers. For example, in ANSI, the objects
        concerned with file input and output are grouped in
        <literal>stdio.h</literal>, whereas those concerned with string
        manipulation are in <literal>string.h</literal>. But a further level
        of refinement is also required. For example, ANSI specifies that the
        type <literal>size_t</literal> is defined in both
        <literal>stdio.h</literal> and <literal>string.h</literal>. Therefore
        <literal>tspec</literal> needs to be able to represent subsets of
        headers in order to express this intersection relation.</para>

      <para>To conclude, <literal>tspec</literal> distinguishes four levels of
        specification - APIs (which are sets of headers), headers (which are
        sets of objects), subsets of headers, and objects. It identifies APIs
        by an identifying name chosen by the person performing the API
        description. The (purely arbitrary) convention is for short, lower
        case names, for example:</para>

      <itemizedlist>
        <listitem>
          <para><literal>ansi</literal> refers to ANSI C (X3.159),</para>
        </listitem>
        <listitem>
          <para><literal>posix</literal> refers to POSIX 1003.1,</para>
        </listitem>
        <listitem>
          <para><literal>xpg3</literal> refers to X/Open Portability Guide 3.</para>
        </listitem>
      </itemizedlist>

      <para>In this document, headers are identified by the API they belong to
        and the header name. Thus <literal>ansi:stdio.h</literal> refers to
        the <literal>stdio.h</literal> header of the ANSI API. Finally subsets
        of headers are identified by the header and the subset name. If, for
        example, the <literal>stdio.h</literal> header of ANSI has a subset
        named <literal>file</literal>, then this is referred to as
        <literal>ansi:stdio.h:file</literal>.</para>

    </sect1>

    <sect1 id="inputlayout">
      <title>Input Layout</title>

      <para>The <literal>tspec</literal> representation of an API is arranged
        as a directory with the same name as the API, containing a number of
        files, one for each API header. For example, the ANSI API is
        represented by a directory <literal>ansi</literal> containing files
        <literal>ansi/stdio.h</literal>, <literal>ansi/string.h</literal> etc.
        In addition each API directory contains a master file (for ANSI it
        would be called <literal>ansi/MASTER</literal>) which lists all the
        headers comprising that API.</para>

      <para>When <literal>tspec</literal> needs to find an API directory it
        does so by searching along its input directory path. This is a colon
        separated list of directories to be searched. This may be specified in
        a number of ways. A default search list is built into
        <literal>tspec</literal>, however this may be overridden by the system
        variable <literal>TSPEC_INPUT</literal>. Directories may be added to
        the start of the path using the <literal>-I</literal>
        <emphasis>dir</emphasis> command-line option (see
        <xref linkend="cmdlineopts"> for a complete list of options). The
        current working directory is always added to the start of the
        path.</para>

    </sect1>

    <sect1 id="outputlayout">
      <title>Output Layout</title>

      <para><literal>tspec</literal> actually outputs two sets of output
        files, the include output files, containing the <literal>#pragma
        token</literal> directives corresponding to the input API, and the
        source output files, which provide a rig for TDF library building (see
        <xref linkend="tdflibbuild">). These output files and directories are
        built up under two standard output directories - the include output
        directory, <emphasis>incl_dir</emphasis> say, and the source output
        directory, <emphasis>src_dir</emphasis> say. <literal>tspec</literal>
        has default values for these directories built in, but these may be
        overridden in a number of ways. Firstly, if the system variable
        <literal>TSPEC_OUTPUT</literal> is defined to be
        <emphasis>dir</emphasis>, say, then <emphasis>incl_dir</emphasis> is
        <emphasis>dir</emphasis><literal>/include</literal> and
        <emphasis>src_dir</emphasis> is <emphasis>dir</emphasis>
        <literal>/src</literal> . Secondly, <emphasis>incl_dir</emphasis> and
        <emphasis>src_dir</emphasis> can be set independently using the system
        variables <literal>TSPEC_INCL_OUTPUT</literal> and
        <literal>TSPEC_SRC_OUTPUT</literal> respectively. Finally, they may
        also be set using the <literal>-O</literal><emphasis>dir</emphasis>
        and <literal>-S</literal><emphasis>dir</emphasis> command-line options
        respectively.</para>

      <para>As an example of the mapping from input files to output files, the
        header <literal>ansi:stdio.h</literal> is mapped to the include output
        file <emphasis>incl_dir</emphasis><literal>/ansi.api/stdio.h</literal>
        and the source output file <emphasis>src_dir</emphasis>
        <literal>/ansi.api/stdio.c</literal>. The header subset
        <literal>ansi:stdio.h:file</literal> is mapped to its own pair of
        output files, <emphasis>incl_dir</emphasis>
        <literal>/shared/ansi.api/file.h</literal> and
        <emphasis>src_dir</emphasis> <literal>/ansi.api/file.c</literal>.
        </para>

      <para>The default output file names can be overridden by means of the
        <literal>INCLNAME</literal> and <literal>SOURCENAME</literal> file
        properties described in <xref linkend="fileprop"></para>

      <para>By default, <literal>tspec</literal> only creates an output file
        if the date stamps on all the input files it depends on indicate that
        it needs updating. In effect, <literal>tspec</literal> creates an
        internal makefile from the dependencies it deduces. This behaviour can
        be overridden by means of the <literal>-f</literal> command-line
        option, which forces all output files to be created.</para>

      <para>In addition, <literal>tspec</literal> only creates the source
        output file if it is needed for TDF library building. If the
        corresponding include output file does not contain any token
        specifications then the source output file is suppressed (see
        <xref linkend="tdflibbuild">).</para>

    </sect1>

    <sect1 id="copyrightmsg">
      <title>Copyright Messages</title>

      <para><literal>tspec</literal> will optionally add a copyright message
        to the start of each include output file. This message is copied from
        a file which may be specified either using the
        <literal>TSPEC_COPYRIGHT</literal> system variable, or by the
        <literal>-C</literal><emphasis>file</emphasis> command-line option.
        </para>

    </sect1>

    <sect1 id="cmdlineopts">
      <title>Command-line Options</title>

      <para>Insert XREF to manpage here..
      </para>

    </sect1>
  </chapter>

  <chapter id="c2">
    <title>Specifying API Structure</title>

    <para>The basic form of the <literal>tspec</literal> description of an API
      has already been explained in <xref linkend="inputlayout"> - it is a
      directory containing a set of files corresponding to the headers in that
      API. Each file basically consists of a list of the objects declared in
      that header.  Each object specification is part of a
      <literal>tspec</literal> construct. These constructs are identified by
      keywords. These keywords always begin with <literal>+</literal> to avoid
      conflict with C identifiers. Comments may be inserted at any point.
      These are prefixed by <literal>#</literal> and run to the end of the
      line.</para>

    <para>In addition to the basic object specification constructs,
      <literal>tspec</literal> also has constructs for imposing structure on
      the API description. It is these constructs that we consider first.
      </para>

    <sect1 id="subset">
      <title>+SUBSET</title>

      <para>A list of <literal>tspec</literal> constructs within a header can
        be grouped into a named subset by enclosing them within:</para>

      <programlisting>
+SUBSET "name" := {
  ....
} ;

      </programlisting>

      <para>where <literal>name</literal> is the subset name. These named
        subsets can be nested, but are still regarded as subsets of the parent
        header.</para>

      <para>Subsets are intended to give a layer of resolution beyond that of
        the entire header (see <xref linkend="speclevel">). Each subset is
        mapped onto a separate pair of output files, so unwary use of subsets
        is discouraged.</para>

    </sect1>

    <sect1 id="implementuse">
      <title>+IMPLEMENT and +USE</title>

      <para><literal>tspec</literal> has two import constructs which allow one
        API, or header, or subset of a header to be included in another. The
        first construct is used to indicate that the given set of objects is
        also declared in the including header, and takes one of the
        forms:</para>

      <programlisting>
+IMPLEMENT "api" ;
+IMPLEMENT "api", "header" ;
+IMPLEMENT "api", "header", "subset" ;
      </programlisting>

      <para>The second construct is used to indicate that the objects are only
        used in the including header, and take one of the forms:</para>

      <programlisting>
+USE "api" ;
+USE "api", "header" ;
+USE "api", "header", "subset" ;
      </programlisting>

      <para>For example, <literal>posix:stdio.h</literal> is an extension of
        <literal>ansi:stdio.h</literal> , so, rather than duplicate all the
        object specifications from the latter in the former, it is easier and
        clearer to use the construct:</para>

      <programlisting>
+IMPLEMENT "ansi", "stdio.h" ;
      </programlisting>

      <para>and just add the extra objects specified by POSIX. Note that this
        makes the relationship between the APIs <literal>ansi</literal> and
        <literal>posix</literal> absolutely explicit. <literal>tspec</literal>
        is as much concerned with the relationships between APIs as their
        actual contents.</para>

      <para>Objects which are specified as being declared in more than one
        header of an API should also be treated using
        <literal>+IMPLEMENT</literal>.  For example, the type
        <literal>size_t</literal> is declared in a number of
        <literal>ansi</literal> headers, namely <literal>stddef.h</literal>,
        <literal>stdio.h</literal>, <literal>string.h</literal> and
        <literal>time.h</literal>. This can be handled by declaring
        <literal>size_t</literal> as part of a named subset of, say,
        <literal>ansi:stddef.h</literal>:</para>

      <programlisting>
+SUBSET "size_t" := {
+TYPE (unsigned) size_t ;
} ;
      </programlisting>

      <para>and including this in each of the other headers:</para>

      <programlisting>
+IMPLEMENT "ansi", "stddef.h", "size_t" ;
      </programlisting>

      <para>Another use of <literal>+IMPLEMENT</literal> is in the
        <literal>MASTER</literal> file used to list the headers in an API (see
        <xref linkend="inputlayout">). This basically consists of a list of
        <literal>+IMPLEMENT</literal> commands, one per header. For example,
        with <literal>ansi</literal> it consists of:</para>

      <programlisting>
+IMPLEMENT "ansi", "assert.h" ;
+IMPLEMENT "ansi", "ctype.h" ;
....
+IMPLEMENT "ansi", "time.h" ;
      </programlisting>

      <para>To illustrate <literal>+USE</literal>,
        <literal>posix:sys/stat.h</literal> uses some types from
        <literal>posix:sys/types.h</literal> but does not define them. To
        avoid the user having to include both headers it makes sense for the
        description to include the latter in the former (provided there are no
        namespace restrictions imposed by the API). This would be done using
        the construct:</para>

      <programlisting>
+USE "posix", "sys/types.h" ;
      </programlisting>

      <para>On the command-line <literal>tspec</literal> is given one set of
        objects, be it an API, a header, or a subset of a header. This causes
        it to read that set, which may contain <literal>+IMPLEMENT</literal>
        or <literal>+USE</literal> commands. It then reads the sets indicated
        by these commands, which again may contain
        <literal>+IMPLEMENT</literal> or <literal>+USE</literal> commands, and
        so on. It is possible for this process to lead to infinite cycles, but
        in this case <literal>tspec</literal> raises an error and aborts. In
        the legal case, the collection of sets read by
        <literal>tspec</literal> is the closure of the set given on the
        command-line under <literal>+IMPLEMENT</literal> and
        <literal>+USE</literal>. Some of these sets will be implemented - that
        it to say, connected to the top level by a chain of
        <literal>+IMPLEMENT</literal> commands - others will merely be used.
        By default <literal>tspec</literal> produces output for all these
        sets, but specifying the <literal>-r</literal> command-line option
        restricts it to the implemented sets.</para>

      <para>For further information on the <literal>+IMPLEMENT</literal> and
        <literal>+USE</literal> commands see <xref linkend="finecontrol">.
        </para>

    </sect1>
  </chapter>

  <chapter id="c3">
    <title>Specifying Objects</title>

    <para>The main body of any <literal>tspec</literal> description of an API
      consists of a list of object specifications. Most of this section is
      concerned with the various <literal>tspec</literal> constructs for
      specifying objects of various kinds, however we start with a few remarks
      on object names.</para>

    <sect1 id="objectnames">
      <title>Object Names</title>
      <sect2 id="intextnames">
        <title>Internal and External Names</title>

        <para>All objects specified using <literal>tspec</literal> actually
          have two names. The first is the internal name by which it is
          identified within the program, the second is the external name by
          which the TDF construct (actually a token) representing this object
          is referred to for the purposes of TDF linking. The internal names
          are normal C identifiers and obey the normal C namespace rules
          (indeed one of the roles of <literal>tspec</literal> is to keep
          track of these namespaces). The external token name is constructed
          by <literal>tspec</literal> from the internal name.</para>

        <para><literal>tspec</literal> has two strategies for making up these
          token names. The first, which is default, is to use the internal
          name as the external name (there is an exception to this simple
          rule, namely field selectors - see <xref linkend="field">). The
          second, which is preferred for standard APIs, is to construct a
          "unique name" from the API name, the header and the internal name.
          For example, under the first strategy, the external name of the type
          <literal>FILE</literal> specified in <literal>ansi:stdio.h</literal>
          would be <literal>FILE</literal>, whereas under the second it would
          be <literal>ansi.stdio.FILE</literal>. The unique name strategy may
          be specified by passing the <literal>-u</literal> command-line
          option to <literal>tspec</literal> (see
          <xref linkend="cmdlineopts">) or by setting the
          <literal>UNIQUE</literal> property to 1 (see
          <xref linkend="fileprop">).</para>

        <para>Both strategies involve flattening the several C namespaces into
          the single TDF token namespace, which can lead to clashes. For
          example, in <literal>posix:sys/stat.h</literal> both a structure,
          <literal>struct stat</literal>, and a procedure,
          <literal>stat</literal>, are specified. In C the two uses of
          <literal>stat</literal> are in different namespaces and so present
          no difficulty, however they are mapped onto the same name in the TDF
          token namespace. To work round such difficulties,
          <literal>tspec</literal> allows an alternative external form to be
          specified. When the object is specified the form:</para>

        <programlisting>
iname | ename
        </programlisting>

        <para>may be used to specify the internal name
          <literal>iname</literal> and the external name
          <literal>ename</literal>.</para>

        <para>For example, in the <literal>stat</literal> case above we could
          distinguish between the two uses as follows:</para>

        <programlisting>
+TYPE struct stat | struct_stat ;
+FUNC int stat ( const char *, struct stat * ) ;
        </programlisting>

        <para>With simple token names the token corresponding to the structure
          would be called <literal>struct_stat</literal>, whereas that
          corresponding to the procedure would still be
          <literal>stat</literal>. With unique token names the names would be
          <literal>posix.stat.struct_stat</literal> and
          <literal>posix.stat.stat</literal> respectively.</para>

        <para>Very occasionally it may be necessary to precisely specify an
          external token name. This can be done using the form:</para>

        <programlisting>
iname | "ename"
        </programlisting>

        <para>which makes the object <literal>iname</literal> have external
          name <literal>ename</literal> regardless of the naming strategy
          used.</para>

      </sect2>
      <sect2 id="moreobj">
        <title>More on Object Names</title>

        <para>Basically the legal identifiers in <literal>tspec</literal> (for
          both internal and external names) are the same as those in C -
          strings of upper and lower case letters, decimal digits or
          underscores, which do not begin with a decimal digit. However there
          is a second class of local identifiers - those consisting of a tilde
          followed by any number of letters, digits or underscores - which are
          intended to indicate objects which are local to the API description
          and should not be visible to any application using the API. For
          example, to express the specification that <literal>t</literal> is a
          pointer type, we could say that there is a locally named type to
          which <literal>t</literal> is a pointer:</para>

        <programlisting>
+TYPE ~t ;
+TYPEDEF ~t *t ;
        </programlisting>

        <para>Finally it is possible to cheat the <literal>tspec</literal>
          namespaces. It may actually be legal to have two objects of the same
          name in an API - they may lie in different branches of a conditional
          compilation, or not be allowed to coexist. To allow for this,
          <literal>tspec</literal> allows version numbers, consisting of a
          decimal pointer plus a number of digits, to be appended to an
          identifier name when it is first introduced. These version numbers
          are purely to tell <literal>tspec</literal> that this version of the
          object is different from a previous version with a different version
          number (or indeed without any version number). If more than one
          version of an object is specified then which version is retrieved by
          <literal>tspec</literal> in any look-up operation is
          undefined.</para>

      </sect2>
    </sect1>

    <sect1 id="func">
      <title>+FUNC</title>

      <para>The simplest form of object to specify is a procedure. This is
        done by means of:</para>

      <programlisting>
+FUNC prototype ;
      </programlisting>

      <para>where <literal>prototype</literal> is the full C prototype of the
        procedure being declared. For example,
        <literal>ansi:string.h</literal> contains:</para>

      <programlisting>
+FUNC char *strcpy ( char *, const char * ) ;
+FUNC int strcmp ( const char *, const char * ) ;
+FUNC size_t strlen ( const char * ) ;
      </programlisting>

      <para>Strictly speaking, <literal>+FUNC</literal> means that the
        procedure may be implemented by a macro, but that there is an
        underlying library function with the same effect. The exception is for
        procedures which take a variable number of arguments, such as:</para>

      <programlisting>
+FUNC int fprintf ( FILE *, const char *, ... ) ;
      </programlisting>

      <para>which cannot be implemented by macros. Occasionally it may be
        necessary to specify that a procedure is only a library function, and
        cannot be implemented by a macro. In this case the form:</para>

      <programlisting>
+FUNC (extern) prototype ;
      </programlisting>

      <para>should be used. Thus:</para>

      <programlisting>
+FUNC (extern) char *strcpy ( char *, const char * ) ;
      </programlisting>

      <para>would mean that <literal>strcpy</literal> was only a library
        function and not a macro.</para>

      <para>Increasingly standard APIs are using prototypes to express their
        procedures. However it still may be necessary on occasion to specify
        procedures declared using old style declarations. In most cases these
        can be easily transcribed into prototype declarations, however things
        are not always that simple. For example,
        <literal>xpg3:stdlib.h</literal> declares <literal>malloc</literal> by
        the old style declaration:</para>

      <programlisting>
void *malloc ( sz )
size_t sz ;
      </programlisting>

      <para>which is in general different from the prototype:</para>

      <programlisting>
void *malloc ( size_t ) ;
      </programlisting>

      <para>In the first case the argument is passed as the integral promotion
        of <literal>size_t</literal>, whereas in the second it is passed as a
        <literal>size_t</literal> . In general we only know that
        <literal>size_t</literal> is an unsigned integral type, so we cannot
        assert that it is its own integral promotion. One possible solution
        would be to use the C to TDF producer's weak prototypes (see reference
        3). The form:</para>

      <programlisting>
+FUNC (weak) void *malloc ( size_t ) ;
      </programlisting>

      <para>means that <literal>malloc</literal> is a library function
        returning <literal>void *</literal> which is declared using an old
        style declaration with a single argument of type
        <literal>size_t</literal>.  (For an alternative approach see
        <xref linkend="typedef">.)</para>

    </sect1>

    <sect1 id="expconst">
      <title>+EXP and +CONST</title>

      <para>Expressions correspond to constants, identities and variables.
        They are specified by:</para>

      <programlisting>
+EXP type exp1, ..., expn ;
      </programlisting>

      <para>where <literal>type</literal> is the base type of the expressions
        <literal>expi</literal> as in a normal C declaration list. For
        example, in <literal>ansi:stdio.h</literal>:</para>

      <programlisting>
+EXP FILE *stdin, *stdout, *stderr ;
      </programlisting>

      <para>specifies three expressions of type <literal>FILE *</literal>.
        </para>

      <para>By default all expressions are rvalues, that is, values which
        cannot be assigned to. If an lvalue (assignable) expression is
        required its type should be qualified using the keyword
        <literal>lvalue</literal>. This is an extension to the C type syntax
        which is used in a similar fashion to <literal>const</literal>. For
        example, <literal>ansi:errno.h</literal> says that
        <literal>errno</literal> is an assignable lvalue of type
        <literal>int</literal>. This is expressed as follows:</para>

      <programlisting>
+EXP lvalue int errno ;
      </programlisting>

      <para>On the other hand, <literal>posix:errno.h</literal> states that
        <literal>errno</literal> is an external value of type
        <literal>int</literal>. As with procedures the
        <literal>(extern)</literal> qualifier may be used to express this
        as:</para>

      <programlisting>
+EXP (extern) int errno ;
      </programlisting>

      <note>

        <para>This automatically means that <literal>errno</literal> is an
          lvalue, so the <literal>lvalue</literal> qualifier is optional in
          this case.</para>

      </note>

      <para>If all the expressions are guaranteed to be literal constants then
        one of the equivalent forms:</para>

      <programlisting>
+EXP (const) type exp1, ..., expn ;
+CONST type exp1, ..., expn ;
      </programlisting>

      <para>should be used. For example, in <literal>ansi:errno.h</literal> we
        have:</para>

      <programlisting>
+CONST int EDOM, ERANGE ;
      </programlisting>

    </sect1>

    <sect1 id="macro">
      <title>+MACRO</title>

      <para>The <literal>+MACRO</literal> construct is similar in form to the
        <literal>+FUNC</literal> construct, except that it means that only a
        macro exists, and no underlying library function. For example, in
        <literal>xpg3:ctype.h</literal> we have:</para>

      <programlisting>
+MACRO int _toupper ( int ) ;
+MACRO int _tolower ( int ) ;
      </programlisting>

      <para>since these are explicitly stated to be macros and not functions.
        Of course the <literal>(extern)</literal> qualifier cannot be used
        with <literal>+MACRO</literal>.</para>

      <para>One thing which macros can do which functions cannot is to return
        assignable values or to assign to their arguments. Thus it is
        legitimate for <literal>+MACRO</literal> constructs to have their
        return type or argument types qualified by <literal>lvalue</literal>,
        whereas this is not allowed for <literal>+FUNC</literal> constructs.
        For example, in <literal>svid3:curses.h</literal>, a macro
        <literal>getyx</literal> is specified which takes a pointer to a
        window and two integer variables and assigns the cursor position of
        the window to those variables. This may be expressed by:</para>

      <programlisting>
+MACRO void getyx ( WINDOW *win, lvalue int y, lvalue int x ) ;
      </programlisting>

    </sect1>

    <sect1 id="statement">
      <title>+STATEMENT</title>

      <para>The <literal>+STATEMENT</literal> construct is very similar to the
        <literal>+MACRO</literal> construct except that, instead of being a C
        expression, it is a C statement (i.e. something ending in a
        semicolon).  As such it does not have a return type and so takes one
        of the forms:</para>

      <programlisting>
+STATEMENT stmt ;
+STATEMENT stmt ( arg1, ..., argn ) ;
      </programlisting>

      <para>depending on whether or not it takes any arguments. (A
        <literal>+MACRO</literal> without any arguments is an
        <literal>+EXP</literal>, so the no argument form does not exist for
        <literal>+MACRO</literal>.) As with <literal>+MACRO</literal>, the
        argument types <literal>argi</literal> can be qualified using
        <literal>lvalue</literal>.</para>

    </sect1>

    <sect1 id="define">
      <title>+DEFINE</title>

      <para>It is possible to insert macro definitions directly into
        <literal>tspec</literal> using the <literal>+DEFINE</literal>
        construct. This has two forms depending on whether the macro has
        arguments:</para>

      <programlisting>
+DEFINE name %% text %% ;
+DEFINE name ( arg1, ..., argn ) %% text %% ;
      </programlisting>

      <para>These translate directly into:</para>

      <programlisting>
#define name text
#define name( arg1, ..., argn ) text
      </programlisting>

      <para>The macro definition, <literal>text</literal>, consists of any
        string of characters delimited by double percents. If
        <literal>text</literal> is a simple number or a single identifier then
        the double percents may be omitted. Thus in
        <literal>ansi:stddef.h</literal> we have:</para>

      <programlisting>
+DEFINE NULL 0 ;
      </programlisting>

    </sect1>

    <sect1 id="type">
      <title>+TYPE</title>

      <para>New types may be specified using the <literal>+TYPE</literal>
        construct. This has the form:</para>

      <programlisting>
+TYPE type1, ..., typen ;
      </programlisting>

      <para>where each <literal>typei</literal> has one of the forms:</para>

      <itemizedlist>
        <listitem>
          <para><literal>name</literal> for a general type (about which we
            know nothing more),</para>
        </listitem>
        <listitem>
          <para><literal>(struct) name</literal> for a structure type,</para>
        </listitem>
        <listitem>
          <para><literal>(union) name</literal> for a union type,</para>
        </listitem>
        <listitem>
          <para><literal>struct name</literal> for a structure tag,</para>
        </listitem>
        <listitem>
          <para><literal>union name</literal> for a union tag,</para>
        </listitem>
        <listitem>
          <para><literal>(int) name</literal> for an integral type,</para>
        </listitem>
        <listitem>
          <para><literal>(signed) name</literal> for a signed integral
            type,</para> </listitem>
        <listitem>
          <para><literal>(unsigned) name</literal> for an unsigned integral
            type,</para> </listitem>
        <listitem>
          <para><literal>(float) name</literal> for a floating type,</para>
        </listitem>
        <listitem>
          <para><literal>(arith) name</literal> for an arithmetic (integral or
            floating) type,</para>
        </listitem>
        <listitem>
          <para><literal>(scalar) name</literal> for a scalar (arithmetic or
            pointer) type.</para>
        </listitem>
      </itemizedlist>

      <para>To make clear the distinction between structure types and
        structure tags, if we have in C:</para>

      <programlisting>
typedef struct tag { int x, y ; } type ;
      </programlisting>

      <para>then <literal>type</literal> is a structure type and
        <literal>tag</literal> is a structure tag.</para>

      <para>For example, in <literal>ansi</literal> we have:</para>

      <programlisting>
+TYPE FILE ;
+TYPE struct lconv ;
+TYPE (struct) div_t ;
+TYPE (signed) ptrdiff_t ;
+TYPE (unsigned) size_t ;
+TYPE (arith) time_t ;
+TYPE (int) wchar_t ;
      </programlisting>

    </sect1>

    <sect1 id="typedef">
      <title>+TYPEDEF</title>

      <para>It is also possible to define new types in terms of existing
        types.  This is done using the <literal>+TYPEDEF</literal> construct,
        which is identical in form to the C <literal>typedef</literal>
        construct. This construct can be used to define pointer, procedure and
        array types, but not compound structure and union types. For these see
        <xref linkend="field"> below.</para>

      <para>For example, in <literal>xpg3:search.h</literal> we have:</para>

      <programlisting>
+TYPE struct entry ;
+TYPEDEF struct entry ENTRY ;
      </programlisting>

      <para>There are a couple of special forms. To understand the first, note
        that C uses <literal>void</literal> function returns for two purposes.
        Firstly to indicate that the function does not return a value, and
        secondly to indicate that the function does not return at all
        (<literal>exit</literal> is an example of this second usage). In TDF
        terms, in the first case the function returns <literal>TOP</literal>,
        in the second it returns <literal>BOTTOM</literal> .
        <literal>tspec</literal> allows types to be introduced which have the
        second meaning. For example, we could have:</para>

      <programlisting>
+TYPEDEF ~special ( "bottom" ) ~bottom ;
+FUNC ~bottom exit ( int ) ;
      </programlisting>

      <para>meaning that the local type <literal>~bottom</literal> is the
        <literal>BOTTOM</literal> form of <literal>void</literal>. The
        procedure <literal>exit</literal>, which never returns, can then be
        declared to return <literal>~bottom</literal> rather than
        <literal>void</literal>. Other such special types may be added in
        future.</para>

      <para>The second special form:</para>

      <programlisting>
+TYPEDEF ~promote ( x ) y ;
      </programlisting>

      <para>means that <literal>y</literal> is an integral type which is the
        integral promotion of <literal>x</literal>. <literal>x</literal> must
        have previously been declared as an integral type. This gives an
        alternative approach to the old style procedure declaration problem
        described in <xref linkend="func">. Recall that:</para>

      <programlisting>
void *malloc ( sz )
size_t sz ;
      </programlisting>

      <para>means that <literal>malloc</literal> has one argument which is
        passed as the integral promotion of <literal>size_t</literal>. This
        could be expressed as follows:</para>

      <programlisting>
+TYPEDEF ~promote ( size_t ) ~size_t ;
+FUNC void *malloc ( ~size_t ) ;
      </programlisting>

      <para>introducing a local type to stand for the integral promotion of
        <literal>size_t</literal> .</para>

    </sect1>

    <sect1 id="field">
      <title>+FIELD</title>

      <para>Having specified a structure or union type, or a structure or
        union tag, we may wish to specify certain fields of this structure or
        union.  This is done using the <literal>+FIELD</literal> construct.
        This takes the form:</para>

      <programlisting>
+FIELD type {
  ftype field1, ..., fieldn ;
  ....
} ;
      </programlisting>

      <para>where <literal>type</literal> is the structure or union type and
        <literal>field1</literal>, ..., <literal>fieldn</literal> are field
        selectors derived from the base type <literal>ftype</literal> as in a
        normal C structure definition. <literal>type</literal> may have one of
        the forms:</para>

      <itemizedlist>
        <listitem>
          <para><literal>(struct) name</literal> for a structure type,</para>
        </listitem>
        <listitem>
          <para><literal>(union) name</literal> for a union type,</para>
        </listitem>
        <listitem>
          <para><literal>struct name</literal> for a structure tag,</para>
        </listitem>
        <listitem>
          <para><literal>union name</literal> for a union tag,</para>
        </listitem>
        <listitem>
          <para><literal>name</literal> for a previously declared structure or
            union type.</para>
        </listitem>
      </itemizedlist>

      <para>Except in the final case (where it is not clear if
        <literal>type</literal> is a structure or a union), it is not
        necessary to have previously introduced <literal>type</literal> using
        a <literal>+TYPE</literal> construct - this declaration is implicit in
        the <literal>+FIELD</literal> construct.</para>

      <para>For example, in <literal>ansi:time.h</literal> we have:</para>

      <programlisting>
+FIELD struct tm {
  int tm_sec ;
  int tm_min ;
  int tm_hour ;
  int tm_mday ;
  int tm_mon ;
  int tm_year ;
  int tm_wday ;
  int tm_yday ;
  int tm_isdst ;
} ;
      </programlisting>

      <para>meaning that there exists a structure with tag
        <literal>tm</literal> with various fields of type
        <literal>int</literal>. Any implementation must have these
        corresponding fields, but they need not be in the given order, nor do
        they have to comprise the whole structure.</para>

      <para>As was mentioned above (in <xref linkend="intextnames">), field
        selectors form a special case when <literal>tspec</literal> is making
        up external token names. For example, in the case above, the token
        name for the <literal>tm_sec</literal> field is either
        <literal>tm.tm_sec</literal> or <literal>ansi.time.tm.tm_sec</literal>
        , depending on whether or not unique token names are used.</para>

      <para>It is possible to have several <literal>+FIELD</literal>
        constructs referring to the same structure or union. For example,
        <literal>posix:dirent.h</literal> declares a structure with tag
        <literal>dirent</literal> and one field, <literal>d_name</literal> ,
        of this structure. <literal>xpg3:dirent.h</literal> extends this by
        adding another field, <literal>d_ino</literal>.</para>

      <para>There is a second form of the <literal>+FIELD</literal> construct
        which has more in common with the <literal>+TYPEDEF</literal>
        construct. The form:</para>

      <programlisting>
+FIELD type := {
  ftype field1, ..., fieldn ;
  ....
} ;
      </programlisting>

      <para>means that the type <literal>type</literal> is defined to be
        exactly the given structure or union type, with precisely the given
        fields in the given order.</para>

    </sect1>

    <sect1 id="nat">
      <title>+NAT</title>

      <para>In the example given in <xref linkend="field">,
        <literal>posix:dirent.h</literal> specifies that the
        <literal>d_name</literal> field of <literal>struct dirent</literal> is
        a fixed sized array of characters, but that the size of this array is
        implementation dependent. We therefore have to introduce a value to
        stand for the size of this array using the <literal>+NAT</literal>
        construct. This has the form:</para>

      <programlisting>
+NAT nat1, ..., natn ;
      </programlisting>

      <para>where <literal>nat1</literal>, ..., <literal>natn</literal> are
        the array sizes to be declared. The example thus becomes:</para>

      <programlisting>
+NAT ~dirent_d_name_size ;
+FIELD struct dirent {
char d_name [ ~dirent_d_name_size ] ;
} ;
      </programlisting>

      <para>Note the use of a local variable to stand for a value, namely the
        array size, which is invisible to the user (see
        <xref linkend="moreobj">).</para>

      <para>As another example, in <literal>ansi:setjmp.h</literal> we know
        that <literal>jmp_buf</literal> is an array type. We therefore
        introduce objects to stand for the type which it is an array of and
        for the size of the array, and define <literal>jmp_buf</literal> by a
        <literal>+TYPEDEF</literal> command:</para>

      <programlisting>
+NAT ~jmp_buf_size ;
+TYPE ~jmp_buf_elt ;
+TYPEDEF ~jmp_buf_elt jmp_buf [ ~jmp_buf_size ] ;
      </programlisting>

      <para>Again, local variables have been used for the introduced
        objects.</para>

    </sect1>

    <sect1 id="enum">
      <title>+ENUM</title>

      <para>Currently <literal>tspec</literal> only has limited support for
        enumeration types. A <literal>+ENUM</literal> construct is translated
        directly into a C definition of an enumeration type. The
        <literal>+ENUM</literal> construct has the form:</para>

      <programlisting>
+ENUM etype := {
entry,
....
} ;
      </programlisting>

      <para>where <literal>etype</literal> is the enumeration type being
        defined - either a type name or <literal>enum etag</literal> for some
        enumeration tag <literal>etag</literal> - and each
        <literal>entry</literal> has one of the forms:</para>

      <programlisting>
name
name = number
      </programlisting>

      <para>as in a C enumeration type. For example, in
        <literal>xpg3:search.h</literal> we have:</para>

      <programlisting>
+ENUM ACTION := { FIND, ENTER } ;
      </programlisting>

    </sect1>

    <sect1 id="token">
      <title>+TOKEN</title>

      <para>As was mentioned in <xref linkend="preface">, the <literal>#pragma
        token</literal> syntax is highly complex, and the token descriptions
        output by <literal>tspec</literal> form only a small subset of those
        possible. It is possible to directly access the full <literal>#pragma
        token</literal> syntax from <literal>tspec</literal> using the
        construct:</para>

      <programlisting>
+TOKEN name %% text %% ;
      </programlisting>

      <para>where the token <literal>name</literal> is defined by the sequence
        of characters <literal>text</literal>, which is delimited by double
        percents. This is turned into the token description:</para>

      <programlisting>
#pragma token text name #
      </programlisting>

      <para>No checks are applied to <literal>text</literal>. A more
        sophisticated mechanism for defining complex tokens may be introduced
        in a later version of <literal>tspec</literal>.</para>

      <para>For example, in <literal>ansi:stdarg.h</literal> a token
        <literal>va_arg</literal> is defined which takes a variable of type
        <literal>va_list</literal> and a type <literal>t</literal> and returns
        a value of type <literal>t</literal>. This is given by:</para>

      <programlisting>
+TOKEN va_arg %% PROC ( EXP lvalue : va_list : e, TYPE t ) EXP rvalue : t : %% ;
      </programlisting>

      <para>See reference 3 for more details on the token syntax.</para>

    </sect1>
  </chapter>

  <chapter id="c4">
    <title>Other tspec Constructs</title>

    <para>Although most <literal>tspec</literal> constructs are concerned
      either with specifying new objects or imposing structure upon various
      sets of objects, there are a few which do not fall into these
      categories.</para>

    <sect1 id="ifelse">
      <title>+IF, +ELSE and +ENDIF</title>

      <para>It is possible to introduce conditional compilation into the API
        description by means of the constructs:</para>

      <programlisting>
+IF %% text %%
+IFDEF %% text %%
+IFNDEF %% text %%
+ELSE
+ENDIF
      </programlisting>

      <para>which are translated into:</para>

      <programlisting>
#if text
#ifdef text
#ifndef text
#else /* text */
#endif /* text */
      </programlisting>

      <para>respectively. If <literal>text</literal> is just a simple number
        or a single identifier the double percent delimiters may be
        excluded.</para>

      <para>A couple of special <literal>+IFDEF</literal> (and also
        <literal>+IFNDEF</literal>) forms are available which are useful on
        occasion. These are:</para>

      <programlisting>
+IFDEF ~building_libs
+IFDEF ~protect ( "api", "header" )
      </programlisting>

      <para>The macros in these constructs expand respectively to
        <literal>__BUILDING_LIBS</literal> which, by convention is defined if
        and only if TDF library building is taking place (see
        <xref linkend="tdflibbuild">), and the protection macro
        <literal>tspec</literal> makes up to protect the file
        <literal>api:header</literal> against multiple inclusion (see
        <xref linkend="protmacros">).</para>

    </sect1>

    <sect1 id="quoted">
      <title>Quoted Text</title>

      <para>It is sometimes desirable to include text in the specification
        file which will be copied directly into one of the output files - for
        example, sections of C. This can be done by enclosing the text for
        copying into the include output file in double percents:</para>

      <programlisting>
%% text %%
      </programlisting>

      <para>and text for copying into the source output file in triple
        percents:</para>

      <programlisting>
%%% text %%%
      </programlisting>

      <para>In fact more percents may be used. An even number always indicates
        text for the include output file, and an odd number the source output
        file.  Note that any <literal>#</literal> characters in
        <literal>text</literal> are copied as normal, and not treated as
        comments. This also applies to the other cases where percent
        delimiters are used.</para>

    </sect1>

    <sect1 id="comments">
      <title>C Comments</title>

      <para>A special case of quoted text are C style comments:</para>

      <programlisting>
/* text */
      </programlisting>

      <para>which are copied directly into the include output file.</para>

    </sect1>

    <sect1 id="fileprop">
      <title>File Properties</title>

      <para>Various properties of individual sets of objects or global
        properties can be set using file properties. These take the
        form:</para>

      <programlisting>
$property = number ;
      </programlisting>

      <para>for numeric (or boolean) properties, and:</para>

      <programlisting>
$property = "string" ;
      </programlisting>

      <para>for string properties.</para>

      <para>The valid property names are as follows:</para>

      <itemizedlist>
        <listitem>
          <para><literal>APINAME</literal> is a string property which may be
            used to override the API name of the current set of objects.</para>
        </listitem>
        <listitem>
          <para><literal>FILE</literal> is a string property which is used by
            the <literal>tspec</literal> preprocessor to indicate the current
            input file name.</para>
        </listitem>
        <listitem>
          <para><literal>FILENAME</literal> is a string property which may be
            used to override the header name of the current set of
            objects.</para>
        </listitem>
        <listitem>
          <para><literal>INCLNAME</literal> is a string property which may be
            used to set the name of the include output file in place of the
            default name given in <xref linkend="outputlayout">. Setting the
            property to the empty string suppresses the output of this
            file.</para>
        </listitem>
        <listitem>
          <para><literal>INTERFACE</literal> is a numeric property which may
            be set to force the creation of the source output file and cleared
            to suppress it.</para>
        </listitem>
        <listitem>
          <para><literal>LINE</literal> is a numeric property which is used by
            the <literal>tspec</literal> preprocessor to indicate the current
            input file line number.</para>
        </listitem>
        <listitem>
          <para><literal>METHOD</literal> is a string property which may be
            used to specify alternative construction methods for TDF library
            building (see <xref linkend="tdflibbuild">).</para>
        </listitem>
        <listitem>
          <para><literal>PREFIX</literal> is a string property which may be
            used as a prefix to unique token names in place of the API and
            header names (see <xref linkend="intextnames">).</para>
        </listitem>
        <listitem>
          <para><literal>PROTECT</literal> is a string property which may be
            used to set the macro used by <literal>tspec</literal> to protect
            the include output file against multiple inclusions (see
            <xref linkend="protmacros">). Setting the property to the empty
            string suppresses this macro.</para>
        </listitem>
        <listitem>
          <para><literal>SOURCENAME</literal> is a string property which may
            be used to set the name of the source output file in place of the
            default name given in <xref linkend="outputlayout">. Setting the
            property to the empty string suppresses the output of this
            file.</para>
        </listitem>
        <listitem>
          <para><literal>SUBSETNAME</literal> is a string property which may
            be used to override the subset name of the current set of
            objects.</para>
        </listitem>
        <listitem>
          <para><literal>UNIQUE</literal> is a numeric property which may be
            used to switch the unique token name flag on and off (see
            <xref linkend="intextnames">). For standard APIs it is recommended
            that this property is set to 1 in the API
            <literal>MASTER</literal> file.</para>
        </listitem>
        <listitem>
          <para><literal>VERBOSE</literal> is a numeric property which may be
            used to set the level of the verbose option (see
            <xref linkend="cmdlineopts">).</para>
        </listitem>
        <listitem>
          <para><literal>VERSION</literal> is a string property which may be
            used to assign a version number or other identification to a
            <literal>tspec</literal> description. This information is
            reproduced in the corresponding include output file.</para>
        </listitem>
      </itemizedlist>
    </sect1>
  </chapter>

  <chapter id="c5">
    <title>Miscellaneous Topics</title>

    <para>In this section we round up a few miscellaneous topics.</para>

    <sect1 id="finecontrol">
      <title>Fine Control of Included Files</title>

      <para>The <literal>+IMPLEMENT</literal> and <literal>+USE</literal>
        commands described in <xref linkend="implementuse"> are capable of
        further refinement.  Normally each such command is translated into a
        corresponding inclusion command in both the include and source output
        files. Occasionally this is not desirable - in particular the
        inclusion in the source output file can cause problems during TDF
        library building. For this reason the <literal>tspec</literal> syntax
        has been extended to allow for fine control of the output
        corresponding to <literal>+IMPLEMENT</literal> and
        <literal>+USE</literal> commands. This takes the forms:</para>

      <programlisting>
+IMPLEMENT "api" (key) ;
+IMPLEMENT "api", "header" (key) ;
+IMPLEMENT "api", "header", "subset" (key) ;
      </programlisting>

      <para>with corresponding forms for <literal>+USE</literal>.
        <literal>key</literal> specifies which output files the inclusion
        commands should appear in. It can be:</para>

      <itemizedlist>
        <listitem>
          <para><literal>??</literal>, indicating neither output file,</para>
        </listitem>
        <listitem>
          <para><literal>!?</literal>, indicating the include output file
            only,</para>
        </listitem>
        <listitem>
          <para><literal>?!</literal>, indicating the source output file
            only,</para>
        </listitem>
        <listitem>
          <para><literal>!!</literal>, indicating both output files (this is
            the same as the normal form).</para>
        </listitem>
      </itemizedlist>

      <para>The second refinement comes from the fact that APIs fall into two
        categories - the base APIs, such as <literal>ansi</literal>,
        <literal>posix</literal> and <literal>xpg3</literal>, and the
        extension APIs, such as <literal>x11</literal>, the X Windows API. The
        latter can be used to extend the former, so that we can form
        <literal>ansi</literal> plus <literal>x11</literal>,
        <literal>posix</literal> plus <literal>x11</literal>, and so on. Base
        APIs may be distinguished in <literal>tspec</literal> by including the
        command:</para>

      <programlisting>
+BASE_API ;
      </programlisting>

      <para>in their <literal>MASTER</literal> file. Occasionally, in an
        extension API, we may wish to include a version of a header from the
        base API, but, because this base API is not fixed, not be able to use
        a simple <literal>+USE</literal> command. Instead the special
        form:</para>

      <programlisting>
+USE ( "api" ), "header" ;
      </programlisting>

      <para>is provided for this purpose (this is the only permitted form). It
        indicates that <literal>tspec</literal> should use the
        <literal>api</literal> version of <literal>header</literal> for
        checking purposes, but allow the inclusion of the version from the
        base API in normal use.</para>

    </sect1>

    <sect1 id="protmacros">
      <title>Protection Macros</title>

      <para>Each include output file is surrounded by a construct of the
        form:</para>

      <programlisting>
#ifndef MACRO
#define MACRO
....
#endif /* MACRO */
      </programlisting>

      <para>to protect it against multiple inclusions. Normally
        <literal>tspec</literal> will generate the macro name,
        <literal>MACRO</literal>, but it can be set using the
        <literal>PROTECT</literal> file property (see
        <xref linkend="fileprop">). Setting <literal>PROTECT</literal> to the
        empty string suppresses the protection construct altogether. (Also see
        <xref linkend="ifelse">)</para>

    </sect1>

    <sect1 id="idxprint">
      <title>Index Printing</title>

      <para>If it is invoked with the <literal>-i</literal> command-line
        option, instead of creating its output file, <literal>tspec</literal>
        prints an index of all the objects it has read to the standard output.
        This information includes the external token name associated with the
        object, whether the object is implemented or used, and where in the
        API description it is defined. It also includes a brief description of
        the object. It is intended that these indexes should be usable as
        quick reference guides to the underlying APIs.</para>

    </sect1>

    <sect1 id="tdflibbuild">
      <title>TDF Library Building</title>

      <para>As was explained in reference 1, the <literal>#pragma
        token</literal> headers output by <literal>tspec</literal> are used
        for two purposes - checking applications against the API during normal
        compilation and checking implementations against the API during TDF
        library building.  This dual use does necessitate some extra work for
        <literal>tspec</literal>. It is not always possible to use exactly the
        same code in the two cases (usually because the C rules on, for
        example, structure definitions get in the way during library
        building).  <literal>tspec</literal> uses a standard macro,
        <literal>__BUILDING_LIBS</literal>, to distinguish between the two
        cases. It is assumed to be defined if and only if library building is
        taking place. <literal>tspec</literal> descriptions can access this
        macro directly using <literal>~building_libs</literal> (see
        <xref linkend="ifelse">).</para>

      <para>The actual library building process consists of compiling the
        <literal>#pragma token</literal> descriptions of the objects
        comprising the API along with the implementation of that API from the
        system headers (or wherever). This creates the local token definitions
        for this API, which may be stored in a token library. To facilitate
        this process <literal>tspec</literal> creates the source output files
        for each implemented header <literal>api:header</literal> containing
        something like:</para>

      <programlisting>
#pragma implement interface &lt;../api/header&gt;
#include &lt;header&gt;
      </programlisting>

      <para>together with a makefile to compile all these programs to token
        definitions and to combine these token definitions into a token
        library. In fact two makefiles are created in the source output
        directory (see <xref linkend="outputlayout">). The first is called
        <literal>M_api</literal> and is designed for stand-alone library
        construction. The second is called <literal>Makefile</literal> and is
        designed for use with the library building script
        <literal>MAKE_LIBS</literal> provided with <literal>tspec</literal>.
        </para>

      <para>There are other methods whereby the source output file may be
        changed into a set of token definitions. For example, in
        <literal>c:sys.h</literal> the <literal>METHOD</literal> file property
        (see <xref linkend="fileprop">) is set to <literal>TDP</literal>,
        causing the <literal>tdp</literal> program to be invoked to produce
        the definitions for the basic C tokens for the system. As another
        example consider:</para>

      <programlisting>
$METHOD = "TNC" ;
+MACRO double fl_abs ( double ) ;
%%%
  ( make_tokdef fl_abs ( exp x ) exp
  ( floating_abs impossible x ) )
%%%
      </programlisting>

      <para>The include output file will specify a token
        <literal>fl_abs</literal> which takes a <literal>double</literal> and
        returns a <literal>double</literal>. The <literal>TNC</literal> method
        tells <literal>MAKE_LIBS</literal> that the source output file, which
        will just contain the quoted text:</para>

      <programlisting>
( make_tokdef fl_abs ( exp x ) exp
( floating_abs impossible x ) )
      </programlisting>

      <para>is an input file for the TDF notation compiler,
        <literal>tnc</literal> (see reference 2). Thus we have defined a token
        which directly accesses the TDF <literal>floating_abs</literal>
        construct.</para>

    </sect1>
  </chapter>

  <chapter id="c6">
    <title>Changes in tspec 2.0</title>

    <para>This document describes <literal>tspec</literal> version 2.0.
      <literal>tspec</literal> 2.0 contains significant changes from previous
      releases. For convenience the main changes which are visible to the
      <literal>tspec</literal> user are listed here:</para>

    <itemizedlist>
      <listitem>
        <para>The added specification level of named subsets of headers has
          been introduced (see <xref linkend="speclevel">). This has been done
          by introducing the <literal>+SUBSET</literal> construct and
          extending the <literal>+IMPLEMENT</literal> and
          <literal>+USE</literal> constructs, as well as the command-line
          options. The previous method of dealing with such subsets - namely
          shared headers - is now obsolete and its use is discouraged.</para>
      </listitem>
      <listitem>
        <para>A number of new command-line options have been added, and some
          of the existing options have been modified slightly (see
          <xref linkend="cmdlineopts">).</para>
      </listitem>
      <listitem>
        <para>The suffix <literal>.api</literal> has been added to the output
          directories (see <xref linkend="outputlayout">) to avoid possible
          confusion with other include file directories.</para>
      </listitem>
      <listitem>
        <para>The use of identifiers beginning with <literal>~</literal> as
          local variables is new (see <xref linkend="moreobj">).</para>
      </listitem>
      <listitem>
        <para>The <literal>+STATEMENT</literal> and <literal>+DEFINE</literal>
          constructs (see <xref linkend="statement"> and <xref
          linkend="define">) are new.</para>
      </listitem>
      <listitem>
        <para>The <literal>(extern)</literal>, <literal>(weak)</literal> and
          <literal>(const)</literal> qualifiers for <literal>+FUNC</literal>
          and <literal>+EXP</literal> (see <xref linkend="func"> and
          <xref linkend="expconst">) are new.</para>
      </listitem>
      <listitem>
        <para>The <literal>(signed)</literal> and
          <literal>(unsigned)</literal> qualifiers for
          <literal>+TYPE</literal> (see <xref linkend="type">) are new.</para>
      </listitem>
      <listitem>
        <para>The <literal>~special</literal> type constructor (see
          <xref linkend="typedef">) is new.</para>
      </listitem>
      <listitem>
        <para>The <literal>~abstract</literal> type constructor has been
        abandoned.</para>
      </listitem>
      <listitem>
        <para>The <literal>+BASE_API</literal> command described in
          <xref linkend="finecontrol"> is new.</para>
      </listitem>
      <listitem>
        <para>The indexing routines (see <xref linkend="idxprint">) have been
          greatly improved.</para>
      </listitem>
    </itemizedlist>
  </chapter>
</book>
