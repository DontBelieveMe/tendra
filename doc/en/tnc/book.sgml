<!DOCTYPE BOOK PUBLIC "-//FreeBSD//DTD DocBook V4.1-Based Extension//EN"[
<!ENTITY % bookinfo PUBLIC "-//FreeBSD//ENTITIES DocBook BookInfo Entities//EN">
%bookinfo;
<!ENTITY % doc PUBLIC "-//FreeBSD//ENTITIES DocBook Document Entities//EN">
%doc
]>

<book>
  <bookinfo>
    <title>tnc User's Guide</title>

    <pubdate>$TenDRA$</pubdate>

    <corpauthor>The TenDRA Documentation Team</corpauthor>

    <copyright>
      <year>2002</year>
      <year>2003</year>
      <year>2004</year>
      <holder>TenDRA Documentation Team</holder>
    </copyright>

    <copyright>
      <year>1997</year>
      <year>1998</year>
      <holder>Defence Evaluation and Research Agency (DERA)</holder>
    </copyright>

    <abstract>
      <para>Please email us at <email>docs@ten15.org</email> if you see any errors.</para>
    </abstract>

    <legalnotice id='legalnotice'>
      <para>Extensions to this document from the original
        <ulink url='ftp://ftp.ten15.org/pub/source/TenDRA-4.1.2-doc.tar.gz'>TenDRA-4.1.2-doc.tar.gz</ulink>
        source distribution are covered by the <link linkend='legal-bsdl'>BSDL</link>,
        while all prior modifications remain under the
        <link linkend='legal-crown'>Crown Copyright</link>.</para>
    </legalnotice>

    &bookinfo.legalnotice;

    &bookinfo.legalnotice-crown;

  </bookinfo>

  <preface id='intro'>
    <title>Introduction</title>

    <para>The TDF notation compiler, <literal>tnc</literal>, is a tool for
      translating TDF capsules to and from text. This paper gives a brief
      introduction to how to use this utility and the syntax of the textual
      form of TDF. The version here described is that supporting version 3.1 of
      the TDF specification.</para>

    <para><literal>tnc</literal> has four modes, two input modes and two output
      modes. These are as follows:</para>

    <itemizedlist>
      <listitem>
        <para><literal>decode</literal> - translate an input TDF capsule into the
          <literal>tnc</literal> internal representation,</para>
      </listitem>
      <listitem>
        <para><literal>read</literal> - translate an input text file into the
          internal representation,</para>
      </listitem>
      <listitem>
        <para><literal>encode</literal> - translate the internal representation
          into an output TDF capsule,</para>
      </listitem>
      <listitem>
        <para><literal>write</literal> - translate the internal representation into
          an output text file.</para>
      </listitem>
    </itemizedlist>

    <para>Due to the modular nature of the program it is possible to form versions
      of <literal>tnc</literal> in which not all the modes are available.
      Passing the <literal>-version</literal> flag to <literal>tnc</literal>
      causes it to report which modes it has implemented.</para>

    <para>Any application of <literal>tnc</literal> consists of the composite of an
      input mode and an output mode. The default action is
      <literal>read</literal>-<literal>encode</literal>, i.e. translate an
      input test file into an output TDF capsule. Other modes may be specified
      by passing the following command line options to <literal>tnc</literal>:</para>

    <itemizedlist>
      <listitem>
        <para><literal>-decode</literal> or <literal>-d</literal>,</para>
      </listitem>
      <listitem>
        <para><literal>-read</literal> or <literal>-r</literal>,</para>
      </listitem>
      <listitem>
        <para><literal>-encode</literal> or <literal>-e</literal>,</para>
      </listitem>
      <listitem>
        <para><literal>-write</literal> or <literal>-w</literal>.</para>
      </listitem>
    </itemizedlist>

    <para>The only other really useful action is
      <literal>decode</literal>-<literal>write</literal>, i.e. translate an
      input TDF capsule into an output text file. This may also be specified by
      the <literal>-print</literal> or <literal>-p</literal> option. The
      actions <literal>decode</literal>-<literal>encode</literal> and
      <literal>read</literal>-<literal>write</literal> are not precise
      identities, they do however give equivalent input and output files.</para>

    <para>In addition, the <literal>decode</literal> mode may be modified to accept
      a TDF library as input rather than a TDF capsule by passing the addition
      flag:</para>

    <para><literal>-lib</literal> or <literal>-l</literal>,</para>

    <para>to <literal>tnc</literal>.</para>

    <para>The overall syntax for <literal>tnc</literal> is as follows:</para>

    <cmdsynopsis>
      <command>tnc</command>
      <arg>
        <replaceable>options</replaceable>
      </arg>
      <arg>
        <replaceable>input_file</replaceable>
      </arg>
      <arg>
        <replaceable>output_file</replaceable>
      </arg>
    </cmdsynopsis>

    <para>If the output file is not specified, the standard output is used.</para>

  </preface>

  <chapter id='input-classes'>
    <title>Input classes</title>

    <para>The rest of this paper is concerned with the form required of the input
      text file. The input can be divided into eight classes.</para>

    <sect1 id='delimiters'>
      <title>Delimiters</title>

      <para>The characters <literal>(</literal> and <literal>)</literal> are used
        as delimiters to impose a syntactic structure on the input.</para>

    </sect1>

    <sect1 id='white-space'>
      <title>White space</title>

      <para>White space comprises sequences of space, tab and newline characters,
        together with comments (see below). It is not significant to the output
        (TDF notation is completely free-form), and serves only to separate
        syntactic units. Every identifier, number etc. must be terminated by a
        white space or a delimiter.</para>

    </sect1>

    <sect1 id='comments'>
      <title>Comments</title>

      <para>Comments may be inserted in the input at any point. They begin with a
        <literal>#</literal> character and run to the end of the line.</para>

    </sect1>

    <sect1 id='identifiers'>
      <title>Identifiers</title>

      <para>An identifier consists of any sequence of characters drawn from the
        following set: upper case letters, lower case letters, decimal digits,
        underscore (<literal>_</literal>), dot (<literal>.</literal>), and
        tilde (<literal>~</literal>), which does not begin with a decimal
        digit. <literal>tnc</literal> generates names beginning with double
        tilde (<literal>~~</literal>) for unnamed objects when in
        <literal>decode</literal> mode, so the use of such identifiers is not
        recommended.</para>

    </sect1>

    <sect1 id='numbers'>
      <title>Numbers</title>

      <para>Numbers can be given in octal (prefixed by <literal>0</literal>),
        decimal, or hexadecimal (prefixed by <literal>0x</literal> or
        <literal>0X</literal>). Both upper and lower case letters can be used
        for hex digits. A number can be preceded by any number of
        <literal>+</literal> or <literal>-</literal> signs.</para>

    </sect1>

    <sect1 id='strings'>
      <title>Strings</title>

      <para>A string consists of a sequence of characters enclosed in double quotes
        (<literal>"</literal>). The following escape sequences are recognised:</para>

      <itemizedlist>
        <listitem>
          <para><literal>\n</literal> represents a newline character,</para>
        </listitem>
        <listitem>
          <para><literal>\t</literal> represents a tab character,</para>
        </listitem>
        <listitem>
          <para><literal>\xxx</literal>, where <literal>xxx</literal> consists of
            three octal digits, represents the character with ASCII code
            <literal>xxx</literal>.</para>
        </listitem>
      </itemizedlist>

      <para>Newlines are not allowed in strings unless they are escaped. For all
        other escaped characters, <literal>\x</literal> represents
        <literal>x</literal>.</para>

    </sect1>

    <sect1 id='blanks'>
      <title>Blanks</title>

      <para>A single minus character (<literal>-</literal>) has a special meaning.
        It may be used to indicate the absence of an optional argument or
        optional group of arguments.</para>

    </sect1>

    <sect1 id='bars'>
      <title>Bars</title>

      <para>A single vertical bar (<literal>|</literal>) has a special meaning. It
        may be used to indicate the end of a sequence of repeated arguments.</para>

    </sect1>
  </chapter>

  <chapter id='input-syntax'>
    <title>Input syntax</title>

    <sect1 id='basic-syntax'>
      <title>Basic syntax</title>

      <para>The basic input syntax is very simple. A construct consists of an
        identifier followed by a list of arguments, all enclosed in brackets in
        a Lisp-like fashion. Each argument can be an identifier, a number, a
        string, a blank, a bar, or another construct. There are further
        restrictions on this basic syntax, described below.</para>

      <programlisting>
construct   : ( identifier arglist )

argument    : construct
  | identifier
  | number
  | string
  | blank
  | bar

arglist     : (empty)
| argument arglist
      </programlisting>

      <para>The construct <literal>( identifier )</literal>, with an empty argument
        list, is equivalent to the identifier argument
        <literal>identifier</literal>. The two may be used interchangeably.</para>

    </sect1>

    <sect1 id='sorts'>
      <title>Sorts</title>

      <para>Except at the outermost level, which forms a special case discussed
        below, every construct and argument has an associated sort. This is one
        of the basic TDF sorts: <literal>access</literal>,
        <literal>al_tag</literal>, <literal>alignment</literal>,
        <literal>bitfield_variety</literal>, <literal>bool</literal>,
        <literal>callees</literal>, <literal>error_code</literal>,
        <literal>error_treatment</literal>, <literal>exp</literal>,
        <literal>floating_variety</literal>, <literal>label</literal>,
        <literal>nat</literal>, <literal>ntest</literal>,
        <literal>procprops</literal>, <literal>rounding_mode</literal> ,
        <literal>shape</literal>, <literal>signed_nat</literal>,
        <literal>string</literal>, <literal>tag</literal>,
        <literal>transfer_mode</literal>, <literal>variety</literal>,
        <literal>tdfint</literal> or <literal>tdfstring</literal>.</para>

      <para>Ignoring for the moment the shorthands discussed below, the ways of
        creating constructs of sort <literal>exp</literal> say, correspond to
        the TDF constructs delivering an <literal>exp</literal>. For example,
        <literal>contents</literal> takes a <literal>shape</literal> and an
        <literal>exp</literal> and delivers an <literal>exp</literal>. Thus:</para>

      <programlisting>
( contents arg1 arg2 )
      </programlisting>

      <para>where <literal>arg1</literal> is an argument of sort
        <literal>shape</literal> and <literal>arg2</literal> is an argument of
        sort <literal>exp</literal>, is a sort-correct construct. Only
        constructs which are sort correct in this sense are allowed.</para>

      <para>As another example, because of the rule concerning constructs with no
        arguments, both</para>

      <programlisting>
( true )
      </programlisting>

      <para>and</para>

      <programlisting>
false
      </programlisting>

      <para>are valid constructs of sort <literal>bool</literal>.</para>

      <para>TDF constructs which take lists of arguments are easily dealt with. For
        example:</para>

      <programlisting>
( make_nof arg1 ... argn )
      </programlisting>

      <para>where <literal>arg1</literal>, ..., <literal>argn</literal> are all
        arguments of sort <literal>exp</literal>, is valid. A vertical bar may
        be used to indicate the end of a sequence of repeated arguments.</para>

      <para>Optional arguments should be entered normally if they are present.
        Their absence may be indicated by means of a blank (minus sign), or by
        simply omitting the argument.</para>

      <para>The vertical bar and blank should be used whenever the input is
        potentially ambiguous. Particular care should be taken with
        <literal>apply_proc</literal> (which is genuinely ambiguous) and
        <literal>labelled</literal>.</para>

      <para>The TDF specification should be consulted for a full list of valid TDF
        constructs and their argument sorts. Alternatively the
        <literal>tnc</literal> help facility may be used. The command:</para>

      <programlisting>
tnc -help cmd1 ... cmdn
      </programlisting>

      <para>prints sort information on the constructs or sorts
        <literal>cmd1</literal>, ..., <literal>cmdn</literal>. Alternatively:</para>

      <programlisting>
tnc -help
      </programlisting>

      <para>prints this information for all constructs. (To obtain help on the sort
        <literal>alignment</literal> as opposed to the construct
        <literal>alignment</literal> use <literal>alignment_sort</literal>.
        This confusion cannot occur elsewhere.)</para>

    </sect1>

    <sect1 id='numbers-strings'>
      <title>Numbers and strings</title>

      <para>Numbers can occur in two contexts, as the argument to the TDF
        constructs <literal>make_nat</literal> and
        <literal>make_signed_nat</literal>. In the former case the number must
        be positive. The following shorthands are understood by
        <literal>tnc</literal>:</para>

      <programlisting>
number for ( make_nat number )
number for ( make_signed_nat number )
      </programlisting>

      <para>depending on whether a construct of sort <literal>nat</literal> or
        <literal>signed_nat</literal> is expected.</para>

      <para>Strings are nominally of sort <literal>tdfstring</literal>. They are
        taken to be simple strings (8 bits per character). Multibyte strings
        (those with other than 8 bits per character) may be represented by
        means of the <literal>multi_string</literal> construct. This takes the
        form:</para>

      <programlisting>
( multi_string b c1 ... cn )
      </programlisting>

      <para>where <literal>b</literal> is the number of bits per character and
        <literal>c1</literal>, ...,<literal>cn</literal> are the codes of the
        characters comprising the string. These multibyte strings cannot be
        used as external names.</para>

      <para>In addition, a simple (8 bit) string can be used as a shorthand for a
        TDF construct of sort <literal>string</literal>, as follows:</para>

      <programlisting>
string for ( make_string string )
      </programlisting>

    </sect1>

    <sect1 id='tokens-tags'>
      <title>Tokens, tags, alignment tags and labels</title>

      <para>In TDF simple tokens, tags, alignment tags and labels are represented
        by numbers which may, or may not, be associated with external names. In
        <literal>tnc</literal> however they are represented by identifiers.
        This brings the problem of scoping which does not occur in TDF. The
        rules are that all tokens, tags, alignment tags and labels must be
        declared before they are used. Externally defined objects have global
        scope, and the scope of a formal argument in a token definition is the
        definition body. For those constructs which introduce a local tag or
        label - for example, <literal>identify</literal>,
        <literal>make_proc</literal>, <literal>make_general_proc</literal> and
        <literal>variable</literal> for tags and
        <literal>conditional</literal>, <literal>labelled</literal> and
        <literal>repeat</literal> for labels - the scope of the object is as
        set out in the TDF specification.</para>

      <para>The following shorthands are understood by <literal>tnc</literal>,
        according to the argument sort expected:</para>

      <programlisting>
tag_id for ( make_tag tag_id )
al_tag_id for ( make_al_tag al_tag_id )
label_id for ( make_label label_id )
      </programlisting>

      <para>The syntax for token applications is as follows:</para>

      <programlisting>
( apply_construct ( token_id arg1 ... argn ) )
      </programlisting>

      <para>where <literal>apply_construct</literal> is the appropriate TDF token
        application construct, for example, <literal>exp_apply_token</literal>
        for tokens declared to deliver <literal>exp</literal>'s. The token
        arguments <literal>arg1</literal>, ..., <literal>argn</literal> must be
        of the sorts indicated in the token declaration or definition. For
        tokens without any arguments the alternative form:</para>

      <programlisting>
( apply_construct token_id )
      </programlisting>

      <para>is allowed.</para>

      <para>The token application above may be abbreviated to:</para>

      <programlisting>
( token_id arg1 ... argn )
      </programlisting>

      <para>the result sort being known from the token declaration. This in turn
        may be abbreviated to:</para>

      <programlisting>
token_id
      </programlisting>

      <para>when there are no token arguments.</para>

      <para>Care needs to be taken with these shorthands, as they can lead to
        confusion, particularly when, due to optional arguments or lists of
        arguments, <literal>tnc</literal> is not sure what sort is coming next.
        The five categories of objects represented by identifiers - TDF
        constructs, tokens, tags, alignment tags and labels - occupy separate
        name spaces, but it is a good idea to try to avoid duplication of
        names.</para>

      <para>By default all these shorthands are used by <literal>tnc</literal> in
        <literal>write</literal> mode. If this causes problems, the
        <literal>-V</literal> flag should be passed to <literal>tnc</literal>.</para>

    </sect1>

    <sect1 id='outer-level'>
      <title>Outer level syntax</title>

      <para>At the outer level <literal>tnc</literal> is expecting a sequence of
        constructs of the following forms:</para>

      <itemizedlist>
        <listitem>
          <para>an included file,</para>
        </listitem>
        <listitem>
          <para>a token declaration,</para>
        </listitem>
        <listitem>
          <para>a token definition,</para>
        </listitem>
        <listitem>
          <para>an alignment tag declaration,</para>
        </listitem>
        <listitem>
          <para>an alignment tag definition,</para>
        </listitem>
        <listitem>
          <para>a tag declaration,</para>
        </listitem>
        <listitem>
          <para>a tag definition.</para>
        </listitem>
      </itemizedlist>
    </sect1>

    <sect1 id='included-files'>
      <title>Included files</title>

      <para>Included files may be of three types - text, TDF capsule or TDF
        library. For TDF capsules and libraries there are two include modes.
        The first just decodes the given capsule or set of capsules. The second
        scans through them to extract token declaration information. These
        declarations appear in the output file only if they are used elsewhere.</para>

      <para>The syntax for an included text file is:</para>

      <programlisting>
( include string )
      </programlisting>

      <para>where <literal>string</literal> is a string giving the pathname of the
        file to be included. <literal>tnc</literal> applies
        <literal>read</literal> to this sub-file before continuing with the
        present file.</para>

      <para>Similarly, the syntaxes for included TDF capsules and libraries are:</para>

      <programlisting>
( code string )
( lib string )
      </programlisting>

      <para>respectively. <literal>tnc</literal> applies <literal>decode</literal>
        to this capsule or set of capsules (provided this mode is available)
        before continuing with the present file.</para>

      <para>The syntaxes for extracting the token declaration information from a
        TDF capsule or library are:</para>

      <programlisting>
( use_code string )
( use_lib string )
      </programlisting>

      <para>Again, these rely on the <literal>decode</literal> mode being
        available.</para>

    </sect1>

    <sect1 id='internal-external'>
      <title>Internal and external names</title>

      <para>All tokens, tags and alignment tags have an internal name, namely the
        associated identifier, but this name does not necessarily appear in the
        corresponding TDF capsule. There must firstly be an associated
        declaration or definition at the outer level - tags internal to a piece
        of TDF do not have external names. Even then we may not wish this name
        to appear at the outer level, because it is local to this file and is
        not required for linking purposes. Alternatively we may wish a
        different external name to be associated with it in the TDF capsule.</para>

      <para>As an example of how <literal>tnc</literal> allows for this, consider
        token declarations (although similar remarks apply to token
        definitions, alignment tag definitions etc.). The basic form of the
        token declaration is:</para>

      <programlisting>
( make_tokdec token_id ... )
      </programlisting>

      <para>This creates a token with both internal and external names equal to
        <literal>token_id</literal>. Alternatively:</para>

      <programlisting>
( local make_tokdec token_id ... )
      </programlisting>

      <para>creates a token with internal name <literal>token_id</literal> but no
        external name. This allows the creation of tokens local to the current
        file. Again:</para>

      <programlisting>
( make_tokdec ( string_extern string ) token_id ... )
      </programlisting>

      <para>creates a token with internal name <literal>token_id</literal> and
        external name given by the string <literal>string</literal>. For
        example, to create a token whose external name is not a valid
        identifier, it would be necessary to use this construct. Finally:</para>

      <programlisting>
( make_tokdec ( unique_extern string1 ... stringn ) token_id ... )
      </programlisting>

      <para>creates a token with internal name <literal>token_id</literal> and
        external name given by the unique name consisting of the strings
        <literal>string1</literal>, ..., <literal>stringn</literal>.</para>

      <para>The <literal>local</literal> quantifier should be used consistently on
        all declarations and definitions of the token, tag or alignment tag.
        The alternative external name should only be given on the first
        occasion however. Thereafter the object is identified by its internal
        name.</para>

    </sect1>

    <sect1 id='token-decl'>
      <title>Token declarations</title>

      <para>The basic form of a token declaration is:</para>

      <programlisting>
( make_tokdec token_id ( arg1 ... argn ) res )
      </programlisting>

      <para>where the token <literal>token_id</literal> is declared to take
        argument sorts <literal>arg1</literal>, ..., <literal>argn</literal>
        and deliver the result sort <literal>res</literal>. These sorts are
        given by their sort names, <literal>al_tag</literal>,
        <literal>alignment</literal>, <literal>bitfield_variety</literal> etc.
        For a token with no arguments the declaration may be given in the form:</para>

      <programlisting>
( make_tokdec token_id res )
      </programlisting>

      <para>A token may be declared any number of times, provided the declarations
        are consistent.</para>

      <para>This basic declaration may be modified in the ways outlined above to
        specify the external token name.</para>

    </sect1>

    <sect1 id='token-def'>
      <title>Token definitions</title>

      <para>The basic form of a token definition is:</para>

      <programlisting>
( make_tokdef token_id ( arg1 id1 ... argn idn ) res def )
      </programlisting>

      <para>where the token <literal>token_id</literal> is defined to take formal
        arguments <literal>id1</literal>, ..., <literal>idn</literal> of sorts
        <literal>arg1</literal>, ..., <literal>argn</literal> respectively and
        have the value <literal>def</literal>, which is a construct of sort
        <literal>res</literal>. The scope of the tokens <literal>id1</literal>,
        ..., <literal>idn</literal> is <literal>def</literal>.</para>

      <para>For a token with no arguments the definition may be given in the form:</para>

      <programlisting>
( make_tokdef token_id res def )
      </programlisting>

      <para>A token may be defined more than once. All definitions must be
        consistent with any previous declarations and definitions (the renaming
        of formal arguments is allowed however).</para>

      <para>This basic definition may be modified in the ways outlined above to
        specify the external token name.</para>

    </sect1>

    <sect1 id='alignment-tag-decl'>
      <title>Alignment tag declarations</title>

      <para>The basic form of an alignment tag declaration is:</para>

      <programlisting>
( make_al_tagdec al_tag_id )
      </programlisting>

      <para>where the alignment tag <literal>al_tag_id</literal> is declared to
        exist.</para>

      <para>This basic declaration may be modified in the ways outlined above to
        specify the external alignment tag name.</para>

    </sect1>

    <sect1 id='alignment-tag-def'>
      <title>Alignment tag definitions</title>

      <para>The basic form of an alignment tag definition is:</para>

      <programlisting>
( make_al_tagdef al_tag_id def )
      </programlisting>

      <para>where the alignment tag <literal>al_tag_id</literal> is defined to be
        <literal>def</literal>, which is a construct of sort
        <literal>alignment</literal>. An alignment tag may be declared or
        defined more than once, provided the definitions are consistent.</para>

      <para>This basic definition may be modified in the ways outlined above to
        specify the external alignment tag name.</para>

    </sect1>

    <sect1 id='tag-declarations'>
      <title>Tag declarations</title>

      <para>The basic forms of a tag declaration are:</para>

      <programlisting>
( make_id_tagdec tag_id info dec )
( make_var_tagdec tag_id info dec )
( common_tagdec tag_id info dec )
      </programlisting>

      <para>where the tag <literal>tag_id</literal> is declared to be an identity,
        variable or common tag with access information <literal>info</literal>,
        which is an optional construct of sort <literal>access</literal>, and
        shape <literal>dec</literal>, which is a construct of sort
        <literal>shape</literal>. A tag may be declared more than once,
        provided all declarations and definitions are consistent (including
        agreement of whether the tag is an identity, a variable or common).</para>

      <para>These basic declarations may be modified in the ways outlined above to
        specify the external tag name.</para>

    </sect1>

    <sect1 id='tag-definitions'>
      <title>Tag definitions</title>

      <para>The basic forms of a tag definition are:</para>

      <programlisting>
( make_id_tagdef tag_id def )
( make_var_tagdef tag_id info def )
( common_tagdef tag_id info def )
      </programlisting>

      <para>where the tag <literal>tag_id</literal> is defined to be an identity,
        variable or common tag with value <literal>def</literal>, which is a
        construct of sort <literal>exp</literal>. Non-identity tag definitions
        also have an optional <literal>access</literal> construct,
        <literal>info</literal>. A tag must have been declared before it is
        defined, but may be defined any number of times. All declarations and
        definitions must be consistent (except that common tags may be defined
        inconsistently) and agree on whether the tag is an identity, a
        variable, or common.</para>

      <para>These basic definitions may be modified in the ways outlined above to
        specify the external tag name.</para>

    </sect1>
  </chapter>

  <chapter id='shape-checking'>
    <title>Shape checking</title>

    <para>The input in <literal>read</literal> (and to a lesser extent
      <literal>decode</literal>) mode is checked for shape correctness if the
      <literal>-check</literal> or <literal>-c</literal> flag is passed to
      <literal>tnc</literal>. This is not guaranteed to pick up all shape
      errors, but is better than nothing.</para>

    <para>When in <literal>write</literal> mode the results of the shape checking
      may be viewed by passing the <literal>-cv</literal> flag to
      <literal>tnc</literal>. Each expression is associated with its shape by
      means of the:</para>

    <programlisting>
( exp_with_shape exp shape ) -&gt; exp
    </programlisting>

    <para>pseudo-construct. Unknown shapes are indicated by <literal>....</literal></para>

  </chapter>

  <chapter id='remarks'>
    <title>Remarks</title>

    <para>The target independent TDF capsules produced by the C -&gt; TDF compiler,
      <literal>tcc</literal>, do not contain declarations or definitions for
      all the tokens they use. Thus <literal>tnc</literal> cannot fully decode
      them as they stand. However the necessary token declaration information
      may be made available to <literal>tnc</literal> by using the
      <literal>use_lib</literal> construct. The commands:</para>

    <programlisting>
( use_lib library )
( code capsule )
    </programlisting>

    <para>will decode the TDF capsule <literal>capsule</literal> which uses tokens
      defined in the TDF library <literal>library</literal>.</para>

  </chapter>

  <chapter id='limitations'>
    <title>Limitations</title>

    <para>The main limitations in the current version of <literal>tnc</literal> are
      as follows:</para>

    <itemizedlist>
      <listitem>
        <para>There is no error recovery,</para>
      </listitem>
      <listitem>
        <para>There is no support for foreign sorts,</para>
      </listitem>
      <listitem>
        <para>The support for tokenised tokens is limited and undocumented.</para>
      </listitem>
    </itemizedlist>

    <para>In addition, far more of the checks (scopes, shape checking, checking of
      consistency of declarations and definitions etc.) are implemented for
      <literal>read</literal> mode rather than <literal>decode</literal> mode.
      To shape check a TDF capsule, it will almost certainly be more effective
      to translate it into text and check that.</para>

    <para>Another limitation is that the scoping rules for local tags do not allow
      such tags to be accessed outside their scopes using
      <literal>env_offset</literal> .</para>

  </chapter>

  <chapter id='revision'>
    <title>Revision History</title>

    <para>This chapter describes revisions to this document.</para>

    <para>Only major changes are listed in the revision history.  Please see
      <ulink url="http://cvsweb.ten15.org/cgi/cvsweb.cgi/doc/en/tnc/book.sgml">http://cvsweb.ten15.org/cgi/cvsweb.cgi/doc/en/tnc/book.sgml</ulink>
      for a complete list of changes.</para>

    <note><para>CVS revision numbers are located behind the date in the format
      <literal>r</literal><emphasis>XX</emphasis></para></note>

    <para>
    <revhistory>
      <revision>
        <revnumber>1.0</revnumber>
        <date>2002/10/07 r1.1</date>
        <authorinitials>verm</authorinitials>
        <revremark>Converted to SGML from the &doc.original;.</revremark>
      </revision>
    </revhistory>
  </para>
  </chapter>

</book>
