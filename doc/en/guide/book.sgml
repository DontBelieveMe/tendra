<!DOCTYPE BOOK PUBLIC "-//FreeBSD//DTD DocBook V4.1-Based Extension//EN"[
<!ENTITY % bookinfo PUBLIC "-//FreeBSD//ENTITIES DocBook BookInfo Entities//EN">
%bookinfo;
<!ENTITY % doc PUBLIC "-//FreeBSD//ENTITIES DocBook Document Entities//EN">
%doc;
]>

<book>
  <bookinfo>
    <title>TDF Guide</title>

    <pubdate>$TenDRA$</pubdate>

    <corpauthor>The TenDRA Documentation Team</corpauthor>

    <copyright>
      <year>2002</year>
      <year>2003</year>
      <year>2004</year>
      <holder>TenDRA Documentation Team</holder>
    </copyright>

    <copyright>
      <year>1997</year>
      <year>1998</year>
      <holder>Defence Evaluation and Research Agency (DERA)</holder>
    </copyright>

    <abstract>
      <para> Please email us at <email>docs@ten15.org</email> if you see any
          errors or omissions.</para>
    </abstract>

    <legalnotice id='legalnotice'>
      <para>Extensions to this document from the original
          <ulink url='ftp://ftp.ten15.org/pub/source/TenDRA-4.1.2-doc.tar.gz'>TenDRA-4.1.2-doc.tar.gz</ulink>
          source distribution are covered by the <link linkend='legal-bsdl'>BSDL</link>,
          while all prior modifications remain under the
          <link linkend='legal-crown'>Crown Copyright</link>.</para>
    </legalnotice>

    &bookinfo.legalnotice;

    &bookinfo.legalnotice-crown;

  </bookinfo>

  <preface id='intro'>
    <title>Introduction</title> 

    <para>This memo is intended to be a fairly detailed commentary on the
      specification of TDF, a kind of Talmud to the Torah. If it conflicts with
      the specification document, it is wrong. The aim is elucidate the various
      constructions of TDF, giving examples of usages both from the point of view
      of a producer of TDF and how it is used to construct programs on particular
      platforms using various installers or translators. In addition, some
      attempt is made to give the reasons why the particular constructions have
      been chosen. Most of the commentary is a distillation of questions and
      answers raised by people trying to learn TDF from the specification
      document.</para>

    <para>Throughout this document, references like (S5.1) are headings in the
      &doc.tdf;. I use the term
      "compiling" or "producing" to mean the production of TDF from some source
      language and "translating" to mean making a program for some specific
      platform from TDF.</para>

    <para>I use the first person where I am expressing my own opinions or
      preferences; these should not be taken as official opinions of DRA or the
      TenDRA team.</para>
  </preface>

  <chapter id='sorts-tokens'>
    <title>SORTs and TOKENs</title> 

    <para>In the syntax of language like C or Pascal, we find various syntactic
      units like &lt;Expression&gt;, &lt;Identifier&gt; etc. A SORT bears the
      same relation to TDF as these syntactic units bear to the language; roughly
      speaking, the syntactic unit &lt;Expression&gt; corresponds to the SORT EXP
      and &lt;Identifier&gt; to TAG . However, instead of using BNF to compose
      syntactic units from others, TDF uses explicit constructors to compose its
      SORTs; each constructor uses other pieces of TDF of specified SORTs to make
      a piece of its result SORT. For example, the constructor plus uses an
      ERROR_TREATMENT and two EXPs to make another EXP.</para>

    <para>At the moment, there are 58 different SORTS, from ACCESS to VARIETY
      given in tables 1 and 2. Some of these have familiar analogues in standard
      language construction as with EXP and TAG above. Others will be less
      familiar since TDF must concern itself with issues not normally addressed
      in language definitions. For example, the process of linking together TDF
      programs is at the root of the architecture neutrality of TDF and so must
      form an integral part of its definition. On the other hand, TDF is not
      meant to be a language readily accessible to the human reader or writer;
      computers handle it much more easily. Thus a great many choices have been
      made in the definition which would be intolerable in a standard language
      definition for the human programmer but which, paradoxically enough, make
      it much simpler for a computer to produce and analyse TDF.</para>

    <para>The SORTs and constructors in effect form a multi-sorted algebra.
      There were two principal reasons for choosing this algebraic form of
      definition. First, it is easy to extend - a new operation on existing
      constructs simply requires a new constructor. Secondly, the algebraic form
      is highly amenable to the automatic construction of programs. Large parts
      of both TDF producers and TDF translators have been created by automatic
      transformation of the text of the specification document itself, by
      extracting the algebraic signature and constructing C program which can
      read or produce TDF. To this extent, one can regard the specification
      document as a formal description of the free algebra of TDF SORTs and
      constructors. Of course, most of the interesting parts of the definition of
      TDF lies in the equivalences of parts of TDF, so this formality only covers
      the easy bit.</para>

    <para>Another distinction between the TDF definition and language syntactic
      description is that TDF is to some extent conscious of its own SORTs so
      that it can specify a new construction of a given SORT. The analogy in
      normal languages would be that one could define a new construction with new
      syntax and say this is an example of an &lt;Expression&gt;, for example; I
      don't know of any standard language which permits this, although those of
      you with a historical bent might remember Algol-N which made a valiant
      attempt at it. Of course, the algebraic method of description makes it much
      easier to specify, rather than having to give syntax to provide the syntax
      for the new construction in a language.</para>

    <sect1 id='token-first-class-sorts'>
      <title>Token applications and first-class SORTs</title> 

      <para>A new construction is introduced by the SORT TOKEN; the
        constructors involving TOKENs allow one to give an expansion for the
        TOKEN in terms of other pieces of TDF, possibly including parameters. We
        can encapsulate a (possibly parameterised) fragment of TDF of a suitable
        SORT by giving it a TOKEN as identification. Not all of the SORTs are
        available for this kind of encapsulation - only those which have a
        SORTNAME constructor (from access to variety). These are the
        "first-class" SORTs given in table 1 on page 8. Each of these have an
        appropriate _apply_token constructor (e.g. exp_apply_token ) give the
        expansion. Most of these also have _cond constructors (e.g.see exp_cond
        in <xref linkend='cond-constructors'> ) which allows translate
        time conditional expansion of the SORT.</para>

      <table frame="all" id='first-class-sorts'>
        <title>First class SORTs</title> 

        <tgroup cols="2">
          <thead>
            <row>
              <entry>SORT</entry>

              <entry>USAGE</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>ACCESS</entry>

              <entry>Properties of TAGs</entry>
            </row>

            <row>
              <entry>AL_TAG</entry>

              <entry>Name for alignment</entry>
            </row>

            <row>
              <entry>ALIGNMENT</entry>

              <entry>Abstraction of data alignment</entry>
            </row>

            <row>
              <entry>BITFIELD_VARIETY</entry>

              <entry>Give no of bits in bit-field with sign</entry>
            </row>

            <row>
              <entry>BOOL</entry>

              <entry>true or false</entry>
            </row>

            <row>
              <entry>ERROR_TREATMENT</entry>

              <entry>How to handle errors in operations</entry>
            </row>

            <row>
              <entry>EXP</entry>

              <entry>Piece of TDF program manipulating values</entry>
            </row>

            <row>
              <entry>FLOATING_VARIETY</entry>

              <entry>Kind of floating point number</entry>
            </row>

            <row>
              <entry>LABEL</entry>

              <entry>Mark on EXP to jump to</entry>
            </row>

            <row>
              <entry>NAT</entry>

              <entry>Non-negative static number of unbounded size</entry>
            </row>

            <row>
              <entry>NTEST</entry>

              <entry>Test in comparisons</entry>
            </row>

            <row>
              <entry>PROCPROPS</entry>

              <entry>Porperties of calls and definitions of procedures</entry>
            </row>

            <row>
              <entry>ROUNDING_MODE</entry>

              <entry>How to round floating point operations</entry>
            </row>

            <row>
              <entry>SHAPE</entry>

              <entry>Abstraction of size and representation of values</entry>
            </row>

            <row>
              <entry>SIGNED_NAT</entry>

              <entry>Static number of unbounded size</entry>
            </row>

            <row>
              <entry>STRING</entry>

              <entry>Static string of n-bit integers</entry>
            </row>

            <row>
              <entry>TAG</entry>

              <entry>Name for value in run-time program</entry>
            </row>

            <row>
              <entry>TRANSFERMODE</entry>

              <entry>Controls special contents and assignments
              operations</entry>
            </row>

            <row>
              <entry>TOKEN</entry>

              <entry>Install-time function</entry>
            </row>

            <row>
              <entry>VARIETY</entry>

              <entry>Kind of integer used in run-time program</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>Every TOKEN has a result SORT, i.e. the SORT of its resulting
        expansion and before it can be expanded, one must have its parameter
        SORTs. Thus, you can regard a TOKEN as having a type defined by its
        result and parameter SORTs and the _apply_token as the operator which
        expands the encapsulation and substitutes the parameters.</para>

      <para>However, if we look at the signature of exp_apply_token:</para>
<programlisting>
<emphasis>token_value</emphasis>: TOKEN
<emphasis>token_args</emphasis>:  BITSTREAM <emphasis>param_sorts(token_value)</emphasis>
-&gt; EXP <emphasis>x</emphasis>
</programlisting>

      <para>we are confronted by the mysterious BITSTREAM where one might
        expect to find the actual parameters of the TOKEN.</para>

      <para>
          To explain BITSTREAMs requires a diversion into the bit-encoding of
          TDF. Constructors for a particular SORT are represented in a number of
          bits depending on the number of constructors for that SORT; the context
          will determine the SORT required, so no more bits are required. Thus
          since there is only one constructor for UNITs, no bits are required to
          represent make_unit; there are about 120 different constructors for
          EXPs so 7 bits are required to cover all the EXPs. The parameters of
          each constructor have known SORTs and so their representations are just
          concatenated after the representation of the constructor. 
  
          <footnote>
            <para>There are facilities to allow extensions to the number of
            constructors, so it is not quite as simple as this</para>
        </footnote>
        While this is a very compact representation, it suffers from the defect
        that one must decode it even just to skip over it. This is very irksome
        is some applications, notably the TDF linker which is not interested
        detailed expansions. Similarly, in translators there are places where
        one wishes to skip over a token application without knowledge of the
        SORTs of its parameters. Thus a BITSTREAM is just an encoding of some
        TDF, preceded by the number of bits it occupies. Applications can then
        skip over BITSTREAMs trivially. Similar considerations apply to
        BYTESTREAMs used elsewhere; here the encoding is preceded by the number
        of bytes in the encoding and is aligned to a byte boundary to allow
        fast copying.
      </para>
    </sect1>

    <sect1 id='token-def-decl'>
      <title>Token definitions and declarations</title> 

      <para>Thus the <emphasis>token_args</emphasis> parameter of
        exp_apply_token is just the BITSTREAM formed from the actual parameters
        in the sequence described by the definition of the
        <emphasis>token_valu</emphasis><emphasis>e</emphasis> parameter. This
        will be given in a TOKEN_DEFN somewhere with constructor
        token_definition:</para>
<programlisting>
<emphasis>result_sort</emphasis>: SORTNAME
<emphasis>tok_params</emphasis>:  LIST(TOKFORMALS)
<emphasis>body</emphasis>:    <emphasis>result_sort</emphasis>
-&gt; TOKEN_DEFN
</programlisting>

      <para>The <emphasis>result_sort</emphasis> is the SORT of the
        construction of <emphasis>body</emphasis>; e.g. if
        <emphasis>result_sort</emphasis> is formed from exp then
        <emphasis>body</emphasis> would be constructed using the EXP constructors
        and one would use exp_apply_token to give the expansion. The list
        <emphasis>tok_params</emphasis> gives the formal parameters of the
        definition in terms of TOKFORMALS constructed using
        make_tok_formals:</para>
<programlisting>
<emphasis>sn</emphasis>:  SORTNAME
<emphasis>tk</emphasis>:  TDFINT
-&gt; TOKFORMALS
</programlisting>

      <para>The TDFINT <emphasis>tk</emphasis> will be the integer
        representation of the formal parameter expressed as a TOKEN whose result
        sort is <emphasis>sn</emphasis> (see more about name representation in
        <xref linkend='make-capsule-name-spaces'> .). To use the parameter in the
        body of the TOKEN_DEFN, one simply uses the _apply_token appropriate to
        <emphasis>sn</emphasis>.Note that sn may be a TOKEN but the
        <emphasis>result_sort</emphasis> may not.</para>

      <para>Hence the BITSTREAM
        <emphasis>param_sorts</emphasis>(<emphasis>token_value</emphasis>) in the
        actual parameter of exp_apply_token above is simply formed by the
        catenation of constructions of the SORTs given by the SORTNAMEs in the
        <emphasis>tok_params</emphasis> of the TOKEN being expanded.</para>

      <para>Usually one gives a name to a TOKEN_DEFN using to form a TOKDEF
        using make_tokdef :</para>
<programlisting>
<emphasis>tok</emphasis>: TDFINT
<emphasis>signature</emphasis>:   OPTION(STRING)
<emphasis>def</emphasis>: BITSTREAM TOKEN_DEFN
-&gt; TOKDEF
</programlisting>

      <para>Here, <emphasis>tok</emphasis> gives the name that will be used to
        identify the TOKEN whose expansion is given by <emphasis>def</emphasis>.
        Any use of this TOKEN (e.g. in exp_apply_token) will be given by
        make_token(<emphasis>tok</emphasis> ) . Once again, a BITSTREAM is used
        to encapsulate the TOKEN_DEFN.</para>

      <para>The significance of the signature parameter is discussed in
        <xref linkend='decl-definition'> .</para>

      <para>Often, one wishes a token without giving its definition - the
        definition could, for example, be platform-dependent. A TOKDEC introduces
        such a token using make_tokdec:</para>
<programlisting>
<emphasis>tok</emphasis>: TDFINT
<emphasis>signature</emphasis>:   OPTION(STRING)
<emphasis>s</emphasis>:   SORTNAME
-&gt; TOKDEC
</programlisting>

      <para>Here the SORTNAME, <emphasis>s</emphasis>, is given by
        token:</para>
<programlisting>
<emphasis>result</emphasis>:  SORTNAME
<emphasis>params</emphasis>:  LIST(SORTNAME)
               -&gt; SORTNAME
</programlisting>

      <para>which gives the result and parameter SORTs of
        <emphasis>tok</emphasis>.</para>

      <para>One can also use a TOKEN_DEFN in an anonymous fashion by giving it
        as an actual parameter of a TOKEN which itself demands a TOKEN parameter.
        To do this one simply uses use_tokdef :</para>
<programlisting>
<emphasis>tdef</emphasis>:    BITSTREAM TOKEN_DEFN
-&gt; TOKEN
</programlisting>
    </sect1>

    <sect1 id='simple-token'>
      <title>A simple use of a TOKEN</title> 

      <para>The crucial use of TOKENs in TDF is to provide abstractions of APIs
        (see <xref linkend='tokens-apis'> ) but they are also used as
        shorthand for commonly occurring constructions. For example, given the
        TDF constructor plus, mentioned above, we could define a plus with only
        two EXP parameters more suitable to C by using the wrap constructor as
        the ERROR_TREATMENT:</para>
<programlisting>
make_tokdef (C_plus, empty,
  token_definition(
exp(),
(make_tokformals(exp(), l), make_tokformals(exp(), r)),
plus(wrap(), exp_apply_token(l, ()), exp_apply_token(r,())
  )
)
</programlisting>
    </sect1>

    <sect1 id='second-class-sorts'>
      <title>Second class SORTs</title> 

      <para>Second class SORTs (given in table 2 on page 11) cannot be
        TOKENised. These are the "syntactic units" of TDF which the user cannot
        extend; he can only produce them using the constructors defined in
        core-TDF.</para>

      <para>Some of these constructors are implicit. For example, there are no
        explicit constructors for LIST or SLIST which are both used to form lists
        of SORTs; their construction is simply part of the encoding of TDF.
        However, it is forseen that LIST constructors would be highly desireable
        and there will probably extensions to TDF to promote LIST from a
        second-class SORT to a first-class one. This will not apply to SLIST or
        to the other SORTs which have implicit constructions. These include
        BITSTREAM, BYTESTREAM, TDFINT, TDFIDENT and TDFSTRING.</para>

      <table frame="all" id='sorts-without-sortnames'>
        <title>Sorts without SORTNAMEs</title> 

        <tgroup cols="2">
          <thead>
            <row>
              <entry>SORT</entry>

              <entry>USAGE</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>AL_TAGDEF</entry>

              <entry>Alignment name definition</entry>
            </row>

            <row>
              <entry>AL_TAGDEF_PROPS</entry>

              <entry>Body of UNIT containing AL_TAGDEFs</entry>
            </row>

            <row>
              <entry>BITSTREAM</entry>

              <entry>Encapsulation of a bit encoding</entry>
            </row>

            <row>
              <entry>BYTE STREAM</entry>

              <entry>Encapsulation of a byte encoding</entry>
            </row>

            <row>
              <entry>CALLEES</entry>

              <entry>Actual callee parameters</entry>
            </row>

            <row>
              <entry>CAPSULE</entry>

              <entry>Independent piece of TDF program</entry>
            </row>

            <row>
              <entry>CAPSULE_LINK</entry>

              <entry>No and kind of linkable entities in CAPSULE</entry>
            </row>

            <row>
              <entry>CASELIM</entry>

              <entry>Bounds in case constructor</entry>
            </row>

            <row>
              <entry>ERROR_CODE</entry>

              <entry>Encoding for exceptions</entry>
            </row>

            <row>
              <entry>EXTERNAL</entry>

              <entry>External name used to connect CAPSULE name</entry>
            </row>

            <row>
              <entry>EXTERN_LINK</entry>

              <entry>List of LINKEXTERNs in CAPSULE</entry>
            </row>

            <row>
              <entry>GROUP</entry>

              <entry>List of UNITs with same identification</entry>
            </row>

            <row>
              <entry>LINK</entry>

              <entry>Connects names in CAPSULE</entry>
            </row>

            <row>
              <entry>LINK EXTERN</entry>

              <entry>Used to connect CAPSULE names to outside world</entry>
            </row>

            <row>
              <entry>LINKS</entry>

              <entry>List of LINKs</entry>
            </row>

            <row>
              <entry>LIST (AUX)</entry>

              <entry>List of AUX SORTs; may have SORTNAME later</entry>
            </row>

            <row>
              <entry>OTAGEXP</entry>

              <entry>Describes a formal parameter</entry>
            </row>

            <row>
              <entry>PROPS</entry>

              <entry>Program info in a UNIT</entry>
            </row>

            <row>
              <entry>SLIST (AUX)</entry>

              <entry>List of AUX SORTs; will not have SORTNAME later</entry>
            </row>

            <row>
              <entry>SORTNAME</entry>

              <entry>SORT which can be parameter of TOKEN</entry>
            </row>

            <row>
              <entry>TAGACC</entry>

              <entry>Used in constructing proc formals</entry>
            </row>

            <row>
              <entry>TAGDEC</entry>

              <entry>Declaration of TAG at UNIT level</entry>
            </row>

            <row>
              <entry>TAGDEC_PROPS</entry>

              <entry>Body of UNIT containing TAGDECs</entry>
            </row>

            <row>
              <entry>TAGDEF</entry>

              <entry>Definition of TAG at UNIT level</entry>
            </row>

            <row>
              <entry>TAGDEF_PROPS</entry>

              <entry>Body of UNIT containing TAGDEFs</entry>
            </row>

            <row>
              <entry>TAGSHACC</entry>

              <entry>A formal parameter</entry>
            </row>

            <row>
              <entry>TDFBOOL</entry>

              <entry>TDF encoding for a boolean</entry>
            </row>

            <row>
              <entry>TDFIDENT</entry>

              <entry>TDF encoding of a byte string</entry>
            </row>

            <row>
              <entry>TDFINT</entry>

              <entry>TDF encoding of an integer</entry>
            </row>

            <row>
              <entry>TDFSTRING</entry>

              <entry>TDF encoding of n-bit byte string</entry>
            </row>

            <row>
              <entry>TOKDEC</entry>

              <entry>Declaration of a TOKEN</entry>
            </row>

            <row>
              <entry>TOKDEC_PROPS</entry>

              <entry>Body of UNIT containing TOKDECs</entry>
            </row>

            <row>
              <entry>TOKDEF</entry>

              <entry>Definition of a TOKEN</entry>
            </row>

            <row>
              <entry>TOKDEF_PROPS</entry>

              <entry>Body of UNIT containing TOKDEFs</entry>
            </row>

            <row>
              <entry>TOKEN_DEFN</entry>

              <entry>Defines TOKEN expansion</entry>
            </row>

            <row>
              <entry>TOKFORMALS</entry>

              <entry>Sort and name for parameters in TOKEN_DEFN</entry>
            </row>

            <row>
              <entry>UNIQUE</entry>

              <entry>World-wide name</entry>
            </row>

            <row>
              <entry>UNIT</entry>

              <entry>Component of CAPSULE with LINKs to other UNITs</entry>
            </row>

            <row>
              <entry>VERSION</entry>

              <entry>Version no of TDF</entry>
            </row>

            <row>
              <entry>VERSION_PROPS</entry>

              <entry>Body of UNIT containing version information</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </sect1>
  </chapter>

  <chapter id='capsules-units'>
    <title>CAPSULEs and UNITs</title> 

    <para>A CAPSULE is typically the result of a single compilation - one could
      regard it as being the TDF analogue of a Unix .o file. Just as with .o
      files, a set of CAPSULEs can be linked together to form another. Similarly,
      a CAPSULE may be translated to make program for some platform, provided
      certain conditions are met. One of these conditions is obviously that a
      translator exists for the platform, but there are others. They basically
      state that any names that are undefined in the CAPSULE can be supplied by
      the system in which it is to be run. For example, the translator could
      produce assembly code with external identifiers which will be supplied by
      some system library.</para>

    <sect1 id='make-capsule-name-spaces'>
      <title>make_capsule and name-spaces</title> 

      <para>The only constructor for a CAPSULE is make_capsule. Its basic
        function is to compose together UNITs which contain the declarations and
        definitions of the program. The signature of make_capsule looks rather
        daunting and is probable best represented graphically.</para>

      <figure id="make-capsule">
        <title>make_capsule Signature</title> 

        <mediaobject>
          <imageobject><imagedata fileref="guide2" scale="100" format=
          "PNG"></imageobject>
        </mediaobject>
      </figure>

      <para>The diagram gives an example of a CAPSULE using the same components
        as in the following text.</para>

      <para>Each CAPSULE has its own name-space, distinct from all other
        CAPSULEs' name-spaces and also from the name-spaces of its component
        UNITs (see <xref linkend='units'> ). There are several
        different kinds of names in TDF and each name-space is further subdivided
        into one for each kind of name. The number of different kinds of names is
        potentially unlimited but only three are used in core-TDF, namely "tag",
        "token" and "al_tag". Those names in a "tag" name-space generally
        correspond to identifiers in normal programs and I shall use these as the
        paradigm for the properties of them all.</para>

      <para>The actual representations of a "tag" name in a given name-space is
        an integer, described as SORT TDFINT. These integers are drawn from a
        contiguous set starting from 0 up to some limit given by the constructor
        which introduces the name-space. For CAPSULE name-spaces, this is given
        by the <emphasis>capsule_linking</emphasis> parameter of
        make_capsule:</para>
<programlisting>
<emphasis>capsule_linking</emphasis>: SLIST(CAPSULE_LINK)
</programlisting>

      <para>In the most general case in core-TDF, there would be three entries
        in the list introducing limits using make_capsule_link for each of the
        "tag", "token" and "al_tag" name-spaces for the CAPSULE. Thus if:</para>
<programlisting>
<emphasis>capsule_linking</emphasis> = (make_capsule_link("tag", 5),
  make_capsule_link("token", 6),
  make_capsule_link("al_tag", 7))
</programlisting>

      <para>there are 5 CAPSULE "tag" names used within the CAPSULE, namely 0,
        1, 2, 3 and 4; similarly there are 6 "token" names and 7 "al_tag"
        names.</para>

      <sect2 id='external-linkages'>
        <title>External linkages</title> 

        <para>The context of usage will always determine when and how an
          integer is to be interpreted as a name in a particular name-space. For
          example, a TAG in a UNIT is constructed by make_tag applied to a TDFINT
          which will be interpreted as a name from that UNIT's "tag" name-space.
          An integer representing a name in the CAPSULE name-space would be found
          in a LINKEXTERN of the <emphasis>external_linkage</emphasis> parameter
          of make_capsule.</para>
<programlisting>
<emphasis>external_linkage:</emphasis> SLIST(EXTERN_LINK)
</programlisting>

        <para>Each EXTERN_LINK is itself formed from an SLIST of LINKEXTERNs
          given by make_extern_link . The order of the EXTERN_LINKs determines
          which name-space one is dealing with; they are in the same order as
          given by the <emphasis>capsule_linkage</emphasis> parameter. Thus, with
          the <emphasis>capsule_linkage</emphasis> given above, the first
          EXTERN_LINK would deal with the "tag" name-space; Each of its component
          LINKEXTERNs constructed by make_linkextern would be identifying a tag
          number with some name external to the CAPSULE; for example one might
          be:</para>
<programlisting>
make_linkextern (4, string_extern("printf"))
</programlisting>

        <para>This would mean: identify the CAPSULE's "tag" 4 with an name
          called "printf", external to the module. The name "printf" would be
          used to linkage external to the CAPSULE; any name required outside the
          CAPSULE would have to be linked like this.</para>
      </sect2>

      <sect2 id='units'>
        <title>UNITs</title> 

        <para>This name "printf", of course, does not necessarily mean the C
          procedure in the system library. This depends both on the system
          context in which the CAPSULE is translated and also the meaning of the
          CAPSULE "tag" name 4 given by the component UNITs of the CAPSULE in the
          <emphasis>groups</emphasis> parameter of make_capsule:</para>
<programlisting>
<emphasis>groups:</emphasis> SLIST(GROUP)
</programlisting>

        <para>
            Each GROUP in the <emphasis>groups</emphasis> SLIST will be formed by
            sets of UNITs of the same kind. Once again, there are a potentially
            unlimited number of kinds of UNITs but core-TDF only uses those named
            "tld","al_tagdefs", "tagdecs", "tagdefs", "tokdecs" and "tokdefs" 
  
            <footnote>
              <para>The "tld" UNITs gives usage information for namess to aid the
              linker, tld, to discover which namess have definitions and some
              usage information. The C producer also optionally constructs
              "diagnostics" UNITs (to give run-time diagnostic
              information).</para>
          </footnote>
          These names will appear (in the same order as in
          <emphasis>groups</emphasis>) in the <emphasis>prop_names</emphasis>
          parameter of make_capsule, one for each kind of UNIT appearing in the
          CAPSULE:
        </para>
<programlisting>
<emphasis>prop_names:</emphasis> SLIST<emphasis>(</emphasis>TDFIDENT)
</programlisting>

        <para>Thus if:</para>
<programlisting>
<emphasis>prop_names</emphasis> = ("tagdecs", "tagdefs")
</programlisting>

        <para>then, the first element of <emphasis>groups</emphasis> would
          contain only "tagdecs" UNITs and and the second would contain only
          "tagdefs" UNITs. A "tagdecs" UNIT contains things rather like a set of
          global identifier declarations in C, while a "tagdefs" UNIT is like a
          set of global definitions of identifiers.</para>
      </sect2>

      <sect2 id='make-unit'>
        <title>make_unit</title> 

        <para>Now we come to the construction of UNITs using make_unit, as in
          the diagram below</para>

        <figure id="make-quit">
          <title>make_quit Diagram</title> 

          <mediaobject>
            <imageobject><imagedata fileref="guide1" scale="100" format=
            "PNG"></imageobject>
          </mediaobject>
        </figure>

        <para>First we give the limits of the various name-spaces local to the
          UNIT in the <emphasis>local_vars</emphasis> parameter:</para>
<programlisting>
<emphasis>local_vars</emphasis><emphasis>:</emphasis> SLIST(TDFINT<emphasis>)</emphasis>
</programlisting>

        <para>Just in the same way as with
          <emphasis>external_linkage</emphasis>, the numbers in local_vars
          correspond (in the same order) to the spaces indicated in
          <emphasis>capsule_linking</emphasis> in <xref linkend='make-capsule-name-spaces'> .
          With our example,the first element of <emphasis>local_vars</emphasis>
          gives the number of "tag" names local to the UNIT, the second gives the
          number of "token" names local to the UNIT etc. These will include all
          the names used in the body of the UNIT. Each declaration of a TAG, for
          example, will use a new number from the "tag" name-space; there is no
          hiding or reuse of names within a UNIT.</para>
      </sect2>

      <sect2 id='link'>
        <title>LINK</title> 

        <para>Connections between the CAPSULE name-spaces and the UNIT
          name-spaces are made by LINKs in the <emphasis>lks</emphasis> parameter
          of make_unit:</para>
<programlisting>
<emphasis>lks</emphasis>: SLIST(LINKS<emphasis>)</emphasis>
</programlisting>

        <para>Once again, <emphasis>lks</emphasis> is effectively indexed by
          the kind of name-space a. Each LINKS is an SLIST of LINKs each of which
          which establish an identity between names in the CAPSULE name-space and
          names in the UNIT name-space. Thus if the first element of
          <emphasis>lks</emphasis> contains:</para>
<programlisting>
make_link(42, 4)
</programlisting>

        <para>then, the UNIT "tag" 42 is identical to the CAPSULE "tag"
          4.</para>

        <para>Note that names from the CAPSULE name-space only arise in two
          places, LINKs and LINK_EXTERNs. Every other use of names are derived
          from some UNIT name-space.</para>
      </sect2>
    </sect1>

    <sect1 id='def-decl'>
      <title>Definitions and declarations</title> 

      <para>The encoding in the <emphasis>properties</emphasis>:BYTSTREAM
        parameter of a UNIT is a PROPS , for which there are five constructors
        corresponding to the kinds of UNITs in core-TDF, make_al_tagdefs,
        make_tagdecs, make_tagdefs, make_tokdefs and make_tokdecs. Each of these
        will declare or define names in the appropriate UNIT name-space which can
        be used by make_link in the UNIT's <emphasis>lks</emphasis> parameter as
        well as elsewhere in the <emphasis>properties</emphasis> parameter. The
        distinction between "declarations" and "definitions" is rather similar to
        C usage; a declaration provides the "type" of a name, while a definition
        gives its meaning. For tags, the "type" is the SORT SHAPE (see below).
        For tokens, the "type" is a SORTNAME constructed from the SORTNAMEs of
        the parameters and result of the TOKEN using token:</para>
<programlisting>
<emphasis>params</emphasis>:  LIST(SORTNAME)
<emphasis>result</emphasis>:  SORTNAME
  -&gt; SORTNAME
</programlisting>

      <para>Taking make_tagdefs as a paradigm for PROPS, we have:</para>
<programlisting>
<emphasis>no_labels</emphasis>:  TDFINT
<emphasis>tds</emphasis>:    SLIST(TAGDEF)
-&gt; TAGDEF_PROPS
</programlisting>

      <para>The <emphasis>no_labels</emphasis> parameter introduces the size of
        yet another name-space local to the PROPS, this time for the LABELs used
        in the TAGDEFs. Each TAGDEF in <emphasis>tds</emphasis> will define a
        "tag" name in the UNIT's name-space. The order of these TAGDEFs is
        immaterial since the initialisations of the tags are values which can be
        solved at translate time, load time or as unordered dynamic
        initialisations.</para>

      <para>There are three constructors for TAGDEFs, each with slightly
        different properties. The simplest is make_id_tagdef:</para>
<programlisting>
<emphasis>t</emphasis>:   TDFINT
<emphasis>signature</emphasis>:   OPTION(STRING)
<emphasis>e</emphasis>:   EXP <emphasis>x</emphasis>
-&gt; TAGDEF
</programlisting>

      <para>Here, <emphasis>t</emphasis> is the tag name and the evaluation of
        <emphasis>e</emphasis> will be the value of SHAPE <emphasis>x</emphasis>
        of an obtain_tag(<emphasis>t</emphasis>) in an EXP. Note that t is not a
        variable; the value of obtain_tag(<emphasis>t</emphasis>) will be
        invariant. The <emphasis>signature</emphasis> parameter gives a STRING
        (see <xref linkend='string'> ) which may be used as an name for
        the tag, external to TDF and also as a check introduced by the producer
        that a tagdef and its corresponding tagdec have the same notion of the
        language-specific type of the tag.</para>

      <para>The two other constructors for TAGDEF, make_var_tagdef and
        common_tagdef both define variable tags and have the same
        signature:</para>
<programlisting>
<emphasis>t</emphasis>:   TDFINT
<emphasis>opt_access</emphasis>: OPTION(ACCESS)
<emphasis>signature</emphasis>:   OPTION(STRING)
<emphasis>e</emphasis>:   EXP <emphasis>x</emphasis>
-&gt; TAGDEF
</programlisting>

      <para>
          Once again <emphasis>t</emphasis> is tag name but now
          <emphasis>e</emphasis> is initialisation of the variable
          <emphasis>t</emphasis>. A use of obtain_tag(<emphasis>t</emphasis>)
          will give a pointer to the variable (of SHAPE POINTER x), rather than
          its contents. 
  
          <footnote>
            <para>There is a similar distinction between tags introduced to be
              locals of a procedure using identify and variable (see 
              <xref linkend='identify-variable'> )</para>
        </footnote>
        There can only be one make_var_tagdef of a given tag in a program, but
        there may be more than one common_tagdef, possibly with different
        initialisations; however these initialisations must overlap
        consistently just as in common blocks in FORTRAN.
      </para>

      <para>The ACCESS parameter gives various properties required for the tag
        being defined and is discussed in <xref linkend='access'> .</para>

      <para>The initialisation EXPs of TAGDEFs will be evaluated before the
        "main" program is started. An initialiation EXP must either be a constant
        (in the sense of <xref linkend='constants'> ) or reduce to
        (either directly or by token or _cond expansions) to an
        initial_value:</para>
<programlisting>
<emphasis>init</emphasis>:    EXP <emphasis>s</emphasis>
-&gt; EXP <emphasis>s</emphasis>
</programlisting>

      <para>The translator will arrange that <emphasis>init</emphasis> will be
        evaluated once only before any procedure application, other than those
        themselves involved in initial_values, but after any constant
        initialisations. The order of evaluation of different initial_values is
        arbitrary.</para>

      <sect2 id='scopes-linking'>
        <title>Scopes and linking</title> 

        <para>Only names introduced by AL_TAGDEFS, TAGDEFS, TAGDECs, TOKDECs
          and TOKDEFs can be used in other UNITs (and then, only via the
          <emphasis>lks</emphasis> parameters of the UNITs involved). You can
          regard them as being similar to C global declarations. Token
          definitions include their declarations implicitly; however this is not
          true of tags. This means that any CAPSULE which uses or defines a tag
          across UNITs must include a TAGDEC for that tag in its "tagdecs" UNITs.
          A TAGDEC is constructed using either make_id_tagdec , make_var_tagdec
          or common_tagdec, all with the same form:</para>
<programlisting>
<emphasis>t_intro</emphasis>: TDFINT
<emphasis>acc</emphasis>:     OPTION(ACCESS)
<emphasis>signature</emphasis>:   OPTION(STRING)
<emphasis>x</emphasis>:       SHAPE
-&gt; TAGDEC
</programlisting>

        <para>Here the tagname is given by <emphasis>t_intro</emphasis>; the
          SHAPE <emphasis>x</emphasis> will defined the space and alignment
          required for the tag (this is analogous to the type in a C
          declaration). The <emphasis>acc</emphasis> field will define certain
          properties of the tag not implicit in its SHAPE; I shall return to the
          kinds of properties envisaged in discussing local declarations in
          <xref linkend='defining-using-locals'> .</para>

        <para>Most program will appear in the "tagdefs" UNITs - they will
          include the definitions of the procedures of the program which in turn
          will include local definitions of tags for the locals of the
          procedures.</para>

        <para>The standard TDF linker allows one to link CAPSULEs together
          using the name identifications given in the LINKEXTERNs, perhaps hiding
          some of them in the final CAPSULE. It does this just by generating a
          new CAPSULE name-space, grouping together component UNITs of the same
          kind and replacing their <emphasis>lks</emphasis> parameters with
          values derived from the new CAPSULE name-space without changing the
          UNITs' name-spaces or their <emphasis>props</emphasis> parameters. The
          operation of grouping together UNITs is effectively assumed to be
          associative, commutative and idempotent e.g. if the same tag is
          declared in two capsules it is assumed to be the same thing . It also
          means that there is no implied order of evaluation of UNITs or of their
          component TAGDEFs</para>

        <para>Different languages have different conventions for deciding how
          programs are actually run. For example, C requires the presence of a
          suitably defined "main" procedure; this is usually enforced by
          requiring the system ld utility to bind the name "main" along with the
          definitions of any library values required. Otherwise, the C
          conventions are met by standard TDF linking. Other languages have more
          stringent requirements. For example, C++ requires dynamic
          initialisation of globals, using initial_value. As the only runnable
          code in TDF is in procedures, C++ would probably require an additional
          linking phase to construct a "main" procedure which calls the
          initialisation procedures of each CAPSULE involved if the system linker
          did not provide suitable C++ linking.</para>
      </sect2>

      <sect2 id='decl-definition'>
        <title>Declaration and definition
        <emphasis>signatures</emphasis></title> 

        <para>The <emphasis>signature</emphasis> arguments of TAGDEFs and
          TAGDECs are designed to allow a measure of cross-UNIT checking when
          linking independently compiled CAPSULEs. Suppose that we have a tag,
          <emphasis>t</emphasis>, used in one CAPSULE and defined in another; the
          first CAPSULE would have to have a TAGDEC for <emphasis>t</emphasis>
          whose TAGDEF is in the second. The <emphasis>signature</emphasis>
          STRING of both could be arranged to represent the language-specific
          type of <emphasis>t</emphasis> as understood at compilation-time.
          Clearly, when the CAPSULEs are linked the types must be identical and
          hence their STRING representation must be the same - a translator will
          reject any attempt to link definitions and declarations of the same
          object with different signatures.</para>

        <para>Similar considerations apply to TOKDEFs and TOKDECs; the "type"
          of a TOKEN may not have any familiar analogue in most HLLs, but the
          principle remains the same.</para>
      </sect2>

      <sect2 id='string'>
        <title>STRING</title> 

        <para>The SORT STRING is used in various constructs other than
          declarations and definitions. It is a first-class SORT with
          string_apply_token and string_cond. A primitive STRING is constructed
          from a TDFSTRING(k,n) which is an encoding of n integers,each of k
          bits, using make_string:</para>
<programlisting>
<emphasis>arg</emphasis>: TDFSTRING<emphasis>(k, n)</emphasis>
-&gt; STRING<emphasis>(k, n)</emphasis>
</programlisting>

        <para>STRINGs may be concatenated using concat_string:</para>
<programlisting>
<emphasis>arg1</emphasis>:    STRING<emphasis>(k, n)</emphasis>
<emphasis>arg2</emphasis>:    STRING<emphasis>(k,m)</emphasis>
-&gt; STRING<emphasis>(k, n+m)</emphasis>
</programlisting>

        <para>Being able to compose strings, including token applications etc,
          means that late-binding is possible in <emphasis>signature</emphasis>
          checking in definitions and declarations. This late-binding means that
          the representation of platform-dependent HLL types need only be fully
          expanded at install-time and hence the types could be expressed in
          their representational form on the specific platform.</para>
      </sect2>
    </sect1>
  </chapter>

  <chapter id='shapes-align-offets'>
    <title>SHAPEs, ALIGNMENTs and OFFSETs</title> 

    <para>In most languages there is some notion of the type of a value. This
      is often an uncomfortable mix of a definition of a representation for the
      value and a means of choosing which operators are applicable to the value.
      The TDF analogue of the type of value is its SHAPE (S3.20). A SHAPE is only
      concerned with the representation of a value, being an abstraction of its
      size and alignment properties. Clearly an architecture-independent
      representation of a program cannot say, for example, that a pointer is 32
      bits long; the size of pointers has to be abstracted so that translations
      to particular architectures can choose the size that is apposite for the
      platform.</para>

    <sect1 id='shapes'>
      <title>Shapes</title> 

      <para>There are ten different basic constructors for the SORT SHAPE from
        bitfield to top as shown in table 3. SHAPEs arising from those
        constructors are used as qualifiers (just using an upper case version of
        the constructor name) to various SORTs in the definition; for example,
        EXP TOP is an expression with top SHAPE. This is just used for
        definitional purposes only; there is no SORT SHAPENAME as one has
        SORTNAME.</para>

      <para>In the TDF specification of EXPs, you will observe that all EXPs in
        constructor signatures are all qualified by the SHAPE name; for example,
        a parameter might be EXP INTEGER(v). This merely means that for the
        construct to be meaningful the parameter must be derived from a
        constructor defined to be an EXP INTEGER(v). You might be forgiven for
        assuming that TDF is hence strongly-typed by its SHAPEs. This is not
        true; the producer must get it right. There are some checks in
        translators, but these are not exhaustive and are more for the benefit of
        translator writers than for the user. A tool for testing the SHAPE
        correctness of a TDF program would be useful but has yet to be
        written.</para>

      <sect2 id='top-bottom-lub'>
        <title>TOP, BOTTOM, LUB</title> 

        <para>Two of the SHAPE constructions are rather specialised; these are
          TOP and BOTTOM. The result of any expression with a TOP shape will
          always be discarded; examples are those produced by assign and
          integer_test . A BOTTOM SHAPE is produced by an expression which will
          leave the current flow of control e.g. goto . The significance of these
          SHAPEs only really impinges on the computation of the shapes of
          constructs which have alternative expressions as results. For example,
          the result of conditional is the result of one of its component
          expressions. In this case, the SHAPE of the result is described as the
          LUB of the SHAPEs of the components. This simply means that if one of
          the component SHAPEs is TOP then the resulting SHAPE is TOP; if one is
          BOTTOM then the resulting SHAPE is the SHAPE of the other; otherwise
          both component SHAPEs must be equal and is the resulting SHAPE. Since
          this operation is associative, commutative and idempotent, we can speak
          quite unambiguously of the LUB of several SHAPEs.</para>
      </sect2>

      <sect2 id='integer'>
        <title>INTEGER</title> 

        <para>Integer values in TDF have shape INTEGER(v) where v is of SORT
          VARIETY. The constructor for this SHAPE is integer with a VARIETY
          parameter. The basic constructor for VARIETY is var_limits which has a
          pair of signed natural numbers as parameters giving the limits of
          possible values that the integer can attain. The SHAPE required for a
          32 bit signed integer would be:</para>
<programlisting>
integer(var_limits(-2<emphasis>31</emphasis>, 2<emphasis>31</emphasis>-1))
</programlisting>

        <para>while an unsigned char is:</para>
<programlisting>
integer(var_limits(0, 255))
</programlisting>

        <para>A translator should represent each integer variety by an object
          big enough (or bigger) to contain all the possible values with limits
          of the VARIETY. That being said, I must confess that most current
          translators do not handle integers of more than the maximum given
          naturally by the target architecture, but this will be rectified in due
          course.</para>

        <para>The other way of constructing a VARIETY is to specify the number
          of bits required for its 2s-complemennt representation using
          var_width:</para>
<programlisting>
signed_width:   BOOL
width:  NAT
-&gt; VARIETY
</programlisting>
      </sect2>

      <sect2 id='floating-complex'>
        <title>FLOATING and complex</title> 

        <para>Similarly, floating point and complex numbers have shape FLOATING
          qualified by a FLOATING_VARIETY.</para>

        <para>A FLOATING_VARIETY for a real number is constructed using
          fvar_parms:</para>
<programlisting>
base:   NAT
mantissa_digits:    NAT
minimum_exponent:   NAT
maximum_exponent::  NAT
-&gt; FLOATING_VARIETY
</programlisting>

        <para>A FLOATING_VARIETY specifies the base, number of mantissa digits,
          and maximum and minimum exponent. Once again, it is intended that the
          translator will choose a representation which will contain all possible
          values, but in practice only those which are included in IEEE float,
          double and extended are actually implemented.</para>

        <para>Complex numbers have a floating variety constructed by
          complex_parms which has the the same signature as fvar_parms. The
          representation of these numbers is likely to be a pair of real numbers
          each defined as if by fvar_parms with the same arguments. The real and
          imaginary parts of of a complex number can be extracted using real_part
          and imaginary_part; these could have been injected ito the complex
          number using make_complex or any of the complex operations. Many
          translators will simply transform complex numbers into COMPOUNDs
          consisting of two floating point numbers, transforming the complex
          operations into floating point operations on the fields.</para>
      </sect2>

      <sect2 id='bitfield'>
        <title>BITFIELD</title> 

        <para>A number of contiguous bits have shape BITFIELD, qualified by a
          BITFIELD_VARIETY (S3.4) which gives the number of bits involved and
          whether these bits are to be treated as signed or unsigned integers.
          Current translators put a maximum of 32 or 64 on the number of
          bits.</para>
      </sect2>

      <sect2 id='proc'>
        <title>PROC</title> 

        <para>The representational SHAPEs of procedure values is given by PROC
          with constructor proc . I shall return to this in the description of
          the operations which use it.</para>
      </sect2>

      <sect2 id='non-primitive-shapes'>
        <title>Non-primitive SHAPEs</title> 

        <para>The construction of the other four SHAPEs involves either
          existing SHAPEs or the alignments of existing SHAPEs. These are
          constructed by compound, nof , offset and pointer. Before describing
          these, we require a digression into what is meant by alignments and
          offsets.</para>
      </sect2>
    </sect1>

    <sect1 id='alignments'>
      <title>Alignments</title> 

      <para>In most processor architectures there are limitations on how one
        can address particular kinds of objects in convenient ways. These
        limitations are usually defined as part of the ABI for the processor. For
        example, in the MIPs processor the fastest way to access a 32-bit integer
        is to ensure that the address of the integer is aligned on a 4-byte
        boundary in the address space; obviously one can extract a mis-aligned
        integer but not in one machine instruction. Similarly, 16-bit integers
        should be aligned on a 2-byte boundary. In principle, each primitive
        object could have similar restrictions for efficient access and these
        restrictions could vary from platform to platform. Hence, the notion of
        alignment has to be abstracted to form part of the architecture
        independent TDF - we cannot assume that any particular alignment regime
        will hold universally.</para>

      <para>The abstraction of alignments clearly has to cover compound objects
        as well as primitive ones like integers. For example, if a field of
        structure in C is to be accessed efficiently, then the alignment of the
        field will influence the alignment of the structure as whole; the
        structure itself could be a component of a larger object whose alignment
        must then depend on the alignment of the structure and so on. In general,
        we find that a compound alignment is given by the maximum alignment of
        its components, regardless of the form of the compound object e.g.
        whether it is a structure, union, array or whatever.</para>

      <para>This gives an immediate handle on the abstraction of the alignment
        of a compound object - it is just the set of abstractions of the
        alignments of its components. Since "maximum" is associative, commutative
        and idempotent, the component sets can be combined using normal set-union
        rules. In other words, a compound alignment is abstracted as the set of
        alignments of the primitive objects which make up the compound object.
        Thus the alignment abstraction of a C structure with only float fields is
        the singleton set containing the alignment of a float while that of a C
        union of an int and this structure is a pair of the alignments of an int
        and a float.</para>

      <sect2 id='alignment-const'>
        <title>ALIGNMENT constructors</title> 

        <para>The TDF abstraction of an alignment has SORT ALIGNMENT. The
          constructor, unite_alignments, gives the set-union of its ALIGNMENT
          parameters; this would correspond to taking a maximum of two real
          alignments in the translator.</para>

        <para>The constructor , alignment, gives the ALIGNMENT of a given SHAPE
          according to the rules given in the definition. These rules effectively
          <emphasis>define</emphasis> the primitive ALIGNMENTs as in the
          ALIGNMENT column of table 3. Those for PROC, all OFFSETs and all
          POINTERs are constants regardless of any SHAPE qualifiers. Each of the
          INTERGER VARIETYs, each of the FLOATING VARIETYs and each of the
          BITFIELD VARIETYs have their own ALIGNMENTs. These ALIGNMENTs will be
          bound to values apposite to the particular platform at translate-time.
          The ALIGNMENT of TOP is conventionally taken to be the empty set of
          ALIGNMENTs (corresponding to the minimum alignment on the
          platform).</para>

        <para>The alignment of a procedure parameter clearly has to include the
          alignment of its SHAPE; however, most ABIs will mandate a greater
          alignment for some SHAPEs e.g. the alignment of a byte parameter is
          usually defined to be on a 32-bit rather than an 8-bit boundary. The
          constructor, parameter_alignment, gives the ALIGNMENT of a parameter of
          given SHAPE.</para>
      </sect2>

      <sect2 id='special-alignments'>
        <title>Special alignments</title> 

        <para>There are several other special ALIGNMENTs.</para>

        <para>The alignment of a code address is {<emphasis>code</emphasis>}
          given by code_alignment; this will be the alignment of a pointer given
          by make_local_lv giving the value of a label.</para>

        <para>The other special ALIGNMENTs are considered to include all of the
          others, but remain distinct. They are all concerned with offsets and
          pointers relevant to procedure frames, procedure parameters and local
          allocations and are collectively known as frame alignments. These frame
          alignments differ from the normal alignments in that their mapping to a
          given architecture is rather more than just saying that it describes
          some n-bit boundary. For example, alloca_alignment describes the
          alignment of dynamic space produced by local_alloc (roughly the C
          alloca). Now, an ABI could specify that the alloca space is a stack
          disjoint from the normal procedure stack; thus manipulations of space
          at alloca_alignment may involve different code to space generated in
          other ways.</para>

        <para>Similar considerations apply to the other special alignments,
          callees_alignment(b), callers_alignment(b) and locals_alignment. The
          first two give the alignments of the bases of the two different
          parameter spaces in procedures (q.v.) and locals_alignment gives the
          alignment of the base of locally declared tags within a procedure. The
          exact interpretation of these depends on how the frame stack is defined
          in the target ABI, e.g. does the stack grow downwards or
          upwards?</para>

        <para>The final special alignment is var_param_alignment. This
          describes the alignment of a special kind of parameter to a procedure
          which can be of arbitrary length (see <xref linkend='vartag'> .</para>
      </sect2>

      <sect2 id='al-tag-make-al-tagdef'>
        <title>AL_TAG, make_al_tagdef</title> 

        <para>Alignments can also be named as AL_TAGs using make_al_tagdef.
          There is no corresponding make_al_tagdec since AL_TAGs are implicitly
          declared by their constructor, make_al_tag. The main reason for having
          names for alignments is to allow one to resolve the ALIGNMENTs of
          recursive data structures. If, for example, we have mutually recursive
          structures, their ALIGNMENTs are best named and given as a set of
          equations formed by AL_TAGDEFs. A translator can then solve these
          equations trivially by substitution; this is easy because the only
          significant operation is set-union.</para>
      </sect2>
    </sect1>

    <sect1 id='pointer-offset-shapes'>
      <title>Pointer and offset SHAPEs</title> 

      <para>A pointer value must have a form which reflects the alignment of
        the object that it points to; for example, in the MIPs processor, the
        bottom two bits of a pointer to an integer must be zero. The TDF SHAPE
        for a pointer is POINTER qualified by the ALIGNMENT of the object pointed
        to. The constructor pointer uses this alignment to make a POINTER
        SHAPE.</para>

      <sect2 id='offset'>
        <title>OFFSET</title> 

        <para>Expressions which give sizes or offsets in TDF have an OFFSET
          SHAPE. These are always described as the difference between two
          pointers. Since the alignments of the objects pointed to could be
          different, an OFFSET is qualified by these two ALIGNMENTs. Thus an EXP
          OFFSET(X,Y) is the difference between an EXP POINTER(X) and an EXP
          POINTER(Y). In order for the alignment rules to apply, the set X of
          alignments must include Y. The constructor offset uses two such
          alignments to make an OFFSET SHAPE. However, many instances of offsets
          will be produced implicitly by the offset arithmetic, e.g.,
          offset_pad:</para>
<programlisting>
<emphasis>a</emphasis>:  ALIGNMENT
<emphasis>arg</emphasis>1:   EXP OFFSET(<emphasis>z, t</emphasis>)
-&gt; EXP OFFSET(<emphasis>z</emphasis> xc8 <emphasis>a, a</emphasis>)
</programlisting>

        <para>This gives the next OFFSET greater or equal to
          <emphasis>arg1</emphasis> at which an object of ALIGNMENT
          <emphasis>a</emphasis> can be placed. It should be noted that the
          calculation of shapes and alignments are all translate-time activities;
          only EXPs should produce runnable code. This code, of course, may
          depend on the shapes and alignments involved; for example, offset_pad
          might round up <emphasis>arg1</emphasis> to be a multiple of four bytes
          if <emphasis>a</emphasis> was an integer ALIGNMENT and
          <emphasis>z</emphasis> was a character ALIGNMENT. Translators also do
          extensive constant analysis, so if <emphasis>arg1</emphasis> was a
          constant offset, then the round-off would be done at translate-time to
          produce another constant.</para>
      </sect2>
    </sect1>

    <sect1 id='compound-shapes'>
      <title>Compound SHAPEs</title> 

      <para>The alignments of compound SHAPEs (i.e. those arising from the
        constructors compound and nof) are derived from the constructions which
        produced the SHAPE. To take the easy one first, the constructor nof has
        signature:</para>
<programlisting>
<emphasis>n</emphasis>:   NAT
<emphasis>s</emphasis>:  SHAPE
-&gt; SHAPE
</programlisting>

      <para>This SHAPE describes an array of <emphasis>n</emphasis> values all
        of SHAPE <emphasis>s</emphasis>; note that <emphasis>n</emphasis> is a
        natural number and hence is a constant known to the producer. Throughout
        the definition this is referred to as the SHAPE NOF(n, s). The ALIGNMENT
        of such a value is alignment(s); i.e. the alignment of an array is just
        the alignment of its elements.</para>

      <para>The other compound SHAPEs are produced using compound:</para>
<programlisting>
<emphasis>sz</emphasis>:     EXP OFFSET(<emphasis>x, y</emphasis>)
-&gt; S  HAPE
</programlisting>

      <para>The <emphasis>sz</emphasis> parameter gives the minimum size which
        can accommodate the SHAPE.</para>

      <sect2 id='offset-arith-compound-shapes'>
        <title>Offset arithmetic with compound shapes</title> 

        <para>The constructors offset_add , offset_zero and shape_offset are
          used together with offset_pad to implement (<emphasis>inter
          alia</emphasis>) selection from structures represented by COMPOUND
          SHAPEs. Starting from the zero OFFSET given by offset_zero, one can
          construct an EXP which is the offset of a field by padding and adding
          offsets until the required field is reached. The value of the field
          required could then be extracted using component or add_to_ptr. Most
          producers would define a TOKEN for the EXP OFFSET of each field of a
          structure or union used in the program simply to reduce the size of the
          TDF</para>

        <para>The SHAPE of a C structure consisting of an char followed by an
          int would require <emphasis>x</emphasis> to be the set consisting of
          two INTEGER VARIETYs, one for int and one for char, and
          <emphasis>sz</emphasis> would probably have been constructed
          like:</para>
<programlisting>
<emphasis>sz</emphasis> = offset_add(offset_pad(int_al, shape_offset(char)), shape_offset(int))
</programlisting>

        <para>The various rules for the ALIGNMENT qualifiers of the OFFSETs
          give the required SHAPE; these rules also ensure that offset arithmetic
          can be implemented simply using integer arithmetic for standard
          architectures (see <xref linkend='model-standard-architecture'> ). Note
          that the OFFSET computed here is the minimum size for the SHAPE. This
          would not in general be the same as the difference between successive
          elements of an array of these structures which would have SHAPE
          OFFSET(<emphasis>x</emphasis>, <emphasis>x</emphasis>) as produced by
          offset_pad(<emphasis>x</emphasis>, <emphasis>sz</emphasis>). For
          examples of the use of OFFSETs to access and create structures, see
          <xref linkend='tdf-expansions-offsets'> .</para>
      </sect2>

      <sect2 id='offset-mult'>
        <title>offset_mult</title> 

        <para>In C, all structures have size known at translate-time. This
          means that OFFSETs for all field selections of structures and unions
          are translate-time constants; there is never any need to produce code
          to compute these sizes and offsets. Other languages (notably Ada) do
          have variable size structures and so sizes and offsets within these
          structures may have to be computed dynamically. Indexing in C will
          require the computation of dynamic OFFSETs; this would usually be done
          by using offset_mult to multiply an offset expression representing the
          stride by an integer expression giving the index:</para>
<programlisting>
<emphasis>arg1</emphasis>:   EXP OFFSET(<emphasis>x, x</emphasis>)
<emphasis>arg2</emphasis>:   EXP INTEGER(<emphasis>v</emphasis>)
-&gt; EXP OFFSET(<emphasis>x, x</emphasis>)
</programlisting>

        <para>and using add_to_ptr with a pointer expression giving the base of
          the array with the resulting OFFSET.</para>
      </sect2>

      <sect2 id='offset-ordering-rep'>
        <title>OFFSET ordering and representation</title> 

        <para>There is an ordering defined on OFFSETs with the same alignment
          qualifiers, as given by offset_test and offset_max having properties
          like:</para>
<programlisting>
shape_offset(S) xb3  offset_zero(alignment(S))
A xb3  B    iff offset_max(A,B) = A
offset_add(A, B) xb3  A     where B xb3  offset_zero(some compatible alignment)
</programlisting>

        <para>In most machines, OFFSETs would be represented as single integer
          values with the OFFSET ordering corresponding to simple integer
          ordering. The offset_add constructor just translates to simple addition
          with offset_zero as 0 with similar correspondences for the other offset
          constructors. You might well ask why TDF does not simply use integers
          for offsets, instead of introducing the rather complex OFFSET SHAPE.
          The reasons are two-fold. First, following the OFFSET arithmetic rules
          concerned with the ALIGNMENT qualifiers will ensure that one never
          extracts a value from a pointer with the wrong alignment by, for
          example, applying contents to an add_to_pointer. This frees TDF from
          having to define the effect of strange operations like forming a float
          by taking the contents of a pointer to a character which may be
          mis-aligned with respect to floats - a heavy operation on most
          processors. The second reason is quite simple; there are machines which
          cannot represent OFFSETs by a single integer value.</para>

        <para>The iAPX-432 is a fairly extreme example of such a machine; it is
          a "capability" machine which must segregate pointer values and
          non-pointer values into different spaces. On this machine a value of
          SHAPE POINTER({<emphasis>pointer</emphasis>, int}) (e.g. a pointer to a
          structure containing both integers and pointers) could have two
          components; one referring to the pointers and another to the integers.
          In general, offsets from this pointer would also have two components,
          one to pick out any pointer values and the other the integer values.
          This would obviously be the case if the original POINTER referred to an
          array of structures containing both pointers and integers; an offset to
          an element of the array would have SHAPE
          OFFSET({<emphasis>pointer</emphasis>,
          int},{<emphasis>pointer</emphasis> , int}); both elements of the offset
          would have to be used as displacements to the corresponding elements of
          the pointer to extract the structure element. The OFFSET ordering is
          now given by the comparison of both displacements. Using this method,
          one finds that pointers in store to non-pointer alignments are two
          words in different blocks and pointers to pointer-alignments are four
          words, two in one block and two in another. This sounds a very unwieldy
          machine compared to normal machines with linear addressing. However,
          who knows what similar strange machines will appear in future; the
          basic conflicts between security, integrity and flexibility that the
          iAPX-432 sought to resolve are still with us. For more on the modelling
          of pointers and offsets see <xref linkend='models-tdf-algebra'> .</para>
      </sect2>
    </sect1>

    <sect1 id='bitfield-align'>
      <title>BITFIELD alignments</title> 

      <para>
          Even in standard machines, one finds that the size of a pointer may
          depend on the alignment of the data pointed at. Most machines do not
          allow one to construct pointers to bits with the same facility as other
          alignments. This usually means that pointers in memory to BITFIELD
          VARIETYs must be implemented as two words with an address and bit
          displacement. One might imagine that a translator could implement
          BITFIELD alignments so that they are the same as the smallest natural
          alignment of the machine and avoid the bit displacement, but this is
          not the intention of the definition. On any machine for which it is
          meaningful, the alignment of a BITFIELD must be one bit; in other words
          successive BITFIELDs are butted together with no padding bits. 
  
          <footnote>
            <para>Note that is not generally true for C bitfields; most C ABIs
            have (different) rules for putting in padding bits depending on the
            size of the bitfield and its relation with the natural alignments.
            This is a fruitful source of errors in data exchange between
            different C ABIs For more on similar limitations of bitfields in TDF
            (see <xref linkend='assining-extracting-bit'> ).</para>
        </footnote>
        Within the limits of what one can extract from BITFIELDs, namely
        INTEGER VARIETYs, this is how one should implement non-standard
        alignments, perhaps in constructing data, such as protocols, for
        exchange between machines. One could implement some Ada
        representational statements in this way; certainly the most commonly
        used ones.
      </para>

      <para>TDF Version 3.0 does not allow one to construct a pointer of SHAPE
        POINTER(b) where b consists entirely of bitfield alignments; this
        relieves the translators of the burden of doing general bit-addressing.
        Of course, this simply shifts the burden to the producer. If the high
        level language requires to construct a pointer to an arbitrary bit
        position, then the producer is required to represent such a pointer as a
        pair consisting of pointer to some alignment including the required
        bitfield and an offset from this alignment to the bitfield. For example,
        Ada may require the construction of a pointer to a boolean for use as the
        parameter to a procedure; the SHAPE of the rep resentation of this Ada
        pointer could be a COMPOUND formed from a POINTER({x,b}) and an
        OFFSET({x, b}, b) where b is the alignment given by a 1 bit alignment. To
        access the boolean, the producer would use the elements of this pair as
        arguements to bitfield_assign and bitfield_contents
        (<xref linkend='assining-extracting-bit'> ).</para>
    </sect1>
  </chapter>

  <chapter id='procedures-locals'>
    <title>Procedures and Locals</title> 

    <para>All procedures in TDF are essentially global; the only values which
      are accessible from the body of a procedure are those which are derived
      from global TAGs (introduced by TAGDEFs or TAGDECs), local TAGs defined
      within the procedure and parameter TAGs of the procedure.</para>

    <para>All executable code in TDF will arise from an EXP PROC made by either
      make_proc or make_general_proc. They differ in their treatment of how space
      for the actual parameters of a call is managed; in particular, is it the
      caller or the callee which deallocates the parameter space?</para>

    <para>With make_proc, this management is conceptually done by the caller at
      an apply_proc; i.e. the normal C situation. This suffers from the
      limitation that tail-calls of procedures are then only possible in
      restricted circumstances (e.g. the space for the parameters of the
      tail-call must be capable of being included in caller's parameters) and
      could only be implemented as an optimisation within a translator. A
      producer could not predict these circumstances in a machine independent
      manner, whether or not it knew that a tail-call was valid.</para>

    <para>An alternative would be to make the management of parameter space the
      responsibility of the called procedure. Rather than do this,
      make_general_proc (and apply_general_proc) splits the parameters into two
      sets, one whose allocation is the responsibility of the caller and the
      other whose allocation is dealt with by the callee. This allows an explicit
      tail_call to be made to a procedure with new callee parameters; the caller
      parameters for the tail_call will be the same as (or some initial subset
      of) the caller parameters of the procedure containing the tail_call
      .</para>

    <para>A further refinement of make_general_proc is to allow access to the
      caller parameter space in a postlude at the call of the procedure using an
      apply_general_proc. This allows simple implementations of Ada
      out_parameters, or more generally, multiple results of procedures.</para>

    <sect1 id='make-proc-apply-proc'>
      <title>make_proc and apply_proc</title> 

      <para>The make_proc constructor has signature:</para>
<programlisting>
<emphasis>result_shape</emphasis>:   SHAPE
<emphasis>params_intro</emphasis>:   LIST(TAGSHACC)
<emphasis>var_intro</emphasis>:  OPTION(TAGACC)
<emphasis>body</emphasis>:   EXP BOTTOM
-&gt;    EXP PROC
</programlisting>

      <para>The <emphasis>params_intro</emphasis> and
        <emphasis>var_intro</emphasis> parameters introduce the formal parameters
        of the procedure which may be used in <emphasis>body</emphasis>. The
        procedure result will have SHAPE <emphasis>result_shape</emphasis> and
        will be usually given by some return construction within
        <emphasis>body</emphasis>. The basic model is that space will be provided
        to copy actual parameters (into space supplied by some apply_proc) by
        value into these formals and the body will treat this space effectively
        as local variables.</para>

      <para>Each straightforward formal parameter is introduced by an auxiliary
        SORT TAGSHACC using make_tagshacc:</para>
<programlisting>
<emphasis>sha</emphasis>: SHAPE
<emphasis>opt_access</emphasis>:  OPTION(LIST(ACCESS))
<emphasis>tg_intro</emphasis>:    TAG POINTER(alignment(<emphasis>sha</emphasis>))
-&gt; TAGSHACC
</programlisting>

      <para>Within <emphasis>body</emphasis>, the formal will be accessed using
        <emphasis>tg_intro</emphasis>; it is always considered to be a pointer to
        the space of SHAPE <emphasis>sha</emphasis> allocated by apply_proc,
        hence the pointer SHAPE.</para>

      <para>For example, if we had a simple procedure with one integer
        parameter, <emphasis>var_intro</emphasis> would be empty and
        <emphasis>params_intro</emphasis> might be:</para>
<programlisting>
<emphasis>params_intro</emphasis> = make_tagshacc<emphasis>(</emphasis> integer(v), empty, make_tag(13))
</programlisting>

      <para>Then, TAG 13 from the enclosing UNIT's name-space is identified
        with the formal parameter with SHAPE POINTER(INTEGER(v)). Any use of
        obtain_tag(make_tag(13)) in <emphasis>body</emphasis> will deliver a
        pointer to the integer parameter. I shall return to the meaning of
        <emphasis>opt_access</emphasis> and the ramifications of the scope and
        extent of TAGs involved in conjunction with local declarations in
        <xref linkend='identify-variable'> .</para>

      <para>Procedures, whether defined by make_proc or make_general_proc, will
        usually terminate and deliver its result with a return:</para>
<programlisting>
<emphasis>arg1</emphasis>:   EXP <emphasis>x</emphasis>
-&gt; EXP BOTTOM
</programlisting>

      <para>Here <emphasis>x</emphasis> must be identical to the
        <emphasis>result_shape</emphasis> of the call of the procedure There may
        be several returns in body; and the SHAPE <emphasis>x</emphasis> in each
        will be the same. Some languages allow different types to be returned
        depending on the particular call. The producer must resolve this issue.
        For example, C allows one to deliver void if the resulting value is not
        used. In TDF a dummy value must be provided at the return; for example
        make_value(<emphasis>result_shape</emphasis>)</para>

      <para>Note that the <emphasis>body</emphasis> has SHAPE bottom since all
        possible terminations to a procedure have SHAPE BOTTOM..</para>

      <para>Procedures defined by make_proc are called using apply_proc:</para>
<programlisting>
<emphasis>result_shape</emphasis>:   SHAPE
<emphasis>arg1</emphasis>:   EXP PROC
<emphasis>arg2</emphasis>:   LIST(EXP)
<emphasis>varparam</emphasis>:   OPTION(EXP)
--&gt; EXP <emphasis>result_shape</emphasis>
</programlisting>

      <para>
          Here <emphasis>arg1</emphasis> is the procedure to be called and
          <emphasis>arg2</emphasis> gives the actual parameters. There must be at
          least as many actual parameters as given (with the same SHAPE) in the
          <emphasis>params_intro</emphasis> of the corresponding make_proc for
          arg1. 
  
          <footnote>
            <para>The vararg construction in C are implemented by giving more
            actuals than formals; the extra parameters are accessed by offset
            arithmetic with a pointer to a formal, using parameter_alignment to
            pad the offsets.</para>
        </footnote>
        The values of <emphasis>arg2</emphasis> will be copied into space
        managed by caller.
      </para>

      <para>The SHAPE of the result of the call is given by
        <emphasis>result_shape</emphasis> which must be identical to the
        <emphasis>result_shape</emphasis> of the make_proc.</para>

      <sect2 id='vartag'>
        <title><emphasis>vartag</emphasis>,
        <emphasis>varparam</emphasis></title> 

        <para>U se of the <emphasis>var_intro</emphasis> OPTION in make_proc
          and the corresponding <emphasis>varparam</emphasis> in apply_proc
          allows one to have a parameter of any SHAPE, possibly differing from
          call to call where the actual SHAPE can be deduced in some way by the
          <emphasis>body</emphasis> of the make_proc . One supplies an extra
          actual parameter, <emphasis>varparam</emphasis>, which usually would be
          a structure grouping some set of values. The body of the procedure can
          then access these values using the pointer given by the TAG
          <emphasis>var_intro</emphasis>, using add_to_ptr with some computed
          offsets to pick out the individual fields.</para>

        <para>This is a slightly different method of giving a variable number
          of parameters to a procedure, rather than simply giving more actuals
          than formals. The principle difference is in the alignment of the
          components of <emphasis>varparam</emphasis>; these will be laid out
          according to the default padding defined by the component shapes. In
          most ABIs, this padding is usually different to the way parameters are
          laid out; for example, character parameters are generally padded out to
          a full word. Thus a sequence of parameters of given shape has a
          different layout in store to the same sequence of shapes in a
          structure. If one wished to pass an arbitrary structure to a procedure,
          one would use the <emphasis>varparam</emphasis> option rather passing
          the fields individually as extra actual parameters.</para>
      </sect2>
    </sect1>

    <sect1 id='make-general-proc'>
      <title>make_general_proc and apply_general_proc</title> 

      <para>A make_general_proc has signature:</para>
<programlisting>
<emphasis>result_shape</emphasis>:    SHAPE
<emphasis>prcprops</emphasis>:    OPTION(PROCPROPS)
<emphasis>caller_intro</emphasis>:    LIST(TAGSHACC)
<emphasis>callee_intro</emphasis>:    LIST(TAGSHACC)
<emphasis>body</emphasis>:    EXP BOTTOM
-&gt; EXP PROC
</programlisting>

      <para>Here the formal parameters are split into two sets,
        <emphasis>caller_intro</emphasis> and <emphasis>callee_intro</emphasis>,
        each given by a list of TAGSHACCs just as in make_proc. The distinction
        between the two sets is that the make_general_proc is responsible for
        de_allocating any space required for the callee parameter set; this
        really only becomes obvious at uses of tail_call within
        <emphasis>body.</emphasis></para>

      <para>The <emphasis>result_shape</emphasis> and <emphasis>body</emphasis>
        have the same general properties as in make_proc. In addition
        <emphasis>prcprops</emphasis> gives other information both about
        <emphasis>body</emphasis> and the way that that the procedure is called.
        PROCPROPS are a set drawn from check_stack, inline, no_long_jump_dest,
        untidy, var_callees and var_callers. The set is composed using
        add_procprops. The PROCPROPS no_long_jump_dest is a property of
        <emphasis>body</emphasis> only; it indicates that none of the labels
        within <emphasis>body</emphasis> will be the target of a long_jump
        construct. The other properties should also be given consistently at all
        calls of the procedure; theu are discussed in <xref linkend='procprops'> .</para>

      <para>A procedure, <emphasis>p</emphasis>, constructed by
        make_general_proc is called using apply_general_proc:</para>
<programlisting>
<emphasis>result_shape</emphasis>:    SHAPE
<emphasis>prcprops</emphasis>:    OPTION(PROCPROPS)
<emphasis>p</emphasis>:   EXP PROC
<emphasis>caller_params</emphasis>:   LIST(OTAGEXP)
<emphasis>callee_params</emphasis>:   CALLEES
<emphasis>postlude</emphasis>:    EXP TOP
-&gt; EXP <emphasis>result_shape</emphasis>
</programlisting>

      <para>The actual caller parameters are given by
        <emphasis>caller_params</emphasis> as a list of OTAGEXPs constructed
        using make_otagexp:</para>
<programlisting>
<emphasis>tgopt</emphasis>:   OPTION(TAG <emphasis>x</emphasis>)
<emphasis>e</emphasis>:   EXP <emphasis>x</emphasis>
-&gt; OTAGEXP
</programlisting>

      <para>
          Here, <emphasis>e</emphasis> is the value of the parameter and
          <emphasis>tgopt</emphasis>, if present, is a TAG which will bound to
          the final value of the parameter (after <emphasis>body</emphasis> is
          evaluated) in the <emphasis>postlude</emphasis> expression of the
          apply_general_proc. 
  
          <footnote>
            <para>If a formal parameter is to be used in this way, it should be
            marked as having out_par ACCESS in its corresponding TAGSHACC in
            callers_intro.</para>
        </footnote>
        Clearly, this allows one to use a caller parameter as an extra result
        of the procedure; for example, as in Ada out-parameters.
      </para>

      <para>The actual <emphasis>callee_params</emphasis> may be constructed in
        three different ways. The usual method is to use make_callee_list, giving
        a list of actual EXP parameters, corresponding to the
        <emphasis>caller_intro</emphasis> list in the obvious way.The
        constructor, same_callees allows one to use the callees of the current
        procedure as the callees of the call; this, of course, assumes that the
        formals of the current procedure are compatible with the formals required
        for the call The final method allows one to construct a dynamically sized
        set of CALLEES; make_dynamic_callees takes a pointer and a size
        (expressed as an OFFSET) to make the CALLEES; this will be used in
        conjunction with a var_callees PROCPROPS (see <xref linkend='procprops'> ).</para>

      <para>Some procedures can be expressed using either make_proc or
        make_general_proc. For example:</para>

      <para>make_proc(S, L, empty, B) = make_general_proc(S, var_callers, L,
        empty, B)</para>

      <sect2 id='tail-call'>
        <title>tail_call</title> 

        <para>Often the result of a procedure, <emphasis>f</emphasis>, is
          simply given by the call of another (or the same) procedure,
          <emphasis>g</emphasis>. In appropriate circumstances, the same stack
          space can be used for the call of <emphasis>g</emphasis> as the call of
          <emphasis>f</emphasis>. This can be particularly important where
          heavily recursive routines are involved; some languages even use tail
          recursion as the preferred method of looping.</para>

        <para>One condition for such a tail call to be applicable is knowing
          that <emphasis>g</emphasis> does not require any pointers to locals of
          <emphasis>f</emphasis>; this is often implicit in the language
          involved. Equally important is that the action on the return from
          <emphasis>f</emphasis> is indistiguishable from the return from
          <emphasis>g</emphasis>. For example, if it were the callers
          responsibility to pop the the space for the parameters on return from a
          call, then the tail call of <emphasis>g</emphasis> would only work if
          <emphasis>g</emphasis> had the same parameter space as
          <emphasis>f</emphasis>.</para>

        <para>This is the justification for splitting the parameter set of a
          general proc; it is (at least conceptually) the caller's responsibility
          for popping the caller-parameters only - the callee-parameters are
          dealt with by the procedure itself. Hence we can define tail_call which
          uses the same caller-parameters, but a different set of
          callee-parameters:</para>
<programlisting>
<emphasis>prcprops</emphasis>:    OPTION(PROCPROPS)
<emphasis>p</emphasis>:   EXP PROC
<emphasis>callee_params</emphasis>:   CALLEES
-&gt; EXP BOTTOM
</programlisting>

        <para>The procedure p will be called with the same caller parameters as
          the current procedure and the new <emphasis>callee_params</emphasis>
          and return to the call site of the current procedure. Semantically, if
          S is the return SHAPE of the current procedure, and L is its
          caller-parameters:</para>

        <para>tail_call(P, p, C) = return(apply_general_proc(S, P, p, L, C,
          make_top()))</para>

        <para>However an implementation is expected to conserve stack by using
          the same space for the call of p as the current procedure.</para>
      </sect2>

      <sect2 id='procprops'>
        <title>PROCPROPS</title> 

        <para>The presence of var_callees (or var_callers) means that the
          procedure can be called with more actual callee (or caller) parameters
          than are indicated in <emphasis>callee_intro</emphasis> (or
          <emphasis>caller_intro</emphasis> ). These extra parameters would be
          accessed within body using offset calculations with respect to the
          named parameters. The offsets should be calculated using
          parameter_alignment to give the packing of the parameter packs.</para>

        <para>The presence of untidy means that <emphasis>body</emphasis> may
          be terminated by an untidy_return. This returns the result of the
          procedure as in return, but the lifetime of the local space of the
          procedure is extended (in practice this is performed by not returning
          the stack to its original value at the call). A procedure containing an
          untidy_return is a generalisation of a local_alloc(see 
          <xref linkend='local-alloc-local-free'> ).
          For example the procedure could do some complicated
          local allocation (a triangular array, say) and untidily return a
          pointer to it so that the space is still valid in the calling
          procedure. The space will remain valid for the lifetime of the calling
          procedure unless some local_free is called within it, just as if the
          space had been generated by a local_alloc in the calling
          procedure.</para>

        <para>The presence of inline is just a hint to the translator that the
          procedure body is a good candidate for inlining at the call.</para>

        <para>The presence of check_stack means that the static stack
          requirements of the procedure will be checked on entry to see that they
          do not exceed the limits imposed by set_stack_limit; if they are
          exceeded a TDF exception with ERROR_CODE stack_overflow (see
          <xref linkend='exceptional-flow'> ) will be raised.</para>
      </sect2>
    </sect1>

    <sect1 id='defining-using-locals'>
      <title>Defining and using locals</title> 

      <sect2 id='identify-variable'>
        <title>identify, variable</title> 

        <para>Local definitions within the <emphasis>body</emphasis> of a
          procedure are given by two EXP constructors which permit one to give
          names to values over a scope given by the definition. Note that this is
          somewhat different to declarations in standard languages where the
          declaration is usually embedded in a larger construct which defines the
          scope of the name; here the scope is explicit in the definition. The
          reason for this will become more obvious in the discussion of TDF
          transformations. The simpler constructor is identify:</para>
<programlisting>
<emphasis>opt_access</emphasis>: OPTION(ACCESS)
<emphasis>name_intro</emphasis>: TAG <emphasis>x</emphasis>
<emphasis>definition</emphasis>: EXP <emphasis>x</emphasis>
<emphasis>body</emphasis>:    EXP <emphasis>y</emphasis>
-&gt; EXP <emphasis>y</emphasis>
</programlisting>

        <para>The <emphasis>definition</emphasis> is evaluated and its result
          is identified with the TAG given by <emphasis>name_intro</emphasis>
          within its scope <emphasis>body</emphasis>. Hence the use of any
          obtain_tag(<emphasis>name_intro</emphasis>) within
          <emphasis>body</emphasis> is equivalent to using this result. Anywhere
          else, obtain_tag(<emphasis>name_intro</emphasis> ) is meaningless,
          including in other procedures.</para>

        <para>The other kind of local definition is variable:</para>
<programlisting>
<emphasis>opt_access</emphasis>: OPTION(ACCESS)
<emphasis>name_intro</emphasis>: TAG <emphasis>x</emphasis>
<emphasis>init</emphasis>:   EXP <emphasis>x</emphasis>
<emphasis>body</emphasis>:    EXP <emphasis>y</emphasis>
-&gt; EXP <emphasis>y</emphasis>
</programlisting>

        <para>Here the <emphasis>init</emphasis> EXP is evaluated and its
          result serves as an initialisation of space of SHAPE
          <emphasis>x</emphasis> local to the procedure. The TAG name_intro is
          then identified with a pointer to that SPACE within body. A use of
          obtain_tag(<emphasis>name_intro</emphasis>) within
          <emphasis>body</emphasis> is equivalent to using this pointer and is
          meaningless outside <emphasis>body</emphasis> or in other procedures.
          Many variable declarations in programs are uninitialised; in this case,
          the <emphasis>init</emphasis> argument could be provided by make_value
          which will produce some value with SHAPE given by its parameter.</para>
      </sect2>

      <sect2 id='access'>
        <title>ACCESS</title> 

        <para>The ACCESS SORT given in tag declarations is a way of describing
          a list of properties to be associated with the tag. They are basically
          divided into two classes, one which describes global properties of the
          tag with respect to the model for locals and the other which gives
          "hints" on how the value will be used. Any of these can be combined
          using add_access.</para>

        <sect3 id='locals-model'>
          <title>Locals model</title> 

          <para>At the moment there are just three possibilities in the first
            class of ACCESS constructors. They are standard_access (the default)
            , visible, out_par and long_jump_access.</para>

          <para>The basic model used for the locals and parameters of a
            procedure is a frame within a stack of nested procedure calls. One
            could implement a procedure by allocating space according to SHAPEs
            of all of the parameter and local TAGs so that the corresponding
            values are at fixed offsets either from the start of the frame or
            some pointer within it.</para>

          <para>Indeed, if the ACCESS <emphasis>opt_access</emphasis> parameter
            in a TAG definition is produced by visible, then a translator is
            almost bound to do just that for that TAG. This is because it allows
            for the possibility of the value to be accessed in some way other
            than by using obtain_tag which is the standard way of recovering the
            value bound to the TAG. The principal way that this could happen
            within TDF is by the combined use of env_offset to give the offset
            and current_env to give a pointer to the current frame (see
            <xref linkend='current-env-env-offet'> ).</para>

          <para>The out_par ACCESS is only applicable to caller parameters of
            procedures; it indicates that the value of the TAG concerned will
            accessed by the postlude part of an apply_general_proc. Hence, the
            value of the parameter must be accessible after the call; usually
            this will be on the stack in the callers frame.</para>

          <para>The long_jump_access flag is used to indicate that the tag must
            be available after a long_jump. In practice, if either visible or
            long_jump_access is set, most translators would allocate the space
            for the declaration on the main-store stack rather than in an
            available register. If it is not set, then a translator is free to
            use its own criteria for whether space which can fit into a register
            is allocated on the stack or in a register, provided there is no
            observable difference (other than time or program size) between the
            two possibilities.</para>

          <para>Some of these criteria are rather obvious; for example, if a
            pointer to local variable is passed outside the procedure in an
            opaque manner, then it is highly unlikely that one can allocate the
            variable in a register. Some might be less obvious. If the only uses
            of a TAG t was in obtain_tag(t)s which are operands of contents or
            the left-hand operands of assigns , most ABIs would allow the tag to
            be placed in a register. We do not necessarily have to generate a
            pointer value if it can be subsumed by the operations
            available.</para>
        </sect3>

        <sect3 id='access-hints'>
          <title>Access "hints"</title> 

          <para>A variable tag with ACCESS constant is a write-once value; once
            it is initialised the variable will always contain the
            initialisation. In other words the tag is a pointer to a constant
            value; translators can use this information to apply various
            optimisations.</para>

          <para>A POINTER tag with ACCESS no_other_read or no_other_write is
            asserting that there are no "aliassed" accesses to the contents of
            the pointer. For example, when applied to a parameter of a procedure,
            it is saying that the original pointer of the tag is distinct from
            any other tags used (reading/writing) in the lifetime of the tag.
            These other tags could either be further parameters of the procedure
            or globals. Clearly, this is useful for describing the limitations
            imposed by Fortran parameters, for example.</para>
        </sect3>
      </sect2>

      <sect2 id='current-env-env-offet'>
        <title>current_env, env_offset</title> 

        <para>The constructor current_env gives a pointer to the current
          procedure frame of SHAPE POINTER(<emphasis>fa</emphasis>) where
          <emphasis>fa</emphasis> is depends on how the procedure was defined and
          will be some set of the special frame ALIGNMENTs. This set will always
          include locals_alignment - the alignment of any locals defined within
          the procedure. If the procedure has any caller- parameters, the set
          will also include callers_alignment(b) where b indicates whether there
          can be a variable number of them; similarly for
          callee-parameters.</para>

        <para>Offsets from the current_env of a procedure to a tag declared in
          the procedure are constructed by env_offset:</para>
<programlisting>
<emphasis>fa</emphasis>:  ALIGNMENT
<emphasis>y</emphasis>:   ALIGNMENT
<emphasis>t</emphasis>:   TAG <emphasis>x</emphasis>
-&gt; EXP OFFSET(<emphasis>fa</emphasis>,<emphasis>y</emphasis>)
</programlisting>

        <para>The frame ALIGNMENT <emphasis>fa</emphasis> will be the
          appropriate one for the TAG <emphasis>t</emphasis>; i.e. if
          <emphasis>t</emphasis> is a local then the <emphasis>fa</emphasis> will
          be locals_alignment; if <emphasis>t</emphasis> is a caller parameter,
          <emphasis>fa</emphasis> will be callers_alignment(b); if
          <emphasis>t</emphasis> is a callee_parameter, <emphasis>fa</emphasis>
          will be callees_alignment(b). The alignment <emphasis>y</emphasis> will
          be the alignment of the initialisation of
          <emphasis>t</emphasis>.</para>

        <para>The offset arithmetic operations allow one to access the values
          of tags non-locally using values derived from current_env and
          env_offset. They are effectively defined by the following
          identities:</para>
<programlisting>
If TAG t is derived from a variable definition
add_to_ptr(current_env(), env_offset(locals_alignment, A, t)) = obtain_tag(t)
if TAG t is derived from an identify definition:
contents(S, add_to_ptr(current_env(), env_offset(locals_alignment, A, t))) = obtain_tag(t)
if TAG t is derived from a caller parameter:
add_to_ptr(current_env(), env_offset(callers_alignment(b), A, t)) = obtain_tag(t)
if TAG t is derived from a callee parameter:
add_to_ptr(current_env(), env_offset(callees_alignment(b), A, t)) = obtain_tag(t)
</programlisting>

        <para>These identities are valid throughout the extent of t, including
          in inner procedure calls. In other words, one can dynamically create a
          pointer to the value by composing current_env and env_offset.</para>

        <para>The importance of this is that env_offset(t) is a constant OFFSET
          and can be used anywhere within the enclosing UNIT, in other procedures
          or as part of constant TAGDEF; remember that the TDFINT underlying t is
          unique within the UNIT. The result of a current_env could be passed to
          another procedure (as a parameter, say) and this new procedure could
          then access a local of the original by using its env_offset. This would
          be the method one would use to access non-local, non-global identifiers
          in a language which allowed one to define procedures within procedures
          such as Pascal or Algol. Of course, given the stack-based model, the
          value given by current_env becomes meaningless once the procedure in
          which it is invoked is exited.</para>
      </sect2>

      <sect2 id='local-alloc-local-free'>
        <title>local_alloc, local_free_all, last_local</title> 

        <para>The size of stack frame produced by variable and identify
          definitions is a translate-time constant since the frame is composed of
          values whose SHAPEs are known. TDF also allows one to produce
          dynamically sized local objects which are conceptually part of the
          frame. These are produced by local_alloc:</para>
<programlisting>
<emphasis>arg1</emphasis>:   EXP OFFSET(<emphasis>x, y</emphasis>)
-&gt; EXP POINTER(alloca_alignment)
</programlisting>

        <para>The operand <emphasis>arg1</emphasis> gives the size of the new
          object required and the result is a pointer to the space for this
          object "on top of the stack" as part of the frame. The quotation marks
          indicate that a translator writer might prefer to maintain a dynamic
          stack as well as static one. There are some disadvantages in putting
          everything into one stack which may well out-weigh the trouble of
          maintaining another stack which is relatively infrequently used. If a
          frame has a known size, then all addressing of locals can be done using
          a stack-front register; if it is dynamically sized, then another
          frame-pointer register must be used - some ABIs make this easy but not
          all. The majority of procedures contain no local_allocs, so their
          addressing of locals can always be done relative to a stack-front; only
          the others have to use another register for a frame pointer.</para>

        <para>The alignment of pointer result is alloca_alignment which must
          include all SHAPE alignments.</para>

        <para>There are two constructors for releasing space generated by
          local_alloc. To release all such space generated in the current
          procedure one does local_free_all(); this reduces the size of the
          current frame to its static size.</para>

        <para>The other constructor is local_free whch is effectively a "pop"
          to local_alloc's "push":</para>
<programlisting>
a:  EXP OFFSET(<emphasis>x</emphasis>, <emphasis>y</emphasis>)
<emphasis>p</emphasis>:   EXP POINTER(alloca_alignment)
-&gt;    EXP TOP
</programlisting>

        <para>Here <emphasis>p</emphasis> must evaluate to a pointer generated
          either by local_alloc or last_local . The effect is to free all of the
          space locally allocated after p. The usual implementation (with a
          downward growing stack) of this is that p becomes the "top of stack"
          pointer</para>

        <para>The use of a procedure with an untidy_return is just a
          generalisation of the idea of local_alloc and the space made available
          by its use can be freed in the same way as normal local allocations. Of
          course, given that it could be the result of the procedure it can be
          structured in an arbitrarily complicated way.</para>
      </sect2>
    </sect1>

    <sect1 id='heap-storage'>
      <title>Heap storage</title> 

      <para>At the moment, there are no explicit constructors of creating
        dynamic off-stack storage in TDF. Any off-stack storage requirements must
        be met by the API in which the system is embedded, using the standard
        procedural interface. For example, the ANSI C API allows the creation of
        heap space using standard library procedures like malloc.</para>
    </sect1>
  </chapter>

  <chapter id='control-flow-proc'>
    <title>Control Flow within procedures</title> 

    <sect1 id='unconditional-flow'>
      <title>Unconditional flow</title> 

      <sect2 id='sequence'>
        <title>sequence</title> 

        <para>To perform a sequential set of operations in TDF, one uses the
          constructor sequence:</para>
<programlisting>
<emphasis>statements</emphasis>: LIST(EXP)
<emphasis>result</emphasis>: EXP <emphasis>x</emphasis>
-&gt; EXP <emphasis>x</emphasis>
</programlisting>

        <para>Each of the <emphasis>statements</emphasis> are evaluated in
          order, throwing away their results. Then, <emphasis>result</emphasis>
          is evaluated and its result is the result of the sequence.</para>

        <para>A translator is free to rearrange the order of evaluation if
          there is no observable difference other than in time or space. This
          applies anywhere I say "something is evaluated and then ...". We find
          this kind of statement in definitions of local variables in
          <xref linkend='defining-using-locals'> , and in the controlling
          parts of the conditional constructions below.</para>

        <para>For a more precise discussion of allowable reorderings see
          (S7.14) .</para>
      </sect2>
    </sect1>

    <sect1 id='conditional-flow'>
      <title>Conditional flow</title> 

      <sect2 id='labelled-make-label'>
        <title>labelled, make_label</title> 

        <para>All simple changes of flow of control within a TDF procedure are
          done by jumps or branches to LABELs, mirroring what actually happens in
          most computers. There are three constructors which introduce LABELs;
          the most general is labelled which allows arbitrary jumping between its
          component EXPs:</para>
<programlisting>
<emphasis>placelabs_intro</emphasis>:    LIST(LABEL)
<emphasis>starter</emphasis>:    EXP <emphasis>x</emphasis>
<emphasis>places</emphasis>: LIST(EXP)
-&gt; EXP <emphasis>w</emphasis>
</programlisting>

        <para>Each of the EXPs in <emphasis>place</emphasis>s is labelled by
          the corresponding LABEL in <emphasis>placelabs_intro</emphasis>; these
          LABELs are constructed by make_label applied to a TDFINT uniquely drawn
          from the LABEL name-space introduced by the enclosing PROPS. The
          evaluation starts by evaluating <emphasis>starter</emphasis>; if this
          runs to completion the result of the labelled is the result of
          <emphasis>starter.</emphasis> If there is some jump to a LABEL in
          <emphasis>placelabs_intro</emphasis> then control passes to the
          corresponding EXP in <emphasis>place</emphasis>s and so on. If any of
          these EXPS runs to completion then its result is the result of the
          labelled; hence the SHAPE of the result, w, is the LUB of the SHAPEs of
          the component EXPs.</para>

        <para>Note that control does not automatically pass from one EXP to the
          next; if this is required the appropriate EXP must end with an explicit
          goto.</para>
      </sect2>

      <sect2 id='goto-make-local-lv'>
        <title>goto, make_local_lv, goto_local_lv, long_jump,
        return_to_label</title> 

        <para>The unconditional goto is the simplest method of jumping. In
          common with all the methods of jumping using LABELs, its LABEL
          parameter must have been introduced in an enclosing construction, like
          labelled, which scopes it.</para>

        <para>One can also pick up a label value of SHAPE POINTER {code}
          (usually implemented as a program address) using make_local_lv for
          later use by an "indirect jump" such as goto_local_lv . Here the same
          prohibition holds - the construction which introduced the LABEL must
          still be active.</para>

        <para>The construction goto_local_lv only permits one to jump within
          the current procedure; if one wished to do a jump out of a procedure
          into a calling one, one uses long_jump which requires a pointer to the
          destination frame (produced by current_env in the destination
          procedure) as well as the label value. If a long_jump is made to a
          label, only those local TAGs which have been defined with a visible
          ACCESS are guaranteed to have preserved their values; the translator
          could allocate the other TAGs in scope as registers whose values are
          not necessarily preserved.</para>

        <para>A slightly "shorter" long jump is given by return_to_label. Here
          the destination of the jump must a label value in the calling
          procedure. Usually this value would be passed as parameter of the call
          to provide an alternative exit to the procedure.</para>
      </sect2>

      <sect2 id='integer-test-ntest'>
        <title>integer_test, NTEST</title> 

        <para>Conditional branching is provided by the various _test
          constructors, one for each primitive SHAPE except BITFIELD. I shall use
          integer_test as the paradigm for them all:</para>
<programlisting>
<emphasis>nt</emphasis>: NTEST
<emphasis>dest</emphasis>:   LABEL
<emphasis>arg1</emphasis>:   EXP INTEGER(<emphasis>v</emphasis>)
<emphasis>arg2</emphasis>:   EXP INTEGER(<emphasis>v</emphasis>)
-&gt;    EXP TOP
</programlisting>

        <para>The NTEST <emphasis>nt</emphasis> chooses a dyadic test (e.g. =,
          &gt;=, &lt;, etc.) that is to be applied to the results of evaluating
          <emphasis>arg1</emphasis> and <emphasis>arg2</emphasis>. If
          <emphasis>arg1 nt arg2</emphasis> then the result is TOP; otherwise
          control passes to the LABEL <emphasis>dest</emphasis>. In other words,
          integer_test acts like an assertion where if the assertion is false,
          control passes to the LABEL instead of continuing in the normal
          fashion.</para>

        <para>Some of the constructors for NTESTs are disallowed for some
          _tests (e.g. proc_test ) while others are redundant for some _tests;
          for example, not_greater_than is the same as less_than_or_equal for all
          except possibly floating_test. where the use of NaNs (in the IEEE
          sense) as operands may give different results.</para>
      </sect2>

      <sect2 id='case'>
        <title>case</title> 

        <para>There are only two other ways of changing flow of control using
          LABELs. One arises in ERROR_TREATMENTs which will be dealt with in the
          arithmetic operations. The other is case:</para>
<programlisting>
<emphasis>exhaustive</emphasis>: BOOL
<emphasis>control</emphasis>:    EXP INTEGER(<emphasis>v</emphasis>)
<emphasis>branches</emphasis>:   LIST(CASELIM)
-&gt;    EXP (<emphasis>exhaustive</emphasis> ? BOTTOM : TOP)
</programlisting>

        <para>Each CASELIM is constructed using make_caselim:</para>
<programlisting>
branch: LABEL
lower:  SIGNED_NAT
upper:  SIGNED_NAT
-&gt; CASELIM
</programlisting>

        <para>In the case construction, the <emphasis>control</emphasis> EXP is
          evaluated and tested to see whether its value lies inclusively between
          some <emphasis>lower</emphasis> and <emphasis>upper</emphasis> in the
          list of CASELIMs. If so, control passes to the corresponding
          <emphasis>branch</emphasis>. The order in which these tests are
          performed is undefined, so it is probably best if the tests are
          exclusive. The exhaustive flag being true asserts that one of the
          branches will be taken and so the SHAPE of the result is BOTTOM.
          Otherwise, if none of the branches are taken, its SHAPE is TOP and
          execution carries on normally.</para>
      </sect2>

      <sect2 id='conditional-repeat'>
        <title>conditional, repeat</title> 

        <para>Besides labelled, two other constructors, conditional and repeat,
          introduce LABELs which can be used with the various jump instructions.
          Both can be expressed as labelled, but have extra constraints which
          make assertions about the use of the LABELs introduced and could
          usually be translated more efficiently; hence producers are advised to
          use them where possible. A conditional expression or statement would
          usually be done using conditional:</para>
<programlisting>
<emphasis>alt_label_intro</emphasis>:    LABEL
<emphasis>first</emphasis>:  EXP <emphasis>x</emphasis>
<emphasis>alt</emphasis>:    EXP <emphasis>y</emphasis>
-&gt;    EXP(LUB(<emphasis>x, y</emphasis>))
</programlisting>

        <para>Here <emphasis>first</emphasis> is evaluated; if it terminates
          normally, its result is the result of the conditional. If a jump to
          <emphasis>alt_label_intro</emphasis> occurs then
          <emphasis>alt</emphasis> is evaluated and its result is the result of
          the conditional. Clearly, this, so far, is just the same as
          labelled((<emphasis>alt_label_intro</emphasis> ),
          <emphasis>first</emphasis>, (<emphasis>alt</emphasis>)). However,
          conditional imposes the constraint that <emphasis>alt</emphasis> cannot
          use <emphasis>alt_label_intro</emphasis>. All jumps to
          <emphasis>alt_label_intro</emphasis> are "forward jumps" - a useful
          property to know in a translator.</para>

        <para>Obviously, this kind of conditional is rather different to those
          found in traditional high-level languages which usually have three
          components, a boolean expression, a then-part and an else-part. Here,
          the <emphasis>first</emphasis> component includes both the boolean
          expression and the then-part; usually we find that it is a sequence of
          the tests (branching to <emphasis>alt_label_intro</emphasis> ) forming
          the boolean expression followed by the else-part. This formulation
          means that HLL constructions like "andif" and "orelse" do not require
          special constructions in TDF.</para>

        <para>A simple loop can be expressed using repeat:</para>
<programlisting>
<emphasis>repeat_label_intro</emphasis>: LABEL
<emphasis>start</emphasis>:  EXP TOP
<emphasis>body</emphasis>:   EXP <emphasis>y</emphasis>
-&gt; EXP <emphasis>y</emphasis>
</programlisting>

        <para>The EXP <emphasis>start</emphasis> is evaluated, followed by
          <emphasis>body</emphasis> which is labelled by
          <emphasis>repeat_label_intro</emphasis>. If a jump to
          <emphasis>repeat_label_intro</emphasis> occurs in
          <emphasis>body</emphasis>, then <emphasis>body</emphasis> is
          re-evaluated. If <emphasis>body</emphasis> terminates normally then its
          result is the result of the repeat. This is just the same as:</para>
<programlisting>
labelled((<emphasis>repeat_label_intro</emphasis>), sequence((<emphasis>start</emphasis>), goto(<emphasis>repeat_label_intro</emphasis> )), <emphasis>(body</emphasis>))
</programlisting>

        <para>except that no jumps to <emphasis>repeat_label_intro</emphasis>
          are allowed in <emphasis>start</emphasis> - a useful place to do
          initialisations for the loop.</para>

        <para>Just as with conditionals, the tests for the continuing or
          breaking the loop are included in <emphasis>body</emphasis> and require
          no special constructions.</para>
      </sect2>
    </sect1>

    <sect1 id='exceptional-flow'>
      <title>Exceptional flow</title> 

      <para>A further way of changing the flow of control in a TDF program is
        by means of exceptions. TDF exceptions currently arise from three sources
        - overflow in arithmetic operations with trap ERROR_TREATMENT(see
        <xref linkend='error-treatment'> ) , an attempt to access a
        value via a nil pointer using assign_with_mode, contents_with_mode or
        move_some(see <xref linkend='transfer-mode-oper'> ) or a stack
        overflow on procedure entry with PROCPROPS check_stack(see
        <xref linkend='procprops'> ) or a
        local_alloc_check.</para>

      <para>Each of these exceptions have an ERROR_CODE ascribed to them,
        namely overflow, nil_access and stack_overflow. Each ERROR_CODE can be
        made into a distinct NAT by means of the constructor error_val; these
        NATs could be used, for example, to discriminate the different kinds of
        errors using a case construction.</para>

      <para>When one of these exceptions is raised, the translator will arrange
        that a TOKEN, ~Throw, is called with the appropriate ERROR_CODE as its
        (sole) parameter. Given that every language has a different way of both
        characterising and handling exceptions, the exact expansion of ~Throw
        must be given by the producer for that language - usually it will involve
        doing a long_jump to some label specifying a signal handler and
        translating the ERROR_CODE into its language-specific
        representation.</para>

      <para>The expansion of ~Throw forms part of the language specific
        environment required for the translation of TDF derived from the
        language, just as the exact shape of FILE must be given for the
        translation of C.</para>
    </sect1>
  </chapter>

  <chapter id='values-variables-assign'>
    <title>Values, variables and assignments.</title> 

    <para>TAGs in TDF fulfil the role played by identifiers in most programming
      languages. One can apply obtain_tag to find the value bound to the TAG.
      This value is always a constant over the scope of a particular definition
      of the TAG. This may sound rather strange to those used to the concepts of
      left-hand and right-hand values in C, for example, but is quite easily
      explained as follows.</para>

    <para>If a TAG, id, is introduced by an identify, then the value bound is
      fixed by its <emphasis>definition</emphasis> argument. If, on the other
      hand, v was a TAG introduced by a variable definition, then the value bound
      to v is a pointer to fixed space in the procedure frame (i.e. the left-hand
      value in C).</para>

    <sect1 id='contents'>
      <title>contents</title> 

      <para>In order to get the contents of this space (the right-hand value in
        C), one must apply the contents operator to the pointer:</para>
<programlisting>
contents(shape(v), obtain_tag(v))
</programlisting>

      <para>In general, the contents constructor takes a SHAPE and an
        expression delivering pointer:</para>
<programlisting>
<emphasis>s</emphasis>:  SHAPE
<emphasis>arg1</emphasis>:   EXP POINTER(<emphasis>x</emphasis>)
-&gt;    EXP <emphasis>s</emphasis>
</programlisting>

      <para>It delivers the value of SHAPE <emphasis>s</emphasis>, pointed at
        by the evaluation of <emphasis>arg1</emphasis>. The alignment of
        <emphasis>s</emphasis> need not be identical to <emphasis>x</emphasis>.
        It only needs to be included in it; this would allow one, for example, to
        pick out the first field of a structure from a pointer to it.</para>
    </sect1>

    <sect1 id='assign'>
      <title>assign</title> 

      <para>A simple assignment in TDF is done using assign:</para>
<programlisting>
<emphasis>arg1</emphasis>:   EXP POINTER(<emphasis>x</emphasis>)
<emphasis>arg2</emphasis>:   EXP <emphasis>y</emphasis>
-&gt; EXP TOP
</programlisting>

      <para>The EXPs <emphasis>arg1</emphasis> and <emphasis>arg2</emphasis>
        are evaluated (no ordering implied) and the value of SHAPE
        <emphasis>y</emphasis> given by <emphasis>arg2</emphasis> is put into the
        space pointed at by <emphasis>arg1</emphasis>. Once again, the alignment
        of <emphasis>y</emphasis> need only be included in
        <emphasis>x</emphasis>, allowing the assignment to the first field of a
        structure using a pointer to the structure. An assignment has no obvious
        result so its SHAPE is TOP.</para>

      <para>Some languages give results to assignments. For example, C defines
        the result of an assignment to be its right-hand expression, so that if
        the result of (v = exp) was required, it would probably be expressed
        as:</para>
<programlisting>
identify(empty, newtag, exp,
sequence((assign(obtain_tag(v), obtain_tag(newtag))), obtain_tag(newtag)))
</programlisting>

      <para>From the definition of assign, the destination argument,
        <emphasis>arg1</emphasis>, must have a POINTER shape. This means that
        given the TAG id above, assign(obtain_tag(id), lhs) is only legal if the
        <emphasis>definition</emphasis> of its identify had a POINTER SHAPE. A
        trivial example would be if id was defined:</para>
<programlisting>
identify(empty, id, obtain_tag(v), assign(obtain_tag(id), lhs))
</programlisting>

      <para>This identifies id with the variable v which has a POINTER SHAPE,
        and assigns lhs to this pointer. Given that id does not occur in lhs,
        this is identical to:</para>
<programlisting>
assign(obtain_tag(v), lhs).
</programlisting>

      <para>Equivalences like this are widely used for transforming TDF in
        translators and other tools (see <xref linkend='tdf-transformations'> ).</para>
    </sect1>

    <sect1 id='transfer-mode-oper'>
      <title>TRANSFER_MODE operations</title> 

      <para>The TRANSFER_MODE operations allow one to do assignment and
        contents operations with various qualifiers to control how the access is
        done in a more detailed manner than the standard contents and assign
        operations.</para>

      <para>For example, the value assigned in assign has some fixed SHAPE; its
        size is known at translate-time. Variable sized objects can be moved by
        move_some:</para>
<programlisting>
<emphasis>md</emphasis>:  TRANSFER_MODE
<emphasis>arg1</emphasis>:    EXP POINTER <emphasis>x</emphasis>
<emphasis>arg2</emphasis>:    EXP POINTER y
<emphasis>arg3</emphasis>:    EXP OFFSET(z, t)
-&gt;    EXP TOP
</programlisting>

      <para>The EXP <emphasis>arg1</emphasis> is the destination pointer, and
        <emphasis>arg2</emphasis> is a source pointer. The amount moved is given
        by the OFFSET <emphasis>arg3</emphasis>.</para>

      <para>The TRANSFER_MODE <emphasis>md</emphasis> parameter controls the
        way that the move will be performed. If overlap is present, then the
        translator will ensure that the move is equivalent to moving the source
        into new space and then copying it to the destination; it would probably
        do this by choosing a good direction in which to step through the value.
        The alternative, standard_transfer_mode, indicates that it does not
        matter.</para>

      <para>If the TRANSFER_MODE trap_on_nil is present and
        <emphasis>arg1</emphasis> is a nil pointer, a TDF exception with
        ERROR_CODE nil_access is raised.</para>

      <para>There are variants of both the contents and assign constructors.
        The signature of contents_with_mode is:</para>
<programlisting>
<emphasis>md</emphasis>:  TRANSFER_MODE
<emphasis>s</emphasis>:   SHAPE
<emphasis>arg1</emphasis>:    EXP POINTER(<emphasis>x</emphasis>)
-&gt; EXP s
</programlisting>

      <para>Here, the only significant TRANSFER_MODE constructors
        <emphasis>md</emphasis> are trap_on_nil and volatile. The latter is
        principally intended to implement the C volatile construction; it
        certainly means that the contents_with_mode operation will never be
        "optimised" away.</para>

      <para>Similar considerations apply to assign_with_mode; here the overlap
        TRANSFER_MODE is also possible with the same meaning as in
        move_some.</para>
    </sect1>

    <sect1 id='assining-extracting-bit'>
      <title>Assigning and extracting bitfields</title> 

      <para>Since pointers to bits are forbidden, two special operations are
        provided to extract and assign bitfields. These require the use of a
        pointer value and a bitfield offset from the pointer. The signature of
        bitfield_contents which extracts a bitfield in this manner is:</para>
<programlisting>
<emphasis>v</emphasis>:   BITFIELD_VARIETY
<emphasis>arg1</emphasis>:    EXP POINTER(<emphasis>x</emphasis>)
<emphasis>arg2</emphasis>:    EXP OFFSET(<emphasis>y,z</emphasis>)
-&gt; EXP bitfield(<emphasis>v</emphasis>)
</programlisting>

      <para>Here <emphasis>arg1</emphasis> is a pointer to an alignment
        <emphasis>x</emphasis> which includes <emphasis>v</emphasis>, the
        required bitfield alignment. In practice, <emphasis>x</emphasis> must
        include an INTEGER VARIETY whose representation can contain the entire
        bitfield. Thus on a standard architecture, if v is a 15 bit bitfield, x
        must include at least a 16 bit integer variety; a 27 bitfield would
        require a 32 bit integer variety and so on. Indeed the constraint is
        stronger than this since there must be an integer variety, accessible
        from arg1, which entirely contains the bitfield.</para>

      <para>This constraint means that producers cannot expect that arbitrary
        bitfield lengths can be accomodated without extra padding; clearly it
        also means that the maximum bitfield length possible is the maximum size
        of integer variety that can be implemented on the translator concerned
        (this is defined to be at least 32). On standard architectures, the
        producer can expect that an array of bitfields of lenth
        2<emphasis>n</emphasis> will be packed without padding; this, of course,
        includes arrays of booleans. For structures of several different
        bitfields, he can be sure of no extra padding bits if the total number of
        bits involved is less than or equal to 32; similarly if he can subdivide
        the bitfields so that each of the subdivisions (except the last) is
        exactly equal to 32 and the last is less than or equal to 32. This could
        be relaxed to 64 bits if the translator deals with 64 bit integer
        varieties, but would require that conditional TDF is produced to maintain
        portability to 32 bit platforms - and on these platforms the assurance of
        close packing would be lost.</para>

      <para>Since a producer is ignorant of the exact representational
        varieties used by a translator, the onus is on the translator writer to
        provide standard tokens which can be used by a producer to achieve both
        optimum packing of bitfields and minimum alignments for COMPOUNDs
        containing them(see <xref linkend='bitfield-offsets'> ).
        These tokens would allow one to construct an offset of the form OFFSET(x,
        b) (where b is some bitfield alignment and x is the `minimum' alignment
        which could contain it) in a manner analogous to the normal padding
        operations for offsets. This offset could then used both in the
        construction of a compound shape and in the extraction and assignment
        constructors.</para>

      <para>The assignment of bitfields follows the same pattern with the same
        constraints using bitfield_assign:</para>
<programlisting>
<emphasis>arg1</emphasis>:    EXP POINTER(<emphasis>x</emphasis>)
<emphasis>arg2</emphasis>:    EXP OFFSET(<emphasis>y,z</emphasis>)
<emphasis>arg3</emphasis>:    EXP BITFIELD_VARIETY(<emphasis>v</emphasis>)
-&gt; EXP TOP
</programlisting>
    </sect1>
  </chapter>

  <chapter id='operations'>
    <title>Operations</title> 

    <para>Most of the arithmetic operations of TDF have familiar analogues in
      standard languages and processors. They differ principally in how error
      conditions (e.g. numeric overflow) are handled. There is a wide diversity
      in error handling in both languages and processors, so TDF tries to reduce
      it to the simplest primitive level compatible with their desired operation
      in languages and their implementation on processors. Before delving into
      the details of error handling, it is worthwhile revisiting the SHAPEs and
      ranges in arithmetic VARIETYs.</para>

    <sect1 id='variety-overflow'>
      <title>VARIETY and overflow</title> 

      <para>An INTEGER VARIETY, for example, is defined by some range of signed
        natural numbers. A translator will fit this range into some possibly
        larger range which is convenient for the processor in question. For
        example, the integers with variety(1,10) would probably be represented as
        unsigned characters with range (0..255), a convenient representation for
        both storage and arithmetic.</para>

      <para>The question then arises of what is meant by overflow in an
        operation which is meant to deliver an integer of this VARIETY - is it
        when the integer result is outside the range (1..10) or outside the range
        (0..255)? For purely pragmatic reasons, TDF chooses the latter - the
        result is overflowed when it is outside its representational range
        (0..255). If the program insists that it must be within (1..10), then it
        can always test for it. If the program uses the error handling mechanism
        and the result is outside (1..10) but still within the representational
        limits, then, in order for the program to be portable, then the error
        handling actions must in some sense be "continuous" with the normal
        action. This would not be the case if, for example, the value was used to
        index an array with bounds (1..10), but will usually be the case where
        the value is used in further arithmetic operations which have similar
        error handling. The arithmetic will continue to give the mathematically
        correct result provided the representational bounds are not
        exceeded.</para>

      <para>The limits in a VARIETY are there to provide a guide to its
        representation, and not to give hard limits to its possible values. This
        choice is consistent with the general TDF philosophy of how exceptions
        are to be treated. If, for example, one wishes to do array-bound
        checking, then it must be done by explicit tests on the indices and
        jumping to some exception action if they fail. Similarly, explicit tests
        can be made on an integer value, provided its representational limits are
        not exceeded. It is unlikely that a translator could produce any more
        efficient code, in general, if the tests were implicit. The
        representational limits can be exceeded in arithmetic operations, so
        facilities are provided to either to ignore it , to allow one to jump to
        a label , or to obey a TDF exception handler if it happens.</para>

      <sect2 id='error-treatment'>
        <title>ERROR_TREATMENT</title> 

        <para>Taking integer addition as an example, plus has signature:</para>
<programlisting>
<emphasis>ov_err</emphasis>:     ERROR_TREATMENT
<emphasis>arg1</emphasis>:   EXP INTEGER(<emphasis>v</emphasis>)
<emphasis>arg2</emphasis>:   EXP INTEGER(<emphasis>v</emphasis>)
-&gt;    EXP INTEGER(<emphasis>v</emphasis>)
</programlisting>

        <para>The result of the addition has the same integer VARIETY as its
          parameters. If the representational bounds of <emphasis>v</emphasis>
          are exceeded, then the action taken depends on the ERROR_TREATMENT
          <emphasis>ov_err</emphasis>.</para>

        <para>The ERROR_TREATMENT , impossible, is an assertion by the producer
          that overflow will not occur; on its head be it if it does.</para>

        <para>The ERROR_TREATMENTS continue and wrap give "fixup" values for
          the result. For continue the fixup value is undefined. For wrap, the
          the answer will be modulo 2 to the power of the number of bits in the
          representational variety.Thus, integer arithmetic with byte
          representational variety is done modulo 256. This just corresponds to
          what happens in most processors and, incidentally, the definition of
          C.</para>

        <para>The ERROR_TREATMENT that one would use if one wished to jump to a
          label is error_jump:</para>
<programlisting>
<emphasis>lab</emphasis>:    LABEL
-&gt;    ERROR_TREATMENT
</programlisting>

        <para>A branch to <emphasis>lab</emphasis> will occur if the result
          overflows.</para>

        <para>The ERROR_TREATMENT, trap(overflow) will raise a TDF
          exception(see <xref linkend='exceptional-flow'> )with
          ERROR_CODE overflow if overflow occurs.</para>
      </sect2>
    </sect1>

    <sect1 id='division-remainder'>
      <title>Division and remainder</title> 

      <para>The various constructors in involving integer division (e.g. div1,
        rem1) have two ERROR_TREATMENT parameters, one for overflow and one for
        divide-by-zero e.g. div1 is:</para>
<programlisting>
<emphasis>div_by_zero_error</emphasis>:   ERROR_TREATMENT
<emphasis>ov_err</emphasis>:  ERROR_TREATMENT
<emphasis>arg1</emphasis>:    EXP INTEGER(<emphasis>v</emphasis>)
<emphasis>arg2</emphasis>:    EXP INTEGER(<emphasis>v</emphasis>)
-&gt; EXP INTEGER(<emphasis>v</emphasis>)
</programlisting>

      <para>. There are two different kinds of division operators (with
        corresponding remainder operators) defined. The operators div2 and rem2
        are those generally implemented directly by processor instructions giving
        the sign of the remainder the same as the sign of the quotient. The other
        pair, div1 and rem1, is less commonly implemented in hardware, but have
        rather more consistent mathematical properties; here the sign of
        remainder is the same as the sign of divisor. Thus, div1(x, 2) is the
        same as shift_right(x, 1) which is only true for div2 if x is positive.
        The two pairs of operations give the same results if both operands have
        the same sign. The constructors div0 and rem0 allow the translator to
        choose whichever of the two forms of division is convenient - the
        producer is saying that he does not care which is used, as long as they
        are pairwise consistent. The precise definition of the divide operations
        is given in (S7.4).</para>
    </sect1>

    <sect1 id='change-variety'>
      <title>change_variety</title> 

      <para>Conversions between the various INTEGER varieties are provided for
        by change_variety:</para>
<programlisting>
<emphasis>ov_err</emphasis>:  ERROR_TREATMENT
<emphasis>r</emphasis>:  VARIETY
<emphasis>arg1</emphasis>:   EXP INTEGER(<emphasis>v</emphasis>)
-&gt;    EXP INTEGER(<emphasis>r</emphasis>)
</programlisting>

      <para>If the value <emphasis>arg1</emphasis> is outside the limits of the
        representational variety of <emphasis>r</emphasis>, then the
        ERROR_TREATMENT <emphasis>ov_err</emphasis> will be invoked.</para>
    </sect1>

    <sect1 id='and-or-not-xor'>
      <title>and, or, not, xor</title> 

      <para>The standard logical operations, and, not, or and xor are provided
        for all integer varieties. Since integer varieties are defined to be
        represented in twos-complement the result of these operations are well
        defined.</para>
    </sect1>

    <sect1 id='floating-point-oper'>
      <title>Floating-point operations, ROUNDING_MODE</title> 

      <para>All of the floating-point (including complex) operations include
        ERROR-TREATMENTs. If the result of a floating-point operation cannot be
        represented in the desired FLOATING_VARIETY, the error treatment is
        invoked. If the ERROR_TREATMENT is wrap or impossible, the result is
        undefined; otherwise the jump operates in the same way as for integer
        operations. Both floating_plus and floating_mult are defined as n-ary
        operations. In general, floating addition and multiplication are not
        associative, but a producer may not care about the order in which they
        are to be performed. Making them appear as though they were associative
        allows the translator to choose an order which is convenient to the
        hardware.</para>

      <para>Conversions from integer to floating are done by float_int and from
        floating to integers by round_with_mode . This latter constructor has a
        parameter of SORT ROUNDING_MODE which effectively gives the IEEE rounding
        mode to be applied to the float to produce its integer result.</para>

      <para>One can extract the real and imaginary parts of a complex FLOATING
        using real_part and imaginary_part. A complex FLOATING can be constructed
        using make_complex. Normal complex arithmetic applies to all the other
        FLOATING constructors except for those explicitly excluded (eg
        floating_abs, floating_max etc.)</para>
    </sect1>

    <sect1 id='change-bitfield-to-int'>
      <title>change_bitfield_to_int, change_int_to_bitfield</title> 

      <para>There are two bit-field operation, change_bitfield_to_int and
        change_int_to_bitfield to transform between bit-fields and integers. If
        the varieties do not fit the result is undefined; the producer can always
        get it right.</para>
    </sect1>

    <sect1 id='make-compound-make-nof'>
      <title>make_compound, make_nof, n_copies</title> 

      <para>There is one operation to make values of COMPOUND SHAPE,
        make_compound:</para>
<programlisting>
<emphasis>arg1</emphasis>:   EXP OFFSET(<emphasis>base, y</emphasis>)
<emphasis>arg2</emphasis>:   LIST(EXP)
-&gt; EXP COMPOUND(<emphasis>sz</emphasis>)
</programlisting>

      <para>The OFFSET <emphasis>arg1</emphasis> is evaluated as a
        translate-time constant to give <emphasis>sz</emphasis>, the size of the
        compound object. The EXPs of arg2 are alternately OFFSETs (also
        translate-time constants) and values which will be placed at those
        offsets. This constructor is used to construct values given by structure
        displays; in C, these only occur with constant
        <emphasis>val[i]</emphasis> in global definitions. It is also used to
        provide union injectors; here <emphasis>sz</emphasis> would be the size
        of the union and the list would probably two elements with the first
        being an offset_zero.</para>

      <para>Constant sized array values may be constructed using make_nof,
        make_nof_int (see <xref linkend='make-compound-make-nof'> ), and
        n_copies. Again,
        they only occur in C as constants in global definitions.</para>
    </sect1>
  </chapter>

  <chapter id='constants'>
    <title>Constants</title> 

    <para>The representation of constants clearly has peculiar difficulties in
      any architecture neutral format. Leaving aside any problems of how numbers
      are to be represented, we also have the situation where a "constant" can
      have different values on different platforms. An obvious example would be
      the size of a structure which, although it is a constant of any particular
      run of a program, may have different values on different machines. Further,
      this constant is in general the result of some computation involving the
      sizes of its components which are not known until the platform is chosen.
      In TDF, sizes are always derived from some EXP OFFSET constructed using the
      various OFFSET arithmetic operations on primitives like shape_offset and
      offset_zero. Most such EXP OFFSETs produced are in fact constants of the
      platform; they include field displacements of structure as well as their
      sizes. TDF assumes that, if these EXPs can be evaluated at translate-time
      (i.e. when the sizes and alignments of primitive objects are known), then
      they must be evaluated there. An example of why this is so arises in
      make_compound; the SHAPE of its result EXP depends on its
      <emphasis>arg1</emphasis> EXP OFFSET parameter and all SHAPEs must be
      translate-time values.</para>

    <para>
        An initialisation of a TAGDEF is a constant in this sense 
  
        <footnote>
          <para>However see also initial_value in section</para>
      </footnote>
      ; this allows one to ignore any difficulties about their order of
      evaluation in the UNIT and consequently the order of evaluation of UNITs.
      Once again all the EXPs which are initialisations must be evaluated
      before the program is run; this obviously includes any make_proc or
      make_general_proc. . The limitation on an initialisation EXP to ensure
      this is basically that one cannot take the contents of a variable
      declared outside the EXP after all tokens and conditional evaluation is
      taken into account. In other words, each TDF translator effectively has
      an TDF interpreter which can do evaluation of expressions (including
      conditionals etc.) involving only constants such as numbers, sizes and
      addresses of globals. This corresponds very roughly to the kind of
      initialisations of globals that are permissible in C; for a more precise
      definition, see (S7.3).
    </para>

    <sect1 id='cond-constructors'>
      <title>_cond constructors</title> 

      <para>Another place where translate-time evaluation of constants is
        mandated is in the various _cond constructors which give a kind of
        "conditional compilation" facility; every SORT which has a SORTNAME,
        other that TAG, TOKEN and LABEL, has one of these constructors e.g.
        exp_cond:</para>
<programlisting>
<emphasis>control</emphasis>:    EXP INTEGER(<emphasis>v</emphasis>)
<emphasis>e1</emphasis>:     BITSTREAM EXP <emphasis>x</emphasis>
<emphasis>e2</emphasis>:     BITSTREAM EXP <emphasis>y</emphasis>
-&gt;    EXP <emphasis>x</emphasis> or EXP <emphasis>y</emphasis>
</programlisting>

      <para>The constant, <emphasis>control</emphasis>, is evaluated at
        translate time. If it is not zero the entire construction is replaced by
        the EXP in <emphasis>e1</emphasis>; otherwise it is replaced by the one
        in <emphasis>e2</emphasis>. In either case, the other BITSTREAM is
        totally ignored; it even does not need to be sensible TDF. This kind of
        construction is use extensively in C pre-processing directives
        e.g.:</para>
<programlisting>
#if (sizeof(int) == sizeof(long)) ...

</programlisting>
    </sect1>

    <sect1 id='primitive-const-const'>
      <title>Primitive constant constructors</title> 

      <para>Integer constants are constructed using make_int:</para>
<programlisting>
<emphasis>v</emphasis>:  VARIETY
<emphasis>value</emphasis>:  SIGNED_NAT
-&gt;    EXP INTEGER(<emphasis>v</emphasis>)
</programlisting>

      <para>The SIGNED_NAT <emphasis>value</emphasis> is an encoding of the
        binary value required for the integer; this value must lie within the
        limits given by <emphasis>v</emphasis>. I have been rather slip-shod in
        writing down examples of integer constants earlier in this document;
        where I have written 1 as an integer EXP, for example, I should have
        written make_int(v, 1) where v is some appropriate VARIETY.</para>

      <para>Constants for both floats and strings use STRINGs. A constant
        string is just an particular example of make_nof_int:</para>
<programlisting>
<emphasis>v</emphasis>:  VARIETY
<emphasis>str</emphasis>:    STRING(<emphasis>k, n</emphasis>)
-&gt;    EXP NOF(<emphasis>n</emphasis>, INTEGER(<emphasis>v</emphasis>))
</programlisting>

      <para>Each unsigned integer in <emphasis>str</emphasis> must lie in the
        variety <emphasis>v</emphasis> and the result is the constant array whose
        elements are the integers considered to be of VARIETY
        <emphasis>v</emphasis>. An ASCI-C constant string might have
        <emphasis>v</emphasis> = variety(-128,127) and <emphasis>k</emphasis> =
        7; however, make_nof_int can be used to make strings of any INTEGER
        VARIETY; a the elements of a Unicode string would be integers of size 16
        bits.</para>

      <para>A floating constant uses a STRING which contains the ASCI
        characters of a expansion of the number to some base in
        make_floating:</para>
<programlisting>
<emphasis>f</emphasis>:  FLOATING_VARIETY
<emphasis>rm</emphasis>:     ROUNDING_MODE
<emphasis>sign</emphasis>:   BOOL
<emphasis>mantissa</emphasis>:   STRING(<emphasis>k, n</emphasis>)
<emphasis>base</emphasis>:   NAT
<emphasis>exponent</emphasis>:   SIGNED_NAT
-&gt;    EXP FLOATING(<emphasis>f</emphasis>)
</programlisting>

      <para>For a normal floating point number, each integer in
        <emphasis>mantissa</emphasis> is either the ASCI `.'-symbol or the ASCI
        representation of a digit of the representation in the given
        <emphasis>base</emphasis>; i.e. if c is the ASCI symbol, the digit value
        is c-'0'. The resulting floating point number has SHAPE FLOATING(f) and
        value <emphasis>mantissa</emphasis> * <emphasis>base</emphasis>
        <emphasis>exponent</emphasis> rounded according to
        <emphasis>rm</emphasis>. Usually the base will be 10 (sometimes 2) and
        the rounding mode to_nearest. Any floating-point evaluation of
        expressions done at translate-time will be done to an accuracy greater
        that implied by the FLOATING_VARIETY involved, so that floating constants
        will be as accurate as the platform permits.</para>

      <para>The make_floating construct does not apply apply to a complex
        FLOATING_VARIETY <emphasis>f</emphasis>; to construct a complex constant
        use make_complex with two make_floating arguments.</para>

      <para>Constants are also provided to give unique null values for
        pointers, label values and procs i.e.: make_null_ptr, make_null_local_lv
        and make_null_proc. Any significant use of these values (e.g. taking the
        contents of a null pointer) is undefined, but they can be assigned and
        used in tests in the normal way.</para>
    </sect1>
  </chapter>

  <chapter id='tokens-apis'>
    <title>Tokens and APIs</title> 

    <para>All of the examples of the use of TOKENs so far given have really
      been as abbreviations for commonly used constructs, e.g. the EXP OFFSETS
      for fields of structures. However, the real justification for TOKENs are
      their use as abstractions for things defined in libraries or application
      program interfaces (APIs).</para>

    <sect1 id='application-prog-inter'>
      <title>Application programming interfaces</title> 

      <para>APIs usually do not give complete language definitions of the
        operations and values that they contain; generally, they are defined
        informally in English giving relationships between the entities within
        them. An API designer should allow implementors the opportunity of
        choosing actual definitions which fit their hardware and the possibility
        of changing them as better algorithms or representations become
        available.</para>

      <para>The most commonly quoted example is the representation of the type
        FILE and its related operations in C. The ANSI C definition gives no
        common representation for FILE; its implementation is defined to be
        platform-dependent. A TDF producer can assume nothing about FILE; not
        even that it is a structure. The only things that can alter or create
        FILEs are also entities in the Ansi-C API and they will always refer to
        FILEs via a C pointer. Thus TDF abstracts FILE as a SHAPE TOKEN with no
        parameters, make_tok(T_FILE) say. Any program that uses FILE would have
        to include a TOKDEC introducing T_FILE:</para>
<programlisting>
make_tokdec(T_FILE, empty, shape())
</programlisting>

      <para>and anywhere that it wished to refer to the SHAPE of FILE it would
        do:</para>
<programlisting>
shape_apply_token(make_tok(T_FILE), ())
</programlisting>

      <para>Before this program is translated on a given platform, the actual
        SHAPE of FILE must be supplied. This would be done by linking a TDF
        CAPSULE which supplies the TOKDEF for the SHAPE of FILE which is
        particular to the target platform.</para>

      <para>Many of the C operations which use FILEs are explicitly allowed to
        be expanded as either procedure calls or as macros. For example,
        putc(c,f) may be implemented either as a procedure call or as the
        expansion of macro which uses the fields of f directly. Thus, it is quite
        natural for putc(c, f) to be represented in TDF as an EXP TOKEN with two
        EXP parameters which allows it to be expanded in either way. Of course,
        this would be quite distinct from the use of putc as a value (as a proc
        parameter of a procedure for example) which would require some other
        representation. One such representation that comes to mind might be to
        simply to make a TAGDEC for the putc value, supplying its TAGDEF in the
        Ansi API CAPSULE for the platform. This might prove to be rather
        short-sighted, since it denies us the possibility that the putc value
        itself might be expanded from other values and hence it would be better
        as another parameterless TOKEN. I have not come across an actual API
        expansion for the putc value as other than a simple TAG; however the
        FILE* value stdin is sometimes expressed as:</para>
<programlisting>
#define stdin &amp;_iob[0]
</programlisting>

      <para>which illustrates the point. It is better to have all of the
        interface of an API expressed as TOKENs to give both generality and
        flexibility across different platforms.</para>
    </sect1>

    <sect1 id='linking-to-apis'>
      <title>Linking to APIs</title> 

      <para>In general, each API requires platform-dependent definitions to be
        supplied by a combination of TDF linking and system linking for that
        platform. This is illustrated in the following diagram giving the various
        phases involved in producing a runnable program.</para>

      <figure id="compile-phase">
        <title>Compile Phase</title> 

        <mediaobject>
          <imageobject><imagedata fileref="guide3" scale="100" format=
          "PNG"></imageobject>
        </mediaobject>
      </figure>

      <para>There will be CAPSULEs for each API on each platform giving the
        expansions for the TOKENs involved, usually as uses of identifiers which
        will be supplied by system linking from some libraries. These CAPSULEs
        would be derived from the header files on the platform for the API in
        question, usually using some automatic tools. For example, there will be
        a TDF CAPSULE (derived from &lt;stdio.h&gt;) which defines the TOKEN
        T_FILE as the SHAPE for FILE, together with definitions for the TOKENs
        for putc, stdin, etc., in terms of identifiers which will be found in the
        library libc.a.</para>

      <sect2 id='target-ind-head'>
        <title>Target independent headers, unique_extern</title> 

        <para>Any producer which uses an API will use system independent
          information to give the common interface TOKENs for this API. In the C
          producer, this is provided by header files using pragmas, which tell
          the producer which TOKENs to use for the particular constructs of the
          API . In any target-independent CAPSULE which uses the API, these
          TOKENs would be introduced as TOKDECs and made globally accessible by
          using make_linkextern. For a world-wide standard API, the EXTERNAL
          "name" for a TOKEN used by make_linkextern should be provided by an
          application of unique_extern on a UNIQUE drawn from a central
          repository of names for entities in standard APIs; this repository
          would form a kind of super-standard for naming conventions in all
          possible APIs. The mechanism for controlling this super-standard has
          yet to be set up, so at the moment all EXTERN names are created by
          string_extern.</para>

        <para>An interesting example in the use of TOKENs comes in abstracting
          field names. Often, an API will say something like "the type Widget is
          a structure with fields alpha, beta ..." without specifying the order
          of the fields or whether the list of fields is complete. The field
          selection operations for Widget should then be expressed using EXP
          OFFSET TOKENs; each field would have its own TOKEN giving its offset
          which will be filled in when the target is known. This gives
          implementors on a particular platform the opportunity to reorder fields
          or add to them as they like; it also allows for extension of the
          standard in the same way.</para>

        <para>The most common SORTs of TOKENs used for APIs are SHAPEs to
          represent types, and EXPs to represent values, including procedures and
          constants. NATs and VARIETYs are also sometimes used where the API does
          not specify the types of integers involved. The other SORTs are rarely
          used in APIs; indeed it is difficult to imagine
          <emphasis>any</emphasis> realistic use of TOKENs of SORT BOOL. However,
          the criterion for choosing which SORTs are available for TOKENisation
          is not their immediate utility, but that the structural integrity and
          simplicity of TDF is maintained. It is fairly obvious that having BOOL
          TOKENs will cause no problems, so we may as well allow them.</para>
      </sect2>
    </sect1>

    <sect1 id='lang-prog-inter'>
      <title>Language programming interfaces</title> 

      <para>
          So far, I have been speaking as though a TOKENised API could only be
          some library interface, built on top of some language, like xpg3,
          posix, X etc. on top of C. However, it is possible to consider the
          constructions of the language itself as ideal candidates for
          TOKENisation. For example, the C for-statement could be expressed as
          TOKEN with four parameters. This TOKEN could be expanded in TDF in
          several different ways, all giving the correct semantics of a
          for-statement. A translator (or other tools) could choose the expansion
          it wants depending on context and the properties of the parameters. The
          C producer could give a default expansion which a lazy translator
          writer could use, but others might use expansions which might be more
          advantageous. This idea could be extended to virtually all the
          constructions of the language, giving what is in effect a C-language
          API; perhaps this might be called more properly a language programming
          interface (LPI). Thus, we would have TOKENs for C for-statements, C
          conditionals, C procedure calls, C procedure definitions etc. 
  
          <footnote>
            <para>Exercise for the reader: what are the SORTs of these
            parameters?</para>

          <para>The current C producer does this for some of the constructs,
            but not in any systematic manner; perhaps it will change.</para>
        </footnote>
      </para>

      <para>The notion of a producer for any language working to an LPI
        specific to the constructs of the language is very attractive. It could
        use different TOKENs to reflect the subtle differences between uses of
        similar constructs in different languages which might be difficult or
        impossible to detect from their expansions, but which could allow better
        optimisations in the object code. For example, Fortran procedures are
        slightly different from C procedures in that they do not allow aliasing
        between parameters and globals. While application of the standard TDF
        procedure calls would be semantically correct, knowledge of that the
        non-aliasing rule applies would allow some procedures to be translated to
        more efficient code. A translator without knowledge of the semantics
        implicit in the TOKENs involved would still produce correct code, but one
        which knew about them could take advantage of that knowledge.</para>

      <para>I also think that LPIs would be a very useful tool for crystalising
        ideas on how languages should be translated, allowing one to experiment
        with expansions not thought of by the producer writer. This decoupling is
        also an escape clause allowing the producer writer to defer the
        implementation of a construct completely to translate-time or link-time,
        as is done at the moment in C for off-stack allocation. As such it also
        serves as a useful test-bed for TOKEN constructions which may in future
        become new constructors of core TDF.</para>
    </sect1>
  </chapter>

  <chapter id='tdf-transformations'>
    <title>TDF transformations</title> 

    <para>TDF to TDF transformations form the basis of most of the tools of
      TDF, including translators. TDF has a rich set of easily performed
      transformations; this is mainly due to its algebraic nature, the liberality
      of its sequencing rules, and the ease with which one can introduce new
      names over limited scopes. For example, a translator is always free to
      transform:</para>
<programlisting>
assign(e1, e2)
</programlisting>

    <para>to:</para>
<programlisting>
identify(empty, new_tag, e1, assign(obtain_tag(new_tag), e2))
</programlisting>

    <para>i.e. identify the evaluation of the left-hand side of the assignment
      with a new TAG and use that TAG as the left-hand operand of a new
      assignment in the body of the identification. Note that the reverse
      transformation is only valid if the evaluation of e1 does not side-effect
      the evaluation of e2. A producer would have had to use the second form if
      it wished to evaluate e1 before e2. The definition of assign allows its
      operands to be evaluated in any order while identify insists that the
      evaluation of its <emphasis>definition</emphasis> is conceptually complete
      before starting on its <emphasis>body</emphasis>.</para>

    <para>Why would a translator wish to make the more complicated form from
      the simpler one? This would usually depend on the particular forms of e1
      and e2 as well as the machine idioms available for implementing the
      assignment. If, for example, the joint evaluation of e1 and e2 used more
      evaluation registers than is available, the transformation is probably a
      good idea. It would not necessarily commit one to putting the new tag value
      into the stack; some other more global criteria might lead one to allocate
      it into a register disjoint from the evaluation registers. In general, this
      kind of transformation is used to modify the operands of TDF constructions
      so that the code-production phase of the translator can just "churn the
      handle" knowing that the operands are already in the correct form for the
      machine idioms.</para>

    <para>Transformations like this are also used to give optimisations which
      are largely independent of the target architecture. In general, provided
      that the sequencing rules are not violated, any EXP construction, F(X),
      say, where X is some inner EXP, can be replaced by:</para>
<programlisting>
identify(empty, new_tag, X, F(obtain_tag(new_tag))).
</programlisting>

    <para>This includes the extraction of expressions which are constant over a
      loop; if F was some repeat construction and one can show that the EXP X is
      invariant over the repeat, the transformation does the constant
      extraction.</para>

    <para>Most of the transformations performed by translators are of the above
      form, but there are many others. Particular machine idioms might lead to
      transformations like changing a test (i&gt;=1) to (i&gt;0) because the test
      against zero is faster; replacing multiplication by a constant integer by
      shifts and adds because multiplication is slow; and so on. Target
      independent transformations include things like procedure inlining and loop
      unrolling. Often these target independent transformations can be profitably
      done in terms of the TOKENs of an LPI; loop unrolling is an obvious
      example.</para>

    <sect1 id='transformations-def'>
      <title>Transformations as definitions</title> 

      <para>As well being a vehicle for expressing optimisation, TDF
        transformations can be used as the basis for defining TDF. In principle,
        if we were to define all of the allowable transformations of the TDF
        constructions, we would have a complete definition of TDF as the initial
        model of the TDF algebra. This would be a fairly impracticable project,
        since the totality of the rules including all the simple constructs would
        be very unwieldy, difficult to check for inconsistencies and would not
        add much illumination to the definition. However, knowledge of allowable
        transformations of TDF can often answer questions of the meaning of
        diverse constructs by relating them to a single construct. What follows
        is an alphabet of generic transformations which can often help to answer
        knotty questions. Here, E[X \ Y] denotes an EXP E with all internal
        occurrences of X replaced by Y.</para>

      <para>
          If F is any non order-specifying 
  
          <footnote>
            <para>The order-specifying constructors are conditional, identify,
            repeat, labelled, sequence and variable</para>
        </footnote>
      </para>

      <para>EXP constructor and E is one of the EXP operands of F, then:</para>
<programlisting>
F(... , E, ...) &lt;=&gt; identify(empty, newtag, E, F(... ,obtain_tag(newtag), ...))
</programlisting>

      <para>
          If E is a non side-effecting 
  
          <footnote>
            <para>A sufficient condition for not side-effecting in this sense is
            that there are no apply_procs or local_allocs in E; that any
            assignments in E are to variables defined in E; and that any branches
            in E are to labels defined in conditionals in E.</para>
        </footnote>
      </para>

      <para>EXP and none of the variables used in E are assigned to in
        B:</para>
<programlisting>
identify(v, tag, E, B) &lt;=&gt; B[obtain_tag(tag) \ E]
</programlisting>

      <para>If all uses of tg in B are of the form</para>
<programlisting>
contents(shape(E), obtain_tag(tg)):
variable(v, tg, E, B) &lt;=&gt; identify(v, nt, E, B[contents(shape(E), obtain_tag(tg)) \
obtain_tag(nt)]) sequence((S<emphasis>1</emphasis>, ... ,
S<emphasis>n</emphasis>), sequence((P<emphasis>1</emphasis>, ...,
P<emphasis>m</emphasis>), R) =&gt; sequence((S<emphasis>1</emphasis>,
..., S<emphasis>n</emphasis>, P<emphasis>1</emphasis>, ...,
P<emphasis>m</emphasis>), R) If S<emphasis>i</emphasis> =
sequence((P<emphasis>1</emphasis>, ..., P<emphasis>m</emphasis>),
R) : sequence((S<emphasis>1</emphasis>, ... ,
S<emphasis>n</emphasis>), T) =&gt; sequence((S<emphasis>1</emphasis>,
..., S<emphasis>i-1</emphasis>, P<emphasis>1</emphasis>, ...,
P<emphasis>m</emphasis>, R, S<emphasis>i+1</emphasis>, ...,
S<emphasis>n</emphasis>), T) E =&gt; sequence(( ), E)
</programlisting>

      <para>If D is either identify or variable:</para>
<programlisting>
D(v, tag, sequence((S<emphasis>1</emphasis>,
..., S<emphasis>n</emphasis>), R), B) &lt;=&gt;
sequence((S<emphasis>1</emphasis>, ..., S<emphasis>n</emphasis>),
D(v, tag, R, B) )
</programlisting>

      <para>If S<emphasis>i</emphasis> is an EXP BOTTOM , then:</para>
<programlisting>
sequence((S<emphasis>1</emphasis>, S<emphasis>2</emphasis>,
... S<emphasis>n</emphasis>), R) &lt;=&gt;
sequence((S<emphasis>1</emphasis>, ... S<emphasis>i-1</emphasis>),
S<emphasis>i</emphasis>)
</programlisting>

      <para>If E is an EXP BOTTOM, and if D is either identify or
        variable:</para>
<programlisting>
D(v, tag, E, B) &lt;=&gt; E
</programlisting>

      <para>If S<emphasis>i</emphasis> is make_top(), then:</para>
<programlisting>
sequence((S<emphasis>1</emphasis>, S<emphasis>2</emphasis>, ...
S<emphasis>n</emphasis>), R) =&gt; sequence((S<emphasis>1</emphasis>,
... S<emphasis>i-1</emphasis>, S<emphasis>i+1</emphasis>,
...S<emphasis>n</emphasis>), R)
</programlisting>

      <para>If S<emphasis>n</emphasis> is an EXP TOP:</para>
<programlisting>
sequence((S<emphasis>1</emphasis>, ...
S<emphasis>n</emphasis>), make_top()) =&gt;
sequence((S<emphasis>1</emphasis> , ...,
S<emphasis>n-1</emphasis>), S<emphasis>n</emphasis>)
</programlisting>

      <para>If E is an EXP TOP and E is not side-effecting then:</para>
<programlisting>
E &lt;=&gt; make_top()
</programlisting>

      <para>If C is some non order-specifying and non side-effecting
        constructor, and S<emphasis>i</emphasis> is
        C(P<emphasis>1</emphasis>,..., P<emphasis>m</emphasis>)</para>

      <para>where</para>

      <para>P<emphasis>1..m</emphasis> are the EXP operands of C:</para>
<programlisting>
sequence((S<emphasis>1</emphasis>, ...,
S<emphasis>n</emphasis>), R) &lt;=&gt; sequence((S<emphasis>1</emphasis>,
..., S<emphasis>i-1</emphasis>, P<emphasis>1</emphasis>, ...,
P<emphasis>m</emphasis>, S<emphasis>i+1</emphasis>, ...,
S<emphasis>n</emphasis>), R)
</programlisting>

      <para>If none of the S<emphasis>i</emphasis> use the label L:</para>
<programlisting>
conditional(L, sequence((S<emphasis>1</emphasis>,
..., S<emphasis>n</emphasis>), R), A) &lt;=&gt;
sequence((S<emphasis>1</emphasis>, ..., S<emphasis>n</emphasis>),
conditional(L, R, A))
</programlisting>

      <para>
          If there are no uses of L in X: 
  
          <footnote>
            <para>There are analogous rules for labelled and repeat with unused
            LABELs.</para>
        </footnote>
      </para>
<programlisting>
conditional(L, X, Y) &lt;=&gt;
X conditional(L, E , goto(Z)) &lt;=&gt; E[L \ Z]
</programlisting>

      <para>If EXP X contains no use of the LABEL L:</para>
<programlisting>
conditional(L, conditional(M, X, Y), Z) &lt;=&gt;
conditional(M, X, conditional(L, Y, Z)) repeat(L, I, E) &lt;=&gt;
sequence( (I), repeat(L, make_top(), E)) repeat(L, make_top(), E)
&lt;=&gt; conditional(Z, E[L \ Z], repeat(L, make_top(), E))
</programlisting>

      <para>If there are no uses of L in E:</para>
<programlisting>
repeat(L, make_top(), sequence((S, E),
make_top()) &lt;=&gt; conditional(Z, S[L \ Z], repeat(L, make_top(),
sequence((E, S), make_top()) ) )
</programlisting>

      <para>
          If f is a procedure defined 
  
          <footnote>
            <para>This has to be modified if B contains any uses of
            local_free_all or last_local.</para>
        </footnote>
        :
      </para>
<programlisting>
make_proc(rshape,
formal<emphasis>1..n</emphasis>, vtg , B( return
R<emphasis>1</emphasis>, ..., return R<emphasis>m</emphasis>))
</programlisting>

      <para>where:</para>
<programlisting>
formal<emphasis>i</emphasis> =
make_tagshacc(s<emphasis>i</emphasis>, v<emphasis>i</emphasis>,
tg<emphasis>i</emphasis>)
</programlisting>

      <para>and B is an EXP with all of its internal return constructors
        indicated parametrically then, if A<emphasis>i</emphasis> has SHAPE
        s<emphasis>i</emphasis></para>
<programlisting>
apply_proc(rshape, f, (A<emphasis>1</emphasis>, ... ,
A<emphasis>n</emphasis>), V) &lt;=&gt; variable( empty, newtag,
make_value((rshape=BOTTOM)? TOP: rshape), labelled( (L),
variable(v<emphasis>1</emphasis>, tg<emphasis>1</emphasis>,
A<emphasis>1</emphasis>, ... , variable(v<emphasis>n</emphasis>,
tg<emphasis>n</emphasis>, A<emphasis>n</emphasis>, variable(empty,
vtg, V, B(sequence( assign(obtain_tag(newtag),
R<emphasis>1</emphasis>), goto(L)) , ... , sequence(
assign(obtain_tag(newtag), R<emphasis>m</emphasis>), goto(L)) ) )
), contents(rshape, obtain_tag(newtag)) ) ) assign(E, make_top())
&lt;=&gt; sequence( (E), make_top()) contents(TOP, E) &lt;=&gt; sequence((E),
make_top()) make_value(TOP) &lt;=&gt; make_top() component(s,
contents(COMPOUND(S), E), D) &lt;=&gt; contents(s, add_to_ptr(E, D))
make_compound(S, ((E<emphasis>1</emphasis>,
D<emphasis>1</emphasis>), ..., (E<emphasis>n</emphasis>,
D<emphasis>n</emphasis>)) ) &lt;=&gt; variable(empty, nt,
make_value(COMPOUND(S)), sequence( (
assign(add_to_ptr(obtain_tag(nt), D<emphasis>1</emphasis>),
E<emphasis>1</emphasis>), ... , assign(add_to_ptr(obtain_tag(nt),
D<emphasis>n</emphasis>), E<emphasis>n</emphasis>) ), contents(S,
obtain_tag(nt)) ) )
</programlisting>

      <sect2 id='examples-f-trans'>
        <title>Examples of transformations</title> 

        <para>Any of these transformations may be performed by the TDF
          translators. The most important is probably {A} which allows one to
          reduce all of the EXP operands of suitable constructors to obtain_tags.
          The expansion rules for identification, {G}, {H} and {I}, gives
          definition to complicated operands as well as strangely formed ones,
          e.g. return(... return(X)...). Rule {A} also illustrates neatly the
          lack of ordering constraints on the evaluation of operands. For
          example, mult(et, exp1, exp2) could be expanded by applications of {A}
          to either:</para>

        <example id='example-trans'>
          <title>Examples of transformations</title> 
<programlisting>
identify(empty, t1, exp1,
identify(empty, t2, exp2, mult(et, obtain_tag(t1), obtain_tag(t2))) )
</programlisting>

          <para>or:</para>
<programlisting>
identify(empty, t2, exp2,
identify(empty, t1, exp1, mult(et, obtain_tag(t1), obtain_tag(t2))) )
</programlisting>
        </example>

        <para>Both orderings of the evaluations of exp1 and exp2 are
          acceptable, regardless of any side-effects in them. There is no
          requirement that both expansions should produce the same answer for the
          multiplications; the only person who can say whether either result is
          "wrong" is the person who specified the program.</para>

        <para>Many of these transformations often only come into play when some
          previous transformation reveals some otherwise hidden information. For
          example, after procedure in-lining given by {U} or loop un-rolling
          given by {S}, a translator can often deduce the behaviour of a _test
          constructor, replacing it by either a make_top or a goto. This may
          allow one to apply either {J} or {H} to eliminate dead code in
          sequences and in turn {N} or {P} to eliminate entire conditions and so
          on.</para>

        <para>Application of transformations can also give expansions which are
          rather pathological in the sense that a producer is very unlikely to
          form them. For example, a procedure which returns no result would have
          result statements of the form return(make_top()). In-lining such a
          procedure by {U} would have a form like:</para>
<programlisting>
variable(empty, nt, make_shape(TOP),
labelled( (L),
... sequence((assign(obtain_tag(nt), make_top())),
goto(L)) ...
contents(TOP, obtain_tag(nt))
)
)
</programlisting>

        <para>The rules {V}, {W} and {X} allow this to be replaced by:</para>
<programlisting>
variable(empty, nt, make_top(),
labelled( (L),
... sequence((obtain_tag(nt)), goto(L)) ...
sequence((obtain_tag(nt)), make_top())
)
)
</programlisting>

        <para>The obtain_tags can be eliminated by rule {M} and then the
          sequences by {F}. Sucessive applications of {C} and {B} then
          give:</para>
<programlisting>
labelled( (L),
... goto(L) ...
make_top()
)
</programlisting>
      </sect2>

      <sect2 id='prog-undef-values'>
        <title>Programs with undefined values</title> 

        <para>
            The definitions of most of the constructors in the TDF specification
            are predicated by some conditions; if these conditions are not met
            the effect and result of the constructor is not defined for all
            possible platforms. 
  
            <footnote>
              <para>However, we may find that the mapping of a constraint allows
              extra relationships for a class of architectures which do not hold
              in all generality; this may mean that some constructions are
              defined on this class while still being undefined in others (see
              <xref linkend='models-tdf-algebra'> ).</para>
          </footnote>
          Any value which is dependent on the effect or result of an undefined
          construction is also undefined. This is not the same as saying that a
          program is undefined if it can construct an undefined value - the
          dynamics of the program might be such that the offending construction
          is never obeyed.
        </para>
      </sect2>
    </sect1>
  </chapter>

  <chapter id='tdf-expansions-offsets'>
    <title>TDF expansions of offsets</title> 

    <para>Consider the C structure defined by:</para>
<programlisting>
<emphasis>typedef struct{ int i; double d; char c;} mystruct;</emphasis>
</programlisting>

    <para>Given that sh_int, sh_char and sh_double are the SHAPEs for int, char
      and double, the SHAPE of <emphasis>mystruct</emphasis> is constructed
      by:</para>
<programlisting>
SH_mystruct = compound(S_c)
</programlisting>

    <para>where:</para>
<programlisting>
S_c = offset_add(O_c, shape_offset(sh_char))
</programlisting>

    <para>where:</para>
<programlisting>
O_c = offset_pad(alignment(sh_char), S_d)
</programlisting>

    <para>where:</para>
<programlisting>
S_d = offset_add(O_d, shape_offset(sh_double))
</programlisting>

    <para>where:</para>
<programlisting>
O_d = offset_pad(alignment(sh_double), S_i)
</programlisting>

    <para>
        where: 
  
        <footnote>
          <para>I could equally have given simply shape_offset(sh_int) for S_i,
          but the above formulation is more uniform with respect to selection
          OFFSETs.</para>
      </footnote>
    </para>

    <para>S_i = offset_add(O_i, shape_offset(sh_int)) and: O_i =
      offset_zero(alignment(sh_int)) Each of S_c, S_d and S_i gives the minimum
      "size" of the space required to upto and including the field c, d and i
      respectively. Each of O_c, O_d and O_i gives the OFFSET "displacement" from
      a pointer to a <emphasis>mystruct</emphasis> required to select the fields
      c, d and i respectively. The C program fragment:</para>
<programlisting>
mystruct s;
.... s.d = 1.0; ...
</programlisting>

    <para>would translate to something like:</para>
<programlisting>
variable(empty, tag_s, make_value(compound(S_c)),
sequence( ...
assign(add_to_ptr(obtain_tag(tag_s), O_d), 1.0)
...
)
)
</programlisting>

    <para>Each of the OFFSET expressions above are ideal candidates for
      tokenisation; a producer would probably define tokens for each of them and
      use exp_apply_token to expand them at each of their uses.</para>

    <para>From the definition, we find that:</para>
<programlisting>
S_c = shape_offset(SH_mystruct)
i.e. an OFFSET(alignment(sh_int) xc8  alignment(sh_char) xc8  alignment(sh_double), {})
</programlisting>

    <para>This would not be the OFFSET required to describe
      <emphasis>sizeof(mystruct)</emphasis> in C, since this is defined to be the
      difference between successive elements an array of
      <emphasis>mystruct</emphasis>s. The <emphasis>sizeof</emphasis> OFFSET
      would have to pad S_c to the alignment of SH_mystruct:</para>
<programlisting>
offset_pad(alignment(SH_mystruct), S_c)
</programlisting>

    <para>This is the OFFSET that one would use to compute the displacement of
      an element of an array of <emphasis>mystruct</emphasis>s using offset_mult
      with the index.</para>

    <para>The most common use of OFFSETs is in add_to_ptr to compute the
      address of a structure or array element. Looking again at its signature in
      a slightly different form:</para>
<programlisting>
<emphasis>arg1</emphasis>:   EXP POINTER(<emphasis>y</emphasis> <emphasis>xc8</emphasis> <emphasis>A</emphasis>)
<emphasis>arg2</emphasis>:   EXP OFFSET(<emphasis>y, z</emphasis>)
-&gt; EXP POINTER(<emphasis>z</emphasis>)
... for any ALIGNMENT <emphasis>A</emphasis>
</programlisting>

    <para>one sees that <emphasis>arg2</emphasis> can measure an OFFSET from a
      value of a "smaller" alignment than the value pointed at by
      <emphasis>arg1</emphasis>. If <emphasis>arg2</emphasis> were O_d, for
      example, then <emphasis>arg1</emphasis> could be a pointer to any structure
      of the form struct {int i, double d,...} not just
      <emphasis>mystruct</emphasis>. The general principle is that an OFFSET to a
      field constructed in this manner is independent of any fields after it,
      corresponding to normal usage in both languages and machines. A producer
      for a language which conflicts with this would have to produce less obvious
      TDF, perhaps by re-ordering the fields, padding the offsets by later
      alignments or taking maxima of the sizes of the fields.</para>

    <sect1 id='bitfield-offsets'>
      <title>Bitfield offsets</title> 

      <para>Bitfield offsets are governed by rather stricter rules. In order to
        extract or assign a bitfield, we have to find an integer variety which
        entirely contains the bitfield. Suppose that we wished to extract a
        bitfield by:</para>
<programlisting>
bitfield_contents(v, p:POINTER(X), b:OFFSET(Y, B))
</programlisting>

      <para>Y must be an alignment(I) where I is some integer SHAPE, contained
        in X. Further, this has to be equivalent to:</para>
<programlisting>
bitfield_contents(v, add_ptr(p, d:OFFSET(Y,Y)), b':OFFSET(Y, B))
</programlisting>

      <para>for some d and b' such that:</para>
<programlisting>
offset_pad(v, shape_offset(I)) &gt;= b'
and
offset_add(offset_pad(v, offset_mult(d, sizeof(I)), b') = b
</programlisting>

      <para>Clearly, we have a limitation on the length of bitfields to the
        maximum integer variety available; in addition, we cannot have a bitfield
        which overlaps two such varieties.</para>

      <para>The difficulties inherent in this may be illustrated by attempting
        to construct an array of bitfields using the nof constructor. Assuming a
        standard architecture, we find that we cannot usefully define an object
        of SHAPE nof(N, bitfield(bfvar_bits(b, M))) without padding this shape
        out to some integer variety which can contain M bits. In addition, they
        can only be usefully indexed (using bitfield_contents)either if M is some
        power of 2 or M*N is less than the length of the maximum integer variety.
        Thus a producer must be sure that these conditions hold if he is to
        generate and index this object simply. Even here he is in some dificulty,
        since he does not know the representational varieties of the integers
        available to him; also it is difficult for him to ensure that the
        alignment of the entire array is in some sense minimal. Similar
        difficulties occur with bitfields in structures - they are not restricted
        to arrays.</para>

      <para>The solution to this conundrum in its full generality requires
        knowledge of the available representational varieties. Particular
        languages have restrictions which means that sub-optimal solutions will
        satisfy its specification on the use of bitfields. For example, C is
        satisfied with bitfields of maximum length 32 and simple alignment
        constraints. However, for the general optimal solution, I can see no
        reasonable alternative to the installer defining some tokens to produce
        bitfield offsets which are guaranteed to obey the alignment rules and
        also give optimal packing of fields and alignments of the total object
        for the platform in question. I believe that three tokens are sufficient
        to do this; these are analogous to the constructors offset_zero,
        offset_pad and offset_mult with ordinary alignments and their signatures
        could be:</para>
<programlisting>
~Bitfield_offset_zero:
<emphasis>n</emphasis>:   NAT
<emphasis>issigned</emphasis>:    BOOL
-&gt; EXP OFFSET(A, bfvar_bits(<emphasis>issigned</emphasis>, <emphasis>n</emphasis>))
</programlisting>

      <para>Here the result is a zero offset to the bitfield with `minimum'
        integer variety alignment A.</para>
<programlisting>
~Bitfield_offset_pad:
<emphasis>n</emphasis>:   NAT
<emphasis>issigned</emphasis>:    BOOL
<emphasis>sh</emphasis>:  SHAPE
-&gt; EXP OFFSET(alignment(<emphasis>sh</emphasis>) xc8  A, bfvar_bits(<emphasis>issigned</emphasis>,
<emphasis>n</emphasis>))
</programlisting>

      <para>Here the result is the shape_offset of <emphasis>sh</emphasis>
        padded with the `minimum' alignment A so that it can accomodate the
        bitfield. Note that this may involve padding <emphasis>sh</emphasis> with
        the alignment of the maximum integer variety if there are not enough bits
        left at the end of <emphasis>sh.</emphasis></para>
<programlisting>
~Bitfield_offset_mult:
<emphasis>n</emphasis>:   NAT
<emphasis>issigned</emphasis>:    BOOL
<emphasis>ind</emphasis>: EXP INTEGER(v)
-&gt; EXP OFFSET(A, bfvar_bits(<emphasis>issigned</emphasis>, <emphasis>n</emphasis>))
</programlisting>

      <para>Here the result is an offset which gives the displacement of
        <emphasis>ind</emphasis> <emphasis>th</emphasis> element of an array of
        <emphasis>n</emphasis>-bit bitfields with `minimum' alignment A. Note
        that this will correspond to a normal multiplication only if
        <emphasis>n</emphasis> is a power of 2 or
        <emphasis>ind</emphasis>*<emphasis>n</emphasis> &lt;= length of the
        maximum integer variety.</para>

      <para>
          These tokens can be expressed in TDF if the lengths of the available
          varieties are known, i.e., they are installer defined. 
  
          <footnote>
            <para>For most architectures, these definition are dependent only on
            a few constants such as the maximum length of bitfield., expessed as
            tokens for the target. The precise specification of such target
            dependent tokens is of current interest outside the scope of this
            document.</para>
        </footnote>
        They ought to be used in place of offset_zero, offset_pad and
        offset_mult whereever the alignment or shape (required to construct a
        SHAPE or an argument to the bitfield constructs) is a pure bitfield.
        The constructor nof should never be used on a pure bitfield; instead it
        should be replaced by:
      </para>
<programlisting>
S = compound(~Bitfield_offset_mult(M, b, N))
</programlisting>

      <para>to give a shape, S, representing an array of N M-bit bitfields.
        This may not be just N*M bits; for example ~Bitfield_offset_mult may be
        implemented to pack an array of 3-bit bitfields as 10 fields to a 32-bit
        word. In any case, one would expect that normal rules for offset
        arithmetic are preserved, e.g.</para>
<programlisting>
offset_add(~Bitfield_offset_pad(M, b, S), size(bitfield(bfvar_bits(b, N))) )
=  ~Bitfield_offset_mult(M, b, N+1)
</programlisting>

      <para>where size(X) = offset_pad(alignment(X), shape_offset(X))</para>
    </sect1>
  </chapter>

  <chapter id='models-tdf-algebra'>
    <title>Models of the TDF algebra</title> 

    <para>TDF is a multi-sorted abstract algebra. Any implementation of TDF is
      a model of this algebra, formed by a mapping of the algebra into a concrete
      machine. An algebraic mapping gives a concrete representation to each of
      the SORTs in such a way that the representation of any construction of TDF
      is independent of context; it is a homomorphism. In other words if we
      define the mapping of a TDF constructor, C, as MAP[C] and the
      representation of a SORT, S, as REPR[S] then:</para>
<programlisting>
REPR[ C(P<emphasis>1</emphasis> ,..., P<emphasis>n</emphasis>) ] = MAP[C]( REPR(P<emphasis>1</emphasis>) ,..., REPR(P<emphasis>n</emphasis> ))
</programlisting>

    <para>Any mapping has to preserve the equivalences of the abstract algebra,
      such as those exemplified by the transformations {A} - {Z} in
      <xref linkend='transformations-def'> . Similarly, the mappings of any
      predicates on the constructions, such as those giving "well-formed"
      conditions, must be satisfied in terms of the mapped
      representations.</para>

    <para>In common with most homomorphisms, the mappings of constructions can
      exhibit more equivalences than are given by the abstract algebra. The use
      of these extra equivalences is the basis of most of the target-dependent
      optimisations in a TDF translator; it can make use of "idioms" of the
      target architecture to produce equivalent constructions which may work
      faster than the "obvious" translation. In addition, we may find that may
      find that more predicates are satisfied in a mapping than would be in the
      abstract algebra. A particular concrete mapping might allow more
      constructions to be well-formed than are permitted in the abstract; a
      producer can use this fact to target its output to a particular class of
      architectures. In this case, the producer should produce TDF so that any
      translator not targeted to this class can fail gracefully.</para>

    <para>Giving a complete mapping for a particular architecture here is
      tantamount to writing a complete translator. However, the mappings for the
      small but important sub-algebra concerned with OFFSETs and ALIGNMENTs
      illustrates many of the main principles. What follows is two sets of
      mappings for disparate architectures; the first gives a more or less
      standard meaning to ALIGNMENTs but the second may be less familiar.</para>

    <sect1 id='model-standard-architecture'>
      <title>Model for a 32-bit standard architecture</title> 

      <para>Almost all current architectures use a "flat-store" model of
        memory. There is no enforced segregation of one kind of data from another
        - in general, one can access one unit of memory as a linear offset from
        any other. Here, TDF ALIGNMENTs are a reflection of constraints for the
        efficient access of different kinds of data objects - usually one finds
        that 32-bit integers are most efficiently accessed if they start at 32
        bit boundaries and so on.</para>

      <sect2 id='alignment-model-a'>
        <title>Alignment model</title> 

        <para>The representation of ALIGNMENT in a typical standard
          architecture is a single integer where:</para>
<programlisting>
REPR [ { } ] = 1
REPR[ {bitfield} ] = 1
REPR[ {char_variety} ] = 8
REPR[ {short_variety} ] = 16
</programlisting>

        <para>Otherwise, for all other primitive ALIGNMENTS a:</para>
<programlisting>
REPR [ {a} ] = 32
</programlisting>

        <para>The representation of a compound ALIGNMENT is given by:</para>
<programlisting>
REPR [ A xc8  B ] = Max(REPR[ A ] , REPR[ B ])
i.e. MAP[ unite_alignment] = Max
</programlisting>

        <para>while the ALIGNMENT inclusion predicate is given by:</para>
<programlisting>
REPR[ A ... B ]= REPR[ A ] xb3  REPR[ B }
</programlisting>

        <para>All the constructions which make ALIGNMENTs are represented here
          and they will always reduce to an integer known at translate-time. Note
          that the mappings for xc8 and ... must preserve the basic algebraic
          properties derived from sets; for example the mapping of xc8 must be
          idempotent, commutative and associative, which is true for Max.</para>
      </sect2>

      <sect2 id='offset-pointer-model-a'>
        <title>Offset and pointer model</title> 

        <para>Most standard architectures use byte addressing; to address bits
          requires more complication. Hence, a value with SHAPE POINTER(A) where
          REPR[A)]xb9 1 is represented by a 32-bit byte address.</para>

        <para>We are not allowed to construct pointers where REPR[A] = 1, but
          we still have offsets whose second alignment is a bitfield. Thus a
          offsets to bitfield are represented differently to offsets to other
          alignments:</para>

        <para>A value with SHAPE OFFSET(A, B) where REPR(B) xb9 1 is
          represented by a 32-bit byte-offset.</para>

        <para>A value with SHAPE OFFSET(A, B) where REPR(B) = 1 is represented
          by a 32-bit <emphasis>bit</emphasis>-offset.</para>
      </sect2>

      <sect2 id='size-model-a'>
        <title>Size model</title> 

        <para>In principle, the representation of a SHAPE is a pair of an
          ALIGNMENT and a size, given by shape_offset applied to the SHAPE. This
          pair is constant which can be evaluated at translate time. The
          construction, shape_offset(S), has SHAPE OFFSET(alignment(s), { } ) and
          hence is represented by a bit-offset:</para>
<programlisting>
REPR[ shape_offset(top()) ] = 0
REPR[ shape_offset(integer(char_variety)) ] = 8
REPR[ shape_offset(integer(short_variety)) ] = 16
.... etc. for other numeric varieties
REPR[ shape_offset(pointer(A)) ]= 32
REPR[ shape_offset(compound(E)) ] = REPR[ E ]
REPR[ shape_offset(bitfield(bfvar_bits(b, N))) ] = N
REPR[ shape_offset(nof(N, S)) ] = N * REPR[ offset_pad(
alignment(S), shape_offset(S)) ]
</programlisting>

        <para>where S is not a bitfield shape</para>

        <para>Similar considerations apply to the other offset-arithmetic
          constructors. In general, we have:</para>
<programlisting>
REPR [ offset_zero(A) ] = 0             for all A

REPR[offset_pad(A, X:OFFSET(C,D))
= ((REPR[X] + REPR[A]-1)/(REPR[A]))*REPR[A]/8
  if REPR[A] xb9  1 xd9  REPR[D ] =1
Otherwise :
REPR[offset_pad(A, X:OFFSET(C,D))
  = ((REPR[X] + REPR[A]-1)/(REPR[A]))*REPR[A]

REPR[ offset_add(X:OFFSET(A,B), Y:OFFSET(C,D) )]
  = REPR[ X ] *8+ REPR[ Y ]
  if REPR[B] xb9 1 xd9  REPR[D ] =1
Otherwise:
REPR[ offset_add(X, Y )] = REPR[ X ] + REPR[ Y ]

REPR[ offset_max(X: OFFSET(A, B), Y: OFFSET(C, D))]
  = Max(REPR[ X ], 8*REPR[ Y ]
  if REPR[ B ] = 1 xd9  REPR[D ] xb9  1
REPR[ offset_max(X: OFFSET(A, B), Y: OFFSET(C, D))]
  = Max(8*REPR[ X ], REPR[ Y ]
  if REPR[ D ] = 1 xd9  REPR[ B ] xb9  1
Otherwise:
REPR[ offset_max(X, Y) ] = Max( REPR[ X ], REPR[ Y ])

REPR[offset_mult(X, E) ] = REPR[ X ] * REPR[ E ]
</programlisting>

        <para>IA translator working to this model maps ALIGNMENTs into the
          integers and their inclusion constraints into numerical comparisons. As
          a result, it will correctly allow many OFFSETs which are disallowed in
          general; for example, OFFSET({pointer}, {char_variety}) is allowed
          since REPR[ {pointer} ] xb3 REPR[ {char_variety} ]. Rather fewer of
          these extra relationships are allowed in the next model
          considered.</para>
      </sect2>
    </sect1>

    <sect1 id='model-mach-iapx'>
      <title>Model for machines like the iAPX-432</title> 

      <para>The iAPX-432 does not have a linear model of store. The address of
        a word in store is a pair consisting of a block-address and a
        displacement within that block. In order to take full advantage of the
        protection facilities of the machine, block-addresses are strictly
        segregated from scalar data like integers, floats, displacements etc.
        There are at least two different kind of blocks, one which can only
        contain block-addresses and the other which contains only scalar data.
        There are clearly difficulties here in describing data-structures which
        contain both pointers and scalar data.</para>

      <para>Let us assume that the machine has bit-addressing to avoid the bit
        complications already covered in the first model. Also assume that
        instruction blocks are just scalar blocks and that block addresses are
        aligned on 32-bit boundaries.</para>

      <sect2 id='alignment-model-b'>
        <title>Alignment model</title> 

        <para>An ALIGNMENT is represented by a pair consisting of an integer,
          giving the natural alignments for scalar data, and boolean to indicate
          the presence of a block-address. Denote this by:</para>
<programlisting>
(s: alignment_of_scalars, b: has_blocks)
</programlisting>

        <para>We then have:</para>
<programlisting>
REPR[ alignment({ }) ] = (s: 1, b: FALSE)
REPR[ alignment({char_variety}) = (s: 8, b:FALSE)
... etc. for other numerical and bitfield varieties.
REPR[ alignment({pointer}) ] = (s: 32, b: TRUE)
REPR[ alignment({proc}) ] = (s: 32, b: TRUE)
REPR[ alignment({local_label_value}) ] = (s: 32, b: TRUE)
</programlisting>

        <para>The representation of a compound ALIGNMENT is given by:</para>
<programlisting>
REPR[ A xc8  B ] = (s: Max(REPR[ A ].s, REPR[ B ].s), b: REPR[ A ].b xda  REPR[ B ].b )
</programlisting>

        <para>and their inclusion relationship is given by:</para>
<programlisting>
REPR[ A ... B ] = (REPR[ A ].s xb3  REPR[ B ].s) xd9  (REPR[ A ].b xda  &yuml; REPR[ B ].b)
</programlisting>
      </sect2>

      <sect2 id='offset-pointer-model-b'>
        <title>Offset and pointer model</title> 

        <para>A value with SHAPE POINTER A where &yuml; REPR[ A ].b is
          represented by a pair consisting of a block-address of a scalar block
          and an integer bit-displacement within that block. Denote this
          by:</para>
<programlisting>
(sb: scalar_block_address, sd: bit_displacement)
</programlisting>

        <para>A value with SHAPE POINTER A where REPR[ A ].b is represented by
          a quad word consisting of two block-addresses and two bit-displacements
          within these blocks. One of these block addresses will contain the
          scalar information pointed at by one of the bit-displacements;
          similarly, the other pair will point at the block addresses in the data
          are held. Denote this by:</para>
<programlisting>
(sb: scalar_block_address, ab: address_block_address,
sd: scalar_displacement, ad: address_displacement )
</programlisting>

        <para>A value with SHAPE OFFSET(A, B) where &yuml; REPR[ A ].b is
          represented by an integer bit-displacement.</para>

        <para>A value with SHAPE OFFSET(A, B) where REPR[ A ].b is represented
          by a pair of bit-displacements, one relative to a scalar-block and the
          other to an address-block. Denote this by:</para>
<programlisting>
( sd: scalar_displacement, ad: address_displacement )
</programlisting>
      </sect2>

      <sect2 id='size-model-b'>
        <title>Size model</title> 

        <para>The sizes given by shape_offset are now:</para>
<programlisting>
REPR[shape_offset(integer(char_variety)) ] = 8
... etc. for other numerical and bitfield varieties.
REPR[ shape_offset(pointer(A)) ] = ( REPR[ A ].b ) ? (sd: 64, ad: 64) : (sd: 32, ad: 32)
REPR[ shape_offset(offset(A, B)) ] = (REPR[ A ].b) ? 64 : 32)
REPR[ shape_offset(proc) ] = (sd: 32, ad: 32)
REPR[ shape_offset(compound(E)) ] = REPR[ E ]
REPR[ shape_offset(nof(N, S)) ]
= N* REPR[ offset_pad(alignment(S)), shape_offset(S)) ]
REPR[ shape_offset(top) ] = 0
</programlisting>
      </sect2>

      <sect2 id='offset-arithmetic'>
        <title>Offset arithmetic</title> 

        <para>The other OFFSET constructors are given by:</para>
<programlisting>
REPR[ offset_zero(A) ] = 0                                if  &yuml; REPR[ A ].b
REPR[ offset_zero(A) ] = (sd: 0, ad: 0)             if REPR[ A ].b

REPR[ offset_add(X: OFFSET(A,B), Y: OFFSET(C, D)) ] = REPR[ X ] + REPR[ Y ]
  if &yuml; REPR[ A ].b xd9  &yuml; REPR[ C ].b
REPR[ offset_add(X: OFFSET(A,B), Y: OFFSET(C, D)) ]
= ( sd: REPR[ X ].sd + REPR[ Y ].sd, ad: REPR[ X ].ad + REPR[ Y ].ad)
if REPR[ A ].b xd9  REPR[ C ].b
REPR[ offset_add(X: OFFSET(A,B), Y: OFFSET(C, D)) ]
= ( sd: REPR[ X ].sd + REPR[ Y ], ad:REPR[ X ].ad )
  if REPR[ A ].b xd9  &yuml; REPR[ C ].b

REPR[ offset_pad(A, Y: OFFSET(C, D)) ] = (REPR[Y ] + REPR[A ].s - 1)/REPR[ A ].s
  if &yuml; REPR[ A ].b xd9  &yuml; REPR[ C ].b
REPR[ offset_pad(A, Y: OFFSET(C, D)) ]
= ( sd: (REPR[Y ] + REPR[A ].s - 1)/REPR[ A ].s, ad: REPR[ Y ].ad)
if REPR[ C ].b
REPR[ offset_pad(A, Y: OFFSET(C, D)) ]
= ( sd: (REPR[Y]+REPR[A].s-1)/REPR[A].s, ad: 0)
if REPR[ A ].b xd9  &yuml; REPR[ C ].b
REPR[ offset_max(X: OFFSET(A,B), Y: OFFSET(C, D)) ]
= Max(REPR[ X ], REPR[ Y ])
if &yuml; REPR[ A ].b xd9  &yuml; REPR[ C ].b
REPR[ offset_max(X: OFFSET(A,B), Y: OFFSET(C, D)) ]
= ( sd: Max(REPR[ X ].sd, REPR[ Y ].sd),
ad: Max(REPR[ X ].a, REPR[ Y ].ad) )
if REPR[ A ].b xd9  REPR[ C ].b
REPR[ offset_max(X: OFFSET(A,B), Y: OFFSET(C, D)) ]
= ( sd: Max(REPR[ X ].sd, REPR[ Y ]), ad:REPR[ X ].ad )
if REPR[ A ].b xd9  &yuml; REPR[ C ].b
REPR[ offset_max(X: OFFSET(A,B), Y: OFFSET(C, D)) ]
= ( sd: Max(REPR[Y ].sd, REPR[ X]), ad: REPR[Y ].ad )
if REPR[C ].b xd9  &yuml; REPR[ A ].b

REPR[ offset_subtract(X: OFFSET(A,B), Y: OFFSET(C, D)) ]
= REPR[ X ]- REPR[ Y ]
if &yuml; REPR[ A ].b xd9  &yuml; REPR[ C ].b
REPR[ offset_subtract(X: OFFSET(A,B), Y: OFFSET(C, D)) ]
= ( sd: REPR[ X ].sd - REPR[ Y ].sd, ad:REPR[ X ].ad - REPR[ Y ].ad)
if REPR[ A ].b xd9  REPR[ C ].b
REPR[ offset_add(X: OFFSET(A,B), Y: OFFSET(C, D)) ]
= REPR[ X ].sd - REPR[ Y ]
if REPR[ A ].b xd9  &yuml; REPR[ C ].b
.... and so on.
</programlisting>

        <para>Unlike the previous one, this model of ALIGNMENTs would reject
          OFFSETs such as OFFSET({long_variety}, {pointer}) but not OFFSET(
          {pointer}, {long_variety}) since:</para>
<programlisting>
REPR [ {long_variety} ... {pointer} ] = FALSE
but:
REPR [ {pointer} ... {long_variety} ] = TRUE
</programlisting>

        <para>This just reflects the fact that there is no way that one can
          extract a block-address necessary for a pointer from a scalar-block,
          but since the representation of a pointer includes a scalar
          displacement, one can always retrieve a scalar from a pointer to a
          pointer.</para>
      </sect2>
    </sect1>
  </chapter>
</book>


