<!DOCTYPE BOOK PUBLIC "-//FreeBSD//DTD DocBook V4.1-Based Extension//EN"[
<!ENTITY % bookinfo PUBLIC "-//FreeBSD//ENTITIES DocBook BookInfo Entities//EN">
%bookinfo;
<!ENTITY % doc PUBLIC "-//FreeBSD//ENTITIES DocBook Document Entities//EN">
%doc
]>

<book>
  <bookinfo>
    <title>C Checker Reference Manual</title>

    <pubdate>$TenDRA$</pubdate>

    <corpauthor>The TenDRA Documentation Team</corpauthor>

    <copyright>
      <year>2002</year>
      <year>2003</year>
      <year>2004</year>
      <holder>TenDRA Documentation Team</holder>
    </copyright>

    <copyright>
      <year>1997</year>
      <year>1998</year>
      <holder>Defence Evaluation and Research Agency (DERA)</holder>
    </copyright>

    <abstract>
      <para>Please email us at <email>docs@ten15.org</email> if you see any errors</para>
    </abstract>

    <legalnotice id='legalnotice'>
      <para>Extensions to this document from the original
        <ulink url='ftp://ftp.ten15.org/pub/source/TenDRA-4.1.2-doc.tar.gz'>TenDRA-4.1.2-doc.tar.gz</ulink>
        source distribution are covered by the <link linkend='legal-bsdl'>BSDL</link>,
        while all prior modifications remain under the
        <link linkend='legal-crown'>Crown Copyright</link>.</para>
    </legalnotice>

    &bookinfo.legalnotice;

    &bookinfo.legalnotice-crown;

  </bookinfo>

  <bibliography>
    <biblioentry>
      <title>Tdfc: The C to TDF Producer Issue 1.0
      (DRA/CIS3/OSSG/TR/95/102/1.0)</title>
    </biblioentry>

    <biblioentry>
      <title>The C to TDF Producer Issue 2.1.0</title>

      <copyright><year>June 1993</year></copyright>
    </biblioentry>

    <biblioentry>
      <title>TCheck, The TenDRA Program Checker
      (DRA/CIS/CSE2/TR/94/44/1.2)</title>

      <copyright><year>November 1994</year></copyright>
    </biblioentry>

    <biblioentry>
      <title>Tcc Users Guide (DRA/CIS/CSE2/TR/94/48/1.2)</title>

      <copyright><year>June 1994</year></copyright>
    </biblioentry>

    <biblioentry>
      <title>Implementation of ISO/IEC 9899</title>

      <copyright><year>1990</year></copyright>
    </biblioentry>

    <biblioentry>
      <title>tspec - An API Specification Tool DRA/CIS/CSE2/94/48/2.1</title>

      <copyright><year>September 1994</year></copyright>
    </biblioentry>
  </bibliography>

  <preface id='intro'>
    <title>Introduction</title>

    <simplesect id='intro-background'>
      <title>Background</title>

      <para>The C program static checker was originally developed as a
        programming tool to aid the construction of portable programs using the
        Application Programming Interface (API) model of software portability;
        the principle underlying this approach being:</para>

      <blockquote>
        <para><emphasis>If a program is written to conform to an abstract API
          specification, then that program will be portable to any machine which
          implements the API specification correctly.</emphasis></para>
      </blockquote>

      <para>The tool was designed to address the problem of the lack of
        separation between an API specification and an API implementation and as
        such was considered as a compiler for an abstract machine.</para>

      <para>This approach gave the tool an unusually powerful basis for static
        checking of C programs and a large amount of development work has
        resulted in the production of the TenDRA C static checker (tchk). The
        terms, TenDRA C checker and tchk are used interchangably in this
        document.</para>
    </simplesect>

    <simplesect id='intro-c-static-checker'>
      <title>The C static checker</title>

      <para>The C static checker is a powerful and flexible tool which can
        perform a number of static checks on C programs, including:</para>

      <itemizedlist>
        <listitem>
          <para>strict interface checking. In particular, the checker can
            analyse programs against abstract APIs to check their conformance to
            the specification. Abstract versions of most standard APIs are
            provided with the tool; alternatively users can define their own
            abstract APIs using the syntax described in Annex G</para>
        </listitem>

        <listitem>
          <para>checking of integer sizes, overflows and implicit integer
            conversions including potential 64-bit problems, against a 16 bit or
            32 bit architecture profile</para>
        </listitem>

        <listitem>
          <para>strict ISO C standard checking, plus configurable support for
            many non-ISO dialect features</para>
        </listitem>

        <listitem>
          <para>extensive type checking, including prototype-style checking for
            traditionally defined functions, conversion checking, type checking
            on printf and scanf style argument strings and type checking between
            translation units</para>
        </listitem>

        <listitem>
          <para>variable analysis, including detection of unused variables, use
            of uninitialised variables, dependencies on order of evaluation in
            expressions and detection of unused function returns, computed values
            and static variables</para>
        </listitem>

        <listitem>
          <para>detection of unused header files</para>
        </listitem>

        <listitem>
          <para>configurable tests for detecting many other common programming
            errors</para>
        </listitem>

        <listitem>
          <para>complete standard API usage analysis</para>
        </listitem>

        <listitem>
          <para>several built-in checking environments plus support for
            user-defined checking profiles.</para>
        </listitem>
      </itemizedlist>
    </simplesect>

    <simplesect id='intro-about'>
      <title>About this document</title>

      <para>This document is designed as a reference manual detailing the
        features of the C static checker. It contains eleven chapters (including
        this introduction) and nine annexes.</para>

      <itemizedlist>
        <listitem>
          <para>Chapter 2: Configuring the Checker describes the built-in
            checking modes and the design of customised environments</para>
        </listitem>

        <listitem>
          <para>Chapters 3-8: Type Checking, Integral Types, Data Flow and
            Variable Analysis , Preprocessing Checks, ISO C and Other Dialects
            and Common Errors respectively</para>
        </listitem>

        <listitem>
          <para>Chapter 9: The Symbol Table Dump deals with the detection of
            unused header files, type checking across translation units and
            complete standard API usage analysis</para>
        </listitem>

        <listitem>
          <para>Chapter 10: Conditional Compilation describes the checker's
            approach to conditional compilation</para>
        </listitem>

        <listitem>
          <para>Chapter 11: References lists the references used in the
            production of this document</para>
        </listitem>

        <listitem>
          <para>Annex A: Checking Modes gives a description of the built-in
            environments</para>
        </listitem>

        <listitem>
          <para>Annex B: Command Line Options lists the command line checking
            options</para>
        </listitem>

        <listitem>
          <para>Annex C: Specifying Integral Types describes the built-in
            integer modes and the methods for customising them</para>
        </listitem>

        <listitem>
          <para>Annex D: Pragma Syntax Specification</para>
        </listitem>

        <listitem>
          <para>Annex E: Symbol Table Dump Specification</para>
        </listitem>

        <listitem>
          <para>Annex F: Token Syntax describes the methods and syntax used to
            produce abstract APIs</para>
        </listitem>

        <listitem>
          <para>Annex G: Abstract API Manipulation gives details of the ways in
            which TenDRA abstract APIs may be extended, combined or overriden by
            local declarations</para>
        </listitem>

        <listitem>
          <para>Annex H: Specifying Conversions with Tokens</para>
        </listitem>
      </itemizedlist>
    </simplesect>
  </preface>

  <chapter id='config-checker'>
    <title>Configuring the Checker</title>

    <para>There are several methods available for configuring the checker most
      of which are selected by using the relevant command line option. More
      detailed customisation may require special #pragma statements to be
      incorporated into the source code to be analysed (this commonly takes the
      form of a startup file). The configuration options generally act
      independently of one another and unless explicitly forbidden in the
      descriptions below, they may be combined in any way.</para>

    <sect1 id='built-in-checking'>
      <title>Built-in checking profiles</title>

      <para>Six standard checking profiles are provided with the tool and are
        held as a set of startup files which are automatically included in each C
        source file. A brief description of each profile is given below, for a
        complete descriptions see Annex A.</para>

      <itemizedlist>
        <listitem>
          <para>Xs ( strict checks ) denotes strict ISO standard C with most
            extra checks enabled as warnings</para>
        </listitem>

        <listitem>
          <para>Xp ( partial checks ) denotes strict ISO standard C with some
            extra checks enabled</para>
        </listitem>

        <listitem>
          <para>Xc ( conformance ) denotes strict ISO standard C with no extra
            checks enabled</para>
        </listitem>

        <listitem>
          <para>Xw ( warning mode ) represents a `warning' oriented compilation
            mode. Many non-ISO standard C features are permitted with a warning.
            Extra checks are performed to produce warnings</para>
        </listitem>

        <listitem>
          <para>Xa ( `standard-ish' C ) denotes ISO standard C with syntatic
            relaxation and no extra checks</para>
        </listitem>

        <listitem>
          <para>Xt ( traditional C ) denotes traditional ( Kernighan and
            Ritchie ) C with no extra checks</para>
        </listitem>
      </itemizedlist>

      <note>
        <para>The modes Xc, Xa, and Xt are meant to roughly correspond to the
          modes found on some System V compilers.</para>
      </note>

      <para>The default checking environment is Xc, other environments are
        specified by passing the name of the environment to the checker as a
        command line flag, e.g. the -Xs flag specifies that the Xs environment is
        to be used. These environments are the base checking modes and may not be
        combined: if more than one base mode is specified, only the final base
        mode is actually used - the earlier ones are ignored.</para>

      <para>There are also two "add-on" checking profiles, called
        <literal>nepc</literal> (no extra portability checks) and
        <literal>not_ansi</literal>, which may be used to complement any base
        mode. The "add-on" modes may alter the status of checks set in the base
        mode. The <literal>nepc</literal> mode switches off many of the checks
        relating to portability issues and may be specified by passing the
        <literal>-nepc</literal> command line option to tchk. The
        <literal>not_ansi</literal> mode supports a raft of non-ISO features and
        is specified using the <literal>-not_ansi</literal> command line
        flag.</para>
    </sect1>

    <sect1 id='minimum-int-ranges'>
      <title>Minimum integer ranges</title>

      <para>By default the checker assumes that all integer ranges conform to
        the minimum ranges prescribed by the ISO C standard, i.e. char contain at
        least 8 bits, short and int contain at least 16 bits and long contains at
        least 32 bits. If the -Y32bit flag is passed to the checker it assumes
        that integers conform to the minimum ranges commonly found on most 32 bit
        machines, i.e. int contains at least 32 bits and int is strictly larger
        than short so that the integral promotion of unsigned short is int under
        the ISO C standard integer promotion rules.</para>
    </sect1>

    <sect1 id='api-spec'>
      <title>API selection</title>

      <para>By default, programs are checked against the standard ISO C API as
        specified in the ISO C standard Chapter 7. Other APIs are specified by
        passing the -Yapi-name flag to the tchk, where api-name <emphasis>is one
        of the API designators listed below</emphasis>. APIs fall into two
        categories: base APIs and extension APIs. If more than one base API is
        specified to tchk, only the last one is used for checking; the others are
        ignored. Additional extension APIs, however, may be used in addition to
        any suitable base API.</para>

      <para>The base APIs available are:</para>

      <itemizedlist>
        <listitem>
          <para>ansi ANSI X3.159;</para>
        </listitem>

        <listitem>
          <para>iso ISO MSE 9899:1990(Amendment 1:1993(E));</para>
        </listitem>

        <listitem>
          <para>posix POSIX 1003.1;</para>
        </listitem>

        <listitem>
          <para>posix2 POSIX 1003.2;</para>
        </listitem>

        <listitem>
          <para>xpg3 X/Open Portability Guide 3;</para>
        </listitem>

        <listitem>
          <para>xpg4 X/Open Portability Guide 4;</para>
        </listitem>

        <listitem>
          <para>cose COSE 1170;</para>
        </listitem>

        <listitem>
          <para>svid3 System V Interface Definition 3rd Edition;</para>
        </listitem>

        <listitem>
          <para>aes AES Revision A;</para>
        </listitem>

        <listitem>
          <para>system System headers as main API.</para>
        </listitem>
      </itemizedlist>

      <para>and the extension APIs are:</para>

      <itemizedlist>
        <listitem>
          <para>bsd_extn BSD-like extension for use with POSIX etc.;</para>
        </listitem>

        <listitem>
          <para>x5_lib X11 (Release 5) Library;</para>
        </listitem>

        <listitem>
          <para>x5_t X11 (Release 5) Intrinsics Toolkit;</para>
        </listitem>

        <listitem>
          <para>x5_mu X11 (Release 5) Miscellaneous Utilities;</para>
        </listitem>

        <listitem>
          <para>x5_aw X11 (Release 5) Athena Widgets;</para>
        </listitem>

        <listitem>
          <para>x5_mit X11 (Release 5) MIT Implementation;</para>
        </listitem>

        <listitem>
          <para>x5_proto X11 (Release 5) Protocol Extension;</para>
        </listitem>

        <listitem>
          <para>x5_ext X11 (Release 5) Extensions;</para>
        </listitem>

        <listitem>
          <para>x5_private X11 (Release 5) private headers (otherwise protected
            );</para>
        </listitem>

        <listitem>
          <para>motif Motif 1.1;</para>
        </listitem>
      </itemizedlist>

      <para>system+ System headers as last resort API. Search the system
        headers only for those objects for which no declaration or definition can
        be found within the base API.</para>
    </sect1>

    <sect1 id='individual-cmd-line-checking'>
      <title>Individual command line checking options</title>

      <para>Some of the checks available can be controlled using a command line
        option of the form -Xopt,opt,..., where the various opt options give a
        comma-separated list of commands. These commands have the form
        test=status, where test is the name of the check, and status is either
        check (apply check and give an error if it fails), warn (apply check and
        give a warning if it fails) or dont (do not apply check). The names of
        checks can be found with their descriptions in <xref linkend='integral-types'> to <xref linkend='symbol-table-dump'> ; for
        example the check for implicit function declarations described in
        <xref linkend='implicit-funct-decl'> may be switched on using
        <literal>-X:implicit_func=check</literal>.</para>
    </sect1>

    <sect1 id='const-custom-check'>
      <title>Construct a customised checking environment</title>

      <para>The individual checks performed by the C static checker are
        generally controlled by #pragma directives. The reason for this is that
        the ISO standard places no restrictions on the syntax following a #pragma
        preprocessing directive, and most compilers/checkers can be configured to
        ignore any unknown #pragma directives they encounter.</para>

      <para>Most of these directives begin:</para>
<programlisting>
   #pragma TenDRA ...
</programlisting>

      <para>and are always checked for syntactical correctness. The individual
        directives, together with the checks they control are described in
        Chapters 3 - 8. Section 2.2 describes the method of constructing a new
        checking profile from these individual checks.</para>
    </sect1>

    <sect1 id='scoping-check'>
      <title>Scoping checking profiles</title>

      <para>Almost all the available checks are scoped (exceptions will be
        mentioned in the description of the check). A new checking scope may be
        started by inserting the pragma:</para>
<programlisting>
   #pragma TenDRA begin
</programlisting>

      <para>at the outermost level. The scope runs until the matching:</para>
<programlisting>
   #pragma TenDRA end
</programlisting>

      <para>directive, or to the end of the translation unit (the ISO C
        standard definition of a translation unit as being a source file,
        together with any headers or source files included using the #include
        preprocessing directive, less any source lines skipped by any of the
        conditional inclusion preprocessing directives, is used throughout this
        document).</para>

      <para>Checking scopes may be nested in the obvious way.</para>

      <para>Each new checking scope inherits its initial set of checks from the
        checking scope which immediately contains it (this includes the implicit
        main checking scope consisting of the entire source file). Any checks
        switched on or off within the scope apply only to that scope and any
        scope it contains. The set of checks applied reverts to its previous
        state at the end of a scope. Thus, for example:</para>
<programlisting>
   #pragma TenDRA variable analysis on
/* Variable analysis is on here */
#pragma TenDRA begin
#pragma TenDRA variable analysis off
/* Variable analysis is off here */
#pragma TenDRA end
/* Variable analysis is on again here */
</programlisting>

      <para>Once a check has been set any attempt to change its status within
        the same scope is flagged as an error. If checks need to be switched on
        and off in the same source file, they must be properly scoped. The
        built-in compilation modes have the entire source file as their
        scope.</para>

      <para>The method of applying different checking profiles to different
        parts of a program clearly needs to take into account those properties of
        C which can circumvent such scoping. Consider for example:</para>
<programlisting>
   #pragma TenDRA begin
#pragma TenDRA unknown escape allow
#define STRING "hello\!"
#pragma TenDRA end
char * f () {
    return ( STRING ) ;
}
</programlisting>

      <para>The macro STRING is defined in an area where unknown escape
        sequences, such as \!, are allowed, but it is expanded in an area where
        they are not allowed (this is the default setting). The conventional
        approach to macro expansion would lead to the unknown escape sequence
        being flagged as an error, even though the user probably intended to
        avoid this. The checker therefore expands all macros using the checking
        profile in which they were defined, rather than the current checking
        scope.</para>

      <para>The directives describing the user's desired checking profile could
        be included directly in the program itself, ideally in some configuration
        file which is #include'd in all source files. It is however perhaps more
        appropriate to store the directives as a startup file,
        <emphasis>file</emphasis> say, which is passed to the checker using the
        <literal>-f</literal><emphasis>file</emphasis>command line option. It
        should be noted that user-defined compilation modes are defined on top of
        a built-in mode base (normally Xc, the default mode). It is therefore
        important to scope the new checking profile as described above.</para>

      <para>Names may be associated with checking scopes by using an
        alternative form of the begin directive:</para>
<programlisting>
   #pragma TenDRA begin name environment identifier
</programlisting>

      <para>where identifier is any valid C identifier. Thereafter a statement
        of the form:</para>
<programlisting>
   #pragma TenDRA use environment identifier
</programlisting>

      <para>changes the current checking environment to the environment
        associated with identifier.</para>

      <para>Sometimes it may be desirable to use different checking profiles
        for different parts of a translation unit, e.g. applying less strict
        checks to any system headers which may be included. The checker can be
        configured to apply a named checking scope,
        <emphasis>env_name</emphasis>, to any files included from a directory
        which has been named <emphasis>dir_name</emphasis>, using:</para>
<programlisting>
   #pragma TenDRA directory <emphasis>dir_name</emphasis> use environment <emphasis>env_name</emphasis>
</programlisting>

      <para>The directory name must be passed to the checker using the
        <literal>-N</literal><emphasis>dir_name</emphasis>
        <literal>:</literal><emphasis>dir</emphasis>command line option. This is
        equivalent to the usual <literal>-I</literal><literal>dir</literal>
        option for specifying include paths, except that it also attaches the
        name dir_name to the directory.</para>
    </sect1>
  </chapter>

  <chapter id='type-check'>
    <title>Type checking</title>

    <para>Type checking is relevant to two main areas of C. It ensures that all
      declarations referring to the same object are consistent (clearly a
      pre-requisite for a well-defined program). It is also the key to
      determining when an undefined or unexpected value has been produced due to
      the type conversions which arise from certain operations in C. Conversions
      may be explicit (conversion is specified by a cast) or implicit. Generally
      explicit conversions may be regarded more leniently since the programmer
      was obviously aware of the conversion, whereas the implications of an
      implicit conversion may not have been considered.</para>

    <sect1 id='type-conv'>
      <title>Type conversions</title>

      <para>The only types which may be interconverted legally are integral
        types, floating point types and pointer types. Even if these rules are
        observed, the results of some conversions can be surprising and may vary
        on different machines. The checker can detect three categories of
        conversion: integer to integer conversions, pointer to integer and
        integer to pointer conversions, and pointer to pointer
        conversions.</para>

      <para>In the default mode, the checker allows all integer to integer
        conversions, explicit integer to pointer and pointer to integer
        conversions and the explicit pointer to pointer conversions defined by
        the ISO C standard (all conversions between pointers to function types
        and other pointers are undefined according to the ISO C standard).</para>

      <para>Checks to detect these conversions are controlled by the
        pragma:</para>
<programlisting>
#pragma TenDRA conversion analysis <emphasis>status</emphasis>
</programlisting>

      <para>Unless explicitly stated to the contrary, throughout the rest of
        the document where <emphasis>status</emphasis> appears in a pragma
        statement it represents one of <literal>on</literal> (enable the check
        and produce errors), <literal>warning</literal> (enable the check but
        produce only warnings), or <literal>off</literal> (disable the check).
        Here <emphasis>status</emphasis> may be <literal>on</literal> to give an
        error if a conversion is detected, <literal>warning</literal> to produce
        a warning if a conversion is detected, or <literal>off</literal> to
        switch the checks off. The checks may also be controlled using the
        command line
        option<literal>-X:</literal><emphasis>test</emphasis><literal>=</literal><emphasis>
        state</emphasis> where <emphasis>test</emphasis> is one of
        <literal>convert_all</literal>, <literal>convert_int</literal>,
        <literal>convert_int_explicit</literal>,
        <literal>convert_int_implicit</literal>,
        <literal>convert_int_ptr</literal> and <literal>convert_ptr</literal> and
        <emphasis>state</emphasis> is
        <literal>check</literal>,<literal>warn</literal> or
        <literal>dont</literal>.</para>

      <para>Due to the serious nature of implicit pointer to integer, implicit
        pointer to pointer conversions and undefined explicit pointer to pointer
        conversions, such conversions are flagged as errors by default. These
        conversion checks are not controlled by the global conversion analysis
        pragma above, but must be controlled by the relevant individual pragmas
        given in sections <xref linkend='point-int-int-int-conv'>  and <xref linkend='point-point-conv'> 

      <sect2 id='int-int-conversions'>
        <title>Integer to integer conversions</title>

        <para>All integer to integer conversions are allowed in C, however some
          can result in a loss of accuracy and so may be usefully detected. For
          example, conversions from int to long never result in a loss of
          accuracy, but conversions from long to int may. The detection of these
          shortening conversions is controlled by:</para>
<programlisting>
#pragma TenDRA conversion analysis ( int-int ) <emphasis>status</emphasis>
</programlisting>

        <para>Checks on explicit conversions and implicit conversions may be
          controlled independently using:</para>
<programlisting>
#pragma TenDRA conversion analysis ( int-int explicit ) <emphasis>status</emphasis>
</programlisting>

        <para>and</para>
<programlisting>
#pragma TenDRA conversion analysis ( int-int implicit ) <emphasis>status</emphasis>
</programlisting>

        <para>Objects of enumerated type are specified by the ISO C standard to
          be compatible with an implementation-defined integer type. However
          assigning a value of a different integral type other then an
          appropriate enumeration constant to an object of enumeration type is
          not really in keeping with the spirit of enumerations. The check to
          detect the implicit integer to enum type conversions which arise from
          such assignments is controlled using:</para>
<programlisting>
#pragma TenDRA conversion analysis ( int-enum implicit ) <emphasis>status</emphasis>
</programlisting>

        <para>Note that only implicit conversions are flagged; if the
          conversion is made explicit, by using a cast, no errors are
          raised.</para>

        <para>As usual <emphasis>status</emphasis> must be replaced by
          <literal>on</literal>, <literal>warning</literal> or
          <literal>off</literal> in all the pragmas listed above.</para>

        <para>The interaction of the integer conversion checks with the integer
          promotion and arithmetic rules is an extremely complex issue which is
          further discussed in Chapter 4.</para>
      </sect2>

      <sect2 id='point-int-int-int-conv'>
        <title>Pointer to integer and integer to pointer conversions</title>

        <para>Integer to pointer and pointer to integer conversions are
          generally unportable and should always be specified by means of an
          explicit cast. The exception is that the integer zero and null pointers
          are deemed to be inter-convertible. As in the integer to integer
          conversion case, explicit and implicit pointer to integer and integer
          to pointer conversions may be controlled separately using:</para>
<programlisting>
#pragma TenDRA conversion analysis ( int-pointer explicit ) <emphasis>status</emphasis>
</programlisting>

        <para>and</para>
<programlisting>
#pragma TenDRA conversion analysis ( int-pointer implicit ) <emphasis>status</emphasis>
</programlisting>

        <para>or both checks may be controlled together by:</para>
<programlisting>
#pragma TenDRA conversion analysis ( int-pointer ) <emphasis>status</emphasis>
</programlisting>

        <para>where <emphasis>status</emphasis> may be <literal>on</literal>,
          <literal>warning</literal> or <literal>off</literal> as before and
          <literal>pointer-int</literal> may be substituted for
          <literal>int-pointer</literal>.</para>
      </sect2>

      <sect2 id='point-point-conv'>
        <title>Pointer to pointer conversions</title>

        <para>A ccording to the ISO C standard, section 6.3.4, the only legal
          pointer to pointer conversions are explicit conversions between:</para>

        <para>a pointer to an object or incomplete type and a pointer to a
          different object or incomplete type. The resulting pointer may not be
          valid if it is improperly aligned for the type pointed to;</para>

        <para>a pointer to a function of one type and a pointer to a function
          of another type. If a converted pointer, used to call a function, has a
          type that is incompatible with the type of the called function, the
          behaviour is undefined.</para>

        <para>Except for conversions to and from the generic pointer which are
          discussed below, all other conversions, including implicit pointer to
          pointer conversions, are extremely unportable.</para>

        <para>All pointer to pointer conversion may be flagged as errors
          using:</para>
<programlisting>
#pragma TenDRA conversion analysis ( pointer-pointer ) <emphasis>status</emphasis>
</programlisting>

        <para>Explicit and implicit pointer to pointer conversions may be
          controlled separately using:</para>
<programlisting>
#pragma TenDRA conversion analysis ( pointer-pointer explicit ) <emphasis>status</emphasis>
</programlisting>

        <para>and</para>
<programlisting>
#pragma TenDRA conversion analysis ( pointer-pointer implicit ) <emphasis>status</emphasis>
</programlisting>

        <para>where, as before, <literal>status</literal> may be
          <literal>on</literal>, <literal>warning</literal> or
          <literal>off</literal>.</para>

        <para>Conversion between a pointer to a function type and a pointer to
          a non-function type is undefined by the ISO C standard and should
          generally be avoided. The checker can however be configured to treat
          function pointers as object pointers for conversion using:</para>
<programlisting>
#pragma TenDRA function pointer as pointer <emphasis>permit</emphasis>
</programlisting>

        <para>Unless explicitly stated to the contrary, throughout the rest of
          the document where <emphasis>permit</emphasis> appears in a pragma
          statement it represents one of <literal>allow</literal> (allow the
          construct and do not produce errors), <literal>warning</literal> (allow
          the construct but produce warnings when it is detected), or
          <literal>disallow</literal> (produce errors if the construct is
          detected) Here there are three options for <emphasis>permit</emphasis>:
          <literal>allow</literal> (do not produce errors or warnings for
          function pointer &lt;-&gt; pointer conversions);
          <literal>warning</literal> (produce a warning when function pointer
          &lt;-&gt; pointer conversions are detected); or
          <literal>disallow</literal> (produce an error for function pointer
          &lt;-&gt; pointer conversions).</para>

        <para>The generic pointer, void *, is a special case. All conversions
          of pointers to object or incomplete types to or from a generic pointer
          are allowed. Some older dialects of C used char * as a generic pointer.
          This dialect feature may be allowed, allowed with a warning, or
          disallowed using the pragma:</para>
<programlisting>
#pragma TenDRA compatible type : char * == void * <emphasis>permit</emphasis>
</programlisting>

        <para>where <emphasis>permit</emphasis> is <literal>allow</literal>,
          <literal>warning</literal> or <literal>disallow</literal> as
          before.</para>
      </sect2>

      <sect2 id='sixtyfour-bit-port'>
        <title>64-bit portability issues</title>

        <example id='ex-port-issues'>
          <title>64-bit portability issues</title>

          <para>64-bit machines form the "next frontier" of program
            portability. Most of the problems involved in 64-bit portability are
            type conversion problems. The assumptions that were safe on a 32-bit
            machine are not necessarily true on a 64-bit machine - int may not be
            the same size as long, pointers may not be the same size as int, and
            so on. This example illustrates the way in which the checker's
            conversion analysis tests can detect potential 64-bit portability
            problems.</para>

          <para>Consider the following code:</para>
<programlisting>
#include &lt;stdio.h&gt;
void print ( string, offset, scale )
char *string;
unsigned int offset;
int scale;
{
  string += ( scale * offset );
  ( void ) puts ( string );
  return;
}

int main ()
{
  char *s = "hello there";
  print ( s + 4, 2U, -2 );
  return ( 0 );
}
</programlisting>

          <para>This appears to be fairly simple - the offset of 2U scaled by
            -2 cancels out the offset in s + 4, so the program just prints "hello
            there". Indeed, this is what happens on most machines. When ported to
            a particular 64-bit machine, however, it core dumps. The fairly
            subtle reason is that the composite offset, scale * offset, is
            actually calculated as an unsigned int by the ISO C arithmetic
            conversion rules. So the answer is not -4. Strictly speaking it is
            undefined, but on virtually all machines it will be UINT_MAX - 3. The
            fact that adding this offset to string is equivalent to adding -4 is
            only true on machines on which pointers have the same size as
            unsigned int. If a pointer contains 64 bits and an unsigned int
            contains 32 bits, the result is 232 bytes out.</para>

          <para>So the error occurs because of the failure to spot that the
            offset being added to string is unsigned. All mixed integer type
            arithmetic involves some argument conversion. In the case above,
            scale is converted to an unsigned int and that is multiplied by
            offset to give an unsigned int result. If the implicit int-&gt;int
            conversion checks (<xref linkend='int-int-conversions'> ) are enabled, this conversion is
            detected and the problem may be avoided.</para>
        </example>
      </sect2>
    </sect1>

    <sect1 id='funct-type-check'>
      <title>Function type checking</title>

      <para>The importance of function type checking in C lies in the
        conversions which can result from type mismatches between the arguments
        in a function call and the parameter types assumed by its definition or
        between the specified type of the function return and the values returned
        within the function definition. Until the introduction of function
        prototypes into ISO standard C, there was little scope for detecting the
        correct typing of functions. Traditional C allows for absolutely no type
        checking of function arguments, so that totally bizarre functions, such
        as:</para>
<programlisting>
int f ( n ) int n ; {
  return ( f ( "hello", "there" ) ) ;
}
</programlisting>

      <para>are allowed, although their effect is undefined. However, the move
        to fully prototyped programs has been relatively slow. This is partially
        due to an understandable reluctance to change existing, working programs,
        but the desire to maintain compatibility with existing C compilers, some
        of which still do not support prototypes, is also a powerful factor.
        Prototypes are allowed in the checker's default mode but tchk can be
        configured to allow, allow with a warning or disallow prototypes,
        using:</para>
<programlisting>
#pragma TenDRA prototype <emphasis>permit</emphasis>
</programlisting>

      <para>where <emphasis>permit</emphasis> is <literal>allow</literal>,
        <literal>disallow</literal> or <literal>warning</literal>.</para>

      <para>Even if prototypes are not supported the checker has a facility,
        described below, for detecting incorrectly typed functions.</para>

      <sect2 id='type-check-proto'>
        <title>Type checking non-prototyped functions</title>

        <para>The checker offers a method for applying prototype-like checks to
          traditionally defined functions, by introducing the concept of " weak"
          prototypes. A weak prototype contains function parameter type
          information, but has none of the automatic argument conversions
          associated with a normal prototype. Instead weak prototypes imply the
          usual argument promotion passing rules for non-prototyped functions.
          The type information required for a weak prototype can be obtained in
          three ways:</para>

        <orderedlist>
          <listitem>
            <para>A weak prototype may be declared using the syntax:</para>
<programlisting>
int f <emphasis>WEAK</emphasis> ( char, char * ) ;
</programlisting>

            <para>where <emphasis>WEAK</emphasis> represents any keyword which
              has been introduced using:</para>
<programlisting>
#pragma TenDRA keyword <emphasis>WEAK</emphasis> for weak
</programlisting>

            <para>An alternative definition of the keyword must be provided for
              other compilers. For example, the following definition would make
              system compilers interpret weak prototypes as normal (strong)
              prototypes:</para>
<programlisting>
#ifdef __TenDRA__
#pragma TenDRA keyword WEAK for weak
#else
#define WEAK
#endif
</programlisting>

            <para>The difference between conventional prototypes and weak
              prototypes can be illustrated by considering the normal prototype
              for f:</para>
<programlisting>
int f (char,char *);
</programlisting>

            <para>When the prototype is present, the first argument to f would
              be passed as a char. Using the weak prototype, however, results in
              the first argument being passed as the integral promotion of char,
              that is to say, as an int.</para>

            <para>There is one limitation on the declaration of weak prototypes
              - declarations of the form:</para>
<programlisting>
int f <emphasis>WEAK</emphasis>() ;
</programlisting>

            <para>are not allowed. If a function has no arguments, this should
              be stated explicitly as:</para>
<programlisting>
int f <emphasis>WEAK</emphasis>( void ) ;
</programlisting>

            <para>whereas if the argument list is not specified, weak
              prototypes should be avoided and a traditional declaration used
              instead:</para>
<programlisting>
extern int f ();
</programlisting>

            <para>The checker may be configured to allow, allow with a warning
              or disallow weak prototype declarations using:</para>
<programlisting>
#pragma TenDRA prototype ( weak ) <emphasis>permit</emphasis>
</programlisting>

            <para>where <literal>permit</literal> is replaced by
              <literal>allow</literal>, <literal>warning</literal> or
              <literal>disallow</literal> as appropriate. Weak prototypes are not
              permitted in the default mode.</para>
          </listitem>

          <listitem>
            <para>Information can be deduced from a function definition. For
              example, the function definition:</para>
<programlisting>
int f(c,s) char c; char *s;{...}
</programlisting>

            <para>is said to have weak prototype:</para>
<programlisting>
int f <emphasis>WEAK</emphasis> (char,char *);
</programlisting>

            <para>The checker automatically constructs a weak prototype for
              each traditional function definition it encounters and if the weak
              prototype analysis mode is enabled (see below) all subsequent calls
              of the function are checked against this weak prototype.</para>

            <para>For example, in the bizarre function in <xref linkend='funct-type-check'> , the weak
              prototype:</para>
<programlisting>
int f <emphasis>WEAK</emphasis> ( int );
</programlisting>

            <para>is constructed for f. The subsequent call to f:</para>
<programlisting>
f ( "hello", "there" );
</programlisting>

            <para>is then rejected by comparison with this weak prototype - not
              only is f called with the wrong number of arguments, but the first
              argument has a type incompatible with (the integral promotion of)
              int.</para>
          </listitem>

          <listitem>
            <para>Information may be deduced from the calls of a function. For
              example, in:</para>
<programlisting>
extern void f ();
void g ()
{
  f ( 3 );
  f ( "hello" );
}
</programlisting>

            <para>we can infer from the first call of f that f takes one
              integral argument. We cannot deduce the type of this argument, only
              that it is an integral type whose promotion is int (since this is
              how the argument is passed). We can therefore infer a partial weak
              prototype for f:</para>
<programlisting>
void f <emphasis>WEAK</emphasis> ( t );
</programlisting>

            <para>for some integral type t which promotes to int. Similarly,
              from the second call of f we can infer the weak prototype:</para>
<programlisting>
void f <emphasis>WEAK</emphasis> ( char * );
</programlisting>

            <para>(the argument passing rules are much simpler in this case).
              Clearly the two inferred prototypes are incompatible, so an error
              is raised. Note that prototype inferred from function calls alone
              cannot ensure that the uses of the function within a source file
              are correct, merely that they are consistent. The presence of an
              explicit function declaration or definition is required for a
              definitive "right" prototype.</para>

            <para>Null pointers cause particular problems with weak prototypes
              inferred from function calls. For example, in:</para>
<programlisting>
#include &lt;stdio.h&gt;
extern void f ();
void g () {
  f ( "hello" );
  f( NULL );
}
</programlisting>

            <para>the argument in the first call of f is char* whereas in the
              second it is int (because NULL is defined to be 0). Whereas NULL
              can be converted to char*, it is not necessarily passed to
              procedures in the same way (for example, it may be that pointers
              have 64 bits and ints have 32 bits). It is almost always necessary
              to cast NULL to the appropriate pointer type in weak procedure
              calls.</para>
          </listitem>
        </orderedlist>

        <para>Functions for which explicitly declared weak prototypes are
          provided are always type-checked by the checker. Weak prototypes
          deduced from function declarations or calls are used for type checking
          if the weak prototype analysis mode is enabled using:</para>
<programlisting>
#pragma TenDRA weak prototype analysis <emphasis>status</emphasis>
</programlisting>

        <para>where <literal>status</literal> is one of <literal>on</literal>,
          <literal>warning</literal> and <literal>off</literal> as usual. Weak
          prototype analysis is not performed in the default mode.</para>

        <para>There is also an equivalent command line option of the form
          <literal>-X:weak_proto=</literal> <literal>state</literal>, where
          <literal>state</literal> can be <literal>check</literal>,
          <literal>warn</literal> or <literal>dont</literal>.</para>

        <para>This section ends with two examples which demonstrate some of the
          less obvious consequences of weak prototype analysis.</para>

        <example id='obscure-type-mismatch'>
          <title>An obscure type mismatch</title>

          <para>As stated above, the promotion and conversion rules for weak
            prototypes are precisely those for traditionally declared and defined
            functions. Consider the program:</para>
<programlisting>
void f ( n )long n;{
  printf ( "%ld\n", n );
}
void g (){
  f ( 3 );
}
</programlisting>

          <para>The literal constant 3 is an int and hence is passed as such to
            f. f is however expecting a long, which can lead to problems on some
            machines. Introducing a strong prototype declaration of f for those
            compilers which understand them:</para>
<programlisting>
#ifdef __STDC__
  void f ( long );
#endif
</programlisting>

          <para>will produce correct code - the arguments to a function
            declared with a prototype are converted to the appropriate types, so
            that the literal is actually passed as 3L. This solves the problem
            for compilers which understand prototypes, but does not actually
            detect the underlying error. Weak prototypes, because they use the
            traditional argument passing rules, do detect the error. The
            constructed weak prototype:</para>
<programlisting>
void f <emphasis>WEAK</emphasis> ( long );
</programlisting>

          <para>conveys the type information that f is expecting a long, but
            accepts the function arguments as passed rather than converting them.
            Hence, the error of passing an int argument to a function expecting a
            long is detected.</para>

          <para>Many programs, seeking to have prototype checks while
            preserving compilability with non-prototype compilers, adopt a
            compromise approach of traditional definitions plus prototype
            declarations for those compilers which understand them, as in the
            example above. While this ensures correct argument passing in the
            prototype case, as the example shows it may obscure errors in the
            non-prototype case.</para>
        </example>

        <example id='weak-proto-checks'>
          <title>Weak prototype checks in defined programs</title>

          <para>In most cases a program which fails to compile with the weak
            prototype analysis enabled is undefined. ISO standard C does however
            contain an anomalous rule on equivalence of representation. For
            example, in:</para>
<programlisting>
extern void f ();
void g () {
  f ( 3 );
  f ( 4U );
}
</programlisting>

          <para>the TenDRA checker detects an error - in one instance f is
            being passed an int, whereas in the other it is being passed an
            unsigned int. However, the ISO C standard states that, for values
            which fit into both types, the representation of a number as an int
            is equal to that as an unsigned int, and that values with the same
            representation are interchangeable in procedure arguments. Thus the
            program is defined. The justification for raising an error or warning
            for this program is that the prototype analysis is based on types,
            not some weaker notion of "equivalence of representation". The
            program may be defined, but it is not type correct.</para>

          <para>Another case in which a program is defined, but not correct, is
            where an unnecessary extra argument is passed to a function. For
            example, in:</para>
<programlisting>
void f ( a ) int a; {
  printf ( "%d\n", a );
}
void g () {
  f ( 3, 4 );
}
</programlisting>

          <para>the call of f is defined, but is almost certainly a
            mistake.</para>
        </example>
      </sect2>

      <sect2 id='check-printf-strings'>
        <title>Checking printf strings</title>

        <para>Normally functions which take a variable number of arguments
          offer only limited scope for type checking. For example, given the
          prototype:</para>
<programlisting>
int execl ( const char *, const char *, ... );
</programlisting>

        <para>the first two arguments may be checked, but we have no hold on
          any subsequent arguments (in fact in this example they should all be
          const char *, but C does not allow this information to be expressed).
          Two classes of functions of this form, namely the printf and scanf
          families, are so common that they warrant special treatment. If one of
          these functions is called with a constant format string, then it is
          possible to use this string to deduce the types of the extra arguments
          that it is expect ing. For example, in:</para>
<programlisting>
printf ( "%ld", 4 );
</programlisting>

        <para>the format string indicates that printf is expecting a single
          additional argument of type long. We can therefore deduce a
          <emphasis>quasi-prototype</emphasis> which this particular call to
          printf should conform to, namely:</para>
<programlisting>
int printf ( const char *,long );
</programlisting>

        <para>In fact this is a mixture of a strong prototype and a weak
          prototype. The first argument comes from the actual prototype of
          printf, and hence is strong. All subsequent arguments correspond to the
          ellipsis part of the printf prototype, and are passed by the normal
          promotion rules. Hence the long component of the inferred prototype is
          weak (see 3.3.1). This means that the error in the call to printf - the
          integer literal is passed as an int when a long is expected - is
          detected.</para>

        <para>In order for this check to take place, the function declaration
          needs to tell the checker that the function is like printf. This is
          done by introducing a special type, <emphasis>PSTRING</emphasis> say,
          to stand for a printf string, using:</para>
<programlisting>
#pragma TenDRA type <emphasis>PSTRING</emphasis> for ... printf
</programlisting>

        <para>For most purposes this is equivalent to:</para>
<programlisting>
typedef const char *<emphasis>PSTRING</emphasis>;
</programlisting>

        <para>except that when a function declaration:</para>
<programlisting>
int f ( <emphasis>PSTRING</emphasis>, ... );
</programlisting>

        <para>is encountered the checker knows to deduce the types of the
          arguments corresponding to the ... from the PSTRING argument (the
          precise rules it applies are those set out in the XPG4 definition of
          fprintf). If this mechanism is used to apply printf style checks to
          user defined functions, an alternative definition of PSTRING for
          conventional compilers must be provided. For example:</para>
<programlisting>
#ifdef __TenDRA__
#pragma TenDRA type PSTRING for ... printf
#else
typedef const char *PSTRING;
#endif
</programlisting>

        <para>There are similar rules with scanf in place of printf.</para>

        <para>The TenDRA descriptions of the standard APIs use this mechanism
          to describe those functions, namely printf, fprintf and sprintf, and
          scanf, fscanf and sscanf which are of these forms. This means that the
          checks are switched on for these functions by default. However, these
          descriptions are under the control of a macro, __NO_PRINTF_CHECKS,
          which, if defined before stdio.h is included, effectively switches the
          checks off. This macro is defined in the start-up files for certain
          checking modes, so that the checks are disabled in these modes (see
          chapter 2). The checks can be enabled in these cases by #undef'ing the
          macro before including stdio.h. There are equivalent command-line
          options to tchk of the form
          <literal>-X:printf=</literal><literal>state</literal>, where
          <literal>state</literal> can be <literal>check</literal> or
          <literal>dont</literal>, which respectively undefine and define this
          macro.</para>
      </sect2>

      <sect2 id='funct-return-checking'>
        <title>Function return checking</title>

        <para>Function returns normally present no difficulties. The return
          value is converted, as if by assignment, to the function return type,
          so that the problem is essentially one of type conversion (see 3.2).
          There is however one anomalous case. A plain return statement, without
          a return value, is allowed in functions returning a non-void type, the
          value returned being undefined. For example, in:</para>
<programlisting>
int f ( int c )
{
  if ( c ) return ( 1 );
  return;
}
</programlisting>

        <para>the value returned when c is zero is undefined. The test for
          detecting such void returns is controlled by:</para>
<programlisting>
#pragma TenDRA incompatible void return <emphasis>permit</emphasis>
</programlisting>

        <para>where <emphasis>permit</emphasis> may be
          <literal>allow</literal>, <literal>warning</literal> or
          <literal>disallow</literal> as usual.</para>

        <para>There are also equivalent command line options to tchk of the
          form <literal>-X:void_ret=</literal><literal>state</literal>, where
          <literal>state</literal> can be <literal>check</literal>,
          <literal>warn</literal> or <literal>dont</literal>. Incompatible void
          returns are allowed in the default mode and of course, plain return
          statements in functions returning void are always legal.</para>

        <para>This check also detects functions which do not contain a return
          statement, but fall out of the bottom of the function as in:</para>
<programlisting>
int f ( int c )
{
  if ( c ) return ( 1 );
}
</programlisting>

        <para>Occasionally it may be the case that such a function is legal,
          because the end of the function is not reached. Unreachable code is
          discussed in section <xref linkend='unreachable-code'> .</para>
      </sect2>
    </sect1>

    <sect1 id='overriding-type-check'>
      <title>Overriding type checking</title>

      <para>There are several commonly used features of C, some of which are
        even allowed by the ISO C standard, which can circumvent or hinder the
        type-checking of a program. The checker may be configured either to
        enforce the absence of these features or to support them with or without
        a warning, as described below.</para>

      <sect2 id='implicit-funct-decl'>
        <title>Implicit Function Declarations</title>

        <para>The ISO C standard states that any undeclared function is
          implicitly assumed to return int. For example, in ISO C:</para>
<programlisting>
int f ( int c ) {
  return ( g( c )+1 );
}

</programlisting>

        <para>the undeclared function g is inferred to have a
          declaration:</para>
<programlisting>
extern int g ();
</programlisting>

        <para>This can potentially lead to program errors. The definition of f
          would be valid if g actually returned double, but incorrect code would
          be produced. Again, an explicit declaration might give us more
          information about the function argument types, allowing more checks to
          be applied.</para>

        <para>Therefore the best chance of detecting bugs in a program and
          ensuring its portability comes from having each function declared
          before it is used. This means detecting implicit declarations and
          replacing them by explicit declarations. By default implicit function
          declarations are allowed, however the pragma:</para>
<programlisting>
#pragma TenDRA implicit function declaration <emphasis>status</emphasis>
</programlisting>

        <para>may be used to determine how tchk handles implicit function
          declarations. <literal>Status</literal> is replaced by
          <literal>on</literal> to allow implicit declarations,
          <literal>warning</literal> to allow implicit declarations but to
          produce a warning when they occur, or <literal>off</literal> to prevent
          implicit declarations and raise an error where they would normally be
          used.</para>

        <para>(There are also equivalent command-line options to tcc of the
          form <literal>-X:implicit_func=</literal><literal>state</literal>,
          where <literal>state</literal> can be <literal>check</literal>,
          <literal>warn</literal> or <literal>dont</literal>.)</para>

        <para>This test assumes an added significance in API checking. If a
          programmer wishes to check that a certain program uses nothing outside
          the POSIX API, then implicitly declared functions are a potential
          danger area. A function from outside POSIX could be used without being
          detected because it has been implicitly declared. Therefore, the
          detection of implicitly declared functions is vital to rigorous API
          checking.</para>
      </sect2>

      <sect2 id='funct-param'>
        <title>Function Parameters</title>

        <para>Many systems pass function arguments of differing types in the
          same way and programs are sometimes written to take advantage of this
          feature. The checker has a number of options to resolve type mismatches
          which may arise in this way and would otherwise be flagged as
          errors:</para>

        <orderedlist>
          <listitem>
            <formalpara id='type-type-compat'>
              <title>Type-type compatibility</title>

              <para>When comparing function prototypes for compatibility, the
                function parameter types must be compared. If the parameter types
                would otherwise be incompatible, they are treated as compatible
                if they have previously been introduced with a type-type param
                ter compatibility pragma i.e.</para>
            </formalpara>
<programlisting>
#pragma TenDRA argument <emphasis>type-name</emphasis> as <emphasis>type-name</emphasis>
</programlisting>

            <para>where <emphasis>type-name</emphasis> is the name of any type.
              This pragma is transitive and the second type in the pragma is
              taken to be the final type of the parameter.</para>
          </listitem>

          <listitem>
            <formalpara id='type-ellipsis-compat'>
              <title>Type-ellipsis compatibility</title>

              <para>Two function prototypes with different numbers of arguments
                are compatible if:</para>
            </formalpara>

            <itemizedlist>
              <listitem>
                <para>both prototypes have an ellipsis</para>
              </listitem>

              <listitem>
                <para>each parameter type common to both prototypes is
                  compatible</para>
              </listitem>

              <listitem>
                <para>each extra parameter type in the prototype with more
                  parameters, is either specified in a type-ellipsis
                  compatibility pragma or is type-type compatible (see above) to
                  a type that is specified in a type-ellipsis
                  compatibility.</para>
              </listitem>
            </itemizedlist>

            <para>Type-ellipsis compatibility is introduced using the
              pragma:</para>
<programlisting>
#pragma TenDRA argument <emphasis>type-name</emphasis> as ...
</programlisting>

            <para>where again <literal>type-name</literal> is the name of any
              type.</para>
          </listitem>

          <listitem>
            <formalpara>
              <title>Ellipsis compatibility</title>

              <para>If, when comparing two function prototypes for
                compatibility, one has an ellipsis and the other does not, but
                otherwise the two types would be compatible, then if an `extra'
                ellipsis is allowed, the types are treated as compatible. The
                pragma controlling ellipsis compatibility is:</para>
            </formalpara>
<programlisting>
#pragma TenDRA extra ... <emphasis>permit</emphasis>
</programlisting>

            <para>where <literal>permit</literal> may be
              <literal>allow</literal>, <literal>disallow</literal> or
              <literal>warning</literal> as usual.</para>
          </listitem>
        </orderedlist>
      </sect2>

      <sect2 id='impat-promo-funct'>
        <title>Incompatible promoted function arguments</title>

        <para>Mixing the use of prototypes with old-fashioned function
          definitions can result in incorrect code. For example, in the program
          below the function argument promotion rules are applied to the
          definition of f, making it incompatible with the earlier prototype (a
          is converted to the integer promotion of char, i.e. int).</para>
<programlisting>
int f(char);
int f(a)char a;{
...
}
</programlisting>

        <para>An incompatible type error is raised in the default checking
          mode. The check for incompatible types which arise from mixtures of
          prototyped and non-prototyped function declarations and definitions is
          controlled using:</para>

        <para><literal>#pragma TenDRA incompatible promoted function
          argument</literal> <emphasis>permit</emphasis></para>

        <para><literal>Permit</literal> may be replaced by
          <literal>allow</literal>, <literal>warning</literal> or
          <literal>disallow</literal> as normal. The parameter type in the
          resulting function type is the promoted parameter type.</para>
      </sect2>

      <sect2 id='incompat-type-qual'>
        <title>Incompatible type qualifiers</title>

        <para>The declarations</para>
<programlisting>
const int a;
int a;
</programlisting>

        <para>are not compatible according to the ISO C standard because the
          qualifier, const, is present in one declaration but not in the other.
          Similar rules hold for volatile qualified types. By default, tchk
          produces an error when declarations of the same object contain
          different type qualifiers. The check is controlled using:</para>
<programlisting>
#pragma TenDRA incompatible type qualifier <emphasis>permit</emphasis>
</programlisting>

        <para>where the options for <emphasis>permit</emphasis> are
          <literal>allow</literal>, <literal>disallow</literal> or
          <literal>warning</literal>.</para>

        <para><!-- FM pgf ignored -->
          </para>
      </sect2>
    </sect1>
  </chapter>

  <chapter id='integral-types'>
    <title>Integral Types</title>

    <para>The checks described in the previous chapter involved the detection
      of conversions which could result in undefined values. Certain conversions
      involving integral types, however, are defined in the ISO C standard and so
      might be considered safe and unlikely to cause problems. This unfortunately
      is not the case: some of these conversions may still result in a change in
      value; the actual size of each integral type is implementation-dependent;
      and the "old-style" integer conversion rules which predate the ISO standard
      are still in common use. The checker provides support for both ISO and
      traditional integer promotion rules. The set of rules used may be specified
      independently of the two integral range scenarios, 16 bit(default) and 32
      bit, described in section <xref linkend='minimum-int-ranges'> 

    <para>The means of specifying and alternative sets of promotion rules,
      their interaction with the conversion checks described in <xref linkend='type-conv'> 
      and the additional checks which may be performed on integers and integer
      operations are described in the remainder of this chapter.</para>

    <sect1 id='int-promotion-rules'>
      <title>Integer promotion rules</title>

      <para><literal>The ISO C standard rules</literal> may be summarised as
        follows: long integral types promote to themselves; other integral types
        promote to whichever of int or unsigned int they fit into. In full the
        promotions are:</para>

      <itemizedlist>
        <listitem>
          <para>char -&gt; int</para>
        </listitem>

        <listitem>
          <para>signed char -&gt; int</para>
        </listitem>

        <listitem>
          <para>unsigned char -&gt; int</para>
        </listitem>

        <listitem>
          <para>short -&gt; int</para>
        </listitem>

        <listitem>
          <para>unsigned short -&gt; int or unsigned int</para>
        </listitem>

        <listitem>
          <para>int -&gt; int</para>
        </listitem>

        <listitem>
          <para>unsigned int -&gt; unsigned int</para>
        </listitem>

        <listitem>
          <para>long -&gt; long</para>
        </listitem>

        <listitem>
          <para>unsigned long -&gt; unsigned long</para>
        </listitem>
      </itemizedlist>

      <note>
        <para>Even with these simple built-in types, there is a degree of
          uncertainty, namely concerning the promotion of unsigned short. On most
          machines, int is strictly larger than short so the promotion of
          unsigned short is int. However, it is possible for short and int to
          have the same size, in which case the promotion is unsigned int. When
          using the ISO C promotion rules, the checker usually avoids making
          assumptions about the implementation by treating the promotion of
          unsigned short as an abstract integral type. If, however, the
          <literal>-Y32bit</literal> option is specified, int is assumed to be
          strictly larger than short, and unsigned short promotes to int.</para>
      </note>

      <para><literal>The traditional C integer promotion rules</literal> are
        often referred to as the signed promotion rules. Under these rules, long
        integral types promote to themselves, as in ISO C, but the other integral
        types promote to unsigned int if they are qualified by unsigned, and int
        otherwise. Thus the signed promotion rules may be represented as
        follows:</para>

      <itemizedlist>
        <listitem>
          <para>char -&gt; int</para>
        </listitem>

        <listitem>
          <para>signed char -&gt; int</para>
        </listitem>

        <listitem>
          <para>unsigned char -&gt; unsigned int</para>
        </listitem>

        <listitem>
          <para>short -&gt; int</para>
        </listitem>

        <listitem>
          <para>unsigned short -&gt; unsigned int</para>
        </listitem>

        <listitem>
          <para>int -&gt; int</para>
        </listitem>

        <listitem>
          <para>unsigned int -&gt; unsigned int</para>
        </listitem>

        <listitem>
          <para>long -&gt; long</para>
        </listitem>

        <listitem>
          <para>unsigned long -&gt; unsigned long</para>
        </listitem>
      </itemizedlist>

      <para>The traditional promotion rules are applied in the
        <literal>Xt</literal> built-in environment only. All of the other
        built-in environments specify the ISO C promotion rules. Users may also
        specify their own rules for integer promotions and minimum integer
        ranges; the methods for doing this are described in Annex H.</para>
    </sect1>

    <sect1 id='arithmetic-oper'>
      <title>Arithmetic operations on integer types</title>

      <para><literal>The ISO C standard rules</literal> for calculating the
        type of an arithmetic operation involving two integer types is as follows
        - work out the integer promotions of the types of the two operands,
        then:</para>

      <itemizedlist>
        <listitem>
          <para>If either promoted type is unsigned long, the result type is
            unsigned long;</para>
        </listitem>

        <listitem>
          <para>Otherwise, if one promoted type is long and the other is
            unsigned int, then if a long int can represent all values of an
            unsigned int, the result type is long; otherwise the result type is
            unsigned long;</para>
        </listitem>

        <listitem>
          <para>Otherwise, if either promoted type is long, the result type is
            long;</para>
        </listitem>

        <listitem>
          <para>Otherwise, if either promoted type is unsigned int, the result
            type is unsigned int;</para>
        </listitem>

        <listitem>
          <para>Otherwise the result type is int.</para>
        </listitem>
      </itemizedlist>

      <para>Both promoted values are converted to the result type, and the
        operation is then applied.</para>
    </sect1>

    <sect1 id='int-int-conv-checks'>
      <title>Interaction with the integer conversion checks</title>

      <para>A simple-minded implementation of the integer conversion checks
        described in 3.2 would interact badly with these rules. Consider, for
        example, adding two values of type char:</para>
<programlisting>
char f ( char a, char b )
{
  char c = a + b ;
  return ( c ) ;
}
</programlisting>

      <para>The various stages in the calculation of c are as follows - a and b
        are converted to their promotion type, int, added together to give an int
        result, which is converted to a char and assigned to c. The conversions
        of a and b from char to int are always safe, and so present no
        difficulties to the integer conversion checks. The conversion of the
        result from int to char, however, is precisely the type of value
        destroying conversion which these checks are designed to detect.</para>

      <para>Obviously, an integer conversion check which flagged all char
        arithmetic would never be used, thereby losing the potential to detect
        many subtle portability errors. For this reason, the integer conversion
        checks are more sophisticated. In all typed languages, the type is used
        for two purposes - for static type checking and for expressing
        information about the actual representation of data on the target
        machine. Essentially it is a confusion between these two roles which
        leads to the problems above. The C promotion and arithmetic rules are
        concerned with how data is represented and manipulated, rather than the
        underlying abstract types of this data. When a and b are promoted to int
        prior to being added together, this is only a change in representation;
        at the conceptual level they are still char's. Again, when they are
        added, the result may be represented as an int, but conceptually it is a
        char. Thus the assignment to c, an actual char, is just a change in
        representation, not a change in conceptual type.</para>

      <para>So each expression may be regarded as having two types - a
        conceptual type which stands for what the expression means, and a
        representational type which stands for how the expression is to
        represented as data on the target machine. In the vast majority of
        expressions, these types coincide, however the integral promotion and
        arithmetic conversions are changes of representational, not conceptual,
        types. The integer conversion checks are concerned with detecting changes
        of conceptual type, since it is these which are most likely to be due to
        actual programming errors.</para>

      <para>It is possible to define integral types within the TenDRA
        extensions to C in which the split between concept and representation is
        made explicit. The pragma:</para>
<programlisting>
#pragma TenDRA keyword TYPE for type representation
</programlisting>

      <para>may be used to introduce a keyword TYPE for this purpose (as with
        all such pragmas, the precise keyword to be used is left to the user).
        Once this has been done, TYPE ( r, t ) may be used to represent a type
        which is conceptually of type t but is represented as data like type r.
        Both t and r must be integral types. For example:</para>
<programlisting>
TYPE ( int, char ) a ;
</programlisting>

      <para>declares a variable a which is represented as an int, but is
        conceptually a char.</para>

      <para>In order to maintain compatibility with other compilers, it is
        necessary to give TYPE a sensible alternative definition. For all but
        conversion checking purposes, TYPE ( r, t ) is identical to r, so a
        suitable definition is:</para>
<programlisting>
#ifdef __TenDRA__
#pragma TenDRA keyword TYPE for type representation
#else
#define TYPE( r, t ) r
#endif
</programlisting>
    </sect1>

    <sect1 id='target-dep-int-types'>
      <title>Target dependent integral types</title>

      <para>Since the checker uses only information about the minimum
        guaranteed ranges of integral types, integer values for which the actual
        type of the values is unknown may arise. Integer values of undetermined
        type generally arise in one of two ways: through the use of integer
        literals and from API types which are not completely specified.</para>

      <sect2 id='int-literals'>
        <title>Integer literals</title>

        <para><literal>The ISO C rules</literal> on the type of integer
          literals are set out as follows. For each class of integer literals a
          list of types is given. The type of an integer literal is then the
          first type in the appropriate list which is large enough to contain the
          value of the integer literal. The class of the integer literal depends
          on whether it is decimal, hexadecimal or octal, and whether it is
          qualified by U (or u) or L (or l) or both. The rules may be summarised
          as follows:</para>

        <itemizedlist>
          <listitem>
            <para>decimal -&gt; int or long or unsigned long</para>
          </listitem>

          <listitem>
            <para>hex or octal -&gt; int or unsigned int or long or unsigned
              long</para>
          </listitem>

          <listitem>
            <para>any + U -&gt; unsigned int or unsigned long</para>
          </listitem>

          <listitem>
            <para>any + L -&gt; long or unsigned long</para>
          </listitem>

          <listitem>
            <para>any + UL -&gt; unsigned long</para>
          </listitem>
        </itemizedlist>

        <para>These rules are applied in all the built-in checking modes except
          <literal>Xt</literal>. Traditional C does not have the U and L
          qualifiers, so if the <literal>Xt</literal> mode is used, these
          qualifiers are ignored and all integer literals are treated as int,
          long or unsigned long, depending on the size of the number.</para>

        <para>If a number fits into the minimal range for the first type of the
          appropriate list, then it is of that type; otherwise its type is
          undetermined and is said to be target dependent. The checker treats
          target dependent types as abstract integral types which may lead to
          integer conversion problems. For example, in:</para>
<programlisting>
int f ( int n ) {
  return ( n &amp; 0xff00 ) ;
}
</programlisting>

        <para>the type of 0xff00 is target dependent, since it does not fit
          into the minimal range for int specified by the ISO C standard (this is
          detected by the integer overflow analysis described in section 4.6).
          The arithmetic conversions resulting from the &amp; operation is
          detected by the checker's conversion analysis. Note that if the -Y32bit
          option is specified to tchk, an int is assumed to contain at least 32
          bits. In this case, 0xff00 fits into the type int, and so this is the
          type of the integer literal. No invalid integer conversions is then
          detected.</para>
      </sect2>

      <sect2 id='abstract-api-types'>
        <title>Abstract API types</title>

        <para>Target dependent integral types also occur in API specifications
          and may be encountered when checking against one of the
          implementation-independent APIs provided with the checker. The
          commonest example of this is size_t, which is stated by the ISO C
          standard to be a target dependent unsigned integral type, and which
          arises naturally within the language as the type of a sizeof
          expression.</para>

        <para>The checker has its own internal version of size_t, wchar_t and
          ptrdiff_t for evaluating static compile-time expressions. These
          internal types are compatible with the ISO C specification of size_t,
          wchar_t and ptrdiff_t, and thus are compatible with any conforming
          definitions of these types found in included files. However, when
          checking the following program against the system headers, a warning is
          produced on some machines concerning the implicit conversion of an
          unsigned int to type size_t:</para>
<programlisting>
#include &lt;stdlib.h&gt;
int main() {
  size_t size;
  size = sizeof(int);
}
</programlisting>

        <para>The system header on the machine in question actually defines
          size_t to be a signed int (this of course contravenes the ISO C
          standard) but the compile time function sizeof returns the checker's
          internal version of size_t which is an abstract unsigned integral type.
          By using the pragma:</para>
<programlisting>
#pragma TenDRA set size_t:signed int
</programlisting>

        <para>the checker can be instructed to use a different internal
          definition of size_t when evaluating the sizeof function and the error
          does not arise. Equivalent options are also available for the ptrdiff_t
          and wchar_t types.</para>
      </sect2>
    </sect1>

    <sect1 id='int-overflow-checks'>
      <title>Integer overflow checks</title>

      <para>Given the complexity of the rules governing the types of integers
        and results of integer operations, as well as the variation of integral
        ranges with machine architecture, it is hardly surprising that unexpected
        results of integer operations are at the root of many programming
        problems. These problems can often be hard to track down and may suddenly
        appear in an application which was previously considered "safe", when it
        is moved to a new system. Since the checker supports the concept of a
        guaranteed minimum size of an integer it is able to detect many potential
        problems involving integer constants. The pragma:</para>
<programlisting>
#pragma TenDRA integer overflow analysis <emphasis>status</emphasis>
</programlisting>

      <para>where <literal>status</literal> is <literal>on</literal>,
        <literal>warning</literal> or <literal>off</literal>, controls a set of
        checks on arithmetic expressions involving integer constants. These
        checks cover overflow, use of constants exceeding the minimum guaranteed
        size for their type and division by zero. They are not enabled in the
        default mode.</para>

      <para>There are two special cases of integer overflow for which checking
        is controlled separately:</para>

      <para><literal>Bitfield sizes</literal>. Obviously, the size of a
        bitfield must be smaller than or equal to the minimum size of its
        integral type. A bitfield which is too large is flagged as an error in
        the default mode. The check on bitfield sizes is controlled by:</para>
<programlisting>
#pragma TenDRA bitfield overflow <emphasis>permit</emphasis>
</programlisting>

      <para>where <emphasis>permit</emphasis> is one of
        <literal>allow</literal>, <literal>disallow</literal> or
        <literal>warning</literal>.</para>

      <para><literal>Octal and hexadecimal escape sequences</literal>.
        According to the ISO C standard, the value of an octal or hexadecimal
        escape sequence shall be in the range of representable values for the
        type unsigned char for an integer character constant, or the unsigned
        type corresponding to wchar_t for a wide character constant. The check on
        escape sequence sizes is controlled by:</para>
<programlisting>
#pragma TenDRA character escape overflow <emphasis>permit</emphasis>
</programlisting>

      <para>where the options for <emphasis>permit</emphasis> are
        <literal>allow</literal>, <literal>warning</literal> and
        <literal>disallow</literal>. The check is switched on by default.</para>
    </sect1>

    <sect1 id='int-operator-checks'>
      <title>Integer operator checks</title>

      <para>The results of some integer operations are undefined by the ISO C
        standard for certain argument types. Others are implementation-defined or
        simply likely to produce unexpected results.In the default mode such
        operations are processed silently, however a set of checks on operations
        involving integer constants may be controlled using:</para>
<programlisting>
#pragma TenDRA integer operator analysis <emphasis>status</emphasis>
</programlisting>

      <para>where <emphasis>status</emphasis> is replaced by
        <literal>on</literal>, <literal>warning</literal> or
        <literal>off</literal>. This pragma enables checks on:</para>

      <itemizedlist>
        <listitem>
          <para>shift operations where an expression is shifted by a negative
            number or by an amount greater than or equal to the width in bits of
            the expression being shifted;</para>
        </listitem>

        <listitem>
          <para>right shift operation with a negative value of signed integral
            type as the first argument;</para>
        </listitem>

        <listitem>
          <para>division operation with a negative operand;</para>
        </listitem>

        <listitem>
          <para>test for an unsigned value strictly greater than or less than 0
            (these are always true or false respectively);</para>
        </listitem>

        <listitem>
          <para>conversion of a negative constant value to an unsigned
            type;</para>
        </listitem>

        <listitem>
          <para>application of unary - operator to an unsigned value.</para>
        </listitem>
      </itemizedlist>
    </sect1>

    <sect1 id='support-bit-int'>
      <title>Support for 64 bit integer types (long long)</title>

      <para>Although the use of long long to specify a 64 bit integer type is
        not supported by the ISO C standard it is becoming increasingly popular
        as in programming use. By default, tchk does not support the use of long
        long but the checker can be configured to support the long long type to
        different degrees using the following pragmas:</para>
<programlisting>
#pragma TenDRA longlong type <emphasis>permit</emphasis>
</programlisting>

      <para>where <emphasis>permit</emphasis> is one of
        <literal>allow</literal> (long long type accepted),
        <literal>disallow</literal> (errors produced when long long types are
        detected) or <literal>warning</literal> (long long type are accepted but
        a warning is raised).</para>
<programlisting>
#pragma TenDRA set longlong type : type_name
</programlisting>

      <para>where <emphasis>type_name</emphasis> is <literal>long</literal> or
        <literal>long long</literal>.</para>

      <para>The first pragma determines the behaviour of the checker if the
        type long long is encountered as a type specifier. In the disallow case,
        an error is raised and the type specifier mapped to long, otherwise the
        type is stored as long long although a message alerting the user to the
        use of long long is raised in the warning mode. The second pragma
        determines the semantics of long long. If the type specified is long
        long, then long long is treated as a separate integer type and if code
        generation is enabled, long long types appears in the output. Otherwise
        the type is mapped to long and all objects declared long long are output
        as if they had been declared long (a warning is produced when this
        occurs). In either case, long long is treated as a distinct integer type
        for the purpose of integer conversion checking.</para>

      <para>Extensions to the integer promotion and arithmetic conversion rules
        are required for the long long type. These have been implemented as
        follows:</para>

      <itemizedlist>
        <listitem>
          <para>the types of integer arithmetic operations where neither
            argument has long long type are unaffected;</para>
        </listitem>

        <listitem>
          <para>long long and unsigned long long both promote to
            themselves;</para>
        </listitem>

        <listitem>
          <para>the result type of arithmetic operations with one or more
            arguments of type unsigned long long is unsigned long long;</para>
        </listitem>

        <listitem>
          <para>otherwise if either argument has type signed long long the
            overall type is long long if both arguments can be represented in
            this form, otherwise the type is unsigned long long.</para>
        </listitem>
      </itemizedlist>

      <para>There are now three cases where the type of an integer arithmetic
        operation is not completely determined from the type of its arguments,
        i.e.</para>

      <orderedlist>
        <listitem>
          <para>signed long long + unsigned long = signed long long
            <emphasis>or</emphasis> unsigned long long;</para>
        </listitem>

        <listitem>
          <para>signed long long + unsigned int = signed long long
            <emphasis>or</emphasis> unsigned long long;</para>
        </listitem>

        <listitem>
          <para>signed int + unsigned short = signed int
            <emphasis>or</emphasis> unsigned int ( as before ).</para>
        </listitem>
      </orderedlist>

      <para>In these cases, the type of the operation is represented using an
        abstract integral type as described in section <xref linkend='int-promotion-rules'> 
    </sect1>
  </chapter>

  <chapter id='data-flow-var-analysis'>
    <title>Data Flow and Variable Analysis</title>

    <para>The checker has a number of features which can be used to help track
      down potential programming errors relating to the use of variables within a
      source file and the flow of control through the program. Examples of this
      are detecting sections of unused code, flagging expressions that depend
      upon the order of evaluation where the order is not defined, checking for
      unused static variables, etc.</para>

    <sect1 id='unreachable-code'>
      <title>Unreachable code analysis</title>

      <para>Consider the following function definition:</para>
<programlisting>
int f ( int n )
{
  if ( n ) {
  return ( 1 );
} else {
  return ( 0 );
}
  return ( 2 );
}
</programlisting>

      <para>The final return statement is redundant since it can never be
        reached. The test for unreachable code is controlled by:</para>
<programlisting>
#pragma TenDRA unreachable code <emphasis>permit</emphasis>
</programlisting>

      <para>where permit is replaced by <literal>disallow</literal> to give an
        error if unreached code is detected, <literal>warning</literal> to give a
        warning, or <literal>allow</literal> to disable the test (this is the
        default).</para>

      <para>There are also equivalent command-line options to tchk of the form
        <literal>-X:unreached=</literal><literal>state</literal>, where
        <literal>state</literal> can be <literal>check</literal>,
        <literal>warn</literal> or <literal>dont</literal>.</para>

      <para>Annotations to the code in the form of user-defined keywords may be
        used to indicate that a certain statement is genuinely reached or
        unreached. These keywords are introduced using:</para>
<programlisting>
#pragma TenDRA keyword REACHED for set reachable
#pragma TenDRA keyword UNREACHED for set unreachable
</programlisting>

      <para>The statement REACHED then indicates that this portion of the
        program is actually reachable, whereas UNREACHED indicates that it is
        unreachable. For example, one way of fixing the program above might be to
        say that the final return is reachable (this is a blatant lie, but never
        mind). This would be done as follows:</para>
<programlisting>
int f ( int n ) {
  if ( n ) {
return ( 1 );
  } else {
return ( 0 )
  }
  REACHED
  return ( 2 );
}
</programlisting>

      <para>An example of the use of UNREACHED might be in the function below
        which falls out of the bottom without a return statement. We might know
        that, because it is never called with c equal to zero, the end of the
        function is never reached. This could be indicated as follows:</para>
<programlisting>
int f ( int c ){
  if ( c ) return ( 1 );
  UNREACHED
}
</programlisting>

      <para>As always, if new keywords are introduced into a program then
        definitions need to be provided for conventional compilers. In this case,
        this can be done as follows:</para>
<programlisting>
#ifdef __TenDRA__
#pragma TenDRA keyword REACHED for set reachable
#pragma TenDRA keyword UNREACHED for set unreachable
#else
#define REACHED
#define UNREACHED
#endif
</programlisting>
    </sect1>

    <sect1 id='case-fall-through'>
      <title>Case fall through</title>

      <para>Another flow analysis check concerns fall through in case
        statements. For example, in:</para>
<programlisting>
void f ( int n )
{
  switch ( n ) {
case 1 : puts ( "one" );
   case 2 : puts ( "two" );
  }
}
</programlisting>

      <para>the control falls through from the first case to the second. This
        may be due to an error in the program (a missing break statement), or be
        deliberate. Even in the latter case, the code is not particularly
        maintainable as it stands - there is always the risk when adding a new
        case that it will interrupt this carefully contrived flow. Thus it is
        customary to comment all case fall throughs to serve as a warning.</para>

      <para>In the default mode, the TenDRA C checker ignores all such fall
        throughs. A check to detect fall through in case statements is controlled
        by:</para>
<programlisting>
#pragma TenDRA fall into case <emphasis>permit</emphasis>
</programlisting>

      <para>where <literal>permit</literal> is <literal>allow</literal> (no
        errors), <literal>warning</literal> (warn about case fall through) or
        <literal>disallow</literal> (raise errors for case fall through).</para>

      <para>There are also equivalent command-line options to tcc of the form
        -<literal>X:fall_thru=</literal><literal>state</literal>, where
        <literal>state</literal> can be <literal>check</literal>,
        <literal>warn</literal> or <literal>dont</literal>.</para>

      <para>Deliberate case fall throughs can be indicated by means of a
        keyword, which has been introduced using:</para>
<programlisting>
#pragma TenDRA keyword FALL_THROUGH for fall into case
</programlisting>

      <para>Then, if the example above were deliberate, this could be indicated
        by:</para>
<programlisting>
void f ( int n ){
  switch ( n ) {
case 1 : puts ( "one" );
FALL_THROUGH
case 2 : puts ( "two" );
  }
}
</programlisting>

      <note>
        <para>FALL_THROUGH is inserted between the two cases, rather than at
          the end of the list of statements following the first case.</para>
      </note>

      <para>If a keyword is introduced in this way, then an alternative
        definition needs to be introduced for conventional compilers. This might
        be done as follows:</para>
<programlisting>
#ifdef __TenDRA__
#pragma TenDRA keyword FALL_THROUGH for fall into case
#else
#define FALL_THROUGH
#endif
</programlisting>
    </sect1>

    <sect1 id='unusual-flow-cond'>
      <title>Unusual flow in conditional statements</title>

      <para>The following three checks are designed to detect possible errors
        in conditional statements.</para>

      <sect2 id='empty-statements'>
        <title>Empty if statements</title>

        <para>Consider the following C statements:</para>
<programlisting>
if( var1 == 1 ) ;
var2 = 0 ;
</programlisting>

        <para>The conditional statement serves no purpose here and the second
          statement will always be executed regardless of the value of var1. This
          is almost certainly not what the programmer intended to write. A test
          for if statements with no body is controlled by:</para>
<programlisting>
#pragma TenDRA extra ; after conditional <emphasis>permit</emphasis>
</programlisting>

        <para>with the usual <literal>allow</literal> (this is the default
          setting), <literal>warning</literal> and <literal>disallow</literal>
          options for <emphasis>permit</emphasis>.</para>
      </sect2>

      <sect2 id='use-assignments-cont'>
        <title>Use of assignments as control expressions</title>

        <para>Using the C assignment operator, `=', when the equality operator
          `==' was intended is an extremely common problem. The pragma:</para>
<programlisting>
#pragma TenDRA assignment as bool <emphasis>permit</emphasis>
</programlisting>

        <para>is used to control the treatment of assignments used as the
          controlling expression of a conditional statement or a loop,
          e.g.</para>
<programlisting>
if( var = 1 ) { ...
</programlisting>

        <para>The options for <emphasis>permit</emphasis> are
          <literal>allow</literal>, <literal>warning</literal> and
          <literal>disallow</literal>. The default setting allows assignments to
          be used as control statements without raising an error.</para>
      </sect2>

      <sect2 id='constant-cont-exp'>
        <title>Constant control expressions</title>

        <para>Statements with constant control expressions are not really
          conditional at all since the value of the control statement can be
          evaluated statically. Although this feature is sometimes used in loops,
          relying on a break, goto or return statement to end the loop, it may be
          useful to detect all constant control expressions to check that they
          are deliberate. The check for statically constant control expressions
          is controlled using:</para>
<programlisting>
#pragma TenDRA const conditional <emphasis>permit</emphasis>
</programlisting>

        <para>where permit may be replaced by <literal>disallow</literal> to
          give an error when constant control expressions are encountered,
          <literal>warning</literal> <emphasis>to replace the error by a
          warning,</emphasis> or the check may be switched off using the
          <literal>allow</literal> (this is the default).</para>
      </sect2>
    </sect1>

    <sect1 id='operator-precedence'>
      <title>Operator precedence</title>

      <para>The ISO C standard section 6.3, provides a set of rules governing
        the order in which operators within expressions should be applied. These
        rules are said to specify the operator precedence and are summarised in
        the table over the page. Operators on the same line have the same
        precedence and the rows are in order of decreasing precedence. Note that
        the unary +, -, * and &amp; operators have higher precedence than the
        binary forms and thus appear higher in the table.</para>

      <para>The precedence of operators is not always intuitive and often leads
        to unexpected results when expressions are evaluated. A particularly
        common example is to write:</para>
<programlisting>
if ( var &amp; TEST == 1) { ...
}
else { ...
</programlisting>

      <para>assuming that the control expression will be evaluated as:</para>
<programlisting>
( ( var &amp; TEST ) == 1 )
</programlisting>

      <para>However, the == operator has a higher precedence than the bitwise
        &amp; operator and the control expression is evaluated as:</para>
<programlisting>
( var &amp; ( TEST == 1 ) )
</programlisting>

      <para>which in general will give a different result</para>

      <table frame='all' id='iso-c-rules'>
        <title>ISO C Rules for Operator Precedence</title>

        <tgroup cols='2'>
          <thead>
            <row>
              <entry>operators</entry>

              <entry>Precedence</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>function call() [] -&gt; . ++(postfix) --(postfix)</entry>

              <entry>highest</entry>
            </row>

            <row>
              <entry>[ - ++ -- + - * & (type) sizeof</entry>

              <entry></entry>
            </row>

            <row>
              <entry>* / %</entry>

              <entry></entry>
            </row>

            <row>
              <entry>+(binary) -(binary)</entry>

              <entry></entry>
            </row>

            <row>
              <entry>&lt;&lt; &gt;&gt;</entry>

              <entry></entry>
            </row>

            <row>
              <entry>&lt;&lt;= &gt;&gt;=</entry>

              <entry></entry>
            </row>

            <row>
              <entry>== [=</entry>

              <entry></entry>
            </row>

            <row>
              <entry>&</entry>

              <entry></entry>
            </row>

            <row>
              <entry>^</entry>

              <entry></entry>
            </row>

            <row>
              <entry>|</entry>

              <entry></entry>
            </row>

            <row>
              <entry>&&</entry>

              <entry></entry>
            </row>

            <row>
              <entry>||</entry>

              <entry></entry>
            </row>

            <row>
              <entry>?;</entry>

              <entry></entry>
            </row>

            <row>
              <entry>=+= -= *= /= %= &= ^= |= &lt;&lt;= &gt;&gt;=</entry>

              <entry></entry>
            </row>

            <row>
              <entry>.</entry>

              <entry>lowest</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>The TenDRA C checker can be configured to flag expressions
        containing certain operators whose precedence is commonly confused,
        namely:</para>

      <itemizedlist>
        <listitem>
          <para>&amp;&amp; <emphasis>versus</emphasis> ||</para>
        </listitem>

        <listitem>
          <para>&lt;&lt; <emphasis>and</emphasis> &gt;&gt;
            <emphasis>versus</emphasis> + <emphasis>and</emphasis> -</para>
        </listitem>

        <listitem>
          <para>&amp; <emphasis>versus</emphasis> == != &lt; &gt; &lt;= &gt;= +
            <emphasis>and</emphasis> -</para>
        </listitem>

        <listitem>
          <para>^ <emphasis>versus</emphasis> &amp; == |= &lt; &gt; &lt;= &gt;=
            + <emphasis>and</emphasis> -</para>
        </listitem>

        <listitem>
          <para>| <emphasis>versus</emphasis> ^ &amp; == |= &lt; &gt; &lt;=
            &gt;= + <emphasis>and</emphasis> -</para>
        </listitem>
      </itemizedlist>

      <para>The check is switched off by default and is controlled
        using:</para>
<programlisting>
#pragma TenDRA operator precedence <emphasis>status</emphasis>
</programlisting>

      <para>where <emphasis>status</emphasis> is <literal>on</literal>,
        <literal>warning</literal> or <literal>off</literal>.</para>
    </sect1>

    <sect1 id='var-analysis'>
      <title>Variable analysis</title>

      <para>The variable analysis checks are controlled by:</para>
<programlisting>
#pragma TenDRA variable analysis status
</programlisting>

      <para>where <literal>status</literal> is <literal>on</literal>,
        <literal>warning</literal> or <literal>off</literal> as usual. The checks
        are switched off in the default mode.</para>

      <para>There are also equivalent command line options to tchk of the form
        <literal>-X:variable=</literal><literal>state</literal>, where
        <literal>state</literal> can be <literal>check</literal>,
        <literal>warn</literal> or <literal>dont</literal>.</para>

      <para>The variable analysis is concerned with the evaluation of
        expressions and the use of local variables, including function arguments.
        Occasionally it may not be possible to statically perform a full analysis
        on an expression or variable and in these cases the messages produced
        indicate that there may be a problem. If a full analysis is possible a
        definite error or warning is produced. The individual checks are listed
        in sections 5.6.1 to 5.6.6 and section 5.7 describes the source
        annotations which can be used to fine-tune the variable analysis.</para>

      <sect2 id='order-evaluation'>
        <title>Order of evaluation</title>

        <para>The ISO C standard specifies certain points in the expression
          syntax at which all prior expressions encountered are guaranteed to
          have been evaluated. These positions are called sequence points and
          occur:</para>

        <itemizedlist>
          <listitem>
            <para>after the arguments and function expression of a function
              call have been evaluated but before the call itself;</para>
          </listitem>

          <listitem>
            <para>after the first operand of a logical &amp;&amp;, or ||
              operator;</para>
          </listitem>

          <listitem>
            <para>after the first operand of the conditional operator,
              ?:;</para>
          </listitem>

          <listitem>
            <para>after the first operand of the comma operator;</para>
          </listitem>

          <listitem>
            <para>at the end of any full expression (a full expression may take
              one of the following forms: an initialiser; the expression in an
              expression statement; the controlling expression in an
              <literal>if</literal>, <literal>while</literal>,
              <literal>do</literal> or <literal>switch</literal> statement; each
              of the three optional expressions of a <literal>for</literal>
              statement; or the optional expression of a
              <literal>return</literal> statement).</para>
          </listitem>
        </itemizedlist>

        <para>Between two sequence points however, the order in which the
          operands of an operator are evaluated, and the order in which side
          effects take place is unspecified - any order which conforms to the
          operator precedence rules above is permitted. For example:</para>
<programlisting>
var = i + arr[ i++ ] ;
</programlisting>

        <para>may evaluate to different values on different machines, depending
          on which argument of the + operator is evaluated first. The checker can
          detect expressions which depend on the order of evaluation of
          sub-expressions between sequence points and these are flagged as errors
          or warnings when the variable analysis is enabled.</para>
      </sect2>

      <sect2 id='mod-between-seq'>
        <title>Modification between sequence points</title>

        <para>The ISO C standard states that if an object is modified more than
          once, or is modified and accessed other than to determine the new
          value, between two sequence points, then the behaviour is undefined.
          Thus the result of:</para>
<programlisting>
var = arr[i++] + i++ ;
</programlisting>

        <para>is undefined, since the value of i is being incremented twice
          between sequence points. This behaviour is detected by the variable
          analysis.</para>
      </sect2>

      <sect2 id='operand-sizeof'>
        <title>Operand of sizeof operator</title>

        <para>According to the ISO C standard, section 6.3.3.4, the operand of
          the sizeof operator is not itself evaluated. If the operand has any
          side-effects these will not occur. When the variable analysis is
          enabled, the checker detects the use of expressions with side-effects
          in the operand of the sizeof operator.</para>
      </sect2>

      <sect2 id='unused-var'>
        <title>Unused variables</title>

        <para>As part of the variable analysis, a simple test applied to each
          local variable at the end of its scope to determine whether it has been
          used in that scope. For example, in:</para>
<programlisting>
int f ( int n )
{
  int r;
  return ( 0 );
}
</programlisting>

        <para>both the function argument n and the local variable r are
          unused.</para>
      </sect2>

      <sect2 id='values-set-used'>
        <title>Values set and not used</title>

        <para>This is a more complex test since it is applied to every instance
          of setting the variable. For example, in:</para>
<programlisting>
int f ( int n )
{
  int r = 1;
  r = 5;
  return ( r );
}
</programlisting>

        <para>the first value r is set to 1 and is not used before it is
          overwritten by 5 (this second value is used however). This test
          requires some flow analysis. For example, if the program is modified
          to:</para>
<programlisting>
int f ( int n )
{
  int r = 1;
  if ( n == 3 ) {
r = 5;
  }
  return ( r );
}
</programlisting>

        <para>the initial value of r is used when n != 3, so no error is
          detected. However in:</para>
<programlisting>
int f ( int n )
{
  int r = 1;
  if ( n == 3 ) {
r = 5;
  } else {
r = 6;
  }
  return ( r );
}
</programlisting>

        <para>the initial value of r is overwritten regardless of the result of
          the conditional, and hence is unused.</para>
      </sect2>

      <sect2 id='variable-not-used'>
        <title>Variable which has not been set is used</title>

        <para>This test also requires some flow analysis, for example
          in:</para>
<programlisting>
int f ( int n )
{
  int r;
  if ( n == 3 ) {
r = 5;
  }
  return ( r );
}
</programlisting>

        <para>the use of the variable r as a return value is reported because
          there are paths leading to this statement in which r is not set (i.e.
          when n != 3). However, in:</para>
<programlisting>
int f ( int n )
{
  int r;
  if ( n == 3 ) {
r = 5;
  } else {
r = 6;
  }
  return ( r );
}
</programlisting>

        <para>r is always set before it is used, so no error is
          detected.</para>
      </sect2>
    </sect1>

    <sect1 id='overriding-var-analysis'>
      <title>Overriding the variable analysis</title>

      <para>Although many of the problems discovered by the variable analysis
        are genuine mistakes, some may be as the result of deliberate decisions
        by the program writer. In this case, more information needs to be
        provided to the checker to convey the programmer's intentions. Four
        constructs are provided for this purpose: the discard variable, the set
        variable, the exhaustive switch and the non-returning function.</para>

      <sect2 id='discarding-var'>
        <title>Discarding variables</title>

        <para>Actively discarding a variable counts as a use of that variable
          in the variable analysis, and so can be used to suppress messages
          concerning unused variables and values assigned to variables. There are
          two distinct methods to indicate that the variable x is to be
          discarded. The first uses a pragma:</para>
<programlisting>
#pragma TenDRA discard x;
</programlisting>

        <para>which the checker treats as if it were a C statement, ending in a
          semicolon. Having a statement which is noticed by one compiler but
          ignored by another can lead to problems. For example, in:</para>
<programlisting>
if ( n == 3 )
#pragma TenDRA discard x;
  puts ( "n is three" );
</programlisting>

        <para>tchk believes that x is discarded if n == 3 and the message is
          always printed, whereas other compilers will ignore the #pragma
          statement and think that the message is printed if n == 3. An
          alternative, in many ways neater, solution is to introduce a new
          keyword for discarding variables. For example, to introduce the keyword
          DISCARD for this purpose, the pragma:</para>
<programlisting>
#pragma TenDRA keyword DISCARD for discard variable
</programlisting>

        <para>should be used. The variable x can then be discarded by means of
          the statement:</para>
<programlisting>
DISCARD ( x );
</programlisting>

        <para>A dummy definition for DISCARD to use with normal compilers needs
          to be given in order to maintain compilability with those compilers.
          For example, a complete definition of DISCARD might be:</para>
<programlisting>
#ifdef __TenDRA__
#pragma TenDRA keyword DISCARD for discard variable
#else
#define DISCARD(x) (( void ) 0 )
#endif
</programlisting>

        <para>Discarding a variable changes its assignment state to unset, so
          that any subsequent uses of the variable, without an intervening
          assignment to it, lead to a "variable used before being set" error.
          This feature can be exploited if the same variable is used for distinct
          purposes in different parts of its scope, by causing the variable
          analysis to treat the different uses separately. For example,
          in:</para>
<programlisting>
void f ( void ) {
  int i = 0;
  while ( i++ &lt; 10 )
{ puts ( "hello" ); }
  while ( i++ &lt; 10 )
{ puts ( "goodbye" ); }
}
</programlisting>

        <para>which is intended to print both messages ten times, the two uses
          of i as a loop counter are independent - they could have been
          implemented with different variables. By discarding i after the first
          loop, the second loop can be analysed separately. In this way, the
          error of failing to reset i to 0 can be detected.</para>
      </sect2>

      <sect2 id='setting-var'>
        <title>Setting variables</title>

        <para>In addition to discarding variables, it is also possible to set
          them. In deliberately setting a variable, the programmer is telling the
          checker to assume that some value will always have been assigned to the
          variable by that point, so that any "variable used without being set"
          errors can be suppressed. This construct is particularly useful in
          programs with complex flow control, to help out the variable analysis.
          For example, in:</para>
<programlisting>
void f ( int n )
{
  int r;
  if ( n != 0 ) r = n;
  if ( n &gt; 2 ) {
printf ( "%d\n", r );
  }
}
</programlisting>

        <para>r is only used if n &gt; 2, in which case we also have n != 0, so
          that r has already been initialised. However, in its flow analysis, the
          TenDRA C checker treats all the conditionals it meets as if they were
          independent and does not look for any such complex dependencies (indeed
          it is possible to think of examples where such analysis would be
          impossible). Instead, it needs the programmer to clarify the flow of
          the program by asserting that r will be set if the second condition is
          true.</para>

        <para>Programmers may assert that the variable, r, is set either by
          means of a pragma:</para>
<programlisting>
#pragma TenDRA set r;
</programlisting>

        <para>or by using, for example:</para>
<programlisting>
SET ( r );
</programlisting>

        <para>where SET is a keyword which has previously been introduced to
          stand for the variable setting construct using:</para>
<programlisting>
#pragma TenDRA keyword SET for set
</programlisting>

        <note>
          <para>cf. DISCARD above.</para>
        </note>
      </sect2>

      <sect2 id='exhaustive-switch-state'>
        <title>Exhaustive switch statements</title>

        <para>A special case of a flow control construct which may be used to
          set the value of a variable is a switch statement. Consider the
          program:</para>
<programlisting>
char *f ( int n ){
  char *r;
  switch ( n ) {
case 1:r="one";break;
case 2:r="two";break;
case 3:r="three";break;
  }
  return ( r );
}
</programlisting>

        <para>This leads to an error indicating that r is used but not set,
          because it is not set if n lies outside the three cases in the switch
          statement. However, the programmer might know that f is only ever
          called with these three values, and hence that r is always set before
          it is used. This information could be expressed by asserting that r is
          set at the end of the switch construct (see above), but it would be
          better to express the cause of this setting rather than just its
          effect. The reason why r is always set is that the switch statement is
          exhaustive - there are case statements for all the possible values of
          n.</para>

        <para>Programmers may assert that a switch statement is exhaustive by
          means of a pragma immediately following it. For example, in the above
          case it would take the form:</para>
<programlisting>
....
switch ( n )
#pragma TenDRA exhaustive
{
  case 1:r="one";break;
  ....
</programlisting>

        <para>Again, there is an option to introduce a keyword, EXHAUSTIVE say,
          for exhaustive switch statements using:</para>
<programlisting>
#pragma TenDRA keyword EXHAUSTIVE for exhaustive
</programlisting>

        <para>Using this form, the example program becomes:</para>
<programlisting>
switch ( n ) EXHAUSTIVE {
  case 1:r="one";break;
</programlisting>

        <para>In order to maintain compatibility with existing compilers, a
          dummy definition for EXHAUSTIVE must be introduced for them to use. For
          example, a complete definition of EXHAUSTIVE might be:</para>
<programlisting>
#ifdef __TenDRA__
#pragma TenDRA keyword EXHAUSTIVE for exhaustive
#else
#define EXHAUSTIVE
#endif
</programlisting>
      </sect2>

      <sect2 id='non-returning-funct'>
        <title>Non-returning functions</title>

        <para>Consider a modified version of the program above, in which calls
          to f with an argument other than 1, 2 or 3 cause an error message to be
          printed:</para>
<programlisting>
extern void error (const char*);
char *f ( int n ) {
  char *r;
  switch ( n ) {
case 1:r="one";break;
case 2:r="two";break;
case 3:r="three";break;
default:error("Illegal value");
  }
  return ( r );
}
</programlisting>

        <para>This causes an error because, in the default case, r is not set
          before it is used. However, depending on the semantics of the function,
          error, the return statement may never be reached in this case. This is
          because the fact that a function returns void can mean one of two
          distinct things:</para>

        <orderedlist>
          <listitem>
            <para>That the function does not return a value. This is the usual
              meaning of void.</para>
          </listitem>

          <listitem>
            <para>That the function never returns, for example the library
              function, exit, uses void in this sense.</para>
          </listitem>
        </orderedlist>

        <para>If error never returns, then the program above is correct;
          otherwise, an unset value of r may be returned.</para>

        <para>Therefore, we need to be able to declare the fact that a function
          never returns. This is done by introducing a new type to stand for the
          non-returning meaning of void (some compilers use volatile void for
          this purpose). This is done by means of the pragma:</para>
<programlisting>
#pragma TenDRA type VOID for bottom
</programlisting>

        <para>to introduce a type VOID (although any identifier may be used)
          with this meaning. The declaration of error can then be expressed
          as:</para>
<programlisting>
extern VOID error (const char *);
</programlisting>

        <para>In order to maintain compatibility with existing compilers a
          definition of VOID needs to be supplied. For example:</para>
<programlisting>
#ifdef __TenDRA__
#pragma TenDRA type VOID for bottom
#else
typedef void VOID;
#endif
</programlisting>

        <para>The largest class of non-returning functions occurs in the
          various standard APIs - for example, exit and abort. The TenDRA
          descriptions of these APIs contain this information. The information
          that a function does not return is taken into account in all flow
          analysis contexts. For example, in:</para>
<programlisting>
#include &lt;stdlib.h&gt;
int f ( int n )
{
  exit ( EXIT_FAILURE );
  return ( n );
}
</programlisting>

        <para><literal>n</literal> is unused because the return statement is
          not reached (a fact that can also be determined by the unreachable code
          analysis in <xref linkend='unreachable-code'> .</para>
      </sect2>
    </sect1>

    <sect1 id='discard-analysis'>
      <title>Discard Analysis</title>

      <para>A couple of examples of what might be termed "discard analysis"
        have already been described - discarded (unused) local variables and
        discarded (unused) assignments to local variables (see section 5.6.4 and
        5.6.5). The checker can perform three more types of discard analysis:
        discarded function returns, discarded computations and unused static
        variables and procedures. These three tests may be controlled as a group
        using:</para>
<programlisting>
#pragma TenDRA discard analysis <emphasis>status</emphasis>
</programlisting>

      <para>where <emphasis>status</emphasis> is <literal>on</literal>,
        <literal>warning</literal> or <literal>off</literal>.</para>

      <para>In addition, each of the component tests may be switched on and off
        independently using pragmas of the form:</para>
<programlisting>
#pragma TenDRA discard analysis (function return) <emphasis>status</emphasis>
#pragma TenDRA discard analysis (value) <emphasis>status</emphasis>
#pragma TenDRA discard analysis (static) <emphasis>status</emphasis>
</programlisting>

      <para>There are also equivalent command line options to tchk of the form
        <literal>-X:</literal><literal>test</literal><literal>=</literal><literal>
        state</literal>, where <literal>test</literal> can be
        <literal>discard_all</literal>, <literal>discard_func_ret</literal> ,
        <literal>discard_value</literal> or <literal>unused_static</literal>, and
        <literal>state</literal> can be <literal>check</literal>,
        <literal>warn</literal> or <literal>dont</literal>. These checks are all
        switched off in the default mode.</para>

      <para>Detailed descriptions of the individual checks follow in sections
        5.8.1 - 5.8.3. Section 5.9 describes the facilities for fine-tuning the
        discard analysis.</para>

      <sect2 id='dicard-funct'>
        <title>Discarded function returns</title>

        <para>Functions which return a value which is not used form the
          commonest instances of discarded values. For example, in:</para>
<programlisting>
#include &lt;stdio.h&gt;
int main ()
{
  puts ( "hello" );
  return ( 0 );
}
</programlisting>

        <para>the function, puts, returns an int value, indicating whether an
          error has occurred, which is ignored.</para>
      </sect2>

      <sect2 id='discard-computed'>
        <title>Discarded computed values</title>

        <para>A rarer instance of a discarded object, and one which is almost
          always an error, is where a value is computed but not used. For
          example, in:</para>
<programlisting>
int f ( int n ) {
  int r = 4
  if ( n == 3 ) {
r == 5;
  }
  return ( r );
}
</programlisting>

        <para>the value r == 5 is computed but not used. This is actually
          because it is a misprint for r = 5.</para>
      </sect2>

      <sect2 id='unused-static-var'>
        <title>Unused static variables and procedures</title>

        <para>The final example of discarded values, which perhaps more
          properly belongs with the variable analysis tests mentioned above, is
          for static objects which are unused in the source module in which they
          are defined. Of course this means that they are unused in the entire
          program. Such objects can usually be removed.</para>
      </sect2>
    </sect1>

    <sect1 id='overrid-discard'>
      <title>Overriding the discard analysis</title>

      <para>As with the variable analysis, certain constructs may be used to
        provide the checker with extra information about a program, to convey the
        programmer's intentions more clearly.</para>

      <sect2 id='dicard-funct-compute'>
        <title>Discarding function returns and computed values</title>

        <para>Unwanted function returns and, more rarely, discarded computed
          values, may be actively ignored to indicate to the discard analysis
          that the value is being discarded deliberately. This can be done using
          the traditional method of casting the value to void:</para>
<programlisting>
( void ) puts ( "hello" );
</programlisting>

        <para>or by introducing a keyword, IGNORE say, for discarding a value.
          This is done using a pragma of the form:</para>
<programlisting>
#pragma TenDRA keyword IGNORE for discard value
</programlisting>

        <para>The example discarded value then becomes:</para>
<programlisting>
IGNORE puts ( "hello" );
</programlisting>

        <para>Of course it is necessary to introduce a definition of IGNORE for
          conventional compilers in order to maintain compilability. A suitable
          definition might be:</para>
<programlisting>
#ifdef __TenDRA__
#pragma TenDRA keyword IGNORE for discard value
#else
#define IGNORE ( void )
#endif
</programlisting>
      </sect2>

      <sect2 id='preserving-unised'>
        <title>Preserving unused statics</title>

        <para>Occasionally unused static values are introduced deliberately
          into programs. The fact that the static variables or procedures x, y
          and z are deliberately unused may be indicated by introducing the
          pragma:</para>
<programlisting>
#pragma TenDRA suspend static x y z
</programlisting>

        <para>at the outer level after the definition of all three
          objects.</para>
      </sect2>
    </sect1>
  </chapter>

  <chapter id='preprocessing-checks'>
    <title>Preprocessing checks</title>

    <para>This chapter describes tchk's capabilities for checking the
      preprocessing constructs that arise in C.</para>

    <sect1 id='preprocessor-directives'>
      <title>Preprocessor directives</title>

      <para>By default, the TenDRA C checker understands those preprocessor
        directives specified by the ISO C standard, section 6.8, i.e. #if,
        #ifdef, #ifndef, #elif, #else, #endif, #error, #line and #pragma. As has
        been mentioned, #pragma statements play a significant role in the
        checker. While any recognised #pragma statements are processed, all
        unknown pragma statements are ignored by default. The check to detect
        unknown pragma statements is controlled by:</para>
<programlisting>
#pragma TenDRA unknown pragma <emphasis>permit</emphasis>
</programlisting>

      <para>The option for <emphasis>permit</emphasis> are
        <literal>disallow</literal> (raise an error if an unknown pragma is
        encountered), <literal>warning</literal> (allow unknown pragmas with a
        warning), or <literal>allow</literal> (allow unknown pragmas without
        comment).</para>

      <para>In addition, the common non-ISO preprocessor directives, #file,
        #ident, #assert, #unassert and #weak may be permitted using:</para>
<programlisting>
#pragma TenDRA directive <emphasis>dir</emphasis> allow
</programlisting>

      <para>where <emphasis>dir</emphasis> is the appropriate one of
        <literal>file</literal>, <literal>ident</literal> ,
        <literal>assert</literal>, <literal>unassert</literal> or
        <literal>weak</literal>. If <literal>allow</literal> is replaced by
        <literal>warning</literal> then the directive is allowed, but a warning
        is issued. In either case, the modifier <literal>(ignore)</literal> may
        be added to indicate that, although the directive is allowed, its effect
        is ignored. Thus for example:</para>
<programlisting>
#pragma TenDRA directive ident (ignore) allow
</programlisting>

      <para>causes the checker to ignore any #ident directives without raising
        any errors.</para>

      <para>Finally, the directive dir can be disallowed using:</para>
<programlisting>
#pragma TenDRA directive <emphasis>dir</emphasis> disallow
</programlisting>

      <para>Any other unknown preprocessing directives cause the checker to
        raise an error in the default mode. The pragma may be used to force the
        checker to ignore such directives without raising any errors.</para>
<programlisting>
#pragma TenDRA unknown directive allow
</programlisting>

      <para><literal>Disallow</literal> and <literal>warning</literal> variants
        are also available.</para>
    </sect1>

    <sect1 id='indented-preprocessing'>
      <title>Indented Preprocessing Directives</title>

      <para>The ISO C standard allows white space to occur before the # in a
        preprocessing directive, and between the # and the directive name. Many
        older preprocessors have problems with such directives. The checker's
        treatment of such directives can be set using:</para>
<programlisting>
#pragma TenDRA indented # directive <emphasis>permit</emphasis>
</programlisting>

      <para>which detects white space before the # and:</para>
<programlisting>
#pragma TenDRA indented directive after # <emphasis>permit</emphasis>
</programlisting>

      <para>which detects white space between the # and the directive name. The
        options for <emphasis>permit</emphasis> are <literal>allow</literal>,
        <literal>warning</literal> or <literal>disallow</literal> as usual. The
        default checking profile allows both forms of indented directives.</para>
    </sect1>

    <sect1 id='multiple-macro'>
      <title>Multiple macro definitions</title>

      <para>The ISO C standard states that, for two definitions of a
        function-like macro to be equal, both the spelling of the parameters and
        the macro definition must be equal. Thus, for example, in:</para>
<programlisting>
#define f( x ) ( x )
#define f( y ) ( y )
</programlisting>

      <para>the two definitions of f are not equal, despite the fact that they
        are clearly equivalent. Tchk has an alternative definition of macro
        equality which allows for consistent substitution of parameter names. The
        type of macro equality used is controlled by:</para>
<programlisting>
#pragma TenDRA weak macro equality allow
</programlisting>

      <para>where permit is <literal>allow</literal> (use alternative
        definition of macro equality),<literal>warning</literal> (as for allow
        but raise a warning), or <literal>disallow</literal> (use the ISO C
        definition of macro equality - this is the default setting).</para>

      <para>More generally, the pragma:</para>
<programlisting>
#pragma TenDRA extra macro definition allow
</programlisting>

      <para>allows macros to be redefined, both consistently and
        inconsistently. If the definitions are incompatible, the first definition
        is overwritten. This pragma has a <literal>disallow</literal> variant,
        which resets the check to its default mode.</para>
    </sect1>

    <sect1 id='macro-arguments'>
      <title>Macro arguments</title>

      <para>According to the ISO C standard, section 6.8.3, if a macro
        argument contains a sequence of preprocessing tokens that would otherwise
        act as a preprocessing directive, the behaviour is undefined. Tchk allows
        preprocessing directives in macro arguments by default. The check to
        detect such macro arguments is controlled by:</para>
<programlisting>
#pragma TenDRA directive as macro argument <emphasis>permit</emphasis>
</programlisting>

      <para>where <emphasis>permit</emphasis> is <literal>allow</literal>,
        <literal>warning</literal> or <literal>disallow</literal>.</para>

      <para>The ISO C standard, section 6.8.3.2, also states that each #
        preprocessing token in the replacement list for a function-like macro
        shall be followed by a parameter as the next preprocessing token in the
        replacement list. By default, if tchk encounters a # in a function-like
        macro replacement list which is not followed by a parameter of the macro
        an error is raised. The checker's behaviour in this situation is
        controlled by:</para>
<programlisting>
#pragma TenDRA no ident after # <emphasis>permit</emphasis>
</programlisting>

      <para>where the options for <emphasis>permit</emphasis> are
        <literal>allow</literal> (do not raise errors),
        <literal>disallow</literal> (default mode) and <literal>warning</literal>
        (raise warnings instead of errors).</para>
    </sect1>

    <sect1 id='unmatched-quotes'>
      <title>Unmatched quotes</title>

      <para>The ISO C standard, section 6.1, states that if a ` or "
        character matches the category of preprocessing tokens described as
        "single non-whitespace-characters that do not lexically match the other
        preprocessing token categories", then the behaviour is undefined. For
        example:</para>
<programlisting>
#define a `b
</programlisting>

      <para>would result in undefined behaviour. By default the ` character is
        ignored by tchk. A check to detect such statements may be controlled
        by:</para>
<programlisting>
#pragma TenDRA unmatched quote <emphasis>permit</emphasis>
</programlisting>

      <para><emphasis>The usual</emphasis> <literal>allow</literal>,
        <literal>warning</literal> and <literal>disallow</literal> options are
        available.</para>
    </sect1>

    <sect1 id='include-depth'>
      <title>Include depth</title>

      <para>Most preprocessors set a maximum depth for #include directives
        (which may be limited by the maximum number of files which can be open on
        the host system). By default, the checker supports a depth equal to this
        maximum number. However, a smaller maximum depth can be set using:</para>
<programlisting>
#pragma TenDRA includes depth n
</programlisting>

      <para>where <literal>n</literal> can be any positive integral
        constant.</para>
    </sect1>

    <sect1 id='text-after-endif'>
      <title>Text after #endif</title>

      <para>The ISO C standard, section 6.8, specifies that #endif and #else
        preprocessor directives do not take any arguments, but should be followed
        by a newline. In the default checking mode, tchk raises an error when
        #endif or #else statements are not directly followed by a new line. This
        behaviour may be modified using:</para>
<programlisting>
#pragma TenDRA text after directive <emphasis>permit</emphasis>
</programlisting>

      <para>where <emphasis>permit</emphasis> is <literal>allow</literal> (no
        errors are raised and any text on the same line as the #endif or #else
        statement is ignored), <literal>warning</literal> or
        <literal>disallow</literal>.</para>
    </sect1>

    <sect1 id='text-after'>
      <title>Text after #</title>

      <para>The ISO C standard specifies that a # occuring outside of a macro
        replacement list must be followed by a new line or by a preprocessing
        directive and this is enforced by the checker in default mode . The check
        is controlled by:</para>
<programlisting>
#pragma TenDRA no directive/nline after ident <emphasis>permit</emphasis>
</programlisting>

      <para>where <emphasis>permit</emphasis> may be <literal>allow,
        disallow</literal> or <literal>warning</literal>.</para>
    </sect1>

    <sect1 id='new-line-end'>
      <title>New line at end of file</title>

      <para>The ISO C standard, section 5.1.1.2, states that source files must
        end with new lines. Files which do not end in new lines are flagged as
        errors by the checker in default mode. The behaviour can be modified
        using:</para>
<programlisting>
#pragma TenDRA no nline after file end <emphasis>permit</emphasis>
</programlisting>

      <para>where <emphasis>permit</emphasis> has the usual
        <literal>allow</literal><emphasis>,</emphasis><literal>disallow</literal>
        and <literal>warning</literal> options.</para>
    </sect1>
  </chapter>

  <chapter id='dialect-features'>
    <title>Dialect Features</title>

    <para>This chapter describes the capabilities of the TenDRA C checker for
      enforcing the ISO C standard as well as features for detecting areas left
      undefined by the standard. It also lists the non-ISO dialect features
      supported by the checker in order to provide compatibility with older
      versions of C and allow the use of third-party source which may contain
      non-standard constructs.</para>

    <sect1 id='resolving-linkage'>
      <title>Resolving linkage problems</title>

      <para>Often the way that identifier names are resolved can alter the
        semantics of a program. For example, in:</para>
<programlisting>
void f () {
  {
extern void g ();
g ( 3 );
  }
  g ( 7 );
}
</programlisting>

      <para>the external declaration of g is only in scope in the inner block
        of f. Thus, at the second call of g, it is not in scope, and so is
        inferred to have declaration:</para>
<programlisting>
extern int g ();
</programlisting>

      <para>This conflicts with the previous declaration of g
        which, although not in scope, has been registered in the external
        namespace. The pragma:</para>
<programlisting>
#pragma TenDRA unify external linkage on
</programlisting>

      <para>modifies the algorithm for resolving external linkage by searching
        the external namespace before inferring a declaration. In the example
        above, this results in the second use of g being resolved to the previous
        external declaration. The <literal>on</literal> can be replaced by
        <literal>warning</literal> to give a warning when such resolutions are
        detected, or <literal>off</literal> to switch this feature off.</para>

      <para>Another linkage problem, which is left undefined in the ISO C
        standard, is illustrated by the following program:</para>
<programlisting>
int f () {
  extern int g ();
  return ( g () );
}

static int g ()
{
  return ( 0 );
}
</programlisting>

      <para>Is the external variable g (the declaration of which would be
        inferred if it was omitted) the same as the static variable g? Of course,
        had the order of the two functions been reversed, there would be no doubt
        that they were, however, in the given case it is undefined. By default,
        the linkage is resolved externally, so that the two uses of g are not
        identified. However, the checker can be made to resolve its linkage
        internally, so that the two uses of g are identified. The resolution
        algorithm can be set using:</para>
<programlisting>
#pragma TenDRA linkage resolution : <emphasis>action</emphasis>
</programlisting>

      <para>where <literal>action</literal> can be one of:</para>

      <orderedlist>
        <listitem>
          <para><literal>(internal) on</literal></para>
        </listitem>

        <listitem>
          <para><literal>(internal) warning</literal></para>
        </listitem>

        <listitem>
          <para><literal>(external) on</literal></para>
        </listitem>

        <listitem>
          <para><literal>(external) warning</literal></para>
        </listitem>

        <listitem>
          <para><literal>off</literal></para>
        </listitem>
      </orderedlist>

      <para>depending on whether the linkage resolution is internal, external,
        or default, and whether a warning message is required. The most useful
        behaviour is to issue a warning for all such occurrences (by setting
        action to (internal) warning, for example) so that the programmer can be
        alerted to clarify what was intended.</para>
    </sect1>

    <sect1 id='identifier-linkage'>
      <title>Identifier linkage</title>

      <para>The ISO C standard, section 6.1.2.2, states that "if, within a
        translation unit, an identifier appears with both internal and external
        linkage, the behaviour is undefined". By default, the checker silently
        declares the variable with external linkage. The check to detect
        variables which are redeclared with incompatible linkage is controlled
        using:</para>
<programlisting>
#pragma TenDRA incompatible linkage <emphasis>permit</emphasis>
</programlisting>

      <para>where <emphasis>permit</emphasis> <emphasis>may be</emphasis>
        <literal>allow</literal> (default mode), <literal>warning</literal> (warn
        about incompatible linkage) or <literal>disallow</literal> (raise errors
        for redeclarations with incompatible linkage).</para>
    </sect1>

    <sect1 id='implicit-int'>
      <title>Implicit integer types</title>

      <para>Older C dialects allow external variables to be specified without a
        type, the type int being inferred. Thus, for example:</para>
<programlisting>
a, b;
</programlisting>

      <para>is equivalent to:</para>
<programlisting>
int a, b;
</programlisting>

      <para>By default these inferred declarations are not permitted, though
        tchk's behaviour can be modified using:</para>
<programlisting>
#pragma TenDRA implicit int type for external declaration <emphasis>permit</emphasis>
</programlisting>

      <para>where <emphasis>permit</emphasis> is <literal>allow</literal>,
        <literal>warning</literal> or <literal>disallow</literal>.</para>

      <para>A more common feature, allowed by the ISO C standard, but
        considered bad style by some, is the inference of an int return type for
        functions defined in the form:</para>
<programlisting>
f ( int n ) {
  ....
}
</programlisting>

      <para>the checker's treatment of such functions can be determined
        using:</para>
<programlisting>
#pragma TenDRA implicit int type for function return <emphasis>permit</emphasis>
</programlisting>

      <para>where <literal>permit</literal> can be <literal>allow</literal>,
        <literal>warning</literal> or <literal>disallow</literal>.</para>
    </sect1>

    <sect1 id='bitfield-types'>
      <title>Bitfield types</title>

      <para>The ISO C standard only allows signed int, unsigned int and their
        equivalent types as type specifiers in bitfields. Using the default
        checking profile, tchk raises errors for other integral types used as
        type specifiers in bitfields.This behaviour may be modified using the
        pragma:</para>
<programlisting>
#pragma TenDRA extra int bitfield type <emphasis>permit</emphasis>
</programlisting>

      <para><literal>Permit</literal> is one of <literal>allow</literal> (no
        errors raised), <literal>warning</literal> (allow non-int bitfields
        through with a warning) or <literal>disallow</literal> (raise errors for
        non-int bitfields).</para>

      <para>If non-int bitfields are allowed, the bitfield is treated as if it
        had been declared with an int type of the same signedness as the given
        type. The use of the type char as a bitfield type still generally causes
        an error, since whether a plain char is treated as signed or unsigned is
        implementation-dependent. The pragma:</para>
<programlisting>
#pragma TenDRA character <emphasis>set-sign</emphasis>

</programlisting>

      <para>where <literal>set-sign</literal> is <literal>signed</literal>,
        <literal>unsigned</literal> or <literal>either</literal>, can be used to
        specify the signedness of a plain char bitfield. If
        <emphasis>set-sign</emphasis> is <literal>signed</literal> or
        <literal>unsigned</literal>, the bitfield is treated as though it were
        declared signed char or unsigned char respectively. If
        <emphasis>set-sign</emphasis> is <literal>either</literal>, the sign of
        the bitfield is target-dependent and the use of a plain char bitfield
        causes an error.</para>
    </sect1>

    <sect1 id='extra-type-def'>
      <title>Extra type definitions</title>

      <para>In accordence with the ISO C standard, in default mode tchk does
        not allow a type to be defined more than once using a typedef. The
        pragma:</para>
<programlisting>
#pragma TenDRA extra type definition <emphasis>permit</emphasis>
</programlisting>

      <para>where <literal>permit</literal> is <literal>allow</literal>
        (silently accepts redefinitions, provided they are consistent),
        <literal>warning</literal> or <literal>disallow</literal>.</para>
    </sect1>

    <sect1 id='static-block-level'>
      <title>Static block level functions</title>

      <para>The ISO C standard (Section 6.5.1) states that the declaration of
        an identifier for a function that has block scope shall have no explicit
        storage-class specifier other than extern. By default, tchk raises an
        error for declarations which do not conform to this rule. The behaviour
        can be modified using:</para>
<programlisting>
#pragma TenDRA block function static <emphasis>permit</emphasis>
</programlisting>

      <para>where <literal>permit</literal> is <literal>allow</literal> (accept
        block scope function declarations with other storage-class specifiers),
        <literal>disallow</literal> or <literal>warning</literal>.</para>
    </sect1>

    <sect1 id='incomplete-array'>
      <title>Incomplete array element types</title>

      <para>The ISO C standard (Section 6.1.2.5) states that an incomplete type
        e.g an undefined structure or union type, is not an object type and that
        array elements must be of object type. The default behaviour of the
        checker causes errors when incomplete types are used to specify array
        element types. The pragma:</para>
<programlisting>
#pragma TenDRA incomplete type as object type <emphasis>permit</emphasis>
</programlisting>

      <para>can be used to alter the treatment of array declarations with
        incomplete element types. <emphasis>Permit</emphasis> is one of
        <literal>allow</literal>, <literal>disallow</literal> or
        <literal>warning</literal> as usual.</para>
    </sect1>

    <sect1 id='forward-enumeration'>
      <title>Forward enumeration declarations</title>

      <para>The ISO C Standard (Section 6.5.2.3) states that the first
        introduction of an enumeration tag shall declare the constants associated
        with that tag. This rule is enforced by the checker in default mode,
        however it can be relaxed using the pragma:</para>
<programlisting>
#pragma TenDRA forward enum declaration <emphasis>permit</emphasis>
</programlisting>

      <para>where replacing <literal>permit</literal> by
        <literal>allow</literal> permits the declaration and use of an
        enumeration tag before the declaration of its associated enumeration
        constants. A <literal>disallow</literal> variant which restores the
        default behaviour is also available.</para>
    </sect1>

    <sect1 id='untagged-compound'>
      <title>Untagged compound types</title>

      <para>The ISO C standard states that a declaration must declare at least
        a declarator, a tag or the members of an enumeration. The checker detects
        such declarations and, by default, raises an error. The severity of the
        errors can be altered by:</para>
<programlisting>
#pragma TenDRA unknown struct/union <emphasis>permit</emphasis>
</programlisting>

      <para>where <literal>permit</literal> may be <literal>allow</literal> to
        allows code such as:</para>
<programlisting>
struct {int i; int j;};
</programlisting>

      <para>through without errors (statements such as this occur in some
        system headers) or <literal>disallow</literal> to restore the default
        behaviour.</para>
    </sect1>

    <sect1 id='external-vol'>
      <title>External volatility</title>

      <para>The inclusion of the pragma:</para>
<programlisting>
#pragma TenDRA external volatile_t
</programlisting>

      <para>instructs the checker thereafter to treat any object declared with
        external linkage (ISO C standard Section 6.1.2.2) as if it were volatile
        (ISO C standard Section 6.5.3). This was a feature of some traditional C
        dialects. In the default mode, objects with external linkage are only
        treated as volatile if they were declared with the volatile type
        qualifier.</para>
    </sect1>

    <sect1 id='identifier-name-length'>
      <title>Identifier name length</title>

      <para>Under the ISO C standard rules on identifier name length, an
        implementation is only required to treat the first 31 characters of an
        internal name and the first 6 characters of an external name as
        significant. The TenDRA C checker provides a facility for users to
        specify the maximum number of characters allowed in an identifier name,
        to prevent unexpected results when the application is moved to a new
        implementation. The limit is set using:</para>
<programlisting>
#pragma TenDRA set name limit <emphasis>integer_constant</emphasis>
</programlisting>

      <para>There is currently no distinction made between external and
        internal names for length checking. Identifier name lengths are not
        checked in the default mode.</para>
    </sect1>

    <sect1 id='ellipsis-funct-calls'>
      <title>Ellipsis in function calls</title>

      <para>An ellipsis is not an identifier and should not be used in a
        function call, even if, as in the program below, the function prototype
        contains an ellipsis:</para>
<programlisting>
int f(int a,...) {
  return 1; }
int main() {
  int x, y;
  x=f(y ,...);
  return 1;
}
</programlisting>

      <para>In default mode the checker raises an error if an ellipsis is used
        as a parameter in a function call. The severity of this error can be
        modified by using:</para>
<programlisting>
#pragma TenDRA ident ... <emphasis>permit</emphasis>
</programlisting>

      <para>If <literal>permit</literal> is replaced by
        <literal>allow</literal> the ellipsis is ignored, if
        <literal>warning</literal> is used tchk produces a warning and if
        <literal>disallow</literal> is used the default behaviour is
        restored.</para>
    </sect1>

    <sect1 id='conditional-lvalues'>
      <title>Conditional lvalues</title>

      <para>The ? operator cannot normally be used to define an lvalue, so that
        for example, the program:</para>
<programlisting>
struct s {int a, b; };
void f (int n,struct s *s1,struct s *s2) {
  ( n ? s1: s2)-&gt;a = 0;
}
</programlisting>

      <para>is not allowed in ISO C. The pragma:</para>
<programlisting>
#pragma TenDRA conditional lvalue allow
</programlisting>

      <para>allows conditional lvalues if:</para>

      <para>Both options of the conditional operator have compatible compound
        types;</para>

      <para>Both options of the conditional are lvalues.</para>

      <note>
        <para>there is also a <literal>disallow</literal> variant, but
          <literal>warning</literal> is not permitted in this case.</para>
      </note>
    </sect1>

    <sect1 id='unifying-tag-name-space'>
      <title>Unifying the tag name space</title>

      <para>Each object in the tag name space is associated with a
        classification (struct, union or enum) of the type to which it refers. If
        such a tag is used, it must be preceded by the correct classification,
        otherwise the checker produces an error by default. However, the
        pragma:</para>
<programlisting>
#pragma TenDRA ignore struct/union/enum tag <emphasis>status</emphasis>
</programlisting>

      <para>may be used to change the severity of the error. The options for
        <emphasis>status</emphasis> are: <literal>on</literal> (allows a tag to
        be used with any of the three classifications, the correct classification
        being inferred from the type definition), <literal>warning</literal> or
        <literal>off</literal>.</para>
    </sect1>

    <sect1 id='init-compound-types'>
      <title>Initialisation of compound types</title>

      <para>Many older C dialects do not allow the initialisation of automatic
        variables of compound type. Thus, for example:</para>
<programlisting>
void f () {
  struct {
int a;
int b;
  } x = { 3, 2 };
}
</programlisting>

      <para>would not be allowed by some older compilers, although by default
        tchk does not raise any errors since the code is legal according to the
        ISO C standard. The checker's behaviour may be changed using:</para>
<programlisting>
#pragma TenDRA initialization of struct/union (auto) <emphasis>permit</emphasis>
</programlisting>

      <para>where <literal>permit</literal> is <literal>allow</literal>,
        <literal>warning</literal> or <literal>disallow</literal>. This feature
        is particularly useful when developing a program which is intended to be
        compiled with a compiler which does not support automatic compound
        initialisations.</para>
    </sect1>

    <sect1 id='var-init'>
      <title>Variable initialisation</title>

      <para>The ISO C standard (Section 6.5.7) states that all expressions in
        an initialiser for an object that has static storage duration or in an
        initialiser-list for an object that has aggregate or union type shall be
        constant expressions. The pragma:</para>
<programlisting>
#pragma TenDRA variable initialization <emphasis>permit</emphasis>
</programlisting>

      <para>may be used to allow non-constant initialisers if
        <emphasis>permit</emphasis> is replaced by <literal>allow</literal>. The
        other option for <emphasis>permit</emphasis> is
        <literal>disallow</literal> which restores the default behaviour of
        flagging non-constant initialisers for objects of static storage duration
        as errors.</para>
    </sect1>

    <sect1 id='escape-seq'>
      <title>Escape sequences</title>

      <para>The ISO C standard specifies a small set of escape sequences in
        strings, for example \n as newline. Unknown escape sequences lead to an
        error in the default mode , however the severity of the error may be
        altered using:</para>
<programlisting>
#pragma TenDRA unknown escape <emphasis>permit</emphasis>
</programlisting>

      <para>where <emphasis>permit</emphasis> is <literal>allow</literal>
        (silently replaces the unknown escape sequence, \z say, by z),
        <literal>warning</literal> or <literal>disallow</literal>.</para>
    </sect1>

    <sect1 id='identifier-names'>
      <title>$ in identifier names</title>

      <para>The ISO C standard (Section 6.1) states that the use of the
        character $ in identifier names is illegal. The pragma:</para>
<programlisting>
#pragma TenDRA dollar as ident allow
</programlisting>

      <para>can be used to allow such identifiers, which by default are flagged
        as errors. There is also a <literal>disallow</literal> variant which
        restores the default behaviour.</para>
    </sect1>

    <sect1 id='writable-string-lit'>
      <title>Writeable string literals</title>

      <para>The ISO C standard, section 6.1.4, states that "if the program
        attempts to modify a string literal of either form, the behaviour is
        undefined". Assignments to string literals of the form:</para>
<programlisting>
"abc"='3';
</programlisting>

      <para>always result in errors. Other attempts to modify members of string
        literals, e.g.</para>
<programlisting>
"abc"[1]='3';
</programlisting>

      <para>are permitted in the default checking mode. This behaviour can be
        changed using:</para>
<programlisting>
#pragma TenDRA writeable string literal <emphasis>permit</emphasis>
</programlisting>

      <para>where <emphasis>permit</emphasis> may be <literal>allow</literal>,
        <literal>warning</literal> or <literal>disallow</literal>.</para>
    </sect1>

    <sect1 id='concat-char'>
      <title>Concatenation of character string literals and wide character
      string literals</title>

      <para>The ISO C standard, section 6.1.4, states that if a character
        string literal is adjacent to a wide character string literal, the
        behaviour is undefined. By default, this is flagged as an error by the
        checker. If the pragma:</para>
<programlisting>
#pragma TenDRA unify incompatible string literal <emphasis>permit</emphasis>
</programlisting>

      <para>is used, with <emphasis>permit</emphasis> set to
        <literal>allow</literal> or <literal>warning</literal> the character
        string literal is converted to a wide character string literal and the
        strings are concatenated, although in the <literal>warning</literal> case
        a warning is output. <emphasis>The</emphasis> <literal>disallow</literal>
        version of the pragma restores the default behaviour.</para>
    </sect1>

    <sect1 id='nested-comments'>
      <title>Nested comments</title>

      <para>The occurence of the `/*' characters inside a C comment, i.e. text
        surrounded by the `/*' and `*/' symbols, is usually a mistake and can
        lead to the termination of a comment unexpectedly. By default such nested
        comments are processed silently, however an error or warning can be
        produced by setting:</para>
<programlisting>
#pragma TenDRA nested comment analysis <emphasis>status</emphasis>
</programlisting>

      <para>with <emphasis>status</emphasis> as <literal>on</literal> or
        <literal>warning</literal>. If <emphasis>status</emphasis> is
        <literal>off</literal> the default behaviour is restored.</para>
    </sect1>

    <sect1 id='empty-src'>
      <title>Empty source files</title>

      <para>The ISO standard states that each source file should contain at
        least one declaration or definition. Source files which contain no
        external declarations or definitions are flagged as errors by the checker
        in default mode. The severity of the error may be altered using:</para>
<programlisting>
#pragma TenDRA no external declaration <emphasis>permit</emphasis>
</programlisting>

      <para>where the options for <literal>permit</literal> are
        <literal>allow</literal> (no errors raised), <literal>warning</literal>
        or <literal>disallow</literal>.</para>
    </sect1>

    <sect1 id='extra-commas'>
      <title>Extra commas</title>

      <para>The ISO C standard does not allow extra commas in enumeration type
        declarations e.g.</para>
<programlisting>
enum e = {red, orange, yellow,};
</programlisting>

      <para>The extra comma at the end of the declaration is flagged as an
        error by default, but this behaviour may be changed by using:</para>
<programlisting>
#pragma TenDRA extra , <emphasis>permit</emphasis>
</programlisting>

      <para>where <emphasis>permit</emphasis> has the usual
        <literal>allow</literal><emphasis>,</emphasis><literal>disallow</literal>
        and <literal>warning</literal> options.</para>
    </sect1>

    <sect1 id='extra-semicolons'>
      <title>Extra semicolons</title>

      <para>Some dialects of C allow extra semicolons at the external
        declaration and definition level in contravention of the ISO C standard.
        For example, the program:</para>
<programlisting>
int f () {
  return ( 0 );
};
</programlisting>

      <para>is not ISO compliant. The checker enforces the ISO rules by
        default, but the errors raised may be reduced to warning or suppressed
        entirely using:</para>
<programlisting>
#pragma TenDRA extra ; <emphasis>permit</emphasis>
</programlisting>

      <para>with <emphasis>permit</emphasis> as <literal>warning</literal> or
        <literal>allow</literal>. The <literal>disallow</literal> option restores
        the default behaviour.</para>
    </sect1>

    <sect1 id='compat-with-cpp'>
      <title>Compatibility with C++ to TDF producer</title>

      <para>In the interests of compatibility between the C checker and the new
        C++ checker, all pragmas beginning:</para>
<programlisting>
#pragma TenDRA ++
</programlisting>

      <para>are silently ignored by tchk.</para>
    </sect1>
  </chapter>

  <chapter id='common-errors'>
    <title>Common Errors</title>

    <para>Tchk is capable of performing a number of checks for common
      programming mistakes. This chapter describes these checks and controlling
      pragmas.</para>

    <sect1 id='enum-cont-switch-state'>
      <title>Enumerations controlling switch statements</title>

      <para>Enumerations are commonly used as control expressions in switch
        statements. When case labels for some of the enumeration constant
        belonging to the enumeration type do not exist and there is no default
        label, the switch statement has no effect for certain possible values of
        the control expression. Checks to detect such switch statements are
        controlled by:</para>
<programlisting>
#pragma TenDRA enum switch analysis <emphasis>status</emphasis>
</programlisting>

      <para>where <emphasis>status</emphasis> is <literal>on</literal> (raise
        an error), <literal>warning</literal> (produce a warning), or
        <literal>off</literal> (the default mode when no errors are
        produced).</para>
    </sect1>

    <sect1 id='incomplete-struct'>
      <title>Incomplete structures and unions</title>

      <para>ISO C allows for structures or unions to be declared but not
        defined, provided they are not used in a context where it is necessary to
        know the complete structure. For example:</para>
<programlisting>
struct tag *p;
</programlisting>

      <para>is allowed, despite the fact that struct tag is incomplete. The
        TenDRA C checker has an option to detect such incomplete structures or
        unions, controlled by:</para>
<programlisting>
#pragma TenDRA complete struct/union analysis <emphasis>status</emphasis>
</programlisting>

      <para>where <literal>status</literal> is <literal>on</literal> to give an
        error as an incomplete structure or union is detected,
        <literal>warning</literal> to give a warning, or <literal>off</literal>
        to disable the check.</para>

      <para>The check can also be controlled by passing the command-line option
        <literal>-X:complete_struct=</literal><literal>state</literal> to tchk,
        where <literal>state</literal> is <literal>check</literal>,
        <literal>warn</literal> or <literal>dont</literal>.</para>

      <para>The only place where the checker can actually detect that a
        structure or union is incomplete is at the end of the source file. This
        is because it is possible to complete a structure after it has been used.
        For example, in:</para>
<programlisting>
struct tag *p;
struct tag {
  int a;
  int b;
};
</programlisting>

      <para>struct tag is complete despite the fact that it was incomplete in
        the definition of p.</para>
    </sect1>

    <sect1 id='variable-shadowing'>
      <title>Variable shadowing</title>

      <para>It is quite legal in C to have a variable in an inner scope, with
        the same name as a variable in an outer scope. These variables are
        distinct and whilst in the inner scope, the declaration in the outer
        scope is not visible - it is "shadowed" by the local variable of the same
        name. Confusion can arise if this was not what the programmer intended.
        The checker can therefore be configured to detect shadowing in three
        cases: a local variable shadowing a global variable; a local variable
        shadowing a local variable with a wider scope and a local variable
        shadowing a typedef name, by using:</para>
<programlisting>
#pragma TenDRA variable hiding analysis <emphasis>status</emphasis>
</programlisting>

      <para>If <emphasis>status</emphasis> is <literal>on</literal> an error is
        raised when a local variable that shadows another variable is declared,
        if <literal>warning</literal> is used the error is replaced by a warning
        and the <literal>off</literal> option restores the default behaviour
        (shadowing is permitted and no errors are produced).</para>
    </sect1>

    <sect1 id='floating-point-equal'>
      <title>Floating point equality</title>

      <para>Due to the rounding errors that occur in the handling of floating
        point values, comparison for equality between two floating point values
        is a hazardous and unpredictable operation. Tests for equality of two
        floating point numbers are controlled by:</para>
<programlisting>
#pragma TenDRA floating equality <emphasis>permit</emphasis>
</programlisting>

      <para><emphasis>where</emphasis><emphasis>permit</emphasis>
        <emphasis>is</emphasis><literal>allow</literal>,
        <literal>warning</literal> or <literal>disallow</literal>. By default the
        check is switched off.</para>
    </sect1>
  </chapter>

  <chapter id='symbol-table-dump'>
    <title>Symbol Table Dump</title>

    <para>Tchk produces an extra output file, called a dump output file, for
      each translation unit processed. This file is in the form given by the
      symbol table output specification in Annex E, and contains information
      about the objects declared, defined or used within an application. Each
      object encountered during processing is assigned a unique reference number
      allowing uses of the object to be traced back to the declaration and
      definition of the object.</para>

    <para>In the default mode only external declaration and definition
      information is written to each dump file. The amount of information output
      may be increased by passing the <literal>-sym[cehklsu]</literal> command
      line option to tchk. Any combination of the optional flags enclosed by []
      may be used and the effect of each flag is described below:</para>

    <itemizedlist>
      <listitem>
        <para>no flags external declarations, definitions only;</para>
      </listitem>

      <listitem>
        <para>c string and character literals output;</para>
      </listitem>

      <listitem>
        <para>e errors incorporated into dump output;</para>
      </listitem>

      <listitem>
        <para>e_only only errors output;</para>
      </listitem>

      <listitem>
        <para>h included headers output;</para>
      </listitem>

      <listitem>
        <para>k keywords output;</para>
      </listitem>

      <listitem>
        <para>l local variables output;</para>
      </listitem>

      <listitem>
        <para>s scopes output;</para>
      </listitem>

      <listitem>
        <para>u variable usage output.</para>
      </listitem>
    </itemizedlist>

    <para>The dump information is currently used for four main purposes:
      detecting included header files from which nothing is used within the
      translation unit; production of lint-like error output; API usage analysis
      and type checking between translation units.</para>

    <sect1 id='unused-headers'>
      <title>Unused headers</title>

      <para>Header files which are included but from which nothing is used
        within the other source files comprising the translation unit, might just
        as well not have been included. Tchk can detect top level include files
        which are unnecessary, by analysing the dump output for the file. This
        check is enabled by passing the <literal>-Wd,-H</literal> command line
        flag to tchk. Errors are written to stderr in a simple ascii form by
        default, or to the unified dump file in dump format if the
        <literal>-D</literal> command line option is used.</para>
    </sect1>

    <sect1 id='error-processing'>
      <title>Error processing</title>

      <para>By default the error messages generated by the checker are written
        in a simple ascii form to stderr. If instead, the errors are written to
        the dump file using the <literal>-sym:e</literal> option mentioned above,
        an alternative lint-like error output may be generated by processing the
        dump files. The lint-like errors are enabled by passing the
        <literal>-Ycompact</literal> flag to tchk.</para>
    </sect1>

    <sect1 id='api-usage-anal'>
      <title>API usage analysis</title>

      <para>Analysis performed on the set of dump files produced for an entire
        application can detect the objects, types, etc. from external APIs which
        are used by the application. The API usage analysis is enabled by passing
        one or more <literal>-api_check</literal><emphasis>API</emphasis> flags
        to tchk where <emphasis>API</emphasis> may be any of the standard APIs
        listed in section 2.1. The
        <literal>-api_check_out</literal><emphasis>FILE</emphasis> flag may be
        used to direct the API analysis information to the file
        <emphasis>FILE</emphasis> (by default it is written to stdout). The APIs
        used to perform API usage analysis may be different from those used to
        process the application. Annex G.8 contains details of the methods used
        to perform the API usage analysis.</para>
    </sect1>

    <sect1 id='intermodular-checks'>
      <title>Intermodular checks</title>

      <para>All the checks discussed in earlier chapters have been concerned
        with a single source file. However, tchk also contains a linking phase in
        which it is able to perform intermodular checks (i.e. checks between
        source files). In the linking phase, the dumps file generated from each
        translation unit processed are combined into a single dump file
        containing information on all external objects within the application,
        and type consistency checks are applied to ensure that the definitions
        and declarations of each object are consistent and external objects and
        functions have at most one definition.</para>

      <para>The amount of information about an object stored in a dump file
        depends on the compilation mode used to produce that file. For example,
        if extra prototype checks are enabled (see section 3.3), the dump file
        contains any information inferred about a function from its traditional
        style definition or from applications of that function. For example, if
        one file contains:</para>
<programlisting>
extern void f () ;
void g ()
{
  f ( "hello" ) ;
}
</programlisting>

      <para>and another contained:</para>
<programlisting>
void f ( n ) int n ;
{
  return ;
}
</programlisting>

      <para>then the inferred prototype:</para>
<programlisting>
void f WEAK ( char * ) ;
</programlisting>

      <para>from the call of f would be included in the first dump file,
        whereas the weak prototype deduced from the definition of f:</para>
<programlisting>
void f WEAK ( int ) ;
</programlisting>

      <para>would be included in the second. When these two dump files are
        linked, the inconsistency is discovered and an error is reported.</para>
    </sect1>
  </chapter>

  <chapter id='conditional-compilations'>
    <title>Conditional Compilation</title>

    <para>Tchk generally treats conditional compilation in the same way as
      other compilers and checkers. For example, consider:</para>
<programlisting>
#if expr
.... /* First branch */
#else
.... /* Second branch */
#endif
</programlisting>

    <para>the expression, expr, is evaluated: if it is non-zero the first
      branch of the conditional is processed; if it is zero the second branch is
      processed instead.</para>

    <para>Sometimes, however, tchk may be unable to evaluate the expression
      statically because of the abstract types and expressions which arise from
      the minimum integer range assumptions or the abstract standard headers used
      by the tool (see target-dependent types in section 4.5). For example,
      consider the following ISO compliant program:</para>
<programlisting>
#include &lt;stdio.h&gt;
#include &lt;limits.h&gt;
int main () {
#if ( CHAR_MIN == 0 )
  puts ("char is unsigned");
#else
  puts ("char is signed");
#endif
return ( 0 );
}
</programlisting>

    <para>The TenDRA representation of the ISO API merely states that CHAR_MIN
      - the least value which fits into a char - is a target dependent integral
      constant. Hence, whether or not it equals zero is again target dependent,
      so the checker needs to maintain both branches. By contrast, any
      conventional compiler is compiling to a particular target machine on which
      CHAR_MIN is a specific integral constant. It can therefore always determine
      which branch of the conditional it should compile.</para>

    <para>In order to allow both branches to be maintained in these cases, it
      has been necessary for tchk to impose certain restrictions on the form of
      the conditional branches and the positions in which such target-dependent
      conditionals may occur. These may be summarised as:</para>

    <para>Target-dependent conditionals may not appear at the outer level. If
      the checker encounters a target-dependent conditional at the outer level an
      error is produced. In order to continue checking in the rest of the file an
      arbitrary assumption must be made about which branch of the conditional to
      process; tchk assumes that the conditional is true and the first branch is
      used;</para>

    <para>The branches of allowable target-dependent conditionals may not
      contain declarations or definitions.</para>
  </chapter>

  <appendix id='compilation-modes'>
    <title>Compilation Modes</title>

    <sect1 id='base-modes'>
      <title>Base modes</title>

      <para>The Xs, Xp, Xw, Xc, Xa and Xt modes are mutually incompatible and
        should not be used together. All other built-in mode combinations are
        allowed and, of course, any built-in mode can be combined with
        user-defined modes as described in section <xref linkend='scoping-check'> 

      <para>Checks marked with E are enabled to produce an error and checks
        marked with W are enabled to produce a warning. A blank entry implies
        that the check is disabled.</para>

      <table frame="all" id='t-base-modes'>
        <title>Base Modes</title>

        <tgroup cols="7">
          <thead>
            <row>
              <entry>Check</entry>

              <entry>Xs</entry>

              <entry>Xp</entry>

              <entry>Xw</entry>

              <entry>Xc</entry>

              <entry>Xa</entry>

              <entry>Xt</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>+/-Value of __STDC__</entry>

              <entry>1</entry>

              <entry>1</entry>

              <entry>1</entry>

              <entry>1</entry>

              <entry>1</entry>

              <entry>0</entry>
            </row>

            <row>
              <entry>ISO C rules for integer literals</entry>

              <entry>Y</entry>

              <entry>Y</entry>

              <entry>Y</entry>

              <entry>Y</entry>

              <entry>Y</entry>

              <entry>N</entry>
            </row>

            <row>
              <entry>ISO C rules for integer promotions</entry>

              <entry>Y</entry>

              <entry>Y</entry>

              <entry>Y</entry>

              <entry>Y</entry>

              <entry>Y</entry>

              <entry>N</entry>
            </row>

            <row>
              <entry>assignments as conditional control statements</entry>

              <entry></entry>

              <entry></entry>

              <entry>W</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>bitfield overflow</entry>

              <entry>E</entry>

              <entry>E</entry>

              <entry>W</entry>

              <entry>E</entry>

              <entry>E</entry>

              <entry></entry>
            </row>

            <row>
              <entry>block level static function</entry>

              <entry>E</entry>

              <entry>E</entry>

              <entry>W</entry>

              <entry>E</entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>character escape overflow</entry>

              <entry>E</entry>

              <entry>E</entry>

              <entry>W</entry>

              <entry>E</entry>

              <entry>E</entry>

              <entry></entry>
            </row>

            <row>
              <entry>sign of char</entry>

              <entry>+/-^a</entry>

              <entry>+/-</entry>

              <entry>+/-</entry>

              <entry>+/-</entry>

              <entry>+/-</entry>

              <entry>+/-</entry>
            </row>

            <row>
              <entry>char * as generic pointer</entry>

              <entry>E</entry>

              <entry>E</entry>

              <entry>W</entry>

              <entry>E</entry>

              <entry>E</entry>

              <entry></entry>
            </row>

            <row>
              <entry>complete struct/union analysis</entry>

              <entry>W</entry>

              <entry></entry>

              <entry>W</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>conditional lvalues</entry>

              <entry>E</entry>

              <entry>E</entry>

              <entry>E</entry>

              <entry>E</entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>constant conditional control statements</entry>

              <entry></entry>

              <entry></entry>

              <entry>W</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>conversion analysis</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>( int -&gt; enum implicit )</entry>

              <entry></entry>

              <entry></entry>

              <entry>W</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>( int -&gt; int explicit )</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>( int -&gt; int implicit )</entry>

              <entry>W</entry>

              <entry></entry>

              <entry>W</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>( int &lt;-&gt; pointer explicit )</entry>

              <entry>W</entry>

              <entry>W</entry>

              <entry>W</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>( int &lt;-&gt; pinter implicit )</entry>

              <entry>E</entry>

              <entry>E</entry>

              <entry>E</entry>

              <entry>E</entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>( pointer -&gt; pointer explicit )</entry>

              <entry>W</entry>

              <entry></entry>

              <entry>W</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>( pointer -&gt; pointer implicit )</entry>

              <entry>E</entry>

              <entry>E</entry>

              <entry>E</entry>

              <entry>E</entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>directive used as macro argument</entry>

              <entry></entry>

              <entry></entry>

              <entry>W</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>directive assert</entry>

              <entry>E</entry>

              <entry>E</entry>

              <entry>W</entry>

              <entry>E</entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>directive file</entry>

              <entry>E</entry>

              <entry>E</entry>

              <entry>W</entry>

              <entry>E</entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>directive ident</entry>

              <entry>E</entry>

              <entry>E</entry>

              <entry>W</entry>

              <entry>E</entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>directive unassert</entry>

              <entry>E</entry>

              <entry>E</entry>

              <entry>W</entry>

              <entry>E</entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>directive weak</entry>

              <entry>E</entry>

              <entry>E</entry>

              <entry>W</entry>

              <entry>E</entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>discard analysis</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>( function return )</entry>

              <entry>W</entry>

              <entry></entry>

              <entry>W</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>( static)</entry>

              <entry>W</entry>

              <entry></entry>

              <entry>W</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>( value )</entry>

              <entry>W</entry>

              <entry></entry>

              <entry>W</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>"$" used as character</entry>

              <entry>E</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>enum switch analysis</entry>

              <entry></entry>

              <entry></entry>

              <entry>W</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>extra , at end of enum lists</entry>

              <entry>E</entry>

              <entry>E</entry>

              <entry>W</entry>

              <entry>E</entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>extra ... in function prototypes</entry>

              <entry>E</entry>

              <entry>E</entry>

              <entry>W</entry>

              <entry>E</entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>extra ; after external declarations</entry>

              <entry>E</entry>

              <entry>E</entry>

              <entry>W</entry>

              <entry>E</entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>extra ; after contional statements</entry>

              <entry></entry>

              <entry></entry>

              <entry>W</entry>

              <entry></entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>extra int types for bitfields</entry>

              <entry>E</entry>

              <entry>E</entry>

              <entry>W</entry>

              <entry>E</entry>

              <entry></entry>

              <entry></entry>
            </row>

            <row>
              <entry>extra macro definitions</entry>

              <entry>E</entry>

              <entry>E</entry>

              <entry>E</entry>

              <entry>E</entry>

              <entry></entry>

              <entry></entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </sect1>

    <sect1 id='nepc-not-ansi'>
      <title>nepc and not_ansi modes</title>

      <para>These modes modify the base environment.</para>

      <para>The <literal>nepc</literal> environment switches off most of the
        extra portability checking. It is specified by passing the -nepc option
        to tcc.</para>

      <para>Printf String Checking OFF</para>

      <para>Pragma Profile:</para>
<programlisting>
#pragma TenDRA conversion analysis off
#pragma TenDRA weak prototype analysis off
#pragma TenDRA compatible type : char * == void * : allow
#pragma TenDRA function pointer as pointer allow
#pragma TenDRA character escape overflow allow
#pragma TenDRA no nline after file end allow
#pragma TenDRA bitfield overflow allow
</programlisting>

      <para>The <literal>not_ansi</literal> environment provides support for a
        range of non-ansi dialect features. It is specified by passing the
        -not_ansi option to tcc.</para>

      <para>Pragma Profile:</para>
<programlisting>
#pragma TenDRA linkage resolution : (internal) on
#pragma TenDRA unify external linkage on
#pragma TenDRA directive assert allow
#pragma TenDRA directive file allow
#pragma TenDRA directive ident allow
#pragma TenDRA directive unassert allow
#pragma TenDRA directive weak allow
#pragma TenDRA compatible type : char * == void * : allow
#pragma TenDRA conditional lvalue allow
#pragma TenDRA extra ; allow
#pragma TenDRA extra bitfield int type allow
#pragma TenDRA extra type definition allow
#pragma TenDRA ignore struct/union/enum tag on
#pragma TenDRA implicit int type for external declaration allow
#pragma TenDRA implicit int type for function return allow
#pragma TenDRA no external declaration allow
#pragma TenDRA text after directive allow
#pragma TenDRA unknown escape allow
#pragma TenDRA unknown pragma allow
#pragma TenDRA weak macro equality allow
#pragma TenDRA extra ... allow
#pragma TenDRA extra , allow
#pragma TenDRA incomplete type as object type allow
#pragma TenDRA dollar as ident allow
#pragma TenDRA variable initialization allow
#pragma TenDRA extra macro definition allow
#pragma TenDRA incompatible type qualifier allow
#pragma TenDRA no directive/nline after ident allow
#pragma TenDRA unknown directive allow
#pragma TenDRA no ident after # allow
#pragma TenDRA block function static allow
#pragma TenDRA unknown struct/union allow
</programlisting>
    </sect1>
  </appendix>

  <appendix id='command-line-opts-port'>
    <title>Command Line Options for Portability Checking</title>

    <table frame="all" id='t-base-modes-b'>
      <title>Base Modes</title>

      <tgroup cols="3">
        <thead>
          <row>
            <entry>Check</entry>

            <entry>Refrences</entry>

            <entry>Command Line Option</entry>
          </row>
        </thead>

        <tbody>
          <row>
            <entry>Weak Prototype Analysis</entry>

            <entry><xref linkend='type-check-proto'> 

            <entry>-X:weak_proto=<emphasis>status</emphasis></entry>
          </row>

          <row>
            <entry>Implicit Function Declaration</entry>

            <entry><xref linkend='overriding-type-check'> 

            <entry>-X:implicit_func=<emphasis>status</emphasis></entry>
          </row>

          <row>
            <entry>Printf String Checking</entry>

            <entry><xref linkend='point-int-int-int-conv'> 

            <entry>-X:printf=<emphasis>status</emphasis></entry>
          </row>

          <row>
            <entry>Incompatible Void Returns</entry>

            <entry><xref linkend='point-int-int-int-conv'> 

            <entry>-X:void_ret=<emphasis>status</emphasis></entry>
          </row>

          <row>
            <entry>Unreachable Code</entry>

            <entry><xref linkend='unreachable-code'> 

            <entry>-X:unreached=<emphasis>status</emphasis></entry>
          </row>

          <row>
            <entry>Case Fall Through</entry>

            <entry><xref linkend='case-fall-through'> 

            <entry>-X:fall_thru=stat</entry>
          </row>

          <row>
            <entry>Conversion Analysis</entry>

            <entry><xref linkend='type-conv'> 

            <entry>-X:convert_all=<emphasis>status</emphasis></entry>
          </row>

          <row>
            <entry>Integer-Integer Conversion</entry>

            <entry><xref linkend='int-int-conversions'> 

            <entry>-X:convert_int=<emphasis>status</emphasis>
            -X:convert_int_implicit=<emphasis>status</emphasis>
            -Xconvert_int_implicit=<emphasis>status</emphasis></entry>
          </row>

          <row>
            <entry>Integer-Pointer Conversion</entry>

            <entry><xref linkend='point-int-int-int-conv'> 

            <entry>-X:convert_int_ptr=<emphasis>status</emphasis></entry>
          </row>

          <row>
            <entry>Pointer-Pointer Conversion</entry>

            <entry><xref linkend='point-point-conv'> 

            <entry>-X:convert_ptr=<emphasis>status</emphasis></entry>
          </row>

          <row>
            <entry>Complete Struct/Union Analysis</entry>

            <entry><xref linkend='incomplete-struct'> 

            <entry>-X:complete_struct=<emphasis>status</emphasis></entry>
          </row>

          <row>
            <entry>Variable Analysis</entry>

            <entry><xref linkend='var-analysis'> 

            <entry>-X:variable=<emphasis>status</emphasis></entry>
          </row>

          <row>
            <entry>Discard Analysis</entry>

            <entry><xref linkend='discard-analysis'> 

            <entry>-X:discard_all=<emphasis>status</emphasis></entry>
          </row>

          <row>
            <entry>Discarded Function Returns</entry>

            <entry><xref linkend='dicard-funct'> 

            <entry>-X:discard_func_ret=<emphasis>status</emphasis></entry>
          </row>

          <row>
            <entry>Discarded Values</entry>

            <entry><xref linkend='discard-computed'> 

            <entry>-X:discard_value=<emphasis>status</emphasis></entry>
          </row>

          <row>
            <entry>Unused Statics</entry>

            <entry><xref linkend='discard-computed'> 

            <entry>-X:unused_static=<emphasis>status</emphasis></entry>
          </row>
        </tbody>
      </tgroup>
    </table>

    <note>
      <para><emphasis>status</emphasis> can be one of
        <emphasis>check</emphasis>, <emphasis>warn</emphasis> or
        <emphasis>dont</emphasis>.</para>
    </note>
  </appendix>

  <appendix id='integral-type-spec'>
    <title>Integral Type Specification</title>

    <sect1 id='spec-int-lit-types'>
      <title>Specifying integer literal types</title>

      <para>The integer literal pragmas are used to define the method of
        computing the type of an integer literal. Integer literals cannot be used
        in a program unless the class to which they belong has been described
        using an integer literal pragma. Each built-in checking mode includes
        some integer literal pragmas describing the semantics appropriate for
        that mode. If these built-in modes are inappropriate, then the user must
        describe the semantics using the pragma below:</para>
<programlisting>
#pragma integer literal <emphasis>literal_class lit_class_type_list</emphasis>
</programlisting>

      <para>The <emphasis>literal_class</emphasis> identifies the type of
        literal integer involved. The possibilities are:</para>

      <itemizedlist>
        <listitem>
          <para><literal>decimal</literal></para>
        </listitem>

        <listitem>
          <para><literal>octal</literal></para>
        </listitem>

        <listitem>
          <para><literal>hexadecimal</literal></para>
        </listitem>
      </itemizedlist>

      <para>Each of these types can optionally be followed by
        <literal>unsigned</literal> and/or <literal>long</literal> to specify an
        unsigned and/or long type respectively.</para>

      <para>The values of the integer literals of any particular class are
        divided into contiguous sub-ranges specified by the
        <literal>lit_class_type_list</literal> which takes the form below:</para>
<programlisting>
<emphasis>lit_class_type_list</emphasis>
*<emphasis>int_type_spec</emphasis>
<emphasis>integer_constant int_type_spec</emphasis> | <emphasis>lit_class_type_list</emphasis>
<emphasis>int_type_spec</emphasis> :
: <emphasis>type_name</emphasis>
* warning<subscript><emphasis>opt</emphasis></subscript> : <emphasis>identifier</emphasis>
** :
</programlisting>

      <para>The first integer constant, i1 say, identifies the range [0,i1],
        the second, i2 say, identifies the range [i1+1,i2]. The symbol *
        specifies the unlimited range upwards from the last integer constant.
        Each integer constant must be strictly greater than its
        predecessor.</para>

      <para>Associated with each sub-range is an
        <emphasis>int_type_spec</emphasis> which is either a type, a procedure
        token identifier with an optional warning (see G.9)or a failure. For each
        sub-range:</para>

      <itemizedlist>
        <listitem>
          <para>If the <emphasis>int_type_spec</emphasis> is a type name, then
            it must be an integral type and specifies the type associated with
            literals in that sub-range.</para>
        </listitem>

        <listitem>
          <para>If the <literal>int_type_spec</literal> is an identifier, then
            the type of integer is computed by a procedure token of that name
            which takes the integer value as a parameter and delivers its type.
            The procedure token must have been declared previously as</para>
<programlisting>
#pragma token PROC ( VARIETY ) VARIETY
</programlisting>

          <para>Since the type of the integer is computed by a procedure token
            which may be implemented differently on different targets, there is
            the option of producing a warning whenever the token is
            applied.</para>
        </listitem>

        <listitem>
          <para>If the <emphasis>int_type_spec</emphasis> is **, then any
            integer literal lying in the associated sub-range will cause the
            checker to raise an error.</para>
        </listitem>
      </itemizedlist>

      <para>For example:</para>
<programlisting>
#pragma integer literal decimal 0x7fff : int | 0x7fffffff : long | * : unsigned long
</programlisting>

      <para>divides unsuffixed decimal literals into three ranges: literals in
        the range [0, 0x7fff] are of type int, integer literals in the range
        [0x7fff, 0x7fffffff] are of type long and the remainder are of type
        unsigned long.</para>

      <para>There are four pre-defined procedure tokens supplied with the
        compiler which are used in the startup files to provide the default
        specification for integer literals:</para>

      <itemizedlist>
        <listitem>
          <para><literal>~lit_int</literal> is the external identification of a
            token that returns the integer type according to the rules of ISO C
            for an unsuffixed decimal;</para>
        </listitem>

        <listitem>
          <para><literal>~lit_hex</literal> is the external identification of a
            token that returns the integer type according to the rules of ISO C
            for an unsuffixed hexadecimal;</para>
        </listitem>

        <listitem>
          <para><literal>~lit_unsigned</literal> is the external identification
            of a token that returns the integer type according to the rules of
            ISO C for integers suffixed by U only;</para>
        </listitem>

        <listitem>
          <para><literal>~lit_long</literal> is the external identification of
            a token that returns the integer type according to the rules of ISO C
            for integers suffixed by L only.</para>
        </listitem>
      </itemizedlist>
    </sect1>

    <sect1 id='port-table'>
      <title>The Portability Table</title>

      <para>The portability table is used by the checker to describe the
        minimum assumptions about the representation of the integral types. It
        contains information on the minimum integer sizes and the minimum range
        of values that can be represented by each integer type.</para>

      <para>Two built-in portability tables are provided. The default reflects
        the minimal requirements laid down in the ISO C standard. The 32-bit
        portability table (specified by the passing the -Y32bit option to tchk)
        reflects the implementation on most modern 32 bit machines. These tables
        are shown below.</para>

      <table frame="all" id='iso-ansi-min-req'>
        <title>ISO/ANSI Minimum Requirements Portability Table
        (default)</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>.</entry>

              <entry>.</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>char_bits</entry>

              <entry>8</entry>
            </row>

            <row>
              <entry>short_bits</entry>

              <entry>16</entry>
            </row>

            <row>
              <entry>int_bits</entry>

              <entry>16</entry>
            </row>

            <row>
              <entry>long_bits</entry>

              <entry>32</entry>
            </row>

            <row>
              <entry>signed_range</entry>

              <entry>symmetric</entry>
            </row>

            <row>
              <entry>char_type</entry>

              <entry>either</entry>
            </row>

            <row>
              <entry>ptr_int</entry>

              <entry>none</entry>
            </row>

            <row>
              <entry>ptr_fn</entry>

              <entry>yes</entry>
            </row>

            <row>
              <entry>non_prototype_checks</entry>

              <entry>yes</entry>
            </row>

            <row>
              <entry>multibyte</entry>

              <entry>0</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <table frame="all" id='port-tbl-opt'>
        <title>32 bit Portability table (specified by -Y32bit option)</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry>.</entry>

              <entry>.</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>char_bits</entry>

              <entry>8</entry>
            </row>

            <row>
              <entry>short_bits</entry>

              <entry>16</entry>
            </row>

            <row>
              <entry>int_bits</entry>

              <entry>16</entry>
            </row>

            <row>
              <entry>long_bits</entry>

              <entry>32</entry>
            </row>

            <row>
              <entry>signed_range</entry>

              <entry>symmetric</entry>
            </row>

            <row>
              <entry>char_type</entry>

              <entry>either</entry>
            </row>

            <row>
              <entry>ptr_int</entry>

              <entry>none</entry>
            </row>

            <row>
              <entry>ptr_fn</entry>

              <entry>yes</entry>
            </row>

            <row>
              <entry>non_prototype_checks</entry>

              <entry>yes</entry>
            </row>

            <row>
              <entry>multibyte</entry>

              <entry>0</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>The decimal integer associated with each of
        <emphasis>char_bits</emphasis>, <emphasis>short_bits</emphasis> ,
        <emphasis>int_bits</emphasis> and <emphasis>long_bits</emphasis> gives
        the minimum number of bits in the representation of each integer type on
        all target machines. For example, if <emphasis>int_bits</emphasis> is set
        to 32 the compiler will perform its checks in the knowledge that the
        program will not be used on a machine whose int types are represented by
        16 bits although they might be represented by 32 or 64 bits.</para>

      <para>The minimum integer ranges are deduced from the minimum integer
        sizes as follows. Suppose b is the minimum number of bits that will be
        used to represent a certain integral type, then:</para>

      <itemizedlist>
        <listitem>
          <para>For unsigned integer types the minimum range is [0,
            2<superscript>b</superscript>-1];</para>
        </listitem>

        <listitem>
          <para>For signed integer types if <literal>signed_range</literal> is
            maximum the minimum range is [-2<superscript>b-1</superscript>,
            2<superscript>b-1</superscript>-1]. Otherwise, if
            <emphasis>signed_range</emphasis> is symmetric the minimum range is
            [-(2<superscript>b-1</superscript>-1),
            2<superscript>b-1</superscript>-1];</para>
        </listitem>

        <listitem>
          <para>For the type char which is not specified as signed or unsigned,
            if <emphasis>char_type</emphasis> is signed then char is treated as
            signed, if <emphasis>char_type</emphasis> is unsigned then char is
            treated as unsigned, and if <emphasis>char_type</emphasis> is either,
            the minimum range of char is the intersection of the minimum ranges
            of signed char and unsigned char.</para>
        </listitem>
      </itemizedlist>
    </sect1>
  </appendix>

  <appendix id='sum-pragma-statements'>
    <title>Summary of the pragma statements</title>



    <table frame="none" id='pragma-syntax'>
      <title>pragma_syntax</title>
      <tgroup cols="2">
      <thead>
        <row>
          <entry>statement</entry>
          <entry>reference</entry>
        </row>
      </thead>
      <tbody>
      <row>
          <entry>#pragma TenDRA <emphasis>tendra_pragma</emphasis></entry>
          <entry></entry>
      </row>

      <row>
          <entry>#pragma token <emphasis>token_pragma</emphasis></entry>
          <entry></entry>
      </row>

      <row>
          <entry>#pragma <emphasis>token_operation</emphasis></entry>
          <entry></entry>
      </row>

      <row>
          <entry>#pragma <emphasis>integer_pragma</emphasis></entry>
          <entry></entry>
      </row>
      </tbody>
      </tgroup>
    </table>   










    <table frame="none" id='tendra-pragma'>
      <title>tendra_pragma</title>
      <tgroup cols="2">      
      <thead>
        <row>
          <entry>statement</entry>
          <entry>reference</entry>
        </row>
      </thead>
      <tbody>
      <row>
          <entry>begin</entry>
          <entry><xref linkend='scoping-check'> </entry>
      </row>

      <row>
          <entry>begin <emphasis>name</emphasis> environment <emphasis>identifier</emphasis></entry>
          <entry></entry>
      </row>

      <row>
          <entry>declaration block <emphasis>identifier</emphasis> begin</entry>
          <entry><xref linkend='abstract-api-headers'></entry>
      </row>

      <row>
          <entry>declaration block end</entry>
          <entry><xref linkend='abstract-api-headers'></entry>
      </row>

      <row>
          <entry>directory <emphasis>name</emphasis> use environment <emphasis>identifier</emphasis></entry>
          <entry></entry>
      </row>

      <row>
          <entry>use environment <emphasis>identifier</emphasis></entry>
          <entry></entry>
      </row>

      <row>
          <entry>end</entry>
          <entry><xref linkend='scoping-check'> </entry>
      </row>

      <row>
          <entry><emphasis>analysis_spec</emphasis></entry>
          <entry></entry>
      </row>

      <row>
          <entry><emphasis>function_pars</emphasis></entry>
          <entry><xref linkend='funct-param'></entry>
      </row>

      <row>
          <entry>keyword <emphasis>identifier</emphasis> for <emphasis>keyword_spec</emphasis></entry>
          <entry></entry>
      </row>

      <row>
          <entry>type <emphasis>identifier</emphasis> for <emphasis>type_spec</emphasis></entry>
          <entry></entry>
      </row>

      <row>
          <entry><emphasis>check_pragma</emphasis></entry>
          <entry></entry>
      </row>

      <row>
          <entry><emphasis>variable_pragma</emphasis></entry>
          <entry></entry>
      </row>

      <row>
          <entry><emphasis>dialect_pragma</emphasis></entry>
          <entry></entry>
      </row>
      </tbody>
      </tgroup>
    </table>   











    <table frame="none" id='analysis-spec'>
      <title>analysis_spec</title>
      <tgroup cols="2">      
      <thead>
        <row>
          <entry>statement</entry>
          <entry>reference</entry>
        </row>
      </thead>
      <tbody>
      <row>
          <entry>complete struct/union analysis <emphasis>state</emphasis></entry>
          <entry><xref linkend='incomplete-struct'> </entry>
      </row>

      <row>
          <entry>conversion <emphasis>conv_list</emphasis> allow</entry>
          <entry><xref linkend='user-def-conv'></entry>
      </row>

      <row>
          <entry>conversion analysis <emphasis>conversion_spec</emphasis></entry>
          <entry><xref linkend='type-conv'> </entry>
      </row>

      <row>
          <entry>discard analysis <emphasis>discard_spec</emphasis></entry>
          <entry><xref linkend='discard-analysis'> </entry>
      </row>

      <row>
          <entry>enum switch analysis <emphasis>state</emphasis></entry>
          <entry><xref linkend='enum-cont-switch-state'></entry>
      </row>

      <row>
          <entry>fall into case <emphasis>permit</emphasis></entry>
          <entry><xref linkend='case-fall-through'> </entry>
      </row>

      <row>
          <entry>function pointer as pointer <emphasis>permit</emphasis></entry>
          <entry><xref linkend='point-point-conv'> </entry>
      </row>

      <row>
          <entry>integer operator analysis <emphasis>state</emphasis></entry>
          <entry><xref linkend='int-operator-checks'></entry>
      </row>

      <row>
          <entry>integer overflow analysis <emphasis>state</emphasis></entry>
          <entry><xref linkend='int-overflow-checks'></entry>
      </row>

      <row>
          <entry>nested comment analysis <emphasis>state</emphasis></entry>
          <entry><xref linkend='nested-comments'></entry>
      </row>

      <row>
          <entry>operator precedence analysis <emphasis>state</emphasis></entry>
          <entry><xref linkend='operator-precedence'></entry>
      </row>

      <row>
          <entry>unreachable code <emphasis>permit</emphasis></entry>
          <entry><xref linkend='unreachable-code'> </entry>
      </row>

      <row>
          <entry>variable analysis <emphasis>state</emphasis></entry>
          <entry><xref linkend='unreachable-code'> </entry>
      </row>

      <row>
          <entry>variable hiding analysis <emphasis>state</emphasis></entry>
          <entry><xref linkend='variable-shadowing'></entry>
      </row>

      <row>
          <entry>weak prototype analysis <emphasis>state</emphasis></entry>
          <entry><xref linkend='type-check-proto'> </entry>
      </row>
      </tbody>
      </tgroup>
    </table>   








    <table frame="none" id='conversion-spec'>
      <title>conversion_spec</title>
      <tgroup cols="2">      
      <thead>
        <row>
          <entry>statement</entry>
          <entry>reference</entry>
        </row>
      </thead>
      <tbody>
      <row>
          <entry><emphasis>empty</emphasis></entry>
          <entry></entry>
      </row>

      <row>
          <entry>( int-int )</entry>
          <entry><xref linkend='int-int-conversions'> </entry>
      </row>

      <row>
          <entry>( int-int explicit )</entry>
          <entry><xref linkend='int-int-conversions'> </entry>
      </row>

      <row>
          <entry>( int-int implicit )</entry>
          <entry><xref linkend='int-int-conversions'> </entry>
      </row>

      <row>
          <entry>( int-enum implicit)</entry>
          <entry><xref linkend='int-int-conversions'> </entry>
      </row>

      <row>
          <entry>(enum-int implicit)</entry>
          <entry><xref linkend='int-int-conversions'> </entry>
      </row>

      <row>
          <entry>( int-pointer )</entry>
          <entry><xref linkend='point-int-int-int-conv'> </entry>
      </row>

      <row>
          <entry>( int-pointer explicit )</entry>
          <entry><xref linkend='point-int-int-int-conv'> </entry>
      </row>

      <row>
          <entry>(int-pointer implicit )</entry>
          <entry><xref linkend='point-int-int-int-conv'> </entry>
      </row>

      <row>
          <entry>( pointer-int )</entry>
          <entry><xref linkend='point-int-int-int-conv'> </entry>
      </row>

      <row>
          <entry>( pointer-int explicit )</entry>
          <entry><xref linkend='point-int-int-int-conv'> </entry>
      </row>

      <row>
          <entry>( pointer-int implicit )</entry>
          <entry><xref linkend='point-int-int-int-conv'> </entry>
      </row>

      <row>
          <entry>( pointer-pointer )</entry>
          <entry><xref linkend='point-point-conv'> </entry>
      </row>

      <row>
          <entry>( pointer-pointer explicit )</entry>
          <entry><xref linkend='point-point-conv'> </entry>
      </row>

      <row>
          <entry>( pointer-pointer implicit )</entry>
          <entry><xref linkend='point-point-conv'> </entry>
      </row>
      </tbody>
      </tgroup>
    </table>   








    <table frame="none" id='discard-spec'>
      <title>discard_spec</title>
      <tgroup cols="2">      
      <thead>
        <row>
          <entry>statement</entry>
          <entry>reference</entry>
        </row>
      </thead>
      <tbody>
      <row>
          <entry><emphasis>empty</emphasis></entry>
          <entry></entry>
      </row>

      <row>
          <entry>( function return )</entry>
          <entry><xref linkend='dicard-funct'> </entry>
      </row>

      <row>
          <entry>( static )</entry>
          <entry><xref linkend='unused-static-var'></entry>
      </row>

      <row>
          <entry>( value )</entry>
          <entry><xref linkend='discard-computed'> </entry>
      </row>
      </tbody>
      </tgroup>
    </table>   







    <table frame="none" id='function-pars'>
      <title>function_pars</title>
      <tgroup cols="2">
      <thead>
        <row>
          <entry>statement</entry>
          <entry>reference</entry>
        </row>
      </thead>
      <tbody>
      <row>
          <entry>argument <emphasis>type_name</emphasis> as <emphasis>type_name</emphasis></entry>
          <entry><xref linkend='funct-param'></entry>
      </row>

      <row>
          <entry>argument <emphasis>type_name</emphasis> as ...</entry>
          <entry><xref linkend='funct-param'></entry>
      </row>

      <row>
          <entry>extra ... <emphasis>permit</emphasis></entry>
          <entry><xref linkend='funct-param'></entry>
      </row>
      </tbody>
      </tgroup>
    </table>   







    <table frame="none" id='keyword-spec'>
      <title>keyword_spec</title>
      <tgroup cols="2">
      <thead>
        <row>
          <entry>statement</entry>
          <entry>reference</entry>
        </row>
      </thead>
      <tbody>
      <row>
          <entry>discard value</entry>
          <entry><xref linkend='dicard-funct-compute'></entry>
      </row>

      <row>
          <entry>discard variable</entry>
          <entry><xref linkend='discarding-var'></entry>
      </row>

      <row>
          <entry>exhaustive</entry>
          <entry><xref linkend='exhaustive-switch-state'></entry>
      </row>

      <row>
          <entry>fall into case</entry>
          <entry><xref linkend='case-fall-through'> </entry>
      </row>

      <row>
          <entry>set</entry>
          <entry><xref linkend='setting-var'></entry>
      </row>

      <row>
          <entry>set reachable</entry>
          <entry><xref linkend='unreachable-code'> </entry>
      </row>

      <row>
          <entry>set unreachable</entry>
          <entry><xref linkend='unreachable-code'> </entry>
      </row>

      <row>
          <entry>type representation</entry>
          <entry><xref linkend='int-int-conv-checks'></entry>
      </row>

      <row>
          <entry>weak</entry>
          <entry><xref linkend='type-check-proto'> </entry>
      </row>
      </tbody>
      </tgroup>
    </table>   






    <table frame="none" id='type-spec'>
      <title>type_spec</title>
      <tgroup cols="2">
      <thead>
        <row>
          <entry>statement</entry>
          <entry>reference</entry>
        </row>
      </thead>
      <tbody>
      <row>
          <entry>bottom</entry>
          <entry><xref linkend='non-returning-funct'></entry>
      </row>

      <row>
          <entry>... printf</entry>
          <entry><xref linkend='check-printf-strings'></entry>
      </row>

      <row>
          <entry>... scanf</entry>
          <entry><xref linkend='check-printf-strings'></entry>
      </row>
      </tbody>
      </tgroup>
    </table>   






    <table frame="none" id='check-pragma'>
      <title>check_pragma</title>
      <tgroup cols="2">
      <thead>
        <row>
          <entry>statement</entry>
          <entry>reference</entry>
        </row>
      </thead>
      <tbody>
      <row>
          <entry>implicit function declaration <emphasis>state</emphasis></entry>
          <entry><xref linkend='implicit-funct-decl'></entry>
      </row>

      <row>
          <entry>incompatible interface declaration <emphasis>permit</emphasis></entry>
          <entry><xref linkend='redclaring-obj-apis'></entry>
      </row>

      <row>
          <entry>incompatible void return <emphasis>permit</emphasis></entry>
          <entry><xref linkend='funct-return-checking'></entry>
      </row>
      </tbody>
      </tgroup>
    </table>   






    <table frame="none" id='variable-pragma'>
      <title>variable_pragma</title>
      <tgroup cols="2">
      <thead>
        <row>
          <entry>statement</entry>
          <entry>reference</entry>
        </row>
      </thead>
      <tbody>
      <row>
          <entry>discard <emphasis>identifier</emphasis> <emphasis>separator</emphasis></entry>
          <entry><xref linkend='discarding-var'></entry>
      </row>

      <row>
          <entry>preserve <emphasis>identifier_list</emphasis></entry>
          <entry><xref linkend='preserving-unised'></entry>
      </row>

      <row>
          <entry>set identifier <emphasis>separator</emphasis></entry>
          <entry><xref linkend='setting-var'></entry>
      </row>

      <row>
          <entry>suspend static <emphasis>identifier_list</emphasis></entry>
          <entry><xref linkend='preserving-unised'></entry>
      </row>

      <row>
          <entry>exhaustive</entry>
          <entry><xref linkend='exhaustive-switch-state'></entry>
      </row>
      </tbody>
      </tgroup>
    </table>   





    <table frame="none" id='separator'>
      <title>separator</title>
      <tgroup cols="2">
      <thead>
        <row>
          <entry>statement</entry>
          <entry>reference</entry>
        </row>
      </thead>
      <tbody>
      <row>
          <entry>;</entry>
          <entry></entry>
      </row>

      <row>
          <entry>,</entry>
          <entry></entry>
      </row>
      </tbody>
      </tgroup>
    </table>   






    <table frame="none" id='identifier-list'>
      <title>identifier_list</title>
      <tgroup cols="2">
      <thead>
        <row>
          <entry>statement</entry>
          <entry>reference</entry>
        </row>
      </thead>
      <tbody>
      <row>
          <entry><emphasis>identifier</emphasis></entry>
          <entry></entry>
      </row>

      <row>
          <entry><emphasis>identifier</emphasis> <emphasis>identifier_list</emphasis></entry>
          <entry></entry>
      </row>
      </tbody>
      </tgroup>
    </table>   







    <table frame="none" id='dialect-pragma'>
      <title>dialect_pragma</title>
      <tgroup cols="2">
      <thead>
        <row>
          <entry>statement</entry>
          <entry>reference</entry>
        </row>
      </thead>
      <tbody>
      <row>
          <entry>++</entry>
          <entry><xref linkend='compat-with-cpp'></entry>
      </row>

      <row>
          <entry>assignment as bool <emphasis>permit</emphasis></entry>
          <entry><xref linkend='use-assignments-cont'></entry>
      </row>

      <row>
          <entry>bitfield overflow <emphasis>permit</emphasis></entry>
          <entry><xref linkend='int-overflow-checks'></entry>
      </row>

      <row>
          <entry>block function static <emphasis>permit</emphasis></entry>
          <entry><xref linkend='static-block-level'></entry>
      </row>

      <row>
          <entry>character <emphasis>set_sign</emphasis></entry>
          <entry><xref linkend='bitfield-types'></entry>
      </row>

      <row>
          <entry>character escape overflow <emphasis>permit</emphasis></entry>
          <entry><xref linkend='int-overflow-checks'></entry>
      </row>

      <row>
          <entry>compatible type : char * == void * : <emphasis>permit</emphasis></entry>
          <entry><xref linkend='point-point-conv'> </entry>
      </row>

      <row>
          <entry>conditional lvalue <emphasis>dallow</emphasis></entry>
          <entry><xref linkend='conditional-lvalues'></entry>
      </row>

      <row>
          <entry>const conditional <emphasis>permit</emphasis></entry>
          <entry><xref linkend='constant-cont-exp'></entry>
      </row>

      <row>
          <entry>dollar as ident <emphasis>dallow</emphasis></entry>
          <entry><xref linkend='identifier-names'></entry>
      </row>

      <row>
          <entry>directive <emphasis>pp_directive pp_spec</emphasis></entry>
          <entry><xref linkend='preprocessor-directives'></entry>
      </row>

      <row>
          <entry>directive as macro argument <emphasis>permit</emphasis></entry>
          <entry><xref linkend='macro-arguments'></entry>
      </row>

      <row>
          <entry>external volatile_t</entry>
          <entry><xref linkend='external-vol'></entry>
      </row>

      <row>
          <entry>extra ; <emphasis>permit</emphasis></entry>
          <entry><xref linkend='extra-semicolons'></entry>
      </row>

      <row>
          <entry>extra ; after conditional <emphasis>permit</emphasis></entry>
          <entry><xref linkend='empty-statements'></entry>
      </row>

      <row>
          <entry>extra , <emphasis>permit</emphasis></entry>
          <entry><xref linkend='extra-commas'></entry>
      </row>

      <row>
          <entry>extra bitfield int type <emphasis>permit</emphasis></entry>
          <entry><xref linkend='bitfield-types'></entry>
      </row>

      <row>
          <entry>extra macro definition <emphasis>dallow</emphasis></entry>
          <entry><xref linkend='multiple-macro'></entry>
      </row>

      <row>
          <entry>extra type definition <emphasis>permit</emphasis></entry>
          <entry><xref linkend='extra-type-def'></entry>
      </row>

      <row>
          <entry>forward enum declaration <emphasis>dallow</emphasis></entry>
          <entry><xref linkend='forward-enumeration'></entry>
      </row>

      <row>
          <entry>floating point equality <emphasis>permit</emphasis></entry>
          <entry><xref linkend='floating-point-equal'></entry>
      </row>

      <row>
          <entry>ident ... <emphasis>permit</emphasis> </entry>
          <entry><xref linkend='ellipsis-funct-calls'></entry>
      </row>

      <row>
          <entry>ignore struct/union/enum tag <emphasis>status</emphasis></entry>
          <entry><xref linkend='unifying-tag-name-space'></entry>
      </row>

      <row>
          <entry>implicit int type for external declaration <emphasis>permit</emphasis></entry>
          <entry><xref linkend='implicit-int'></entry>
      </row>

      <row>
          <entry>implicit int type for function return <emphasis>permit</emphasis></entry>
          <entry><xref linkend='implicit-int'></entry>
      </row>

      <row>
          <entry>includes depth <emphasis>integral_constant</emphasis></entry>
          <entry><xref linkend='include-depth'></entry>
      </row>

      <row>
          <entry>incompatible linkage <emphasis>permit</emphasis></entry>
          <entry><xref linkend='identifier-linkage'></entry>
      </row>

      <row>
          <entry>incompatible promoted function argument <emphasis>dallow</emphasis></entry>
          <entry><xref linkend='impat-promo-funct'></entry>
      </row>

      <row>
          <entry>incompatible type qualifier <emphasis>dallow</emphasis></entry>
          <entry><xref linkend='incompat-type-qual'></entry>
      </row>

      <row>
          <entry>incomplete type as object type <emphasis>permit</emphasis></entry>
          <entry><xref linkend='incomplete-array'></entry>
      </row>

      <row>
          <entry>indented # directive <emphasis>permit</emphasis></entry>
          <entry><xref linkend='indented-preprocessing'></entry>
      </row>

      <row>
          <entry>initialization of struct/union (auto) <emphasis>permit</emphasis></entry>
          <entry><xref linkend='init-compound-types'></entry>
      </row>

      <row>
          <entry>linkage resolution : <emphasis>linkage_spec</emphasis></entry>
          <entry><xref linkend='resolving-linkage'></entry>
      </row>

      <row>
          <entry>longlong type <emphasis>permit</emphasis></entry>
          <entry><xref linkend='support-bit-int'></entry>
      </row>

      <row>
          <entry>no directive/nline after ident <emphasis>permit</emphasis></entry>
          <entry><xref linkend='text-after'></entry>
      </row>

      <row>
          <entry>no external declaration <emphasis>permit</emphasis></entry>
          <entry><xref linkend='empty-src'></entry>
      </row>

      <row>
          <entry>no ident after # <emphasis>permit</emphasis></entry>
          <entry><xref linkend='macro-arguments'></entry>
      </row>

      <row>
          <entry>no nline after file end <emphasis>permit</emphasis></entry>
          <entry><xref linkend='new-line-end'></entry>
      </row>

      <row>
          <entry>prototype <emphasis>permit</emphasis></entry>
          <entry><xref linkend='funct-type-check'></entry>
      </row>

      <row>
          <entry>prototype (weak) <emphasis>permit</emphasis></entry>
          <entry><xref linkend='type-check-proto'> </entry>
      </row>

      <row>
          <entry>set longlong type : <emphasis>type_name</emphasis></entry>
          <entry><xref linkend='support-bit-int'></entry>
      </row>

      <row>
          <entry>set name limit <emphasis>integer_constant</emphasis></entry>
          <entry><xref linkend='identifier-name-length'></entry>
      </row>

      <row>
          <entry>set size_t : <emphasis>type_name</emphasis></entry>
          <entry><xref linkend='abstract-api-types'></entry>
      </row>

      <row>
          <entry>text after directive <emphasis>permit</emphasis></entry>
          <entry><xref linkend='text-after-endif'></entry>
      </row>

      <row>
          <entry>unify external linkage <emphasis>status</emphasis></entry>
          <entry><xref linkend='resolving-linkage'></entry>
      </row>

      <row>
          <entry>unify incompatible string literal <emphasis>permit</emphasis></entry>
          <entry><xref linkend='concat-char'></entry>
      </row>

      <row>
          <entry>unknown escape <emphasis>permit</emphasis></entry>
          <entry><xref linkend='escape-seq'></entry>
      </row>

      <row>
          <entry>unknown pragma <emphasis>permit</emphasis></entry>
          <entry><xref linkend='preprocessor-directives'></entry>
      </row>

      <row>
          <entry>unknown struct/union <emphasis>dallow</emphasis></entry>
          <entry><xref linkend='untagged-compound'></entry>
      </row>

      <row>
          <entry>unknown directive <emphasis>permit</emphasis></entry>
          <entry><xref linkend='preprocessor-directives'></entry>
      </row>

      <row>
          <entry>unmatched quote <emphasis>permit</emphasis></entry>
          <entry><xref linkend='unmatched-quotes'></entry>
      </row>

      <row>
          <entry>variable initialization <emphasis>dallow</emphasis></entry>
          <entry><xref linkend='var-init'></entry>
      </row>

      <row>
          <entry>weak macro equality <emphasis>permit</emphasis></entry>
          <entry><xref linkend='multiple-macro'></entry>
      </row>

      <row>
          <entry>writeable string literal <emphasis>permit</emphasis></entry>
          <entry><xref linkend='writable-string-lit'></entry>
      </row>
      </tbody>
      </tgroup>
    </table>   






    <table frame="none" id='set-sign'>
      <title>set_sign</title>
      <tgroup cols="2">
      <thead>
        <row>
          <entry>statement</entry>
          <entry>reference</entry>
        </row>
      </thead>
      <tbody>
      <row>
          <entry>signed</entry>
          <entry></entry>
      </row>

      <row>
          <entry>unsign</entry>
          <entry></entry>
      </row>

      <row>
          <entry>either</entry>
          <entry></entry>
      </row>
      </tbody>
      </tgroup>
    </table>   






    <table frame="none" id='pp-directive'>
      <title>pp_directive</title>
      <tgroup cols="2">
      <thead>
        <row>
          <entry>statement</entry>
          <entry>reference</entry>
        </row>
      </thead>
      <tbody>
      <row>
          <entry>file</entry>
          <entry></entry>
      </row>

      <row>
          <entry>ident</entry>
          <entry></entry>
      </row>

      <row>
          <entry>assert</entry>
          <entry></entry>
      </row>

      <row>
          <entry>unassert</entry>
          <entry></entry>
      </row>

      <row>
          <entry>weak</entry>
          <entry></entry>
      </row>
      </tbody>
      </tgroup>
    </table>   






    <table frame="none" id='pp-spec'>
      <title>pp_spec</title>
      <tgroup cols="2">
      <thead>
        <row>
          <entry>statement</entry>
          <entry>reference</entry>
        </row>
      </thead>
      <tbody>
      <row>
          <entry>allow</entry>
          <entry></entry>
      </row>

      <row>
          <entry>warning</entry>
          <entry></entry>
      </row>

      <row>
          <entry>(ignore) allow</entry>
          <entry></entry>
      </row>

      <row>
          <entry>(ignore) warning</entry>
          <entry></entry>
      </row>
      </tbody>
      </tgroup>
    </table>   






    <table frame="none" id='linkage-spec'>
      <title>linkage_spec</title>
      <tgroup cols="2">
      <thead>
        <row>
          <entry>statement</entry>
          <entry>reference</entry>
        </row>
      </thead>
      <tbody>
      <row>
          <entry>(internal) on</entry>
          <entry></entry>
      </row>

      <row>
          <entry>(internal) warning</entry>
          <entry></entry>
      </row>

      <row>
          <entry>(external) on</entry>
          <entry></entry>
      </row>

      <row>
          <entry>(external) warning</entry>
          <entry></entry>
      </row>

      <row>
          <entry>off</entry>
          <entry></entry>
      </row>
      </tbody>
      </tgroup>
    </table>   






    <table frame="none" id='state'>
      <title>state</title>
      <tgroup cols="2">
      <thead>
        <row>
          <entry>statement</entry>
          <entry>reference</entry>
        </row>
      </thead>
      <tbody>
      <row>
          <entry>on</entry>
          <entry></entry>
      </row>

      <row>
          <entry>warning</entry>
          <entry></entry>
      </row>

      <row>
          <entry>off</entry>
          <entry></entry>
      </row>
      </tbody>
      </tgroup>
    </table>   






    <table frame="none" id='permit'>
      <title>permit</title>
      <tgroup cols="2">
      <thead>
        <row>
          <entry>statement</entry>
          <entry>reference</entry>
        </row>
      </thead>
      <tbody>
      <row>
          <entry>allow</entry>
          <entry></entry>
      </row>

      <row>
          <entry>warning</entry>
          <entry></entry>
      </row>

      <row>
          <entry>disallow</entry>
          <entry></entry>
      </row>
      </tbody>
      </tgroup>
    </table>   






    <table frame="none" id='dallow'>
      <title>dallow</title>
      <tgroup cols="2">
      <thead>
        <row>
          <entry>statement</entry>
          <entry>reference</entry>
        </row>
      </thead>
      <tbody>
      <row>
          <entry>allow</entry>
          <entry></entry>
      </row>

      <row>
          <entry>disallow</entry>
          <entry></entry>
      </row>
      </tbody>
      </tgroup>
    </table>   






    <table frame="none" id='token-pragma'>
      <title>token_pragma</title>
      <tgroup cols="2">
      <thead>
        <row>
          <entry>statement</entry>
          <entry>reference</entry>
        </row>
      </thead>
      <tbody>
      <row>
          <entry>ARITHMETIC</entry>
          <entry><xref linkend='arithmetic-type-tok'></entry>
      </row>

      <row>
          <entry>DEFINE MEMBER</entry>
          <entry></entry>
      </row>

      <row>
          <entry>EXP</entry>
          <entry><xref linkend='expression-tokens'></entry>
      </row>

      <row>
          <entry>FUNC</entry>
          <entry><xref linkend='funct-prod-tok'></entry>
      </row>

      <row>
          <entry>MEMBER</entry>
          <entry><xref linkend='selector-tok'></entry>
      </row>

      <row>
          <entry>NAT</entry>
          <entry><xref linkend='expression-tokens'></entry>
      </row>

      <row>
          <entry>PROC</entry>
          <entry><xref linkend='general-prod-tok'></entry>
      </row>

      <row>
          <entry>STATEMENT</entry>
          <entry><xref linkend='statement-tokens'></entry>
      </row>

      <row>
          <entry>STRUCT</entry>
          <entry><xref linkend='compound-type-tok'></entry>
      </row>

      <row>
          <entry>TYPE</entry>
          <entry><xref linkend='general-type-tok'></entry>
      </row>

      <row>
          <entry>UNION</entry>
          <entry><xref linkend='compound-type-tok'></entry>
      </row>

      <row>
          <entry>VARIETY</entry>
          <entry><xref linkend='integral-type-tok'></entry>
      </row>
      </tbody>
      </tgroup>
    </table>   






    <table frame="none" id='token-operation'>
      <title>token_operation</title>
      <tgroup cols="2">
      <thead>
        <row>
          <entry>statement</entry>
          <entry>reference</entry>
        </row>
      </thead>
      <tbody>
      <row>
          <entry>define</entry>
          <entry></entry>
      </row>

      <row>
          <entry>no_def</entry>
          <entry></entry>
      </row>

      <row>
          <entry>extend</entry>
          <entry></entry>
      </row>

      <row>
          <entry>ignore</entry>
          <entry></entry>
      </row>

      <row>
          <entry>implement</entry>
          <entry></entry>
      </row>

      <row>
          <entry>interface</entry>
          <entry></entry>
      </row>

      <row>
          <entry>promote</entry>
          <entry><xref linkend='specifying-int-pro'></entry>
      </row>
      </tbody>
      </tgroup>
    </table>   





    <table frame="none" id='integer-pragma'>
      <title>integer_pragma</title>
      <tgroup cols="2">
      <thead>
        <row>
          <entry>statement</entry>
          <entry>reference</entry>
        </row>
      </thead>
      <tbody>
      <row>
          <entry>integer literal <emphasis>lit_class_type_list</emphasis></entry>
          <entry><xref linkend='spec-int-lit-types'></entry>
      </row>
      </tbody>
      </tgroup>
    </table>   




    <table frame="none" id='lit-class-type-list'>
      <title>lit_class_type_list</title>
      <tgroup cols="2">
      <thead>
        <row>
          <entry>statement</entry>
          <entry>reference</entry>
        </row>
      </thead>
      <tbody>
      <row>
          <entry>*<emphasis>int_type_spec</emphasis></entry>
          <entry></entry>
      </row>

      <row>
          <entry>integer_constant <emphasis>int_type_spec</emphasis> | <emphasis>lit_class_type_list</emphasis></entry>
          <entry></entry>
      </row>
      </tbody>
      </tgroup>
    </table>   





    <table frame="none" id='int-type-spec'>
      <title>int_type_spec</title>
      <tgroup cols="2">
      <thead>
        <row>
          <entry>statement</entry>
          <entry>reference</entry>
        </row>
      </thead>
      <tbody>
      <row>
          <entry><emphasis>type_name</emphasis></entry>
          <entry></entry>
      </row>

      <row>
          <entry>*warning<subscript><emphasis>opt</emphasis></subscript> : <emphasis>identifier</emphasis></entry>
          <entry></entry>
      </row>

      <row>
          <entry>** :</entry>
          <entry></entry>
      </row>
      </tbody>
      </tgroup>
    </table>   




  <appendix id='dump-format-spec'>
    <title>Dump format specification</title>

    <sect1 id='basics'>
      <title>Basics</title>

      <para>digit :</para>
<programlisting linenumbering='unnumbered'>
one of 0 1 2 3 4 5 6 7 8 9
</programlisting>

      <para>digit-sequence :</para>
<programlisting linenumbering='unnumbered'>
<emphasis>digit</emphasis>
<emphasis>digit-sequence</emphasis>
</programlisting>

      <para>number :</para>
<programlisting linenumbering='unnumbered'>
<emphasis>digit-sequence</emphasis>
</programlisting>

      <para>string :</para>
<programlisting linenumbering='unnumbered'>
<emphasis>&lt;characters&gt;</emphasis>
<emphasis>&amp;digit-sequence&lt;characters&gt;</emphasis>
</programlisting>

      <para>location :</para>
<programlisting linenumbering='unnumbered'>
<emphasis>number number number string string</emphasis>
<emphasis>number number number string *</emphasis>
<emphasis>number number number *</emphasis>
<emphasis>number number *</emphasis>
<emphasis>number *</emphasis>
<emphasis>*</emphasis>
</programlisting>
    </sect1>

    <sect1 id='dump-commands'>
      <title>Dump commands</title>

      <para>dump-file :</para>
<programlisting>
<emphasis>command-list</emphasis><emphasis>opt</emphasis>
command-list :
<emphasis>command</emphasis>
<emphasis>command command-list</emphasis>
</programlisting>

      <para>command :</para>
<programlisting>
<emphasis>B base-definition</emphasis>  <emphasis>base class graph</emphasis>
<emphasis>error-command</emphasis>
<emphasis>file-command</emphasis>
<emphasis>I identifier-command</emphasis>  <emphasis>implicit declarations etc.</emphasis>
<emphasis>identifier-command</emphasis>
<emphasis>scope-command</emphasis>
<emphasis>O identifier identifier</emphasis> <emphasis>overriding virtual function</emphasis>
<emphasis>P type : type</emphasis>  <emphasis>promotion type specifier</emphasis>
<emphasis>string-command</emphasis>
<emphasis>V number number string</emphasis>  <emphasis>version number</emphasis>
<emphasis>X api-info</emphasis>  <emphasis>external token name</emphasis>
<emphasis>Z template-info</emphasis>    <emphasis>template instance</emphasis>
</programlisting>
    </sect1>

    <sect1 id='api-info'>
      <title>API information</title>

      <para>api-info :</para>
<programlisting>
<emphasis>identifier key identifier string</emphasis>
</programlisting>
    </sect1>

    <sect1 id='base-def'>
      <title>Base definitions</title>

      <para>virtual :</para>
<programlisting>
<emphasis>V</emphasis>
</programlisting>

      <para>base-class :</para>
<programlisting>
<emphasis>number = virtual</emphasis><emphasis>opt</emphasis> <emphasis>access</emphasis><emphasis>opt</emphasis> <emphasis>type-name</emphasis>
<emphasis>number :</emphasis>
</programlisting>

      <para>base-list :</para>
<programlisting>
<emphasis>base-graph</emphasis>
<emphasis>base-graph base-list</emphasis>
</programlisting>

      <para>base-graph :</para>
<programlisting>
<emphasis>base-class</emphasis>
<emphasis>base-class ( base-list )</emphasis>
</programlisting>

      <para>base-definition :</para>
<programlisting>
<emphasis>identifier-key number base-graph</emphasis>
</programlisting>

      <para>base-number :</para>
<programlisting>
<emphasis>number : type-name</emphasis>
</programlisting>
    </sect1>

    <sect1 id='error-commands'>
      <title>Error commands</title>

      <para>error-command :</para>
<programlisting>
<emphasis>EA error-argument</emphasis>  <emphasis>error argument</emphasis>
<emphasis>EC error-info</emphasis>  <emphasis>continuation error</emphasis>
<emphasis>EF location error-info</emphasis>  <emphasis>fatal error</emphasis>
<emphasis>EI location error-info</emphasis>  <emphasis>internal error</emphasis>
<emphasis>ES location error-info</emphasis>  <emphasis>serious error</emphasis>
<emphasis>EW location error-info</emphasis>  <emphasis>warning</emphasis>
</programlisting>

      <para>error-info :</para>
<programlisting>
<emphasis>error-name number number</emphasis>
</programlisting>

      <para>error-name :</para>
<programlisting>
<emphasis>number = string</emphasis>
<emphasis>number</emphasis>
</programlisting>

      <para>error-argument :</para>
<programlisting>
<emphasis>B base-number</emphasis>
<emphasis>C scope-identifier</emphasis>
<emphasis>E exp</emphasis>
<emphasis>H hashid</emphasis>
<emphasis>I identifier</emphasis>
<emphasis>L location</emphasis>
<emphasis>N nat</emphasis>
<emphasis>S string</emphasis>
<emphasis>T type</emphasis>
<emphasis>V number</emphasis>
<emphasis>V -number</emphasis>
</programlisting>
    </sect1>

    <sect1 id='file-commands'>
      <title>File commands</title>

      <para>file-command :</para>
<programlisting>
<emphasis>FD number = string stringopt</emphasis>  <emphasis>inclusion directory</emphasis>
<emphasis>FE location</emphasis> <emphasis>file end</emphasis>
<emphasis>FIA location string</emphasis> <emphasis>file include with &lt;&gt;</emphasis>
<emphasis>FIE location string</emphasis> <emphasis>include end-up</emphasis>
<emphasis>FIN location string</emphasis> <emphasis>file include with []</emphasis>
<emphasis>FIQ location string</emphasis>    <emphasis>file include with &quot;&quot;</emphasis>
FIR location    <emphasis>resume file</emphasis>
FIS location string <emphasis>include startup</emphasis>
FS location directory   <emphasis>file start</emphasis>
</programlisting>

      <para>directory :</para>
<programlisting>
number
*
</programlisting>
    </sect1>

    <sect1 id='ident-commands'>
      <title>Identifier commands</title>

      <para>identifier-command :</para>
<programlisting>
C identifier-info   <emphasis>call identifier</emphasis>
D identifier-info type-info <emphasis>define identifier</emphasis>
L identifier-info   <emphasis>use identifier</emphasis>
M identifier-info type-info <emphasis>declare identifier</emphasis>
Q identifier-info   <emphasis>end identifier definition</emphasis>
T identifier-info type-info <emphasis>tentatively define identifier</emphasis>
U identifier-info   <emphasis>undefine identifier</emphasis>
W identifier-info type-info <emphasis>weak prototype</emphasis>
</programlisting>

      <para>identifier-info :</para>
<programlisting>
identifier-key location identifier
</programlisting>

      <para>identifier-key :</para>
<programlisting>
CD  <emphasis>static data member</emphasis>
CF function-key <emphasis>member function</emphasis>
CM  <emphasis>data member</emphasis>
CS function-key <emphasis>static member function</emphasis>
CV function-key <emphasis>virtual member function</emphasis>
E   <emphasis>enumerator</emphasis>
FB function-key <emphasis>builtin function</emphasis>
FE function key <emphasis>external function</emphasis>
FS function-key <emphasis>static function</emphasis>
K   <emphasis>keyword</emphasis>
L   <emphasis>label</emphasis>
MB  <emphasis>built-in macro</emphasis>
MF  <emphasis>function-like macro</emphasis>
MO  <emphasis>object-like macro</emphasis>
NA  <emphasis>namespace alias</emphasis>
NN  <emphasis>namespace name</emphasis>
TA  <emphasis>type alias</emphasis>
TC  <emphasis>class tag</emphasis>
TE  <emphasis>enum tag</emphasis>
TS  <emphasis>struct tag</emphasis>
TU  <emphasis>union tag</emphasis>
VA  <emphasis>automatic variable</emphasis>
VE  <emphasis>extern variable</emphasis>
VP  <emphasis>function parameter</emphasis>
VS  <emphasis>static variable</emphasis>
XF  <emphasis>procedure token</emphasis>
XO  <emphasis>object token</emphasis>
XP  <emphasis>token parameter</emphasis>
XT  <emphasis>template parameter</emphasis>
</programlisting>

      <para>function-key :</para>
<programlisting>
empty
C function-key  <emphasis>C linkage</emphasis>
I function-key  <emphasis>inline</emphasis>
</programlisting>

      <para>identifier :</para>
<programlisting>
number = hashid accessopt scope-identifier
number
</programlisting>

      <para>hashid :</para>
<programlisting>
string  <emphasis>simple name</emphasis>
C type  <emphasis>constructor</emphasis>
D type  <emphasis>destructor</emphasis>
O string    <emphasis>operator</emphasis>
T type  <emphasis>conversion</emphasis>
</programlisting>

      <para>access :</para>
<programlisting>
B   <emphasis>protected</emphasis>
N   <emphasis>public</emphasis>
P   <emphasis>private</emphasis>
</programlisting>
    </sect1>

    <sect1 id='scope-commands'>
      <title>Scope commands</title>

      <para>scope-command :</para>
<programlisting>
SE scope-key location identifier    <emphasis>end scope</emphasis>
SS scope-key location identifier    <emphasis>start scope</emphasis>
</programlisting>

      <para>scope-key :</para>
<programlisting>
B   <emphasis>block scope</emphasis>
CC  <emphasis>conditional scope</emphasis>
N   <emphasis>namespace scope</emphasis>
CF  <emphasis>false conditional scope</emphasis>
CT  <emphasis>true conditional scope</emphasis>
D   <emphasis>other declarative scope</emphasis>
H   <emphasis>header scope</emphasis>
S   <emphasis>class scope</emphasis>
</programlisting>

      <para>scope-identifier :</para>
<programlisting>
identifier
*
</programlisting>
    </sect1>

    <sect1 id='string-command'>
      <title>String command</title>

      <para>string-command :</para>
<programlisting>
A location string   <emphasis>string literal</emphasis>
AC location string  <emphasis>character literal</emphasis>
ACL location string <emphasis>wide character literal</emphasis>
AL location string  <emphasis>wide string literal</emphasis>
</programlisting>
    </sect1>

    <sect1 id='templates'>
      <title>Templates</title>

      <para>specialisation-info :</para>
<programlisting>
token-application
*
</programlisting>

      <para>template-info :</para>
<programlisting>
identifier-key identifier token-application specialisation-info
</programlisting>
    </sect1>

    <sect1 id='token-sort-info'>
      <title>Token sort information</title>

      <para>sort :</para>
<programlisting>
ZEC type-info   <emphasis>constant expression</emphasis>
ZEL type-info   <emphasis>lvalue expression</emphasis>
ZER type-info   <emphasis>rvalue expression</emphasis>
ZF type-info    <emphasis>function</emphasis>
ZM type-info : type-name    <emphasis>member</emphasis>
ZN  <emphasis>integral constant</emphasis>
ZPS parameter-list-opt : sort   <emphasis>procedure type ()</emphasis>
ZPG parameter-list-opt ; parameter-list-opt:sort
<emphasis>procedure type {}</emphasis>
ZS  <emphasis>statement</emphasis>
ZTA <emphasis>arithmetic type</emphasis>
ZTF <emphasis>floating type</emphasis>
ZTI <emphasis>integral type</emphasis>
ZTO <emphasis>opaque type</emphasis>
ZTP <emphasis>scalar type</emphasis>
ZTS <emphasis>structure type</emphasis>
ZTt parameter-list-opt :    <emphasis>template type</emphasis>
ZTTS    <emphasis>structure tag</emphasis>
ZTTU    <emphasis>union tag</emphasis>
ZTU <emphasis>union type</emphasis>
ZUF number  <emphasis>function macro</emphasis>
ZUO <emphasis>object macro</emphasis>
</programlisting>

      <para>exp :</para>
<programlisting>
nat
</programlisting>

      <para>member :</para>
<programlisting>
identifier
string
</programlisting>

      <para>statement :</para>
<programlisting>
exp
</programlisting>

      <para>token-argument :</para>
<programlisting>
C identifier    <emphasis>template argument</emphasis>
E exp   <emphasis>expression argument</emphasis>
F identifier    <emphasis>function argument</emphasis>
M member    <emphasis>member argument</emphasis>
N nat   <emphasis>integer constant argument</emphasis>
S statement <emphasis>statement argument</emphasis>
T type-info <emphasis>type argument</emphasis>
</programlisting>

      <para>token-argument-list :</para>
<programlisting>
token-argument
token-argument , token-argument-list
</programlisting>

      <para>token-application :</para>
<programlisting>
T identifier , token-argument-list :
</programlisting>
    </sect1>

    <sect1 id='type-info'>
      <title>Type information</title>

      <para>type-info :</para>
<programlisting>
scope-identifier    <emphasis>for namespace alias</emphasis>
sort    <emphasis>for token, macro etc.</emphasis>
type    <emphasis>for variable etc.</emphasis>
type identifier-opt <emphasis>for overloaded function</emphasis>
</programlisting>

      <para>type :</para>
<programlisting>
qualifieropt unqualified-type
</programlisting>

      <para>qualifier :</para>
<programlisting>
C   <emphasis>const</emphasis>
V   <emphasis>volatile</emphasis>
CV  <emphasis>const volatile</emphasis>
</programlisting>

      <para>unqualified-type :</para>
<programlisting>
type-name
token-application
c   <emphasis>char</emphasis>
s   <emphasis>short</emphasis>
i   <emphasis>int</emphasis>
l   <emphasis>long</emphasis>
x   <emphasis>long long</emphasis>
f   <emphasis>float</emphasis>
d   <emphasis>double</emphasis>
r   <emphasis>long double</emphasis>
v   <emphasis>void</emphasis>
b   <emphasis>bool</emphasis>
w   <emphasis>wchar_t</emphasis>
Sc  <emphasis>signed char</emphasis>
Uc  <emphasis>unsigned char</emphasis>
Us  <emphasis>unsigned short</emphasis>
Ui  <emphasis>unsigned int</emphasis>
Ul  <emphasis>unsigned long</emphasis>
Ux  <emphasis>unsigned long long</emphasis>
u   <emphasis>bottom</emphasis>
y   <emphasis>ptrdiff_t</emphasis>
z   <emphasis>size_t</emphasis>
a type : type   <emphasis>arithmetic type</emphasis>
n nat   <emphasis>literal type</emphasis>
p type  <emphasis>promoted type</emphasis>
t parameter-listopt : type  <emphasis>template type</emphasis>
A natopt : type <emphasis>array type</emphasis>
B nat : type    <emphasis>bitfield type</emphasis>
F type parameter-types  <emphasis>function type</emphasis>
M type-name : type  <emphasis>pointer to member type</emphasis>
P type  <emphasis>pointer type</emphasis>
R type  <emphasis>reference type</emphasis>
W type parameter-types  <emphasis>weak function type</emphasis>
Q string    <emphasis>quoted type</emphasis>
*   <emphasis>unknown type</emphasis>
</programlisting>

      <para>parameter-types :</para>
<programlisting>
: exceptionopt qualifieropt :   <emphasis>no parameters</emphasis>
. exceptionopt qualifieropt :   <emphasis>ellipsis</emphasis>
. exceptionopt qualifieropt .   <emphasis>unknown</emphasis>
, type parameter-types
</programlisting>

      <para>exception :</para>
<programlisting>
( exception-listopt )
</programlisting>

      <para>exception-list :</para>
<programlisting>
type
type, exception-list
</programlisting>

      <para>parameter-list :</para>
<programlisting>
identifier
identifier , parameter-list
</programlisting>

      <para>type-name :</para>
<programlisting>
identifier
</programlisting>

      <para>nat :</para>
<programlisting>
+number
-number
string
identifier
token-application
</programlisting>
    </sect1>
  </appendix>

  <appendix id='token-syntax-a'>
    <title>The Token Syntax</title>

    <sect1 id='intro-c'>
      <title>Introduction</title>

      <para>The token syntax is used to introduce references to program
        constructs such as types, expressions etc. that can be defined in other
        compilation modules. This can be thought of as a generalisation of
        function prototyping which is used to introduce references to functions
        defined elsewhere. The references introduced by the token syntax are
        called tokens because they are tokens for the program constructs that
        they reference. The token syntax is said to specify a token
        interface.</para>

      <para>It is expected that the general user will have little direct
        contact with the token syntax, instead using the abstract standard
        headers provided or using the tspec tool [Ref. 5] to generate their own
        token interface header files automatically. However, it may occasionally
        be necessary to use the raw power of the token syntax directly.</para>

      <para>As an example of the power of the token syntax consider the program
        below:</para>
<programlisting>
#pragma token TYPE FILE#
#pragma token EXP rvalue:FILE *:stderr#
int fprintf(FILE *, const char *, ...);
void f(void) {
fprintf(stderr,&quot;hello world\n&quot;);
}
</programlisting>

      <para>The first line of the program introduces a token, FILE, for a type.
        By using its identification, FILE, this token can be used wherever a type
        could have been used throughout the rest of the program. The compiler can
        then compile this program to TDF (the abstract TenDRA machine) even
        though it contains an undefined type. This is fundamental to the
        construction of portable software, where the developer cannot assume the
        definitions of various types as they may be different on different
        machines.</para>

      <para>The second line of the example, which introduces a token for an
        expression, is somewhat more complicated. In order to make use of an
        expression, it is necessary to know its type and whether or not it is an
        lvalue (i.e. whether or not it can be assigned to). As can be seen from
        the example however, it is not necessary to know the exact type of the
        expression because a token can be used to represent its type.</para>

      <para>The TenDRA compiler makes no assumptions about the possible
        definitions of tokens and will raise an error if a program requires
        information about an undefined token. In this way many errors resulting
        from inadvertent use of a definition present on the developer's system
        can be detected. For example, developers often assume that the type FILE
        will be implemented by a structure type when in fact the ISO C standard
        permits the implementation of FILE by any type. In the program above, any
        attempt to access members of stderr would cause the compiler to raise an
        error.</para>
    </sect1>

    <sect1 id='program-construction'>
      <title>Program construction using TDF</title>

      <para>Traditional program construction using the C language has two
        phases: compilation and linking.</para>

      <para>In the compilation phase the source text written in the C language
        is mapped to an object code format. This object code is generally not
        complete in itself and must be linked with other program segments such as
        definitions from the system libraries.</para>

      <para>When tokens are involved there is an extra stage in the
        construction process where undefined tokens in one program segment are
        linked with their definitions in another program segment. To summarise,
        program construction using TDF and the TenDRA tools has four basic
        operations:</para>

      <orderedlist>
        <listitem>
          <para>Source file compilation to TDF. The TDF produced may be
            incomplete in the sense that it may contain undefined tokens;</para>
        </listitem>

        <listitem>
          <para>TDF linking. The undefined tokens represented in TDF are linked
            to their definitions in other compilation modules or libraries.
            During linking, tokens with the same identifier are treated as the
            same token;</para>
        </listitem>

        <listitem>
          <para>TDF translation. This is the conversion of TDF into standard
            object file format for a particular machine system. The program is
            still incomplete at this stage in the sense that it may contain
            undefined library functions;</para>
        </listitem>

        <listitem>
          <para>Object file linking. This corresponds directly to standard
            object file linking.</para>
        </listitem>
      </orderedlist>
    </sect1>

    <sect1 id='token-syntax-b'>
      <title>The token syntax</title>

      <para>The token syntax is an extension to the ISO C standard language to
        allow the use of tokens to represent program constructs. Tokens can be
        used either in place of, or as well as, the definitions required by a
        program. In the latter case, the tokens exist merely to enforce correct
        definitions and usage of the objects they reference. However it should be
        noted that the presence of a token introduction can alter the semantics
        of a program (examples are given in <xref linkend='expression-tokens'> Expression tokens). The
        semantics have been altered to force programs to respect token interfaces
        where they would otherwise fail to do so.</para>

      <para>The token syntax takes the following basic form:</para>
<programlisting>
#pragma token token-introduction token-identification
</programlisting>

      <para>It is introduced as a pragma to allow other compilers to ignore it,
        though if tokens are being used to replace the definitions needed by a
        program, ignoring these pragmas will generally cause the compilation to
        fail.</para>

      <para>The <emphasis>token-introduction</emphasis> defines the kind of
        token being introduced along with any additional information associated
        with that kind of token. Currently there are five kinds of token that can
        be introduced, corresponding approximately to expressions, statements,
        type-names, member designators and function-like macros.</para>

      <para>The <emphasis>token-identification</emphasis> provides the means of
        referring to the token, both internally within the program and externally
        for TDF linking purposes.</para>
    </sect1>

    <sect1 id='token-ident'>
      <title>Token identification</title>

      <para>The syntax for the token-identification is as follows:</para>
<programlisting>
token identification:
<emphasis>name-space</emphasis><subscript><emphasis>opt</emphasis></subscript> <emphasis>identifier</emphasis> # <emphasis>external-identifier</emphasis> <subscript><emphasis>opt</emphasis></subscript>

name-space:
TAG
</programlisting>

      <orderedlist>
        <listitem>
          <para>There is a default name space associated with each kind of
            token and internal identifiers for tokens generally reside in these
            default name spaces. The ISO C standard describes the five name
            spaces as being:</para>
        </listitem>

        <listitem>
          <para>The label space, in which all label identifiers reside;</para>
        </listitem>

        <listitem>
          <para>The tag space, in which structure, union and enumeration tags
            reside;</para>
        </listitem>

        <listitem>
          <para>The member name space, in which structure and union member
            selectors reside;</para>
        </listitem>

        <listitem>
          <para>The macro name space, in which all macro definitions reside.
            Token identifiers in the macro name space have no definition and so
            are not expanded. However, they behave as macros in all other
            respects;</para>
        </listitem>

        <listitem>
          <para>The ordinary name space in which all other identifiers
            reside.</para>
        </listitem>
      </orderedlist>

      <para>The exception is compound type-token identifiers (see
        <xref linkend='compound-type-tok'> Compound type tokens) which by default reside in the
        ordinary name space but can be forced to reside in the tag name space by
        setting the optional name-space to be TAG.</para>

      <para>The first identifier of the
        <emphasis>token-identification</emphasis> provides the internal
        identification of the token. This is the name used to identify the token
        within the program. It must be followed by a #.</para>

      <para>All further preprocessing tokens until the end of the line are
        treated as part of the <emphasis>external-identifier</emphasis> with
        non-empty white space sequences being replaced by a single space. The
        <emphasis>external-identifier</emphasis> specifies the external
        identification of the token which is used for TDF linking. External token
        identifications reside in their own name space which is distinct from the
        external name space for functions and objects. This means that it is
        possible to have both a function and a token with the same external
        identification. If the external-identifier is omitted it is assumed that
        the internal and external identifications are the same.</para>
    </sect1>

    <sect1 id='expression-tokens'>
      <title>Expression tokens</title>

      <para>There are various properties associated with expression tokens
        which are used to determine the operations that may be performed upon
        them.</para>

      <itemizedlist>
        <listitem>
          <para>Designation is the classification of the value delivered by
            evaluating the expression. The three possible designations, implied
            by the ISO C standard, section 6.3, are:</para>

          <itemizedlist mark='opencircle'>
            <listitem>
              <para>value - expression describes the computation of a
                value;</para>
            </listitem>

            <listitem>
              <para>object - expression designates a variable which may have an
                associated type qualifier giving the access conditions;</para>
            </listitem>

            <listitem>
              <para>function designation - expression designates a
                function.</para>
            </listitem>
          </itemizedlist>
        </listitem>

        <listitem>
          <para>Type specifies the type of the expression ignoring any type
            qualification;</para>
        </listitem>

        <listitem>
          <para>Constancy is the property of being a constant expression as
            specified in the ISO C Standard section 6.4.</para>
        </listitem>
      </itemizedlist>

      <para>The syntax for introducing expression tokens is:</para>
<programlisting>
exp-token:
EXP <emphasis>exp-storage</emphasis> : <emphasis>type-name</emphasis> :
NAT
exp-storage:
rvalue
lvalue
const
</programlisting>

      <para>Expression tokens can be introduced using either the EXP or NAT
        token introductions. Expression tokens introduced using NAT are constant
        value designations of type int i.e. they reference constant integer
        expressions. All other expression tokens are assumed to be non-constant
        and are introduced using EXP.</para>

      <itemizedlist>
        <listitem>
          <para>The <literal>exp-storage</literal> is either lvalue or rvalue.
            If it is lvalue, then the token is an object designation without type
            qualification. If it is rvalue then the token is either a value or a
            function designation depending on whether or not its type is a
            function type.</para>
        </listitem>

        <listitem>
          <para>The <emphasis>type-name</emphasis> is the type of the
            expression to which the token refers.</para>
        </listitem>
      </itemizedlist>

      <para>All internal expression token identifiers must reside in the macro
        name space and this is consequently the default name space for such
        identifiers. Hence the optional name-space, TAG, should not be present in
        an EXP token introduction. Although the use of an expression token after
        it has been introduced is very similar to that of an ordinary identifier,
        as it resides in the macro name space, it has the additional properties
        listed below:</para>

      <itemizedlist>
        <listitem>
          <para>expression tokens cannot be hidden by using an inner
            scope;</para>
        </listitem>

        <listitem>
          <para>with respect to #ifdef, expression tokens are defined;</para>
        </listitem>

        <listitem>
          <para>the scope of expression tokens can be terminated by
            #undef.</para>
        </listitem>
      </itemizedlist>

      <para>In order to make use of tokenised expressions, a new symbol,
        <literal>exp-token-name</literal> , has been introduced at translation
        phase seven of the syntax analysis as defined in the ISO C standard. When
        an expression token identifier is encountered by the preprocessor, an
        <emphasis>exp-token-name</emphasis> symbol is passed through to the
        syntax analyser. An <literal>exp-token-name</literal> provides
        information about an expression token in the same way that a
        <literal>typedef-name</literal> provides information about a type
        introduced using a typedef. This symbol can only occur as part of a
        primary-expression (ISO C standard section 6.3.1) and the expression
        resulting from the use of <literal>exp-token-name</literal> will have the
        type, designation and constancy specified in the token introduction. As
        an example, consider the pragma:</para>
<programlisting>
#pragma token EXP rvalue : int : x#
</programlisting>

      <para>This introduces a token for an expression which is a value
        designation of type int with internal and external name x.</para>

      <para>Expression tokens can either be defined using #define statements or
        by using externals. They can also be resolved as a result of applying the
        type-resolution or assignment-resolution operators (see <xref linkend='type-token-compat'> 
        Type token compatibility, definitions etc.). Expression token definitions
        are subject to the following constraints:</para>

      <itemizedlist>
        <listitem>
          <para>if the <literal>exp-token-name</literal> refers to a constant
            expression (i.e. it was introduced using the NAT token introduction),
            then the defining expression must also be a constant expression as
            expressed in the ISO C standard, section 6.4;</para>
        </listitem>

        <listitem>
          <para>if the <literal>exp-token-name</literal> refers to an lvalue
            expression, then the defining expression must also designate an
            object and the type of the expression token must be resolvable to the
            type of the defining expression. All the type qualifiers of the
            defining expression must appear in the object designation of the
            token introduction;</para>
        </listitem>

        <listitem>
          <para>if the <literal>exp-token-name</literal> refers to an
            expression that has function designation, then the type of the
            expression token must be resolvable to the type of the defining
            expression.</para>
        </listitem>
      </itemizedlist>

      <para>The program below provides two examples of the violation of the
        second constraint.</para>
<programlisting>
#pragma token EXP lvalue : int : i#
extern short k;
#define i 6
#define i k
</programlisting>

      <para>The expression token i is an object designation of type int. The
        first violation occurs because the expression, 6, does not designate an
        object. The second violation is because the type of the token expression,
        i, is int which cannot be resolved to the type short.</para>

      <para>If the <emphasis>exp-token-name</emphasis> refers to an expression
        that designates a value, then the defining expression is converted, as if
        by assignment, to the type of the expression token using the
        <emphasis>assignment-resolution</emphasis> operator (see <xref linkend='type-token-compat'> 
        Type token compatibility, definitions etc.). With all other designations
        the defining expression is left unchanged. In both cases the resulting
        expression is used as the definition of the expression token. This can
        subtly alter the semantics of a program. Consider the program:</para>
<programlisting>
#pragma token EXP rvalue:long:li#
#define li 6
int f() {
return sizeof(li);
}
</programlisting>

      <para>The definition of the token li causes the expression, 6, to be
        converted to long (this is essential to separate the use of li from its
        definition). The function, f, then returns sizeof(long). If the token
        introduction was absent however f would return sizeof(int).</para>

      <para>Although they look similar, expression token definitions using
        #defines are not quite the same as macro definitions. A macro can be
        defined by any preprocessing tokens which are then computed in phase 3 of
        translation as defined in the ISO C standard, whereas tokens are defined
        by assignment-expressions which are computed in phase 7. One of the
        consequences of this is illustrated by the program below:</para>
<programlisting>
#pragma token EXP rvalue:int :X#
#define X M+3
#define M sizeof(int)
int f(int x) { return (x+X); }
</programlisting>

      <para>If the token introduction of X is absent, the program above will
        compile as, at the time the definition of X is interpreted (when
        evaluating x+X), both M and X are in scope. When the token introduction
        is present the compilation will fail as the definition of X, being part
        of translation phase 7, is interpreted when it is encountered and at this
        stage M is not defined. This can be rectified by reversing the order of
        the definitions of X and M or by bracketing the definition of X.
        i.e.</para>
<programlisting>
<emphasis>#define X (M+3)</emphasis>
</programlisting>

      <para>Conversely consider:</para>
<programlisting>
#pragma token EXP rvalue:int:X#
#define M sizeof(int)
#define X M+3
#undef M
int M(int x) { return (x+X); }
</programlisting>

      <para>The definition of X is computed on line 3 when M is in scope, not
        on line 6 where it is used. Token definitions can be used in this way to
        relieve some of the pressures on name spaces by undefining macros that
        are only used in token definitions. This facility should be used with
        care as it may not be a straightforward matter to convert the program
        back to a conventional C program.</para>

      <para>Expression tokens can also be defined by declaring the
        <emphasis>exp-token-name</emphasis> that references the token to be an
        object with external linkage e.g.</para>
<programlisting>
#pragma token EXP lvalue:int:x#
extern int x;
</programlisting>

      <para>The semantics of this program are effectively the same as the
        semantics of:</para>
<programlisting>
#pragma token EXP lvalue:int:x#
extern int _x;
#define x _x
</programlisting>
    </sect1>

    <sect1 id='statement-tokens'>
      <title>Statement tokens</title>

      <para>The syntax for introducing a statement token is simply:</para>
<programlisting>
#pragma token STATEMENT init_globs#
int g(int);
int f(int x) { init_globs return g(x);}
</programlisting>

      <para>Internal statement token identifiers reside in the macro name
        space. The optional name space, TAG, should not appear in statement token
        introductions.</para>

      <para>The use of statement tokens is analogous to the use of expression
        tokens (see <xref linkend='expression-tokens'> Expression tokens). A new symbol,
        <emphasis>stat-token-name</emphasis>, has been introduced into the syntax
        analysis at phase 7 of translation as defined in the ISO C standard. This
        token is passed through to the syntax analyser whenever the preprocessor
        encounters an identifier referring to a statement token. A
        <literal>stat-token-name</literal> can only occur as part of the
        statement syntax (ISO C standard, section 6.6).</para>

      <para>As with expression tokens, statement tokens are defined using
        #define statements. An example of this is shown below:</para>
<programlisting>
#pragma token STATEMENT i_globs#
#define i_globs {int i=x;x=3;}
</programlisting>

      <para>The constraints on the definition of statement tokens are:</para>

      <itemizedlist>
        <listitem>
          <para>the use of labels is forbidden unless the definition of the
            statement token occurs at the outer level (i.e outside of any
            compound statement forming a function definition);</para>
        </listitem>

        <listitem>
          <para>the use of return within the defining statement is not
            allowed.</para>
        </listitem>
      </itemizedlist>

      <para>The semantics of the defining statement are precisely the same as
        the semantics of a compound statement forming the definition of a
        function with no parameters and void result. The definition of statement
        tokens carries the same implications for phases of translation as the
        definition of expression tokens (see <xref linkend='expression-tokens'> Expression
        tokens).</para>
    </sect1>

    <sect1 id='type-tokens'>
      <title>Type tokens</title>

      <para>Type tokens are used to introduce references to types. The ISO C
        standard, section 6.1.2.5, identifies the following classification of
        types:</para>

      <itemizedlist>
        <listitem>
          <para>the type char;</para>
        </listitem>

        <listitem>
          <para>signed integral types;</para>
        </listitem>

        <listitem>
          <para>unsigned integral types;</para>
        </listitem>

        <listitem>
          <para>floating types;</para>
        </listitem>

        <listitem>
          <para>character types;</para>
        </listitem>

        <listitem>
          <para>enumeration types;</para>
        </listitem>

        <listitem>
          <para>array types;</para>
        </listitem>

        <listitem>
          <para>structure types;</para>
        </listitem>

        <listitem>
          <para>union types;</para>
        </listitem>

        <listitem>
          <para>function types;</para>
        </listitem>

        <listitem>
          <para>pointer types;</para>
        </listitem>
      </itemizedlist>

      <para>These types fall into the following broader type
        classifications:</para>

      <itemizedlist>
        <listitem>
          <para>integral types - consisting of the signed integral types, the
            unsigned integral types and the type char;</para>
        </listitem>

        <listitem>
          <para>arithmetic types - consisting of the integral types and the
            floating types;</para>
        </listitem>

        <listitem>
          <para>scalar types - consisting of the arithmetic types and the
            pointer types;</para>
        </listitem>

        <listitem>
          <para>aggregate types - consisting of the structure and array
            types;</para>
        </listitem>

        <listitem>
          <para>derived types - consisting of array, structure, union, function
            and pointer types;</para>
        </listitem>

        <listitem>
          <para>derived declarator types - consisting of array, function and
            pointer types.</para>
        </listitem>
      </itemizedlist>

      <para>The classification of a type determines which operations are
        permitted on objects of that type. For example, the ! operator can only
        be applied to objects of scalar type. In order to reflect this, there are
        several type token introductions which can be used to classify the type
        to be referenced, so that the compiler can perform semantic checking on
        the application of operators. The possible type token introductions
        are:</para>
<programlisting>
type-token:
TYPE
VARIETY
ARITHMETIC
STRUCT
UNION
</programlisting>

      <sect2 id='general-type-tok'>
        <title>General type tokens</title>

        <para>The most general type token introduction is TYPE. This introduces
          a type of unknown classification which can be defined to be any C type.
          Only a few generic operations can be applied to such type tokens, since
          the semantics must be defined for all possible substituted types.
          Assignment and function argument passing are effectively generic
          operations, apart from the treatment of array types. For example,
          according to the ISO C standard, even assignment is not permitted if
          the left operand has array type and we might therefore expect
          assignment of general token types to be illegal. Tokens introduced
          using the TYPE token introduction can thus be regarded as representing
          non-array types with extensions to represent array types provided by
          applying non-array semantics as described below.</para>

        <para>Once general type tokens have been introduced, they can be used
          to construct derived declarator types in the same way as conventional
          type declarators. For example:</para>
<programlisting>
#pragma token TYPE t_t#
#pragma token TYPE t_p#
#pragma token NAT n#
typedef t_t *ptr_type; /* introduces pointer type */
typedef t_t fn_type(t_p);/*introduces function type */
typedef t_t arr_type[n];/*introduces array type */
</programlisting>

        <para>The only standard conversion that can be performed on an object
          of general token type is the lvalue conversion (ISO C standard section
          6.2). Lvalue conversion of an object with general token type is defined
          to return the item stored in the object. The semantics of lvalue
          conversion are thus fundamentally altered by the presence of a token
          introduction. If type <literal>t_t</literal> is defined to be an array
          type the lvalue conversion of an object of type
          <emphasis>t_t</emphasis> will deliver a pointer to the first array
          element. If, however, <emphasis>t_t</emphasis> is defined to be a
          general token type, which is later defined to be an array type, lvalue
          conversion on an object of type <emphasis>t_t</emphasis> will deliver
          the components of the array.</para>

        <para>This definition of lvalue conversion for general token types is
          used to allow objects of general tokenised types to be assigned to and
          passed as arguments to functions. The extensions to the semantics of
          function argument passing and assignment are as follows: if the type
          token is defined to be an array then the components of the array are
          assigned and passed as arguments to the function call; in all other
          cases the assignment and function call are the same as if the defining
          type had been used directly.</para>

        <para>The default name space for the internal identifiers for general
          type tokens is the ordinary name space and all such identifiers must
          reside in this name space. The local identifier behaves exactly as if
          it had been introduced with a typedef statement and is thus treated as
          a <emphasis>typedef-name</emphasis> by the syntax analyser.</para>
      </sect2>

      <sect2 id='integral-type-tok'>
        <title>Integral type tokens</title>

        <para>The token introduction VARIETY is used to introduce a token
          representing an integral type. A token introduced in this way can only
          be defined as an integral type and can be used wherever an integral
          type is valid.</para>

        <para>Values which have integral tokenised types can be converted to
          any scalar type (see <xref linkend='type-tokens'> Type tokens). Similarly values with
          any scalar type can be converted to a value with a tokenised integral
          type. The semantics of these conversions are exactly the same as if the
          type defining the token were used directly. Consider:</para>
<programlisting>
#pragma token VARIETY i_t#
short f(void) {
i_t x_i = 5;
return x_i;
}
short g(void) {
long x_i = 5;
return x_i;
}
</programlisting>

        <para>Within the function f there are two conversions: the value, 5, of
          type int, is converted to <emphasis>i_t</emphasis>, the tokenised
          integral type, and a value of tokenised integral type
          <emphasis>i_t</emphasis> is converted to a value of type short. If the
          type <emphasis>i_t</emphasis> were defined to be long then the function
          f would be exactly equivalent to the function g.</para>

        <para>The usual arithmetic conversions described in the ISO C standard
          (section 6.3.1.5) are defined on integral type tokens and are applied
          where required by the ISO C standard.</para>

        <para>The integral promotions are defined according to the rules
          introduced in Chapter 4. These promotions are first applied to the
          integral type token and then the usual arithmetic conversions are
          applied to the resulting type.</para>

        <para>As with general type tokens, integral type tokens can only reside
          in their default name space, the ordinary name space (the optional
          name-space, TAG, cannot be specified in the token introduction). They
          also behave as though they had been introduced using a typedef
          statement.</para>
      </sect2>

      <sect2 id='arithmetic-type-tok'>
        <title>Arithmetic type tokens</title>

        <para>The token introduction ARITHMETIC introduces an arithmetic type
          token. In theory, such tokens can be defined by any arithmetic type,
          but the current implementation of the compiler only permits them to be
          defined by integral types. These type tokens are thus exactly
          equivalent to the integral type tokens introduced using the token
          introduction VARIETY.</para>
      </sect2>

      <sect2 id='compound-type-tok'>
        <title>Compound type tokens</title>

        <para>For the purposes of this document, a compound type is a type
          describing objects which have components that are accessible via member
          selectors. All structure and union types are thus compound types, but,
          unlike structure and union types in C, compound types do not
          necessarily have an ordering on their member selectors. In particular,
          this means that some objects of compound type cannot be initialised
          with an <emphasis>initialiser-list</emphasis> (see ISO C standard
          section 6.5.7).</para>

        <para>Compound type tokens are introduced using either the STRUCT or
          UNION token introductions. A compound type token can be defined by any
          compound type, regardless of the introduction used. It is expected,
          however, that programmers will use STRUCT for compound types with
          non-overlapping member selectors and UNION for compound types with
          overlapping member selectors. The compound type token introduction does
          not specify the member selectors of the compound type - these are added
          later (see <xref linkend='selector-tok'> Selector tokens).</para>

        <para>Values and objects with tokenised compound types can be used
          anywhere that a structure and union type can be used.</para>

        <para>Internal identifiers of compound type tokens can reside in either
          the ordinary name space or the tag name space. The default is the
          ordinary name space; identifiers placed in the ordinary name space
          behave as if the type had been declared using a typedef statement. If
          the identifier, id say, is placed in the tag name space, it is as if
          the type had been declared as struct id or union id. Examples of the
          introduction and use of compound type tokens are shown below:</para>
<programlisting>
#pragma token STRUCT n_t#
#pragma token STRUCT TAG s_t#
#pragma token UNION TAG u_t#

void f() {
n_t x1;
struct n_t x2;      /* Illegal,n_t not in the tag name space */
s_t x3;         /* Illegal,s_t not in the ordinary name space*/
struct s_t x4;
union u_t x5;
}
</programlisting>
      </sect2>

      <sect2 id='type-token-compat'>
        <title>Type token compatibility, definitions etc.</title>

        <para>A type represented by an undefined type token is incompatible
          (ISO C standard section 6.1.3.6) with all other types except for
          itself. A type represented by a defined type token is compatible with
          everything that is compatible with its definition.</para>

        <para>Type tokens can only be defined by using one of the operations
          known as <literal>type-resolution</literal> and
          <literal>assignment-resolution</literal>. Note that, as type token
          identifiers do not reside in the macro name space, they cannot be
          defined using #define statements.</para>

        <para><literal>Type-resolution</literal> operates on two types and is
          essentially identical to the operation of type compatibility (ISO C
          standard section 6.1.3.6) with one major exception. In the case where
          an undefined type token is found to be incompatible with the type with
          which it is being compared, the type token is defined to be the type
          with which it is being compared, thereby making them compatible.</para>

        <para>The ISO C standard prohibits the repeated use of typedef
          statements to define a type. However, in order to allow type
          resolution, the compiler allows types to be consistently redefined
          using multiple typedef statements if:</para>

        <itemizedlist>
          <listitem>
            <para>there is a resolution of the two types;</para>
          </listitem>

          <listitem>
            <para>as a result of the resolution, at least one token is
              defined.</para>
          </listitem>
        </itemizedlist>

        <para>As an example, consider the program below:</para>
<programlisting>
#pragma token TYPE t_t#
typedef t_t *ptr_t_t;
typedef int **ptr_t_t;
</programlisting>

        <para>The second definition of <emphasis>ptr_t_t</emphasis> causes a
          resolution of the types <emphasis>t_t</emphasis> <literal>*</literal>
          and <emphasis>int</emphasis> <literal>**</literal>. The rules of type
          compatibility state that two pointers are compatible if their dependent
          types are compatible, thus type resolution results in the definition of
          <emphasis>t_t</emphasis> as int *.</para>

        <para><literal>Type-resolution</literal> can also result in the
          definition of other tokens. The program below results in the expression
          token N being defined as (4*sizeof(int)).</para>
<programlisting>
#pragma token EXP rvalue:int:N#
typedef int arr[N];
typedef int arr[4*sizeof(int)];
</programlisting>

        <para>The <literal>type-resolution</literal> operator is not symmetric;
          a resolution of two types, A and B say, is an attempt to resolve type A
          to type B. Thus only the undefined tokens of A can be defined as a
          result of applying the <literal>type-resolution</literal> operator. In
          the examples above, if the typedefs were reversed, no
          <literal>type-resolution</literal> would take place and the types would
          be incompatible.</para>

        <para><literal>Assignment-resolution</literal> is similar to
          <literal>type-resolution</literal> but it occurs when converting an
          object of one type to another type for the purposes of assignment.
          Suppose the conversion is not possible and the type to which the object
          is being converted is an undefined token type. If the token can be
          defined in such a way that the conversion is possible, then that token
          will be suitably defined. If there is more than one possible
          definition, the definition causing no conversion will be chosen.</para>
      </sect2>
    </sect1>

    <sect1 id='selector-tok'>
      <title>Selector tokens</title>

      <para>The use of selector tokens is the primary method of adding member
        selectors to compound type tokens. (The only other method is to define
        the compound type token to be a particular structure or union type.) The
        introduction of new selector tokens can occur at any point in a program
        and they can thus be used to add new member selectors to existing
        compound types.</para>

      <para>The syntax for introducing member selector tokens as
        follows:</para>
<programlisting>
selector-token:
MEMBER <emphasis>selector-type-name</emphasis> : <emphasis>type-name</emphasis> :
selector-type-name:
<emphasis>type-name</emphasis>
<emphasis>type-name</emphasis> % <emphasis>constant-expression</emphasis>
</programlisting>

      <para>The <emphasis>selector-type-name</emphasis> specifies the type of
        the object selected by the selector token. If the
        <emphasis>selector-type-name</emphasis> is a plain
        <emphasis>type-name</emphasis>, the member selector token has that type.
        If the <literal>selector-type-name</literal> consists of a
        <emphasis>type-name</emphasis> and a
        <emphasis>constant-expression</emphasis> separated by a % sign, the
        member selector token refers to a bitfield of type
        <emphasis>type-name</emphasis> and width
        <emphasis>constant-expression</emphasis> . The second
        <emphasis>type-name</emphasis> gives the compound type to which the
        member selector belongs. For example:</para>
<programlisting>
#pragma token STRUCT TAG s_t#
#pragma token MEMBER char*: struct s_t:s_t_mem#
</programlisting>

      <para>introduces a compound token type, <emphasis>s_t</emphasis>, which
        has a member selector, <emphasis>s_t_mem</emphasis>, which selects an
        object of type char*.</para>

      <para>Internal identifiers of member selector tokens can only reside in
        the member name space of the compound type to which they belong. Clearly
        this is also the default name space for such identifiers.</para>

      <para>When structure or union types are declared, according to the ISO C
        standard there is an implied ordering on the member selectors. In
        particular this means that:</para>

      <itemizedlist>
        <listitem>
          <para>during initialisation with an initialiser-list the identified
            members of a structure are initialised in the order in which they
            were declared. The first identified member of a union is
            initialised;</para>
        </listitem>

        <listitem>
          <para>the addresses of structure members will increase in the order
            in which they were declared.</para>
        </listitem>
      </itemizedlist>

      <para>The member selectors introduced as selector tokens are not related
        to any other member selectors until they are defined. There is thus no
        ordering on the undefined tokenised member selectors of a compound type.
        If a compound type has only undefined token selectors, it cannot be
        initialised with an initialiser-list. There will be an ordering on the
        defined members of a compound type and in this case, the compound type
        can be initialised automatically.</para>

      <para>The decision to allow unordered member selectors has been taken
        deliberately in order to separate the decision of which members belong to
        a structure from that of where such member components lie within the
        structure. This makes it possible to represent extensions to APIs which
        require extra member selectors to be added to existing compound
        types.</para>

      <para>As an example of the use of token member selectors, consider the
        structure lconv specified in the ISO C Standard library (section
        7.4.3.1). The standard does not specify all the members of struct lconv
        or the order in which they appear. This type cannot be represented
        naturally by existing C types, but can be described by the token
        syntax.</para>

      <para>There are two methods for defining selector tokens, one explicit
        and one implicit. As selector token identifiers do not reside in the
        macro name space they cannot be defined using #define statements.</para>

      <para>Suppose A is an undefined compound token type and mem is an
        undefined selector token for A. If A is later defined to be the compound
        type B and B has a member selector with identifier mem then A.mem is
        defined to be B.mem providing the type of A.mem can be resolved to the
        type of B.mem. This is known as implicit selector token
        definition.</para>

      <para>In the program shown below the redefinition of the compound type
        <emphasis>s_t</emphasis> causes the token for the selector
        <emphasis>mem_x</emphasis> to be implicitly defined to be the second
        member of struct <emphasis>s_tag</emphasis>. The consequential type
        resolution leads to the token type <emphasis>t_t</emphasis> being defined
        to be int.</para>
<programlisting>
#pragma token TYPE t_t#
#pragma token STRUCT s_t#
#pragma token MEMBER t_t : s_t : mem_x#
#pragma token MEMBER t_t : s_t : mem_y#
struct s_tag { int a, mem_x, b; }
typedef struct s_tag s_t;
</programlisting>

      <para>Explicit selector token definition takes place using the
        pragma:</para>
<programlisting>
#pragma DEFINE MEMBER <emphasis>type-name</emphasis> <emphasis>identifier</emphasis> : <emphasis>member-designator</emphasis>

member-designator:
<emphasis>identifier</emphasis>
<emphasis>identifier . member-designator</emphasis>
</programlisting>

      <para>The <emphasis>type-name</emphasis> specifies the compound type to
        which the selector belongs.</para>

      <para>The <emphasis>identifier</emphasis> provides the identification of
        the member selector within that compound type.</para>

      <para>The <emphasis>member-designator</emphasis> provides the definition
        of the selector token. It must identify a selector of a compound
        type.</para>

      <para>If the <emphasis>member-designator</emphasis> is an identifier,
        then the identifier must be a member of the compound type specified by
        the <emphasis>type-name</emphasis>. If the
        <emphasis>member-designator</emphasis> is an identifier,
        <emphasis>id</emphasis> say, followed by a further member-designator, M
        say, then:</para>

      <itemizedlist>
        <listitem>
          <para>the identifier id must be a member identifying a selector of
            the compound type specified by <emphasis>type-name</emphasis>;</para>
        </listitem>

        <listitem>
          <para>the type of the selector identified by id must have compound
            type, C say;</para>
        </listitem>

        <listitem>
          <para>the <literal>member-designator</literal> M must identify a
            member selector of the compound type C.</para>
        </listitem>
      </itemizedlist>

      <para>As with implicit selector token definitions, the type of the
        selector token must be resolved to the type of the selector identified by
        the <emphasis>member-designator</emphasis>.</para>

      <para>In the example shown below, the selector token mem is defined to be
        the second member of struct <emphasis>s</emphasis> which in turn is the
        second member of struct <emphasis>s_t</emphasis>.</para>
<programlisting>
#pragma token STRUCT s_t#
#pragma token MEMBER int : s_t : mem#
typedef struct {int x; struct {char y; int z;} s; } s_t;
#pragma DEFINE MEMBER s_t : mem s.z
</programlisting>
    </sect1>

    <sect1 id='procedure-tok'>
      <title>Procedure tokens</title>

      <para>Consider the macro SWAP defined below:</para>
<programlisting>
#define SWAP(T,A,B) { \
T x; \
x=B; \
B=A; \
A=x; \
}
</programlisting>

      <para>SWAP can be thought of as a statement that is parameterised by a
        type and two expressions.</para>

      <para>Procedure tokens are based on this concept of parameterisation.
        Procedure tokens reference program constructs that are parameterised by
        other program constructs.</para>

      <para>There are three methods of introducing procedure tokens. These are
        described in the sections below.</para>

      <sect2 id='general-prod-tok'>
        <title>General procedure tokens</title>

        <para>The syntax for introducing a general procedure token is:</para>
<programlisting>
general procedure:
PROC { <emphasis>bound-toks</emphasis><subscript><emphasis>opt</emphasis></subscript> | <emphasis>prog-pars</emphasis><subscript><emphasis>opt</emphasis></subscript> } <emphasis>token-introduction</emphasis>

simple procedure:
PROC ( <emphasis>bound-toks</emphasis><subscript><emphasis>opt</emphasis></subscript> ) <emphasis>token-introduction</emphasis>

bound-toks:
<emphasis>bound-token</emphasis>
<emphasis>bound-token</emphasis>, <emphasis>bound-toks</emphasis>

bound-token:
<emphasis>token-introduction name-space</emphasis><subscript><emphasis>opt</emphasis></subscript> <emphasis>identifier</emphasis>

prog-pars:
<emphasis>program-parameter</emphasis>
<emphasis>program-parameter</emphasis>, <emphasis>prog-pars</emphasis>

program parameter:
EXP <emphasis>identifier</emphasis>
STATEMENT <emphasis>identifier</emphasis>
TYPE <emphasis>type-name-identifier</emphasis>
MEMBER <emphasis>type-name-identifier</emphasis> : <emphasis>identifier</emphasis>
</programlisting>

        <para>The final <literal>token-introduction</literal> specifies the
          kind of program construct being parameterised. In the current
          implementation of the compiler, only expressions and statements may be
          parameterised. The internal procedure token identifier is placed in the
          default name space of the program construct which it parameterises. For
          example, the internal identifier of a procedure token parameterising an
          expression would be placed in the macro name space.</para>

        <para>The <literal>bound-toks</literal> are the bound token
          dependencies which describe the program constructs upon which the
          procedure token depends. These should not be confused with the
          parameters of the token. The procedure token introduced in:</para>
<programlisting>
#pragma token PROC {TYPE t,EXP rvalue:t**:e|EXP e} EXP:rvalue:t:dderef#
</programlisting>

        <para>is intended to represent a double dereference and depends upon
          the type of the expression to be dereferenced and upon the expression
          itself but takes only one argument, namely the expression, from which
          both dependencies can be deduced.</para>

        <para>The bound token dependencies are introduced in exactly the same
          way as the tokens described in the previous sections with the
          identifier corresponding to the internal identification of the token.
          No external identification is allowed. The scope of these local
          identifiers terminates at the end of the procedure token introduction,
          and whilst in scope, they hide all other identifiers in the same name
          space. Such tokens are referred to as &quot;bound&quot; because they
          are local to the procedure token.</para>

        <para>Once a bound token dependency has been introduced, it can be used
          throughout the rest of the procedure token introduction in the
          construction of other components.</para>

        <para>The <literal>prog-pars</literal> are the program parameters. They
          describe the parameters with which the procedure token is called. The
          bound token dependencies are deduced from these program
          parameters.</para>

        <para>Each program parameter is introduced with a keyword expressing
          the kind of program construct that it represents. The keywords are as
          follows:</para>

        <itemizedlist>
          <listitem>
            <para>EXP . The parameter is an expression and the identifier
              following EXP must be the identification of a bound token for an
              expression. When the procedure token is called, the corresponding
              parameter must be an assignment-expression and is treated as the
              definition of the bound token, thereby providing definitions for
              all dependencies relating to that token. For example, the call of
              the procedure token dderef, introduced above, in the code
              below:</para>
<programlisting>
char f(char **c_ptr_ptr){
return dderef(c_ptr_ptr);
}
</programlisting>

            <para>causes the expression, e, to be defined to be c_ptr_ptr thus
              resolving the type t** to be char **. The type t is hence defined
              to be char, also providing the type of the expression obtained by
              the application of the procedure token dderef;</para>
          </listitem>

          <listitem>
            <para>STATEMENT. The parameter is a statement. Its semantics
              correspond directly to those of EXP;</para>
          </listitem>

          <listitem>
            <para>TYPE. The parameter is a type. When the procedure token is
              applied, the corresponding argument must be a
              <literal>type-name</literal>. The parameter type is resolved to the
              argument type in order to define any related dependencies;</para>
          </listitem>

          <listitem>
            <para>MEMBER. The parameter is a member selector. The
              <literal>type-name</literal> specifies the composite type to which
              the member selector belongs and the identifier is the
              identification of the member selector. When the procedure token is
              applied, the corresponding argument must be a
              <emphasis>member-designator</emphasis> of the compound type.</para>
          </listitem>
        </itemizedlist>

        <para>Currently PROC tokens cannot be passed as program
          parameters.</para>
      </sect2>

      <sect2 id='simple-prod-tok'>
        <title>Simple procedure tokens</title>

        <para>In cases where there is a direct, one-to-one correspondence
          between the bound token dependencies and the program parameters a
          simpler form of procedure token introduction is available.</para>

        <para>Consider the two procedure token introductions below,
          corresponding to the macro SWAP described earlier.</para>
<programlisting>
/* General procedure introduction */
#pragma token PROC{TYPE t,EXP lvalue:t:e1,EXP lvalue:t:e2 | \
TYPE t,EXP e1,EXP e2 } STATEMENT SWAP#
/* Simple procedure introduction */
#pragma token PROC(TYPE t,EXP lvalue:t:,EXP lvalue:t: ) STATEMENT SWAP#
</programlisting>

        <para>The <emphasis>simple-token</emphasis> syntax is similar to the
          <emphasis>bound-token</emphasis> syntax, but it also introduces a
          program parameter for each bound token. The bound token introduced by
          the <emphasis>simple-token</emphasis> syntax is defined as though it
          had been introduced with the <emphasis>bound-token</emphasis> syntax.
          If the final identifier is omitted, then no name space can be
          specified, the bound token is not identified and in effect there is a
          local hidden identifier.</para>
      </sect2>

      <sect2 id='funct-prod-tok'>
        <title>Function procedure tokens</title>

        <para>One of the commonest uses of simple procedure tokens is to
          represent function in-lining. In this case, the procedure token
          represents the in-lining of the function, with the function parameters
          being the program arguments of the procedure token call, and the
          program construct resulting from the call of the procedure token being
          the corresponding in-lining of the function. This is a direct parallel
          to the use of macros to represent functions.</para>

        <para>The syntax for introducing function procedure tokens is:</para>
<programlisting>
function-procedure:
FUNC <emphasis>type-name</emphasis> :
</programlisting>

        <para>The type-name must be a prototyped function type. The pragma
          results in the declaration of a function of that type with external
          linkage and the introduction of a procedure token suitable for an
          in-lining of the function. (If an ellipsis is present in the prototyped
          function type, it is used in the function declaration but not in the
          procedure token introduction.) Every parameter type and result type is
          mapped onto the token introduction:</para>
<programlisting>
EXP rvalue:
</programlisting>

        <para>The example below:</para>
<programlisting>
#pragma token FUNC int(int): putchar#
</programlisting>

        <para>declares a function, putchar, which returns an int and takes an
          int as its argument, and introduces a procedure token suitable for
          in-lining putchar. Note that:</para>
<programlisting>
#undef putchar
</programlisting>

        <para>will remove the procedure token but not the underlying
          function.</para>
      </sect2>

      <sect2 id='defining-prod'>
        <title>Defining procedure tokens</title>

        <para>All procedure tokens are defined by the same mechanism. Since
          simple and function procedure tokens can be transformed into general
          procedure tokens, the definition will be explained in terms of general
          procedure tokens.</para>

        <para>The syntax for defining procedure tokens is given below and is
          based upon the standard parameterised macro definition. However, as in
          the definitions of expressions and statements, the #defines of
          procedure token identifiers are evaluated in phase 7 of translation as
          described in the ISO C standard.</para>
<programlisting>
#define <emphasis>identifier</emphasis> ( <emphasis>id-list</emphasis><subscript><emphasis>opt</emphasis></subscript> ) <emphasis>assignment-expression</emphasis>
#define <emphasis>identifier</emphasis> ( <emphasis>id-list</emphasis><subscript><emphasis>opt</emphasis></subscript> ) <emphasis>statement</emphasis>

id-list:
<emphasis>identifier</emphasis>
<emphasis>identifer</emphasis>, <emphasis>id-list</emphasis>
</programlisting>

        <para>The <emphasis>id-list</emphasis> must correspond directly to the
          program parameters of the procedure token introduction. There must be
          precisely one identifier for each program parameter. These identifiers
          are used to identify the program parameters of the procedure token
          being defined and have a scope that terminates at the end of the
          procedure token definition. They are placed in the default name spaces
          for the kinds of program constructs which they identify.</para>

        <para>None of the bound token dependencies can be defined during the
          evaluation of the definition of the procedure token since they are
          effectively provided by the arguments of the procedure token each time
          it is called. To illustrate this, consider the example below based on
          the dderef token used earlier.</para>
<programlisting>
#pragma token PROC{TYPE t, EXP rvalue:t**:e|EXP e}EXP rvalue:t:dderef#
#define dderef (A) (**(A))
</programlisting>

        <para>The identifiers t and e are not in scope during the definition,
          being merely local identifiers for use in the procedure token
          introduction. The only identifier in scope is A. A identifies an
          expression token which is an rvalue whose type is a pointer to a
          pointer to a type token. The expression token and the type token are
          provided by the arguments at the time of calling the procedure
          token.</para>

        <para>Again, the presence of a procedure token introduction can alter
          the semantics of a program. Consider the program below.</para>
<programlisting>
#pragma token PROC {TYPE t, EXP lvalue:t:,EXP lvalue:t:}STATEMENT SWAP#
#define SWAP(T,A,B)\
{T x; x=B; B=A; A=x;}
void f(int x, int y) {
SWAP(int, x, y)
}
</programlisting>

        <para>The definition and call of the procedure token are extremely
          straightforward. However, if the procedure token introduction is
          absent, the swap does not take place because x refers to the variable
          in the inner scope.</para>

        <para>Function procedure tokens are introduced with tentative implicit
          definitions, defining them to be direct calls of the functions they
          reference and effectively removing the in-lining capability. If a
          genuine definition is found later in the compilation, it overrides the
          tentative definition. An example of a tentative definition is shown
          below:</para>
<programlisting>
#pragma token FUNC int(int, long) : func#
#define func(A, B) (func) (A, B)
</programlisting>
      </sect2>
    </sect1>

    <sect1 id='tokens-apis'>
      <title>Tokens and APIs</title>

      <para>In <xref linkend='config-checker'> we mentioned that one of the main problems in
        writing portable software is the lack of separation between specification
        and implementation of APIs. The TenDRA technology uses the token syntax
        described in the previous sections to provide an abstract description of
        an API specification. Collections of tokens representing APIs are called
        &quot;interfaces&quot;. Tchk can compile programs with these interfaces
        in order to check applications against API specifications independently
        of any particular implementation that may be present on the developer's
        machine.</para>

      <para>In order to produce executable code, definitions of the interface
        tokens must be provided on all target machines. This is done by compiling
        the interfaces with the system headers and libraries.</para>

      <para>When developing applications, programmers must ensure that they do
        not accidentally define a token expressing an API. Implementers of APIs,
        however, do not want to inadvertently fail to define a token expressing
        that API. Token definition states have been introduced to enable
        programmers to instruct the compiler to check that tokens are defined
        when and only when they wish them to be. This is fundamental to the
        separation of programs into portable and unportable parts.</para>

      <para>When tokens are first introduced, they are in the free state. This
        means that the token can be defined or left undefined and if the token is
        defined during compilation, its definition will be output as TDF.</para>

      <para>Once a token has been given a valid definition, its definition
        state moves to defined. Tokens may only be defined once. Any attempt to
        define a token in the defined state is flagged as an error.</para>

      <para>There are three more token definition states which may be set by
        the programmer. These are as follows:</para>

      <itemizedlist>
        <listitem>
          <para>Indefinable - the token is not defined and must not be defined.
            Any attempt to define the token will cause an error. When compiling
            applications, interface tokens should be in the indefinable state. It
            is not possible for a token to move from the state of defined to
            indefinable;</para>
        </listitem>

        <listitem>
          <para>Committed - the token must be defined during the compilation.
            If no definition is found the compiler will raise an error. Interface
            tokens should be in the committed state when being compiled with the
            system headers and libraries to provide definitions;</para>
        </listitem>

        <listitem>
          <para>Ignored - any definition of the token that is assigned during
            the compilation of the program will not be output as TDF;</para>
        </listitem>
      </itemizedlist>

      <para>These token definition states are set using the pragmas:</para>
<programlisting>
#pragma <emphasis>token-op token-id-list</emphasis><subscript><emphasis>opt</emphasis></subscript>

token-op:
define
no_def
ignore
interface

token-id-list: 
TAG<subscript><emphasis>opt</emphasis></subscript> <emphasis>identifier</emphasis> <emphasis>dot-list</emphasis><subscript><emphasis>opt</emphasis></subscript>  <emphasis>token-id-list</emphasis><subscript><emphasis>opt</emphasis></subscript>

dot-list:
. <emphasis>member-designator</emphasis>
</programlisting>

      <para>The <emphasis>token-id-list</emphasis> is the list of tokens to
        which the definition state applies. The tokens in the
        <literal>token-id-list</literal> are identified by an identifier,
        optionally preceded by TAG. If TAG is present, the identifier refers to
        the tag name space, otherwise the macro and ordinary name spaces are
        searched for the identifier. If there is no <emphasis>dot-list</emphasis>
        present, the identifier must refer to a token. If the
        <emphasis>dot-list</emphasis> is present, the identifier must refer to a
        compound type and the member-designator must identify a member selector
        token of that compound type.</para>

      <para>The <emphasis>token-op</emphasis> specifies the definition state to
        be associated with the tokens in the <literal>token-id-list</literal>.
        There are three literal operators and one context dependent operator, as
        follows:</para>

      <orderedlist>
        <listitem>
          <para><literal>no_def</literal> causes the token state to move to
            indefinable.</para>
        </listitem>

        <listitem>
          <para><literal>define</literal> causes the token state to move to
            committed;</para>
        </listitem>

        <listitem>
          <para><literal>ignore</literal> causes the token state to move to
            ignored;</para>
        </listitem>

        <listitem>
          <para><literal>interface</literal> is the context dependent operator
            and is used when describing extensions to existing APIs.</para>
        </listitem>
      </orderedlist>

      <para>As an example of an extension API, consider the POSIX stdio.h. This
        is an extension of the ANSI stdio.h and uses the same tokens to represent
        the common part of the interface. When compiling applications, nothing
        can be assumed about the implementation of the ANSI tokens accessed via
        the POSIX API so they should be in the indefinable state. When the POSIX
        tokens are being implemented, however, the ANSI implementations can be
        assumed. The ANSI tokens are then in the ignored state. (Since the
        definitions of these tokens will have been output already during the
        definition of the ANSI interface, they should not be output
        again.)</para>

      <para>The <literal>interface</literal> operator has a variable
        interpretation to allow the correct definition state to be associated
        with these `base-API tokens'. The compiler associates a compilation state
        with each file it processes. These compilation states determine the
        interpretation of the interface operator within that file.</para>

      <para>The default compilation state is the standard state. In this state
        the <literal>interface</literal> operator is interpreted as the
        <literal>no_def</literal> operator. This is the standard state for
        compiling applications in the presence of APIs;</para>

      <para>Files included using:</para>
<programlisting>
#include header
</programlisting>

      <para>have the same compilation state as the file from which they were
        included.</para>

      <para>The implementation compilation state is associated with files
        included using:</para>
<programlisting>
#pragma implement interface <emphasis>header</emphasis>
</programlisting>

      <para>In this context the <literal>interface</literal> operator is
        interpreted as the <literal>define</literal> operator.</para>

      <para>Including a file using:</para>
<programlisting>
#pragma extend interface <emphasis>header</emphasis>
</programlisting>

      <para>causes the compilation state to be extension unless the file from
        which it was included was in the standard state, in which case the
        compilation state is the standard state. In the extension state the
        <literal>interface</literal> operator is interpreted as the
        <literal>ignore</literal> operator.</para>
    </sect1>
  </appendix>

  <appendix id='api-checking'>
    <title>API checking</title>

    <sect1 id='intro-d'>
      <title>Introduction</title>

      <para>The token syntax described in the previous annex provides the means
        of describing an API specification independently of any particular
        implementation of the API. Every object in the API specification is
        described using the appropriate #pragma token statement. These statements
        are arranged in TenDRA header files corresponding to the headers
        comprising the API. Each API consists of a separate set of header files.
        For example, if the ANSI API is used, the statement:</para>
<programlisting>
#include &lt;sys/types.h&gt;
</programlisting>

      <para>will lead to a &quot;header not found&quot; error, whereas the
        header will be found in the POSIX API.</para>

      <para>Where relationships exist between APIs these have been made
        explicit in the headers. For example, the POSIX version of stdio.h
        consists of the ANSI version plus some extra objects. This is implemented
        by making the TenDRA header describing the POSIX version of stdio.h
        include the ANSI version of stdio.h.</para>
    </sect1>

    <sect1 id='specifying-apis'>
      <title>Specifying APIs to tcc</title>

      <para>The API against which a program is to be checked is specified to
        tchk by means of a command-line option of the form -Yapi where api is the
        API name. For example, ANSI X3.159 is specified by -Yansi (this is the
        default API) and POSIX 1003.1 is specified by -Yposix (for a full list of
        the supported APIs see <xref linkend='type-check'> ).</para>

      <para>Extension APIs, such as X11, require special attention. The API for
        a program is never just X11, but X11 plus some base API, for example, X11
        plus POSIX or X11 plus XPG3. These composite APIs may be specified by,
        for example, passing the options -Yposix -Yx5_lib (in that order) to tcc
        to specify POSIX 1003.1 plus X11 (Release 5) Xlib. The rule is that base
        APIs, such as POSIX, override the existing API, whereas extension APIs,
        such as X11, extend it. The command-line option -info causes tcc to print
        the API currently in use. For example:</para>
<programlisting>
&gt; tcc -Yposix -Yx5_lib -info file.c
</programlisting>

      <para>will result in the message:</para>
<programlisting>
tcc: Information: API is X11 Release 5 Xlib plus POSIX (1003.1).
</programlisting>
    </sect1>

    <sect1 id='api-check-examples'>
      <title>API Checking Examples</title>

      <para>As an example of the TenDRA compiler's API checking capacities,
        consider the following program which prints the names and inode numbers
        of all the files in the current directory:</para>
<programlisting>
#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;dirent.h&gt;
int main ()
{
DIR *d = opendir ( &quot;.&quot; );
struct dirent *e;
if (d = NULL) return ( 1 );
while(e=readdir(d),e!=NULL)
{
    printf ( &quot;%s %lu\n&quot;, e-&gt;d_name, e-&gt;d_ino );
}
closedir ( d );
return ( 0 );
}
</programlisting>

      <para>A first attempted compilation using strict checking:</para>
<programlisting>
&gt; tcc -Xs a.c
</programlisting>

      <para>results in messages to the effect that the headers
        &lt;sys/types.h&gt; and &lt;dirent.h&gt; cannot be found, plus a number
        of consequential errors. This is because tcc is checking the program
        against the default API, that is against the ANSI API, and the program is
        certainly not ANSI compliant. It does look as if it might be POSIX
        compliant however, so a second attempted compilation might be:</para>
<programlisting>
&gt; tcc -Xs -Yposix a.c
</programlisting>

      <para>This results in one error and three warnings. Dealing with the
        warnings first, the returns of the calls of printf and closedir are being
        discarded and the variable d has been set and not used. The discarded
        function returns are deliberate, so they can be made explicit by casting
        them to void. The discarded assignment to d requires a little more
        thought - it is due to the mistyping d = NULL instead of d == NULL on
        line 9. The error is more interesting. In full the error message
        reads:</para>
<programlisting>
&quot;a.c&quot;:11
printf ( &quot;%s %lu\n&quot;, e-&gt;d_name, e-&gt;d_ino!!!! );
Error:ISO[6.5.2.1]{ANSI[3.5.2.1]}: The identifier 'd_ino' is not a member of
'struct/union posix.dirent.dirent'.
ISO[6.3.2.3]{ANSI[3.3.2.3]}: The second operand of '-&gt;' must be a member of
the struct/union pointed to by the first.
</programlisting>

      <para>That is, struct dirent does not have a field called d_ino. In fact
        this is true; while the d_name field of struct dirent is specified in
        POSIX, the d_ino field is an XPG3 extension (This example shows that the
        TenDRA representation of APIs is able to differentiate between APIs at a
        very fine level). Therefore a third attempted compilation might
        be:</para>
<programlisting>
&gt; tcc -Xs -Yxpg3 a.c
</programlisting>

      <para>This leads to another error message concerning the printf
        statement, that the types unsigned long and (the promotion of) ino_t are
        incompatible. This is due to a mismatch between the printf format string
        &quot;%lu&quot; and the type of e-&gt;d_ino. POSIX only says that ino_t
        is an arithmetic type, not a specific type like unsigned long. The TenDRA
        representation of POSIX reflects this abstract nature of ino_t, so that
        the potential portability error is detected. In fact it is impossible to
        give a printf string which works for all possible implementations of
        ino_t. The best that can be done is to cast e-&gt;d_ino to some fixed
        type like unsigned long and print that.</para>

      <para>Hence the corrected, XPG3 conformant program reads:</para>
<programlisting>
#include &lt;stdio.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;dirent.h&gt;
int main ()
{
DIR *d = opendir ( &quot;.&quot; );
struct dirent *e;
if ( d == NULL ) return (1);
while(e=readdir(d),e!=NULL)
{
    ( void ) printf ( &quot;%s %lu\n&quot;, e-&gt;d_name,( unsigned long ) e-&gt;d_ino );
}
( void ) closedir ( d );
return ( 0 );
}
</programlisting>
    </sect1>

    <sect1 id='redclaring-obj-apis'>
      <title>Redeclaring Objects in APIs</title>

      <para>Of course, it is possible to redeclare the functions declared in
        the TenDRA API descriptions within the program, provided they are
        consistent. However, what constitutes a consistent redeclaration in the
        fully abstract TenDRA machine is not as straightforward as it might seem;
        an interesting example is malloc in the ANSI API. This is defined by the
        prototype:</para>
<programlisting>
void *malloc ( size_t );
</programlisting>

      <para>where size_t is a target dependent unsigned integral type. The
        redeclaration:</para>
<programlisting>
void *malloc ();
</programlisting>

      <para>is only correct if size_t is its own integral promotion, and
        therefore is not correct in general.</para>

      <para>Since it is not always desirable to remove these redeclarations
        (some machines may not have all the necessary functions declared in their
        system headers) the TenDRA compiler has a facility to accept inconsistent
        redeclarations of API functions which can be enabled by using the
        pragma:</para>
<programlisting>
#pragma TenDRA incompatible interface declaration allow
</programlisting>

      <para>This pragma supresses the consistency checking of re-declarations
        of API functions. Replacing <literal>allow</literal> by
        <literal>warning</literal> causes a warning to be printed. In both cases
        the TenDRA API description of the function takes precedence. The normal
        behaviour of flagging inconsistent redeclarations as errors can be
        restored by replacing <literal>allow</literal> by
        <literal>disallow</literal> in the pragma above. (There are also
        equivalent command-line options to tcc of the form -X:interface_decl=
        <emphasis>status</emphasis>, where <emphasis>status</emphasis> can be
        check, warn or dont.)</para>
    </sect1>

    <sect1 id='def-obj-apis'>
      <title>Defining Objects in APIs</title>

      <para>Since the program API is meant to define the interface between what
        the program defines and what the target machine defines, the TenDRA
        compiler normally raises an error if any attempt is made to define an
        object from the API in the program itself. A subtle example of this is
        given by compiling the program:</para>
<programlisting>
#include &lt;errno.h&gt;
extern int errno;
</programlisting>

      <para>with the ANSI API. ANSI states that errno is an assignable lvalue
        of type int, and the TenDRA description of the API therefore states
        precisely that. The declaration of errno as an extern int is therefore an
        inconsistent specification of errno, but a consistent implementation.
        Accepting the lesser of two evils, the error reported is therefore that
        an attempt has been made to define errno despite the fact that it is part
        of the API.</para>

      <note>
        <para>If this same program is compiled using the POSIX API, in which
          errno is explicitly specified to be an extern int, the program merely
          contains a consistent redeclaration of errno and so does not raise an
          error.</para>
      </note>

      <para>The neatest workaround for the ANSI case, which preserves the
        declaration for those machines which need it, is as follows: if errno is
        anything other than an extern int it must be defined by a macro.
        Therefore:</para>
<programlisting>
#include &lt;errno.h&gt;
#ifndef errno
extern int errno;
#endif
</programlisting>

      <para>should always work.</para>

      <para>In most other examples, the definitions are more obvious. For
        example, a programmer might provide a memory allocator containing
        versions of malloc, free etc.:</para>
<programlisting>
#include &lt;stdlib.h&gt;
void *malloc ( size_t sz )
{
....
}
void free ( void *ptr )
{
....
}
</programlisting>

      <para>If this is deliberate then the TenDRA compiler needs to be told to
        ignore the API definitions of these objects and to use those provided
        instead. This is done by listing the objects to be ignored using the
        pragma:</para>
<programlisting>
#pragma ignore malloc free ....
</programlisting>

      <para>This should be placed between the
        API specification and the object definitions. The provided definitions
        are checked for conformance with the API specifications. There are
        special forms of this pragma to enable field selectors and objects in the
        tag namespace to be defined. For example, if we wish to provide a
        definition of the type div_t from stdlib.h we need to ignore three
        objects - the type itself and its two field selectors - quot and rem. The
        definition would therefore take the form:</para>
<programlisting>
#include &lt;stdlib.h&gt;
#pragma ignore div_t div_t.quot div_t.rem
typedef struct {
int quot;
int rem;
} div_t;
</programlisting>

      <para>Similarly if we wish to define struct lconv from locale.h the
        definition would take the form:</para>
<programlisting>
#include &lt;locale.h&gt;
#pragma ignore TAG lconv TAG lconv.decimal_point
....
struct lconv {
char *decimal_point;
....
};
</programlisting>

      <para>to take into account that lconv lies in the tag name space. By
        defining objects in the API in this way, we are actually constructing a
        less general version of the API. This will potentially restrict the
        portability of the resultant program, and so should not be done without
        good reason.</para>
    </sect1>

    <sect1 id='step-outside-apis'>
      <title>Stepping Outside an API</title>

      <para>Using the TenDRA compiler to check a program against a standard API
        will only be effective if the appropriate API description is available to
        the program being tested (just as a program can only be compiled on a
        conventional machine if the program API is implemented on that machine).
        What can be done for a program whose API are not supported depends on the
        degree to which the program API differs from an existing TenDRA API
        description. If the program API is POSIX with a small extension, say,
        then it may be possible to express that extension to the TenDRA compiler.
        For large unsupported program APIs it may be possible to use the system
        headers on a particular machine to allow for partial program checking.</para>

      <para>For small API extensions the ideal method would be to use the token
        syntax described in Annex G to express the program API to the TenDRA
        compiler, however this is not currently encouraged because the syntax of
        such API descriptions is not yet firmly fixed. For the time being it may
        be possible to use C to express much of the information the TenDRA
        compiler needs to check the program. For example, POSIX specifies that
        sys/stat.h contains a number of macros, S_ISDIR, S_ISREG, and so on,
        which are used to test whether a file is a directory, a regular file,
        etc. Suppose that a program is basically POSIX conformant, but uses the
        additional macro S_ISLNK to test whether the file is a symbolic link
        (this is in COSE and AES, but not POSIX). A proper TenDRA description of
        S_ISLNK would contain the information that it was a macro taking a mode_t
        and returning an int, however for checking purposes it is sufficient to
        merely give the types. This can be done by pretending that S_ISLNK is a
        function:</para>
<programlisting>
#ifdef __TenDRA__
/* For TenDRA checking purposes only */
extern int S_ISLNK ( mode_t );
/* actually a macro */
#endif
</programlisting>

      <para>More complex examples might require an object in the API to be
        defined in order to provide more information about it (see H.5). For
        example, suppose that a program is basically ANSI compliant, but assumes
        that FILE is a structure with a field file_no of type int (representing
        the file number), rather than a generic type. This might be expressed
        by:</para>
<programlisting>
#ifdef __TenDRA__
/* For TenDRA checking purposes only */
#pragma ignore FILE
typedef struct {
/* there may be other fields here */
int file_no;
/* there may be other fields here */
} FILE;
#endif
</programlisting>

      <para>The methods of API description above are what might be called
        &quot;example implementations&quot; rather than the &quot;abstract
        implementations&quot; of the actual TenDRA API descriptions. They should
        only be used as a last resort, when there is no alternative way of
        expressing the program within a standard API. For example, there may be
        no need to access the file_no field of a FILE directly, since POSIX
        provides a function, fileno, for this purpose. Extending an API in
        general reduces the number of potential target machines for the
        corresponding program.</para>
    </sect1>

    <sect1 id='using-sys-headers'>
      <title>Using the System Headers</title>

      <para>One possibility if a program API is not supported by the TenDRA
        compiler is to use the set of system headers on the particular machine on
        which tcc happens to be running. Of course, this means that the API
        checking facilities of the TenDRA compiler will not be effective, but it
        is possible that the other program checking aspects will be of
        use.</para>

      <para>The system headers are not, and indeed are not intended to be,
        portable. A simple-minded approach to portability checking with the
        system headers could lead to more portability problems being found in the
        system headers than in the program itself. A more sophisticated approach
        involves applying different compilation modes to the system headers and
        to the program. The program itself can be checked very rigorously, while
        the system headers have very lax checks applied.</para>

      <para>This could be done directly, by putting a wrapper around each
        system header describing the mode to be applied to that header. However
        the mechanism of named compilation modes (see 2.2) provides an
        alternative solution. In addition to the normal -Idir command-line
        option, tcc also supports the option -Nname:dir, which is identical
        except that it also associates the identifier name with the directory
        dir. Once a directory has been named in this way, the name can be used in
        a directive:</para>
<programlisting>
#pragma TenDRA directory <emphasis>name</emphasis> use environment <emphasis>mode</emphasis>
</programlisting>

      <para>which tells tcc to apply the named compilation mode, mode, to any
        files included from the directory, name. This is the mechanism used to
        specify the checks to be applied to the system headers.</para>

      <para>The system headers may be specified to tcc using the -Ysystem
        command-line option. This specifies /usr/include as the directory to
        search for headers and passes a system start-up file to tcc. This system
        start-up file contains any macro definitions which are necessary for tcc
        to navigate the system headers correctly, plus a description of the
        compilation mode to be used in compiling the system headers.</para>

      <para>In fact, before searching /usr/include, tcc searches another
        directory for system headers. This is intended to hold modified versions
        of any system headers which cause particular problems or require extra
        information. For example:</para>

      <itemizedlist>
        <listitem>
          <para>A version of stdio.h is provided for all systems, which
            contains the declarations of printf and similar functions necessary
            for tcc to apply its printf-string checks (see 3.3.2).</para>
        </listitem>

        <listitem>
          <para>A version of stdlib.h is provided for all systems which
            includes the declarations of exit and similar functions necessary for
            tcc to apply its flow analysis correctly (see 5.7).</para>
        </listitem>

        <listitem>
          <para>Versions of stdarg.h and varargs.h are provided for all systems
            which work with tcc. Most system headers contain built-in functions
            which are recognised by cc (but not tcc) to deal with these.</para>
        </listitem>
      </itemizedlist>

      <para>The user can also use this directory to modify any system headers
        which cause problems. For example, not all system headers declare all the
        functions they should, so it might be desirable to add these
        declarations.</para>

      <para>It should be noted that the system headers and the TenDRA API
        headers do not mix well. Both are parts of coherent systems of header
        files, and unless the intersection is very small, it is not usually
        possible to combine parts of these systems sensibly.</para>

      <para>Even a separation, such as compiling some modules of a program
        using a TenDRA API description and others using the system headers, can
        lead to problems in the intermodular linking phase (see Chapter 9). There
        will almost certainly be type inconsistency errors since the TenDRA
        headers and the system headers will have different representations of the
        same object.</para>
    </sect1>

    <sect1 id='abstract-api-headers'>
      <title>Abstract API headers and API usage analysis</title>

      <para>The abstract standard headers provided with the tool are the basis
        for the API usage analysis checking on dump files described in Chapter 9.
        The declarations in each abstract header file are enclosed by the
        following pragmas:</para>
<programlisting>
#pragma TenDRA declaration block <emphasis>API_name</emphasis> begin
#pragma TenDRA declaration block end
</programlisting>

      <para><literal>API_name</literal> has a standard form e.g.
        <emphasis>api__ansi__stdio</emphasis> for stdio.h in the ANSI API.</para>

      <para>This information is output in the dump format as the start and end
        of a header scope, i.e.</para>
<programlisting>
SSH position    ref_no = &lt;API_name&gt;
SEH position    ref_no
</programlisting>

      <para>The first occurence of each identifier in the dump output contains
        scope information; in the case of an identifier declared in the abstract
        headers, this scope information will normally refer to a header scope.
        Since each use of the identifier can be traced back to its declaration,
        this provides a means of tracking API usage within the application when
        the abstract headers are used. The disadvantages of this method are that
        only APIs for which abstract headers are available can be used. Objects
        which are not part of the standard APIs are not available and if an
        application requires such an identifier (or indeed attempts to use a
        standard API identifier for which the appropriate header has not been
        included) the resulting errors may distort or even completely halt the
        dump output resulting in incomplete or incorrect analysis.</para>

      <para>The second method of API analysis allows compilation of the
        application against the system headers, thereby overcoming the problems
        of non-standard API usage mentioned above. The dump of the application
        can be scanned to determine the identifiers which are used but not
        defined within the application itself. These identifiers form the
        program's external API with the system headers and libraries, and can be
        compared with API reference information, provided by dump output files
        produced from the abstract standard headers, to determine the
        applications API usage.</para>
    </sect1>
  </appendix>

  <appendix id='spec-conv-tok-syntax'>
    <title>Specifying conversions using the token syntax</title>

    <sect1 id='intro-a'>
      <title>Introduction</title>

      <para>The token syntax described in Annex F can be used to fine-tune the
        conversion analysis and integer range checks described in section 3.2.2
        and chapter 4 respectively.</para>
    </sect1>

    <sect1 id='user-def-conv'>
      <title>User-defined conversions</title>

      <para>In the example:</para>
<programlisting>
#pragma token TYPE IP#
#pragma no_def IP
#pragma token PROC{ TYPE t ,EXP rvalue : t* : e | EXP e}EXP rvalue:IP:p_to_ip#
#pragma TenDRA conversion p_to_ip allow
void f(void){
IP i, *pip;
i=pip;
}
</programlisting>

      <para>the conversion from type pointer to IP to IP would normally result
        in an error. However the pragma:</para>
<programlisting>
#pragma TenDRA conversion <emphasis>conv_list</emphasis> allow
</programlisting>

      <para>allows users to define their own conversions between types that
        would otherwise be incompatible. Each identifier in the
        <emphasis>conv_list</emphasis> must be a local identifier for a PROC
        token (see <xref linkend='procedure-tok'> Procedure tokens), taking exactly one
        argument which must be an expression. The procedure must also deliver an
        expression and both the parameter and the result must be rvalues. When
        attempting the conversion of a value from one type to another, either by
        assignment or casting, if that conversion would not normally be
        permitted, then, for each token introduced as a conversion token by the
        pragma above:</para>

      <para>An attempt is made to resolve the type of the token result to the
        type to which the value is being converted.</para>

      <para>If the result is resolved and the value to be converted is a
        suitable argument for the token procedure, the token procedure is applied
        to implement the conversion.</para>

      <para>If no suitable conversion token can be found, an error will be
        raised.</para>
    </sect1>

    <sect1 id='specifying-int-pro'>
      <title>Specifying integer promotions</title>

      <para>Whenever an integral type is used, e.g. in a call to a
        traditionally defined function, its promotion must be computed. If no
        promotion type has been specified, the compiler will raise an error.
        Although programs will generally use the default rules provided in the
        built-in compilation modes, the TenDRA compiler also allows programmers
        to specify their own set of integer promotion rules. Such promotions can
        be split into two categories: literal promotions and computed
        promotions.</para>

      <sect2 id='literal-prom'>
        <title>Literal promotions</title>

        <para>The promoted type is supplied directly using the pragma:</para>
<programlisting>
#pragma promote <emphasis>type-name</emphasis> : <emphasis>type-name</emphasis>
</programlisting>

        <para>The second type-name specifies the promoted type of the first
          type-name. Both types must be integral types.</para>
      </sect2>

      <sect2 id='computed-prom'>
        <title>Computed promotions</title>

        <para>The pragma:</para>
<programlisting>
#pragma compute promote <emphasis>proc-token</emphasis>
</programlisting>

        <para>allows the programmer to provide the identification of a
          procedure token (see <xref linkend='procedure-tok'> Procedure tokens) for
          computing the promotion type of any integral type. This token is then
          called whenever the promotion of a type without a literal promotion is
          required. The procedure token <emphasis>proc-token</emphasis> must be
          declared as:</para>
<programlisting>
#pragma token PROC ( VARIETY ) VARIETY proc-token #
</programlisting>

        <para>The TenDRA technology provides two pre-defined procedure tokens,
          identified by <literal>~promote</literal> and
          <literal>~sign-promote</literal>. These procedures perform integer
          promotions according to the ISO/ANSI promotion rules or according to
          the traditional signed promotion rules respectively. The built-in
          compilation environments (see chapter 2) use these tokens to specify
          the appropriate set of integer promotion rules.</para>
      </sect2>
    </sect1>
  </appendix>

  <chapter id='revision'>
    <title>Revision History</title>

    <para>This chapter describes revisions to this document.</para>

    <para>Only major changes are listed in the revision history.  Please see
      <ulink url="http://cvsweb.ten15.org/cgi/cvsweb.cgi/doc/en/tdfc/book.sgml">http://cvsweb.ten15.org/cgi/cvsweb.cgi/doc/en/tdfc/book.sgml</ulink>
      for a complete list of changes.</para>

    <note><para>CVS revision numbers are located behind the date in the format
      <literal>r</literal><emphasis>XX</emphasis></para></note>

    <para>
    <revhistory>
      <revision>
        <revnumber>1.1</revnumber>
        <date>2004/03/09 r1.14</date>
        <authorinitials>verm</authorinitials>
        <revremark>Cross references were fixed.</revremark>
      </revision>

      <revision>
        <revnumber>1.0</revnumber>
        <date>2003/07/30 r1.1</date>
        <authorinitials>verm</authorinitials>
        <revremark>Converted to SGML from the &doc.original;.</revremark>
      </revision>
    </revhistory>
  </para>
  </chapter>


</book>
