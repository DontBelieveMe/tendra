<!DOCTYPE BOOK PUBLIC "-//FreeBSD//DTD DocBook V4.1-Based Extension//EN">

<book>
  <bookinfo>
    <title>TDF Specification</title>
    <pubdate>$TenDRA$</pubdate>
    <corpauthor>The TenDRA Documentation Team</corpauthor>
    <copyright>
      <year>2002</year>
      <holder>TenDRA Documentation Team</holder>
    </copyright>
    <copyright>
      <year>1997</year>
      <year>1998</year>
      <holder>Defence Evaluation and Research Agency (DERA)</holder>
    </copyright>
    <abstract>
      <para>Please email us at <email>docs@tendra.org</email> if you see any errors</para>
    </abstract>
  </bookinfo>

<preface>
<title>Introduction</title>

<para>This is Issue 4.0 of the TDF Specification. TDF version 4.0 is not bitwise compatible with earlier versions.</para>


<para>TDF is a porting technology and, as a result, it is a central part of a shrink-wrapping, distribution and installation technology. TDF has been chosen by the Open Software Foundation as the basis of its Architecture Neutral Distribution Format. It was developed by the United Kingdom's Defence Research Agency (DRA). TDF is not UNIX specific, although most of the implementation has been done on UNIX.</para>

<para>Software vendors, when they port their programs to several platforms, usually wish to take advantage of the particular features of each platform. That is, they wish the versions of their programs on each platform to be functionally equivalent, but not necessarily algorithmically identical. TDF is intended for porting in this sense. It is designed so that a program in its TDF form can be systematically modified when it arrives at the target platform to achieve the intended functionality and to use the algorithms and data structures which are appropriate and efficient for the target machine. A fully efficient program, specialised to each target, is a necessity if independent software vendors are to take-up a porting technology.</para>

<para>These modifications are systematic because, on the source machine, programmers work with generalised declarations of the APIs they are using. The declarations express the requirements of the APIs without giving their implementation. The declarations are specified in terms of TDF's &quot;tokens&quot;, and the TDF which is produced contains uses of these tokens. On each target machine the tokens are used as the basis for suitable substitutions and alterations.</para>

<para>Using TDF for porting places extra requirements on software vendors and API designers. Software vendors must write their programs scrupulously in terms of APIs and nothing more. API designers need to produce an interface which can be specialised to efficient data structures and constructions on all relevant machines.</para>

<para>TDF is neutral with respect to the set of languages which has been considered. The design of C, C++, Fortran and Pascal is quite conventional, in the sense that they are sufficiently similar for TDF constructions to be devised to represent them all. These TDF constructions can be chosen so that they are, in most cases, close to the language constructions. Other languages, such as Lisp, are likely to need a few extensions. To express novel language features TDF will probably have to be more seriously extended. But the time to do so is when the feature in question has achieved sufficient stability. Tokens can be used to express the constructs until the time is right. For example, there is a lack of consensus about the best constructions for parallel languages, so that at present TDF would either have to use low level constructions for parallelism or back what might turn out to be the wrong system. In other words it is not yet the time to make generalisations for parallelism as an intrinsic part of TDF.</para>

<para>TDF is neutral with respect to machine architectures. In designing TDF, the aim has been to retain the information which is needed to produce and optimise the machine code, while discarding identifier and syntactic information. So TDF has constructions which are closely related to typical language features and it has an abstract model of memory. We expect that programs expressed in the considered languages can be translated into code which is as efficient as that produced by native compilers for those languages.</para>

<para>Because of these porting features TDF supports shrink-wrapping, distribution and installation. Installation does not have to be left to the end-user; the production of executables can be done anywhere in the chain from software vendor, through dealer and network manager to the end-user.</para>

<para>This document provides English language specifications for each construct in the TDF format and some general notes on various aspects of TDF. It is intended for readers who are aware of the general background to TDF but require more detailed information.</para>

<simplesect>
<title>Major changes from Issue 3.1</title>

<para>A new <literal>SORT</literal> for <literal>STRING</literal> is introduced having the same relationship to <literal>TDFSTRING</literal> as <literal>BOOL</literal> has to <literal>TDFBOOL</literal>. This is used in place of <literal>TDFSTRING</literal> in various 3.1 constructions.</para>

<para>They are also used in modified tag and token definitions and declarations to provide extra consistency checks in the use of these tags or tokens, and also may be used as names external to the TDF system. For example, the signature of <emphasis>make_id_tagdec</emphasis> is now:</para>

<programlisting>
<emphasis>t_intro</emphasis>: TDFINT
<emphasis>acc</emphasis>:     OPTION(ACCESS)
<emphasis>signature</emphasis>:   OPTION(STRING)
<emphasis>x</emphasis>:       SHAPE
-&gt; TAGDEC
</programlisting>

<para>A new <literal>EXP</literal> constructor, <emphasis>initial_value</emphasis>, is introduced to allow dynamic initialisation of global tags.</para>

<para>These changes arise mainly from requirements of C++, but are clearly applicable elsewhere.</para>

<para>Magic numbers are introduced at the start of files containing TDF bitstream information.</para>

<para>The version 3.1 constructor <emphasis>set_stack_limit</emphasis> has had to be modified in the light of experience with platforms with ABIs which require upward-growing stacks or use disjoint frame stacks and alloca stacks.</para>

<para>Various other minor changes have been made to elucidate some rather pathological cases, e.g. <emphasis>make_nof</emphasis> must have at least one element. Also there are some cosmetic changes to improve consistency, e.g. the order of the arguments of <emphasis>token</emphasis> are now consistent with <emphasis>token_definition</emphasis>.</para>

</simplesect>
<simplesect>
<title>Notes on Revision 1</title>

<para>This Revision 1 of Issue 4.0 incorporates a number of corrections which have arisen where inconsistency or impracticability became evident when validating the OSF Research Institute's AVS (ANDF Validation Suite). Apart from minor textual corrections, the changes are:</para>

<itemizedlist>
<listitem>
<para>Use of installer-defined <literal>TOKEN</literal>s for accessing variable parameter lists - see the companion document -XREF-register.htmlTDF Token Register (Revision 1).</para>
</listitem>
<listitem>
<para>Tolerance of overflow necessary to allow simple implementation of complex multiply and divide.</para>
</listitem>
<listitem>
<para>Modified constraints on the arguments of <emphasis>shift_left</emphasis>, <emphasis>shift_right</emphasis>, <emphasis>rotate_left</emphasis>, <emphasis>rotate_right</emphasis>, <emphasis>make_dynamic_callees</emphasis>, <emphasis>make_var_tagdec</emphasis>, <emphasis>make_tokdec</emphasis>, <emphasis>make_tokdef</emphasis>, and <emphasis>user_info</emphasis>.</para>
</listitem>
<listitem>
<para>Modified constant evaluation constraints with respect to <emphasis>env_size</emphasis> and <emphasis>env_offset</emphasis>.</para>
</listitem>
<listitem>
<para><emphasis>chain_extern</emphasis> no longer supported.</para>
</listitem>
</itemizedlist>

<para>Changes under consideration but not included in Issue 4.0:</para>

<itemizedlist>
<listitem>
<para>Tokenisation of the various LIST constructs.</para>
</listitem>
<listitem>
<para>Inclusion of the specification of run-time diagnostic information in the main specification. This is currently given as an appendix, as it it is less mature than the main specification.</para>
</listitem>
</itemizedlist>

</simplesect>
</preface>

<chapter>
<title>Structure of TDF</title>

<para>Each piece of TDF program is classified as being of a particular <literal>SORT</literal>. Some pieces of TDF are <literal>LABEL</literal>s, some are <literal>TAG</literal>s, some are <literal>ERROR_TREATMENT</literal>s and so on (to list some of the more transparently named <literal>SORT</literal>s). The <literal>SORT</literal>s of the arguments and result of each construct of the TDF format are specified. For instance, <emphasis>plus</emphasis> is defined to have three arguments - an <literal>ERROR_TREATMENT</literal> and two <literal>EXP</literal>s (short for &quot;expression&quot;) - and to produce an <literal>EXP</literal>; <emphasis>goto</emphasis> has a single <literal>LABEL</literal> argument and produces an <literal>EXP</literal>. The specification of the <literal>SORT</literal>s of the arguments and results of each construct constitutes the syntax of the TDF format. When TDF is represented as a parsed tree it is structured according to this syntax. When it is constructed and read it is in terms of this syntax.</para>

<sect1>
<title>The Overall Structure</title>

<para>A separable piece of TDF is called a <literal>CAPSULE</literal>. A producer generates a <literal>CAPSULE</literal>; the TDF linker links <literal>CAPSULE</literal>s together to form a <literal>CAPSULE</literal>; and the final translation process turns a <literal>CAPSULE</literal> into an object file.</para>

<para>The structure of capsules is designed so that the process of linking two or more capsules consists almost entirely of copying large byte-aligned sections of the source files into the destination file, without changing or even examining these sections. Only a small amount of interface information has to be modified and this is made easily accessible. The translation process only requires an extra indirection to account for this interface information, so it is also fast. The description of TDF at the capsule level is almost all about the organisation of the interface information.</para>

<para>There are three major kinds of entity which are used inside a capsule to name its constituents. The first are called tags; they are used to name the procedures, functions, values and variables which are the components of the program. The second are called tokens; they identify pieces of TDF which can be used for substitution - a little like macros. The third are the alignment tags, used to name alignments so that circular types can be described. Because these internal names are used for linking pieces of TDF together, they are collectively called <emphasis>linkable entities</emphasis>. The interface information relates these linkable entities to each other and to the world outside the capsule.</para>

<para>The most important part of a capsule, the part which contains the real information, consists of a sequence of groups of units. Each group contains units of the same kind, and all the units of the same kind are in the same group. The groups always occur in the same order, though it is not necessary for each kind to be present.</para>

      <figure id="capsule4">
        <title>Capsule 4</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="capsule4" scale="100" format="PNG">
          </imageobject>
        </mediaobject>
      </figure>

<para>The order is as follows:</para>

<itemizedlist>
<listitem>
<para><emphasis>tld</emphasis> unit. Every capsule has exactly one tld unit. It gives information to the TDF linker about those items in the capsule which are visible externally.</para>
</listitem>
<listitem>
<para><emphasis>versions</emphasis> unit. These units contain information about the versions of TDF used. Every capsule will have at least one such unit.</para>
</listitem>
<listitem>
<para><emphasis>tokdec</emphasis> units. These units contain declarations for tokens. They bear the same relationship to the following tokdef units that C declarations do to C definitions. However, they are not necessary for the translator, and the current ANSI C producer does not provide them by default.</para>
</listitem>
<listitem>
<para><emphasis>tokdef</emphasis> units. These units contain definitions of tokens.</para>
</listitem>
<listitem>
<para><emphasis>aldef</emphasis> units. These units give the definitions of alignment tags.</para>
</listitem>
<listitem>
<para><emphasis>diagtype</emphasis> units. These units give diagnostic information about types.</para>
</listitem>
<listitem>
<para><emphasis>tagdec</emphasis> units. These units contain declarations of tags, which identify values, procedures and run-time objects in the program. The declarations give information about the size, alignment and other properties of the values. They bear the same relationship to the following tagdef units that C declarations do to C definitions.</para>
</listitem>
<listitem>
<para><emphasis>diagdef</emphasis> units. These units give diagnostic information about the values and procedures defined in the capsule.</para>
</listitem>
<listitem>
<para><emphasis>tagdef</emphasis> units. These units contain the definitions of tags, and so describe the procedures and the values they manipulate.</para>
</listitem>
<listitem>
<para><emphasis>linkinfo</emphasis> units. These units give information about the linking of objects.</para>
</listitem>
</itemizedlist>

<para>This organisation is imposed to help installers, by ensuring that the information needed to process a unit has been provided before that unit arrives. For example, the token definitions occur before any tag definition, so that, during translation, the tokens may be expanded as the tag definitions are being read (in a capsule which is ready for translation all tokens used must be defined, but this need not apply to an arbitrary capsule).</para>

<para>The tags and tokens in a capsule have to be related to the outside world. For example, there might be a tag standing for <emphasis>printf</emphasis>, used in the appropriate way inside the capsule. When an object file is produced from the capsule the identifier <emphasis>printf</emphasis> must occur in it, so that the system linker can associate it with the correct library procedure. In order to do this, the capsule has a table of tags at the capsule level, and a set of external links which provide external names for some of these tags.</para>


      <figure id="capsule1">
        <title>Capsule 1</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="capsule1" scale="100" format="PNG">
          </imageobject>
        </mediaobject>
      </figure>

<para>In just the same way, there are tables of tokens and alignment tags at the capsule level, and external links for these as well.</para>

<para>The tags used inside a unit have to be related to these capsule tags, so that they can be properly named. A similar mechanism is used, with a table of tags at the unit level, and links between these and the capsule level tags.</para>

      <figure id="capsule2">
        <title>Capsule 2</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="capsule2" scale="100" format="PNG">
          </imageobject>
        </mediaobject>
      </figure>

<para>Again the same technique is used for tokens and alignment tags.</para>

<para>It is also necessary for a tag used in one unit to refer to the same thing as a tag in another unit. To do this a tag at the capsule level is used, which may or may not have an external link.</para>

      <figure id="capsule3">
        <title>Capsule 3</title>
        <mediaobject>
          <imageobject>
            <imagedata fileref="capsule3" scale="100" format="PNG">
          </imageobject>
        </mediaobject>
      </figure>

<para>The same technique is used for tokens and alignment tags.</para>

<para>So when the TDF linker is joining two capsules, it has to perform the following tasks:</para>

<itemizedlist>
<listitem>
<para>It creates new sets of capsule level tags, tokens and alignment tags by identifying those which have the same external name, and otherwise creating different entries.</para>
</listitem>
<listitem>
<para>It similarly joins the external links, suppressing any names which are no longer to be external.</para>
</listitem>
<listitem>
<para>It produces new link tables for the units, so that the entities used inside the units are linked to the new positions in the capsule level tables.</para>
</listitem>
<listitem>
<para>It re-organises the units so that the correct order is achieved.</para>
</listitem>
</itemizedlist>

<para>This can be done without looking into the interior of the units (except for the <emphasis>tld</emphasis> unit), simply copying the units into their new place.</para>

<para>During the process of installation the values associated with the linkable entities can be accessed by indexing into an array followed by one indirection. These are the kinds of object which in a programming language are referred to by using identifiers, which involves using hash tables for access. This is an example of a general principle of the design of TDF; speed is required in the linking and installing processes, if necessary at the expense of time in the production of TDF.</para>

</sect1>

<sect1>
<title>Tokens</title>

<para>Tokens are used (applied) in the TDF at the point where substitutions are to be made. Token definitions provide the substitutions and usually reside on the target machine and are linked in there.</para>

<para>A typical token definition has parameters from various <literal>SORT</literal>s and produces a result of a given <literal>SORT</literal>. As an example of a simple token definition, written here in a C-like notation, consider the following.</para>

<programlisting>
<emphasis>EXP ptr_add (EXP par0, EXP par1, SHAPE par2)
{
  add_to_ptr(
    par0,
    offset_mult(
      offset_pad(
        alignment(par2),
        shape_offset(par2)),
      par1))
}</emphasis>
</programlisting>

<para>This defines the token, <emphasis>ptr_add</emphasis>, to produce something of <literal>SORT</literal> <literal>EXP</literal>. It has three parameters, of <literal>SORT</literal>s <literal>EXP</literal>, <literal>EXP</literal> and <literal>SHAPE</literal>. The <emphasis>add_to_ptr</emphasis>, <emphasis>offset_mult</emphasis>, <emphasis>offset_pad</emphasis>, <emphasis>alignment</emphasis> and <emphasis>shape_offset</emphasis> constructions are TDF constructions producing respectively an <literal>EXP</literal>, an <literal>EXP</literal>, an <literal>EXP</literal>, an <literal>ALIGNMENT</literal> and an <literal>EXP</literal>.</para>

<para>A typical use of this token is:</para>

<programlisting>
<emphasis>ptr_add(
  obtain_tag(tag41),
  contents(integer(~signed_int), obtain_tag(tag62)),
  integer(~char))</emphasis>
</programlisting>

<para>The effect of this use is to produce the TDF of the definition with <emphasis>par0</emphasis>, <emphasis>par1</emphasis> and <emphasis>par2</emphasis> substituted by the actual parameters.</para>

<para>There is no way of obtaining anything like a side-effect. A token without parameters is therefore just a constant.</para>

<para>Tokens can be used for various purposes. They are used to make the TDF shorter by using tokens for commonly used constructions (<emphasis>ptr_add</emphasis> is an example of this use). They are used to make target dependent substitutions (<emphasis>~char</emphasis> in the use of <emphasis>ptr_add</emphasis> is an example of this, since <emphasis>~char</emphasis> may be signed or unsigned on the target).</para>

<para>A particularly important use is to provide definitions appropriate to the translation of a particular language. Another is to abstract those features which differ from one ABI to another. This kind of use requires that sets of tokens should be standardised for these purposes, since otherwise there will be a proliferation of such definitions.</para>

</sect1>

<sect1>
<title>Tags</title>

<para>Tags are used to identify the actual program components. They can be declared or defined. A declaration gives the <literal>SHAPE</literal> of a tag (a <literal>SHAPE</literal> is the TDF analogue of a type). A definition gives an <literal>EXP</literal> for the tag (an <literal>EXP</literal> describes how the value is to be made up).</para>

</sect1>

<sect1>
<title>Extending the format</title>

<para>TDF can be extended for two major reasons.</para>

<para>First, as part of the evolution of TDF, new features will from time to time be identified. It is highly desirable that these can be added without disturbing the current encoding, so that old TDF can still be installed by systems which recognise the new constructions. Such changes should only be made infrequently and with great care, for stability reasons, but nevertheless they must be allowed for in the design.</para>

<para>Second, it may be required to add extra information to TDF to permit special processing. TDF is a way of describing programs and it clearly may be used for other reasons than portability and distribution. In these uses it may be necessary to add extra information which is closely integrated with the program. Diagnostics and profiling can serve as examples. In these cases the extra kinds of information may not have been allowed for in the TDF encoding.</para>

<para>Some extension mechanisms are described below and related to these reasons:</para>

<itemizedlist>
<listitem>
<para>The encoding of every <literal>SORT</literal> in TDF can be extended indefinitely (except for certain auxiliary <literal>SORT</literal>s). This mechanism should only be used for extending standard TDF to the next standard, since otherwise extensions made by different groups of people might conflict with each other. See -XREF-spec11.html#13Extendable integer encoding.</para>
</listitem>
<listitem>
<para>Basic TDF has three kinds of linkable entity and seven kinds of unit. It also contains a mechanism for extending these so that other information can be transmitted in a capsule and properly related to basic TDF. The rules for linking this extra information are also laid down. See -XREF-spec8.html#M53make_capsule. 
<para>If a new kind of unit is added, it can contain any information, but if it is to refer to the tags and tokens of other units it must use the linkable entities. Since new kinds of unit might need extra kinds of linkable entity, a method for adding these is also provided. All this works in a uniform way, with capsule level tables of the new entities, and external and internal links for them.</para>
<para>If new kinds of unit are added, the order of groups must be the same in any capsules which are linked together. As an example of the use of this kind of extension, the diagnostic information is introduced in just this way. It uses two extra kinds of unit and one extra kind of linkable entity. The extra units need to refer to the tags in the other units, since these are the object of the diagnostic information. This mechanism can be used for both purposes.</para>
<listitem>
<para>The parameters of tokens are encoded in such a way that foreign information (that is, information which cannot be expressed in the TDF <literal>SORT</literal>s) can be supplied. This mechanism should only be used for the second purpose, though it could be used to experiment with extensions for future standards. See -XREF-spec11.html#8<literal>BITSTREAM</literal>.</para>
</listitem>
</itemizedlist>

</sect1>
</chapter>


<chapter>
<title>Describing the Structure</title>

<para>The following examples show how TDF constructs are described in this document. The first is the construct -XREF-spec8.html#M282<emphasis>floating</emphasis>:</para>

<programlisting>
<emphasis>fv</emphasis>:      FLOATING_VARIETY
  -&gt; SHAPE
</programlisting>

<para>The constructs' arguments (one in this case) precede the &quot;<emphasis>-&gt;</emphasis>&quot; and the result follows it. Each argument is shown as follows:</para>
<programlisting>
<emphasis>name</emphasis>:        SORT
</programlisting>

<para>The name standing before the colon is for use in the accompanying English description within the specification. It has no other significance.</para>

<para>The example given above indicates that <emphasis>floating</emphasis> takes one argument. This argument, <emphasis>v</emphasis>, is of <literal>SORT FLOATING_VARIETY</literal>. After the &quot;<literal>-&gt;</literal>&quot; comes the <literal>SORT</literal> of the result of <emphasis>floating</emphasis>. It is a <literal>SHAPE</literal>.</para>

<para>In the case of <emphasis>floating</emphasis> the formal description supplies the syntax and the accompanying English text supplies the semantics. However, in the case of some constructs it is convenient to specify more information in the formal section. For example, the specification of the construct -XREF-spec8.html#M116<emphasis>floating_negate</emphasis> not only states that it has an <literal>EXP</literal> argument and an <literal>EXP</literal> result:</para>

<programlisting>
<emphasis>flpt_err</emphasis>:     ERROR_TREATMENT
<emphasis>arg1</emphasis>:        EXP FLOATING(<emphasis>f</emphasis>)
-&gt; EXP FLOATING(<emphasis>f</emphasis>)
</programlisting>

<para>it also supplies additional information about those <literal>EXP</literal>s. It specifies that these expressions will be floating point numbers of the same kind.</para>

<para>Some construct's arguments are optional. This is denoted as follows (from -XREF-spec8.html#M80<emphasis>apply_proc</emphasis>):</para>

<programlisting>
<emphasis>result_shape</emphasis>:    SHAPE
<emphasis>p</emphasis>:       EXP PROC
<emphasis>params</emphasis>:      LIST(EXP)
<emphasis>var_param</emphasis>:   OPTION(EXP)
-&gt; EXP <emphasis>result_shape</emphasis>
</programlisting>

<para><emphasis>var_param</emphasis> is an optional argument to the <emphasis>apply_proc</emphasis> construct shown above.</para>

<para>Some constructs take a varying number of arguments. <emphasis>params</emphasis> in the above construct is an example. These are denoted by <literal>LIST</literal>. There is a similar construction, <literal>SLIST</literal>, which differs only in having a different encoding.</para>

<para>Some constructs' results are governed by the values of their arguments. This is denoted by the &quot;<literal>?</literal>&quot; formation shown in the specification of the -XREF-spec8.html#M89<emphasis>case</emphasis> construct shown below:</para>

<programlisting>
<emphasis>exhaustive</emphasis>:  BOOL
<emphasis>control</emphasis>: EXP INTEGER(<emphasis>v</emphasis>)
<emphasis>branches</emphasis>:    LIST(CASELIM)
-&gt; EXP (<emphasis>exhaustive</emphasis> ? BOTTOM : TOP)
</programlisting>

<para>If <emphasis>exhaustive</emphasis> is true, the resulting <literal>EXP</literal> has the <literal>SHAPE BOTTOM</literal>: otherwise it is <literal>TOP</literal>.</para>

<para>Depending on a TDF-processing tool's purpose, not all of some constructs' arguments need necessarily be processed. For instance, installers do not need to process one of the arguments of the <emphasis>x_cond</emphasis> constructs (where <emphasis>x</emphasis> stands for a <literal>SORT</literal>, e.g. -XREF-spec8.html#M75<emphasis>exp_cond</emphasis>. Secondly, standard tools might want to ignore embedded fragments of TDF adhering to some private standard. In these cases it is desirable for tools to be able to skip the irrelevant pieces of TDF. <literal>BITSTREAM</literal>s and <literal>BYTESTREAM</literal>s are formations which permit this. In the encoding they are prefaced with information about their length.</para>

<para>Some constructs' arguments are defined as being <literal>BITSTREAM</literal>s or <literal>BYTESTREAM</literal>s, even though the constructs specify them to be of a particular <literal>SORT</literal>. In these cases the argument's <literal>SORT</literal> is denoted as, for example, <literal>BITSTREAM FLOATING_VARIETY</literal> . This construct must have a <literal>FLOATING_VARIETY</literal> argument, but certain TDF-processing tools may benefit from being able to skip past the argument (which might itself be a very large piece of TDF) without having to read its content.</para>

<para>The nature of the <literal>UNIT</literal>s in a <literal>GROUP</literal> is determined by unit identifications. These occur in <emphasis>make_capsule</emphasis>. The values used for unit identifications are specified in the text as follows:</para>

<simplelist type='horiz' columns='2'>
<member>Unit identification:</member> <member><emphasis>some_name</emphasis></member>
</simplelist>

<para>where <emphasis>some_name</emphasis> might be <emphasis>tokdec</emphasis>, <emphasis>tokdef</emphasis> etc.</para>

<para>The kinds of linkable entity used are determined by linkable entity identifications. These occur in <emphasis>make_capsule</emphasis>. The values used for linkable entity identification are specified in the text as follows:</para>

<simplelist type='horiz' columns='2'>
<member>Linkable entity identification:</member> <member><emphasis>some_name</emphasis></member>
</simplelist>

<para>where <emphasis>some_name</emphasis> might be <emphasis>tag</emphasis>, <emphasis>token</emphasis> etc.</para>

<para>The bit encodings are also specified in this document. The details are given in -XREF-spec11.html#0The bit encoding of TDF. This section describes the encoding in terms of information given with the descriptions of the <literal>SORT</literal>s and constructs.</para>

<para>With each <literal>SORT</literal> the number of bits used to encode the constructs is given in the following form:</para>

<simplelist type='horiz' columns='2'>
<member>Number of encoding bits:</member><member><emphasis>n</emphasis></member>
</simplelist>

<para>This number may be zero; if so the encoding is non-extendable. If it is non-zero the encoding may be extendable or non-extendable. This is specified in the following form:</para>

<simplelist type='horiz' columns='2'>
<member>Is coding extendable:</member> <member>yes/no</member>
</simplelist>

<para>With each construct the number used to encode it is given in the following form:</para>

<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member><emphasis>n</emphasis></member>
</simplelist>

<para>If the number of encoding bits is zero, <emphasis>n</emphasis> will be zero.</para>

<para>There may be a requirement that a component of a construct should start on a byte boundary in the encoding. This is denoted by inserting -XREF-M13<literal>BYTE_ALIGN</literal> before the component <literal>SORT</literal>.</para>
</chapter>

<chapter>
<title>Installer Behaviour</title>

<para> </para>

<sect1>
<title>Definition of terms</title>

<para>In this document the behaviour of TDF installers is described in a precise manner. Certain words are used with very specific meanings. These are:</para>

<itemizedlist>
<listitem>
<para>&quot;undefined&quot;: means that installers can perform any action, including refusing to translate the program. It can produce code with any effect, meaningful or meaningless.</para>
</listitem>
<listitem>
<para>&quot;shall&quot;: when the phrase &quot;<emphasis>P</emphasis> shall be done&quot; (or similar phrases involving &quot;shall&quot;) is used, every installer must perform <emphasis>P</emphasis>.</para>
</listitem>
<listitem>
<para>&quot;should&quot;: when the phrase &quot;<emphasis>P</emphasis> should be done&quot; (or similar phrase involving &quot;should&quot;) is used, installers are advised to perform <emphasis>P</emphasis>, and producer writers may assume it will be done if possible. This usage generally relates to optimisations which are recommended.</para>
</listitem>
<listitem>
<para>&quot;will&quot;: when the phrase &quot;<emphasis>P</emphasis> will be true&quot; (or similar phrases involving &quot;will&quot;) is used to describe the composition of a TDF construct, the installer may assume that <emphasis>P</emphasis> holds without having to check it. If, in fact, a producer has produced TDF for which <emphasis>P</emphasis> does not hold, the effect is undefined.</para>
</listitem>
<listitem>
<para>&quot;target-defined&quot;: means that behaviour will be defined, but that it varies from one target machine to another. Each target installer shall define everything which is said to be &quot;target-defined&quot;.</para>
</listitem>
</itemizedlist>

</sect1>

<sect1>
<title>Properties of Installers</title>

<para>All installers must implement all of the constructions of TDF. There are some constructions where the installers may impose limits on the ranges of values which are implemented. In these cases the description of the installer must specify these limits.</para>

<para>Installers are not expected to check that the TDF they are processing is well-formed, nor that undefined constructs are absent. If the TDF is not well-formed any effect is permitted.</para>

<para>Installers shall only implement optimisations which are correct in all circumstances. This correctness can only be shown by demonstrating the equivalence of the transformed program, from equivalences deducible from this specification or from the ordinary laws of arithmetic. No statements are made in this specification of the form &quot;such and such an optimisation is permitted&quot;.</para>

<note>
<para>Fortran90 has a notion of mathematical equivalence which is not the same as TDF equivalence. It can be applied to transform programs provided parentheses in the text are not crossed. TDF does not acknowledge this concept. Such transformations would have to be applied in a context where the permitted changes are known.</para>
</note>
</sect1>
</chapter>



<chapter>
<title>Specification of TDF Constructs</title>
<para> </para>

<sect1>
<title>ACCESS</title>

<simplelist type='horiz' columns='2'>
<member>Number of encoding bits:</member><member>4</member>
<member>Is coding extendable:</member><member>yes</member>
</simplelist>

<para>An <literal>ACCESS</literal> describes properties a variable or identity may have which may constrain or describe the ways in which the variable or identity is used.</para>

<para>Each construction which needs an <literal>ACCESS</literal> uses it in the form <literal>OPTION</literal>(<literal>ACCESS</literal>). If the option is absent the variable or identity has no special properties.</para>

<para>An <literal>ACCESS</literal> acts like a set of the values <emphasis>constant</emphasis>, <emphasis>long_jump_access</emphasis>, <emphasis>no_other_read</emphasis>, <emphasis>no_other_write</emphasis>, <emphasis>register</emphasis>, <emphasis>out_par</emphasis>, <emphasis>used_as_volatile</emphasis>, and <emphasis>visible</emphasis>. <emphasis>standard_access</emphasis> acts like the empty set. <emphasis>add_accesses</emphasis> is the set union operation.</para>


<sect2>
<title>access_apply_token</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>1</member>
</simplelist>

<programlisting>
<emphasis>token_value</emphasis>: TOKEN
<emphasis>token_args</emphasis>:  BITSTREAM <emphasis>param_sorts(token_value)</emphasis>
-&gt; ACCESS
</programlisting>

<para>The token is applied to the arguments encoded in the <literal>BITSTREAM</literal> <emphasis>token_args</emphasis> to give an <literal>ACCESS</literal>. </para>

<para>The notation <emphasis>param_sorts(token_value)</emphasis> is intended to mean the following. The token definition or token declaration for <emphasis>token_value</emphasis> gives the <literal>SORT</literal>s of its arguments in the <literal>SORTNAME</literal> component. The <literal>BITSTREAM</literal> in <emphasis>token_args</emphasis> consists of these <literal>SORT</literal>s in the given order. If no token declaration or definition exists in the <literal>CAPSULE</literal>, the <literal>BITSTREAM</literal> cannot be read.</para>


</sect2>

<sect2>
<title>access_cond</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>2</member>
</simplelist>

<programlisting>
<emphasis>control</emphasis>: EXP INTEGER(<emphasis>v</emphasis>)
<emphasis>e1</emphasis>:      BITSTREAM ACCESS
<emphasis>e2</emphasis>:      BITSTREAM ACCESS
-&gt; ACCESS
</programlisting>

<para><emphasis>control</emphasis> is evaluated. It will be a constant at install time under the constant evaluation rules. If it is non-zero, <emphasis>e1</emphasis> is installed at this point and <emphasis>e2</emphasis> is ignored and never processed. If <emphasis>control</emphasis> is zero then <emphasis>e2</emphasis> is installed at this point and <emphasis>e1</emphasis> is ignored and never processed.</para>

</sect2>

<sect2>
<title>add_accesses</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>3</member>
</simplelist>

<programlisting>
<emphasis>a1</emphasis>:      ACCESS
<emphasis>a2</emphasis>:      ACCESS
-&gt; ACCESS
</programlisting>

<para>A construction qualified with <emphasis>add_accesses</emphasis> has both <literal>ACCESS</literal> properties <emphasis>a1</emphasis> and <emphasis>a2</emphasis>. This operation is associative and commutative. </para>

</sect2>
<sect2>
<title>constant</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>4</member>
</simplelist>

<programlisting>
-&gt; ACCESS
</programlisting>

<para>Only a variable (not an identity) may be qualified with <emphasis>constant</emphasis>. A variable qualified with <emphasis>constant</emphasis> will retain its initialising value unchanged throughout its lifetime. </para>


</sect2>

<sect2>
<title>long_jump_access</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>5</member>
</simplelist>

<programlisting>
-&gt; ACCESS
</programlisting>

<para>An object must also have this property if it is to have a defined value when a <emphasis>long_jump</emphasis> returns to the procedure declaring the object.</para>

</sect2>
<sect2>

<title>no_other_read</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>6</member>
</simplelist>


<programlisting>
-&gt; ACCESS
</programlisting>

<para>This property refers to a <literal>POINTER</literal>, <emphasis>p</emphasis>. It says that, within the lifetime of the declaration being qualified, there are no <emphasis>contents</emphasis>, <emphasis>contents_with_mode</emphasis> or <emphasis>move_some</emphasis> source accesses to any pointer not derived from <emphasis>p</emphasis> which overlap with any of the <emphasis>contents</emphasis>, <emphasis>contents_with_mode</emphasis>, <emphasis>assign</emphasis>, <emphasis>assign_with_mode</emphasis> or <emphasis>move_some</emphasis> accesses to pointers derived from <emphasis>p</emphasis>. </para>

<para>The <literal>POINTER</literal> being described is that obtained by applying <emphasis>obtain_tag</emphasis> to the <literal>TAG</literal> of the declaration. If the declaration is an <emphasis>identity</emphasis>, the <literal>SHAPE</literal> of the <literal>TAG</literal> will be a <literal>POINTER</literal>.</para>



</sect2>
<sect2>
<title>no_other_write</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>7</member>

</simplelist>
<programlisting>
-&gt; ACCESS
</programlisting>

<para>This property refers to a <literal>POINTER</literal>, <emphasis>p</emphasis>. It says that, within the lifetime of the declaration being qualified, there are no <emphasis>assign</emphasis>, <emphasis>assign_with_mode</emphasis> or <emphasis>move_some</emphasis> destination accesses to any pointer not derived from <emphasis>p</emphasis> which overlap with any of the <emphasis>contents</emphasis>, <emphasis>contents_with_mode</emphasis>, <emphasis>assign</emphasis>, <emphasis>assign_with_mode</emphasis> or <emphasis>move_some</emphasis> accesses to pointers derived from <emphasis>p</emphasis>. </para>

<para>The <literal>POINTER</literal> being described is that obtained by applying <emphasis>obtain_tag</emphasis> to the <literal>TAG</literal> of the declaration. If the declaration is an <emphasis>identity</emphasis>, the <literal>SHAPE</literal> of the <literal>TAG</literal> will be a <literal>POINTER</literal>.</para>



</sect2>
<sect2>
<title>out_par</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>8</member>

</simplelist>
<programlisting>
-&gt; ACCESS
</programlisting>

<para>An object qualified by <emphasis>out_par</emphasis> will be an output parameter in a <emphasis>make_general_proc</emphasis> construct. This will indicate that the final value of the parameter is required in <emphasis>postlude</emphasis> part of an <emphasis>apply_general_proc</emphasis> of this procedure. </para>



</sect2>
<sect2>
<title>preserve</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>9</member>

</simplelist>
<programlisting>
-&gt; ACCESS
</programlisting>

<para>This property refers to a global object. It says that the object will be included in the final program, whether or not all possible accesses to that object are optimised away; for example by inlining all possible uses of procedure object. </para>



</sect2>
<sect2>
<title>register</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>10</member>

</simplelist>
<programlisting>
-&gt; ACCESS
</programlisting>

<para>Indicates that an object with this property is frequently used. This can be taken as a recommendation to place it in a register. </para>



</sect2>
<sect2>
<title>standard_access</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>11</member>

</simplelist>
<programlisting>
-&gt; ACCESS
</programlisting>

<para>An object qualified as having <emphasis>standard_access</emphasis> has normal (i.e. no special) access properties. </para>



</sect2>
<sect2>
<title>used_as_volatile</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>12</member>

</simplelist>
<programlisting>
-&gt; ACCESS
</programlisting>

<para>An object qualified as having <emphasis>used_as_volatile</emphasis> will be used in a <emphasis>move_some</emphasis>, <emphasis>contents_with_mode</emphasis> or an <emphasis>assign_with_mode</emphasis> construct with <literal>TRANSFER_MODE</literal> <emphasis>volatile</emphasis>. </para>



</sect2>
<sect2>
<title>visible</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>13</member>

</simplelist>
<programlisting>
-&gt; ACCESS
</programlisting>

<para>An object qualified as <emphasis>visible</emphasis> may be accessed when the procedure in which it is declared is not the current procedure. A <literal>TAG</literal> must have this property if it is to be used by <emphasis>env_offset</emphasis>. </para>




</sect2>
</sect1>

<sect1>
<title>AL_TAG</title>

<simplelist type='horiz' columns='2'>
<member>Number of encoding bits:</member><member>1</member>
<member>Is coding extendable:</member><member>yes</member>
<member>Linkable entity identification:</member><member><emphasis>alignment</emphasis></member>
</simplelist>


<para><literal>AL_TAG</literal>s name <literal>ALIGNMENT</literal>s. They are used so that circular definitions can be written in TDF. However, because of the definition of alignments, intrinsic circularities cannot occur.</para>

<para><emphasis>For example, the following equation has a circular form</emphasis> <emphasis>x = alignment(pointer(alignment(x))) and it or a similar equation might occur in TDF. But since</emphasis> <emphasis>alignment</emphasis>(<emphasis>pointer</emphasis>(<emphasis>x</emphasis>)) is {<emphasis>pointer</emphasis>}, this reduces to <emphasis>x</emphasis> = {<emphasis>pointer</emphasis>}.</para>

<sect2>
<title>al_tag_apply_token</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>2</member>
</simplelist>

<programlisting>
<emphasis>token_value</emphasis>: TOKEN
<emphasis>token_args</emphasis>:  BITSTREAM <emphasis>param_sorts(token_value)</emphasis>
-&gt; AL_TAG
</programlisting>

<para>The token is applied to the arguments encoded in the <literal>BITSTREAM</literal> <emphasis>token_args</emphasis> to give an <literal>AL_TAG</literal>. </para>

<para>If there is a definition for <emphasis>token_value</emphasis> in the <literal>CAPSULE</literal> then <emphasis>token_args</emphasis> is a <literal>BITSTREAM</literal> encoding of the <literal>SORT</literal>s of its parameters, in the order specified.</para>

</sect2>
<sect2>
<title>make_al_tag</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>1</member>
</simplelist>

<programlisting>
<emphasis>al_tagno</emphasis>:    TDFINT
-&gt; AL_TAG
</programlisting>

<para><emphasis>make_al_tag</emphasis> constructs an <literal>AL_TAG</literal> identified by <emphasis>al_tagno</emphasis>.</para>

</sect2>
</sect1>

<sect1>
<title>AL_TAGDEF</title>
<simplelist type='horiz' columns='2'>
<member>Number of encoding bits:</member><member>1</member>
<member>Is coding extendable:</member><member>yes</member>
</simplelist>

<para>An <literal>AL_TAGDEF</literal> gives the definition of an <literal>AL_TAG</literal> for incorporation into a <literal>AL_TAGDEF_PROPS</literal>.</para>


<sect2>
<title>make_al_tagdef</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>1</member>
</simplelist>

<programlisting>
<emphasis>t</emphasis>:       TDFINT
<emphasis>a</emphasis>:       ALIGNMENT
-&gt; AL_TAGDEF
</programlisting>

<para>The <literal>AL_TAG</literal> identified by <emphasis>t</emphasis> is defined to stand for the <literal>ALIGNMENT</literal> <emphasis>a</emphasis>. All the <literal>AL_TAGDEF</literal>s in a <literal>CAPSULE</literal> must be considered together as a set of simultaneous equations defining <literal>ALIGNMENT</literal> values for the <literal>AL_TAG</literal>s. No order is imposed on the definitions. </para>

<para>In any particular <literal>CAPSULE</literal> the set of equations may be incomplete, but a <literal>CAPSULE</literal> which is being translated into code will have a set of equations which defines all the <literal>AL_TAG</literal>s which it uses.</para>

<para>The result of the evaluation of the <emphasis>control</emphasis> argument of any <emphasis>x_cond</emphasis> construction (e.g <emphasis>alignment_cond</emphasis>) used in <emphasis>a</emphasis> shall be independent of any <literal>AL_TAG</literal>s used in the <emphasis>control</emphasis>. Simultaneous equations defining <literal>ALIGNMENT</literal>s can then always be solved.</para>

<para>See -XREF-spec10.html#32Circular types in languages.</para>

</sect2>
</sect1>


<sect1>
<title>AL_TAGDEF_PROPS</title>

<simplelist type='horiz' columns='2'>
<member>Number of encoding bits:</member><member>0</member>
<member>Is coding extendable:</member><member>no</member>
<member>Unit identification:</member><member><emphasis>aldef</emphasis></member>
</simplelist>

<sect2>
<title>make_al_tagdefs</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>0</member>
</simplelist>

<programlisting>
<emphasis>no_labels</emphasis>:   TDFINT
<emphasis>tds</emphasis>:     SLIST(AL_TAGDEF)
-&gt; AL_TAGDEF_PROPS
</programlisting>

<para><emphasis>no_labels</emphasis> is the number of local <literal>LABEL</literal>s used in <emphasis>tds</emphasis>. <emphasis>tds</emphasis> is a list of <literal>AL_TAGDEF</literal>s which define the bindings for <emphasis>al_tags</emphasis>.</para>
</sect2>
</sect1>


<sect1>
<title>ALIGNMENT</title>

<simplelist type='horiz' columns='2'>
<member>Number of encoding bits:</member><member>4</member>
<member>Is coding extendable:</member><member>yes</member>
</simplelist>

<para>An <literal>ALIGNMENT</literal> gives information about the layout of data in memory and hence is a parameter for the <literal>POINTER</literal> and <literal>OFFSET SHAPE</literal>s (see -XREF-spec10.html#26Memory Model). This information consists of a set of elements.</para>

<para>The possible values of the elements in such a set are <emphasis>proc</emphasis>, <emphasis>code</emphasis>, <emphasis>pointer</emphasis>, <emphasis>offset</emphasis>, all <literal>VARIETY</literal>s, all <literal>FLOATING_VARIETY</literal>s and all <literal>BITFIELD_VARIETY</literal>s. The sets are written here as, for example, {<emphasis>pointer</emphasis>, <emphasis>proc</emphasis>} meaning the set containing <emphasis>pointer</emphasis> and <emphasis>proc</emphasis>.</para>

<para>In addition, there are &quot;special&quot; <literal>ALIGNMENT</literal>s <emphasis>alloca_alignment</emphasis>, <emphasis>callers_alignment</emphasis>, <emphasis>callees_alignment</emphasis>, <emphasis>locals_alignment</emphasis> and <emphasis>var_param_alignment</emphasis>. Each of these are considered to be sets which include all of the &quot;ordinary&quot; <literal>ALIGNMENT</literal>s above.</para>

<para>There is a function, <emphasis>alignment</emphasis>, which can be applied to a <literal>SHAPE</literal> to give an <literal>ALIGNMENT</literal> (see the definition below). The interpretation of a <literal>POINTER</literal> to an <literal>ALIGNMENT</literal>, <emphasis>a</emphasis>, is that it can serve as a <literal>POINTER</literal> to any <literal>SHAPE</literal>, <emphasis>s</emphasis>, such that <emphasis>alignment</emphasis>(<emphasis>s</emphasis>) is a subset of the set <emphasis>a</emphasis>.</para>

<para>So given a <literal>POINTER</literal>({<emphasis>proc</emphasis>, <emphasis>pointer</emphasis>}) it is permitted to assign a <literal>PROC</literal> or a <literal>POINTER</literal> to it, or indeed a compound containing only <literal>PROC</literal>s and <literal>POINTER</literal>s. This permission is valid only in respect of the space being of the right kind; it may or may not be big enough for the data.</para>

<para>The most usual use for <literal>ALIGNMENT</literal> is to ensure that addresses of <emphasis>int</emphasis> values are aligned on 4-byte boundaries, <emphasis>float</emphasis> values are aligned on 4-byte boundaries, <emphasis>double</emphasis>s on 8-bit boundaries etc. and whatever may be implied by the definitions of the machines and languages involved.</para>

<para>In the specification the phrase &quot;<emphasis>a</emphasis> will include <emphasis>b</emphasis>&quot; where <emphasis>a</emphasis> and <emphasis>b</emphasis> are <literal>ALIGNMENT</literal>s, means that the set <emphasis>b</emphasis> will be a subset of <emphasis>a</emphasis> (or equal to <emphasis>a</emphasis>).</para>


<sect2>
<title>alignment_apply_token</title>

<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>1</member>
</simplelist>

<programlisting>
<emphasis>token_value</emphasis>: TOKEN
<emphasis>token_args</emphasis>:  BITSTREAM <emphasis>param_sorts(token_value)</emphasis>
-&gt; ALIGNMENT
</programlisting>

<para>The token is applied to the arguments encoded in the <literal>BITSTREAM</literal> <emphasis>token_args</emphasis> to give an <literal>ALIGNMENT</literal>. </para>

<para>If there is a definition for <emphasis>token_value</emphasis> in the <literal>CAPSULE</literal> then <emphasis>token_args</emphasis> is a <literal>BITSTREAM</literal> encoding of the <literal>SORT</literal>s of its parameters, in the order specified.</para>

</sect2>

<sect2>
<title>alignment_cond</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>2</member>
</simplelist>

<programlisting>
<emphasis>control</emphasis>: EXP INTEGER(<emphasis>v</emphasis>)
<emphasis>e1</emphasis>:      BITSTREAM ALIGNMENT
<emphasis>e2</emphasis>:      BITSTREAM ALIGNMENT
-&gt; ALIGNMENT
</programlisting>

<para><emphasis>control</emphasis> is evaluated. It will be a constant at install time under the constant evaluation rules. If it is non-zero, <emphasis>e1</emphasis> is installed at this point and <emphasis>e2</emphasis> is ignored and never processed. If <emphasis>control</emphasis> is zero then <emphasis>e2</emphasis> is installed at this point and <emphasis>e1</emphasis> is ignored and never processed.</para>

</sect2>

<sect2>
<title>alignment</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>3</member>
</simplelist>

<programlisting>
<emphasis>sha</emphasis>:     SHAPE
-&gt; ALIGNMENT
</programlisting>

<para>The <emphasis>alignment</emphasis> construct is defined as follows:</para>

<itemizedlist>
<listitem>
<para>If <emphasis>sha</emphasis> is <literal>PROC</literal> then the resulting <literal>ALIGNMENT</literal> is {<emphasis>proc</emphasis>}.</para>
</listitem>
<listitem>
<para>If <emphasis>sha</emphasis> is <literal>INTEGER</literal>(<emphasis>v</emphasis>) then the resulting <literal>ALIGNMENT</literal> is {<emphasis>v</emphasis>}.</para>
</listitem>
<listitem>
<para>If <emphasis>sha</emphasis> is <literal>FLOATING</literal>(<emphasis>v</emphasis>) then the resulting <literal>ALIGNMENT</literal> is {<emphasis>v</emphasis>}.</para>
</listitem>
<listitem>
<para>If <emphasis>sha</emphasis> is <literal>BITFIELD</literal>(<emphasis>v</emphasis>) then the resulting <literal>ALIGNMENT</literal> is {<emphasis>v</emphasis>}.</para>
</listitem>
<listitem>
<para>If <emphasis>sha</emphasis> is <literal>TOP</literal> the resulting <literal>ALIGNMENT</literal> is {} - the empty set.</para>
</listitem>
<listitem>
<para>If <emphasis>sha</emphasis> is <literal>BOTTOM</literal> the resulting <literal>ALIGNMENT</literal> is undefined.</para>
</listitem>
<listitem>
<para>If <emphasis>sha</emphasis> is <literal>POINTER</literal>(<emphasis>x</emphasis>) the resulting <literal>ALIGNMENT</literal> is {<emphasis>pointer</emphasis>}.</para>
</listitem>
<listitem>
<para>If <emphasis>sha</emphasis> is <literal>OFFSET</literal>(<emphasis>x</emphasis>, <emphasis>y</emphasis>) the resulting <literal>ALIGNMENT</literal> is {<emphasis>offset</emphasis>}.</para>
</listitem>
<listitem>
<para>If <emphasis>sha</emphasis> is <literal>NOF</literal>(<emphasis>n</emphasis>, <emphasis>s</emphasis>) the resulting <literal>ALIGNMENT</literal> is <emphasis>alignment</emphasis>(<emphasis>s</emphasis>).</para>
</listitem>
<listitem>
<para>If <emphasis>sha</emphasis> is <literal>COMPOUND</literal>(<literal>EXP OFFSET</literal>(<emphasis>x</emphasis>, <emphasis>y</emphasis>)) then the resulting <literal>ALIGNMENT</literal> is <emphasis>x</emphasis>.</para>
</listitem>
</itemizedlist>

</sect2>
<sect2>

<title>alloca_alignment</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>4</member>
</simplelist>

<programlisting>
-&gt; ALIGNMENT
</programlisting>

<para>Delivers the <literal>ALIGNMENT</literal> of <literal>POINTER</literal>s produced from <emphasis>local_alloc</emphasis>. </para>

</sect2>

<sect2>
<title>callees_alignment</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>5</member>
</simplelist>

<programlisting>
<emphasis>var</emphasis>:     BOOL
-&gt; ALIGNMENT
</programlisting>

<para>If <emphasis>var</emphasis> is <emphasis>true</emphasis> the <literal>ALIGNMENT</literal> is that of callee parameters qualified by the <literal>PROCPROPS</literal> <emphasis>var_callees</emphasis>. If <emphasis>var</emphasis> is <emphasis>false</emphasis>, the <literal>ALIGNMENT</literal> is that of callee parameters not qualified by <literal>PROCPROPS</literal> <emphasis>var_callees</emphasis>. </para>

<para>Delivers the <literal>base ALIGNMENT</literal> of <literal>OFFSET</literal>s from a frame-pointer to a <literal>CALLEE</literal> parameter. Values of such <literal>OFFSET</literal>s can only be produced by <emphasis>env_offset</emphasis> applied to <literal>CALLEE</literal> parameters, or offset arithmetic operations applied to existing <literal>OFFSET</literal>s.</para>
</sect2>

<sect2>
<title>callers_alignment</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>6</member>
</simplelist>

<programlisting>
<emphasis>var</emphasis>:     BOOL
-&gt; ALIGNMENT
</programlisting>

<para>If <emphasis>var</emphasis> is <emphasis>true</emphasis> the <literal>ALIGNMENT</literal> is that of caller parameters qualified by the <literal>PROCPROPS</literal> <emphasis>var_callers</emphasis>. If <emphasis>var</emphasis> is <emphasis>false</emphasis>, the <literal>ALIGNMENT</literal> is that of caller parameters not qualified by <literal>PROCPROPS</literal> <emphasis>var_callers</emphasis>. </para>

<para>Delivers the <literal>base ALIGNMENT</literal> of <literal>OFFSET</literal>s from a frame-pointer to a <literal>CALLER</literal> parameter. Values of such <literal>OFFSET</literal>s can only be produced by <emphasis>env_offset</emphasis> applied to <literal>CALLER</literal> parameters, or offset arithmetic operations applied to existing <literal>OFFSET</literal>s.</para>
</sect2>

<sect2>
<title>code_alignment</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>7</member>
</simplelist>

<programlisting>
-&gt; ALIGNMENT
</programlisting>

<para>Delivers {<emphasis>code</emphasis>}, the <literal>ALIGNMENT</literal> of the <literal>POINTER</literal> produced by <emphasis>make_local_lv</emphasis>. </para>

</sect2>

<sect2>
<title>locals_alignment</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>8</member>
</simplelist>

<programlisting>
-&gt; ALIGNMENT
</programlisting>

<para>Delivers the <literal>base ALIGNMENT</literal> of <literal>OFFSET</literal>s from a frame-pointer to a value defined by <emphasis>variable</emphasis> or <emphasis>identify</emphasis>. Values of such <literal>OFFSET</literal>s can only be produced by <emphasis>env_offset</emphasis> applied to <literal>TAG</literal>s so defined, or offset arithmetic operations applied to existing <literal>OFFSET</literal>s. </para>
</sect2>

<sect2>
<title>obtain_al_tag</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>9</member>
</simplelist>

<programlisting>
<emphasis>at</emphasis>:      AL_TAG
-&gt; ALIGNMENT
</programlisting>

<para><emphasis>obtain_al_tag</emphasis> produces the <literal>ALIGNMENT</literal> with which the <literal>AL_TAG</literal> <emphasis>at</emphasis> is bound.</para>

</sect2>

<sect2>
<title>parameter_alignment</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>10</member>
</simplelist>

<programlisting>
<emphasis>sha</emphasis>:     SHAPE
-&gt; ALIGNMENT
</programlisting>

<para>Delivers the <literal>ALIGNMENT</literal> of a parameter of a procedure of <literal>SHAPE</literal> <emphasis>sha</emphasis>. </para>

</sect2>
<sect2>

<title>unite_alignments</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>11</member>
</simplelist>

<programlisting>
<emphasis>a1</emphasis>:      ALIGNMENT
<emphasis>a2</emphasis>:      ALIGNMENT
-&gt; ALIGNMENT
</programlisting>

<para><emphasis>unite_alignments</emphasis> produces the alignment at which all the members of the <literal>ALIGNMENT</literal> sets <emphasis>a1</emphasis> and <emphasis>a2</emphasis> can be placed - in other words the <literal>ALIGNMENT</literal> set which is the union of <emphasis>a1</emphasis> and <emphasis>a2</emphasis>.</para>

</sect2>

<sect2>
<title>var_param_alignment</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>12</member>
</simplelist>

<programlisting>
-&gt; ALIGNMENT
</programlisting>

<para>Delivers the <literal>ALIGNMENT</literal> used in the <emphasis>var_param</emphasis> argument of <emphasis>make_proc</emphasis>. </para>

</sect2>
</sect1>


<sect1>
<title>BITFIELD_VARIETY</title>
<simplelist type='horiz' columns='2'>
<member>Number of encoding bits:</member><member>2</member>
<member>Is coding extendable:</member><member>yes</member>
</simplelist>

<para>These describe runtime bitfield values. The intention is that these values are usually kept in memory locations which need not be aligned on addressing boundaries.</para>

<para>There is no limit on the size of bitfield values in TDF, but an installer may specify limits. See -XREF-spec10.html#66Representing bitfields and -XREF-spec10.html#68Permitted limits.</para>

<sect2>
<title>bfvar_apply_token</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>1</member>
</simplelist>

<programlisting>
<emphasis>token_value</emphasis>: TOKEN
<emphasis>token_args</emphasis>:  BITSTREAM <emphasis>param_sorts(token_value)</emphasis>
-&gt; BITFIELD_VARIETY
</programlisting>

<para>The token is applied to the arguments encoded in the <literal>BITSTREAM</literal> <emphasis>token_args</emphasis> to give a <literal>BITFIELD_VARIETY</literal>. </para>

<para>If there is a definition for <emphasis>token_value</emphasis> in the <literal>CAPSULE</literal> then <emphasis>token_args</emphasis> is a <literal>BITSTREAM</literal> encoding of the <literal>SORT</literal>s of its parameters, in the order specified.</para>


</sect2>
<sect2>
<title>bfvar_cond</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>2</member>
</simplelist>

<programlisting>
<emphasis>control</emphasis>: EXP INTEGER(<emphasis>v</emphasis>)
<emphasis>e1</emphasis>:      BITSTREAM BITFIELD_VARIETY
<emphasis>e2</emphasis>:      BITSTREAM BITFIELD_VARIETY
-&gt; BITFIELD_VARIETY
</programlisting>

<para><emphasis>control</emphasis> is evaluated. It will be a constant at install time under the constant evaluation rules. If it is non-zero, <emphasis>e1</emphasis> is installed at this point and <emphasis>e2</emphasis> is ignored and never processed. If <emphasis>control</emphasis> is zero then <emphasis>e2</emphasis> is installed at this point and <emphasis>e1</emphasis> is ignored and never processed.</para>

</sect2>
<sect2>
<title>bfvar_bits</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>3</member>
</simplelist>

<programlisting>
<emphasis>issigned</emphasis>:    BOOL
<emphasis>bits</emphasis>:        NAT
-&gt; BITFIELD_VARIETY
</programlisting>

<para><emphasis>bfvar_bits</emphasis> constructs a <literal>BITFIELD_VARIETY</literal> describing a pattern of <emphasis>bits</emphasis> bits. If <emphasis>issigned</emphasis> is <emphasis>true</emphasis>, the pattern is considered to be a twos-complement signed number: otherwise it is considered to be unsigned.</para>


</sect2>
</sect1>

<sect1>
<title>BITSTREAM</title>

<para>A <literal>BITSTREAM</literal> consists of an encoding of any number of bits. This encoding is such that any program reading TDF can determine how to skip over it. To read it meaningfully extra knowledge of what it represents may be needed. </para>

<para>A <literal>BITSTREAM</literal> is used, for example, to supply parameters in a <literal>TOKEN</literal> application. If there is a definition of this <literal>TOKEN</literal> available, this will provide the information needed to decode the bitstream.</para>

<para>See -XREF-spec11.html#17The TDF encoding.</para>

</sect1>

<sect1>
<title>BOOL</title>
<simplelist type='horiz' columns='2'>
<member>Number of encoding bits:</member><member>3</member>
<member>Is coding extendable:</member><member>yes</member>
</simplelist>

<para>A <literal>BOOL</literal> is a piece of TDF which can take two values, <emphasis>true</emphasis> or <emphasis>false</emphasis>.</para>

<sect2>
<title>bool_apply_token</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>1</member>
</simplelist>

<programlisting>
<emphasis>token_value</emphasis>: TOKEN
<emphasis>token_args</emphasis>:  BITSTREAM <emphasis>param_sorts(token_value)</emphasis>
-&gt; BOOL
</programlisting>

<para>The token is applied to the arguments encoded in the <literal>BITSTREAM</literal> <emphasis>token_args</emphasis> to give a <literal>BOOL</literal>. </para>

<para>If there is a definition for <emphasis>token_value</emphasis> in the <literal>CAPSULE</literal> then <emphasis>token_args</emphasis> is a <literal>BITSTREAM</literal> encoding of the <literal>SORT</literal>s of its parameters, in the order specified.</para>


</sect2>
<sect2>
<title>bool_cond</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>2</member>
</simplelist>

<programlisting>
<emphasis>control</emphasis>: EXP INTEGER(<emphasis>v</emphasis>)
<emphasis>e1</emphasis>:      BITSTREAM BOOL
<emphasis>e2</emphasis>:      BITSTREAM BOOL
-&gt; BOOL
</programlisting>

<para><emphasis>control</emphasis> is evaluated. It will be a constant at install time under the constant evaluation rules. If it is non-zero, <emphasis>e1</emphasis> is installed at this point and <emphasis>e2</emphasis> is ignored and never processed. If <emphasis>control</emphasis> is zero then <emphasis>e2</emphasis> is installed at this point and <emphasis>e1</emphasis> is ignored and never processed.</para>


</sect2>
<sect2>
<title>false</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>3</member>
</simplelist>

<programlisting>
-&gt; BOOL
</programlisting>

<para><emphasis>false</emphasis> produces a false <literal>BOOL</literal>.</para>

</sect2>

<sect2>
<title>true</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>4</member>
</simplelist>

<programlisting>
-&gt; BOOL
</programlisting>

<para><emphasis>true</emphasis> produces a true <literal>BOOL</literal>.</para>


</sect2>
</sect1>

<sect1>
<title>BYTESTREAM</title>

<para>A <literal>BYTESTREAM</literal> is analogous to a <literal>BITSTREAM</literal>, but is encoded to permit fast copying. </para>

<para>See -XREF-spec11.html#17The TDF encoding.</para>

</sect1>

<sect1>
<title>CALLEES</title>
<simplelist type='horiz' columns='2'>

<member>Number of encoding bits:</member><member>2</member>
<member>Is coding extendable:</member><member>yes</member>
</simplelist>

<para>This is an auxilliary <literal>SORT</literal> used in calling procedures by <emphasis>apply_general_proc</emphasis> and <emphasis>tail_call</emphasis> to provide their actual callee parameters.</para>


<sect2>
<title>make_callee_list</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>1</member>
</simplelist>

<programlisting>
<emphasis>args</emphasis>:        LIST(EXP)
-&gt; CALLEES
</programlisting>

<para>The list of <literal>EXP</literal>s <emphasis>args</emphasis> are evaluated in any interleaved order and the resulting list of values form the actual callee parameters of the call. </para>

</sect2>

<sect2>
<title>make_dynamic_callees</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>2</member>
</simplelist>

<programlisting>
<emphasis>ptr</emphasis>:     EXP POINTER(<emphasis>x</emphasis>)
<emphasis>sze</emphasis>:     EXP OFFSET(<emphasis>x</emphasis>, <emphasis>y</emphasis>)
-&gt; CALLEES
</programlisting>

<para>The value of size <emphasis>sze</emphasis> pointed at by <emphasis>ptr</emphasis> forms the actual callee parameters of the call. </para>

<para>The <literal>CALLEES</literal> value is intended to refer to a sequence of zero or more callee parameters. <emphasis>x</emphasis> will include <emphasis>parameter_alignment</emphasis>(<emphasis>s</emphasis>) for each <emphasis>s</emphasis> that is the <literal>SHAPE</literal> of an intended callee parameter. The value addressed by <emphasis>ptr</emphasis> may be produced in one of two ways. It may be produced as a <literal>COMPOUND SHAPE</literal> value in the normal sense of a structure, whose successive elements will be used to generate the sequence of callee parameters. In this case, each element in the sequence of <literal>SHAPE</literal> <emphasis>s</emphasis> must additionally be padded to <emphasis>parameter_alignment</emphasis>(<emphasis>s</emphasis>). Alternatively, <emphasis>ptr</emphasis> may address the callee parameters of an already activated procedure, by referring to the first of the sequence. <emphasis>sze</emphasis> will be equivalent to <emphasis>shape_offset</emphasis>(<emphasis>c</emphasis>) where <emphasis>c</emphasis> is the <literal>COMPOUND SHAPE</literal> just described.</para>

<para>The call involved (i.e. <emphasis>apply_general_proc</emphasis> or <emphasis>tail_call</emphasis>) must have a <emphasis>var_callees</emphasis> <literal>PROCPROPS</literal>.</para>

</sect2>
<sect2>
<title>same_callees</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>3</member>
</simplelist>

<programlisting>
-&gt; CALLEES
</programlisting>

<para>The callee parameters of the call are the same as those of the current procedure. </para>


</sect2>
</sect1>

<sect1>
<title>CAPSULE</title>
<simplelist type='horiz' columns='2'>
<member>Number of encoding bits:</member><member>0</member>
<member>Is coding extendable:</member><member>no</member>
</simplelist>

<para>A <literal>CAPSULE</literal> is an independent piece of TDF. There is only one construction, <emphasis>make_capsule</emphasis>.</para>


<sect2>
<title>make_capsule</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>0</member>
</simplelist>

<programlisting>
<emphasis>prop_names</emphasis>:  SLIST(TDFIDENT)
<emphasis>cap_linking</emphasis>: SLIST(CAPSULE_LINK)
<emphasis>ext_linkage</emphasis>: SLIST(EXTERN_LINK)
<emphasis>groups</emphasis>:      SLIST(GROUP)
-&gt; CAPSULE
</programlisting>

<para><emphasis>make_capsule</emphasis> brings together <literal>UNIT</literal>s and linking and naming information. See -XREF-spec5.html#2The Overall Structure.</para>

<para>The elements of the list, <emphasis>prop_names</emphasis>, correspond one-to-one with the elements of the list, <emphasis>groups</emphasis>. The element of <emphasis>prop_names</emphasis> is the unit identification of all the <literal>UNIT</literal>s in the corresponding <literal>GROUP</literal>. See -XREF-#M266<literal>PROPS</literal>. A <literal>CAPSULE</literal> need not contain all the kinds of <literal>UNIT</literal>.</para>

<para>It is intended that new kinds of <literal>PROPS</literal> with new unit identifications can be added to the standard in a purely additive fashion, either to form a new standard or for private purposes.</para>

<para>The elements of the list, <emphasis>cap_linking</emphasis>, correspond one-to-one with the elements of the list, <emphasis>ext_linkage</emphasis>. The element of <emphasis>cap_linking</emphasis> gives the linkable entity identification for all the <literal>LINKEXTERN</literal>s in the element of <emphasis>ext_linkage</emphasis>. It also gives the number of <literal>CAPSULE</literal> level linkable entities having that identification.</para>

<para>The elements of the list, <emphasis>cap_linking</emphasis>, also correspond one-to-one with the elements of the lists called <emphasis>local_vars</emphasis> in each of the <emphasis>make_unit</emphasis> constructions for the <literal>UNIT</literal>s in <emphasis>groups</emphasis>. The element of <emphasis>local_vars</emphasis> gives the number of <literal>UNIT</literal> level linkable entities having the identification in the corresponding member of <emphasis>cap_linking</emphasis>.</para>

<para>It is intended that new kinds of linkable entity can be added to the standard in a purely additive fashion, either to form a new standard or for private purposes.</para>

<para><emphasis>ext_linkage</emphasis> provides a list of lists of <literal>LINKEXTERN</literal>s. These <literal>LINKEXTERN</literal>s specify the associations between the names to be used outside the <literal>CAPSULE</literal> and the linkable entities by which the <literal>UNIT</literal>s make objects available within the <literal>CAPSULE</literal>.</para>

<para>The list, <emphasis>groups</emphasis>, provides the non-linkage information of the <literal>CAPSULE</literal>.</para>

</sect2>
</sect1>

<sect1>
<title>CAPSULE_LINK</title>
<simplelist type='horiz' columns='2'>
<member>Number of encoding bits:</member><member>0</member>
<member>Is coding extendable:</member><member>no</member>
</simplelist>

<para>An auxiliary <literal>SORT</literal> which gives the number of linkable entities of a given kind at <literal>CAPSULE</literal> level. It is used only in <emphasis>make_capsule</emphasis>.</para>

<sect2>
<title>make_capsule_link</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>0</member>
</simplelist>

<programlisting>
<emphasis>sn</emphasis>:      TDFIDENT
<emphasis>n</emphasis>:       TDFINT
-&gt; CAPSULE_LINK
</programlisting>

<para><emphasis>n</emphasis> is the number of <literal>CAPSULE</literal> level linkable entities (numbered from 0 to <emphasis>n</emphasis>-1) of the kind given by <emphasis>sn</emphasis>. <emphasis>sn</emphasis> corresponds to the linkable entity identification.</para>

</sect2>
</sect1>


<sect1>
<title>CASELIM</title>
<simplelist type='horiz' columns='2'>
<member>Number of encoding bits:</member><member>0</member>
<member>Is coding extendable:</member><member>no</member>
</simplelist>

<para>An auxiliary <literal>SORT</literal> which provides lower and upper bounds and the <literal>LABEL</literal> destination for the <emphasis>case</emphasis> construction.</para>

<sect2>
<title>make_caselim</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>0</member>
</simplelist>

<programlisting>
<emphasis>branch</emphasis>:      LABEL
<emphasis>lower</emphasis>:       SIGNED_NAT
<emphasis>upper</emphasis>:       SIGNED_NAT
-&gt; CASELIM
</programlisting>

<para>Makes a triple of destination and limits. The <emphasis>case</emphasis> construction uses a list of <literal>CASELIM</literal>s. If the control variable of the <emphasis>case</emphasis> lies between <emphasis>lower</emphasis> and <emphasis>upper</emphasis>, control passes to <emphasis>branch</emphasis>. </para>


</sect2>
</sect1>


<sect1>
<title>ERROR_CODE</title>
<simplelist type='horiz' columns='2'>
<member>Number of encoding bits:</member><member>2</member>
<member>Is coding extendable:</member><member>yes</member>
</simplelist>


<sect2>
<title>nil_access</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>1</member>
</simplelist>

<programlisting>
-&gt; ERROR_CODE
</programlisting>

<para>Delivers the <literal>ERROR_CODE</literal> arising from an attempt to access a nil pointer in an operation with <literal>TRANSFER_MODE</literal> <emphasis>trap_on_nil</emphasis>. </para>

</sect2>

<sect2>
<title>overflow</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>2</member>
</simplelist>

<programlisting>
-&gt; ERROR_CODE
</programlisting>

<para>Delivers the <literal>ERROR_CODE</literal> arising from a numerical exceptional result in an operation with <literal>ERROR_TREATMENT</literal> <emphasis>trap</emphasis>(<emphasis>overflow</emphasis>). </para>

</sect2>

<sect2>
<title>stack_overflow</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>3</member>
</simplelist>

<programlisting>
-&gt; ERROR_CODE
</programlisting>

<para>Delivers the <literal>ERROR_CODE</literal> arising from a stack overflow in the call of a procedure defined with <literal>PROCPROPS</literal> <emphasis>check_stack.</emphasis></para>

</sect2>
</sect1>

<sect1>
<title>ERROR_TREATMENT</title>
<simplelist type='horiz' columns='2'>
<member>Number of encoding bits:</member><member>3</member>
<member>Is coding extendable:</member><member>yes</member>
</simplelist>

<para>These values describe the way to handle various forms of error which can occur during the evaluation of operations.</para>

<para>It is expected that additional <literal>ERROR_TREATMENT</literal>s will be needed.</para>


<sect2>
<title>errt_apply_token</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>1</member>
</simplelist>

<programlisting>
<emphasis>token_value</emphasis>: TOKEN
<emphasis>token_args</emphasis>:  BITSTREAM <emphasis>param_sorts(token_value)</emphasis>
-&gt; ERROR_TREATMENT
</programlisting>

<para>The token is applied to the arguments encoded in the <literal>BITSTREAM</literal> <emphasis>token_args</emphasis> to give an <literal>ERROR_TREATMENT</literal>. </para>

<para>If there is a definition for <emphasis>token_value</emphasis> in the <literal>CAPSULE</literal> then <emphasis>token_args</emphasis> is a <literal>BITSTREAM</literal> encoding of the <literal>SORT</literal>s of its parameters, in the order specified.</para>

</sect2>
<sect2>
<title>errt_cond</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>2</member>
</simplelist>

<programlisting>
<emphasis>control</emphasis>: EXP INTEGER(<emphasis>v</emphasis>)
<emphasis>e1</emphasis>:      BITSTREAM ERROR_TREATMENT
<emphasis>e2</emphasis>:      BITSTREAM ERROR_TREATMENT
-&gt; ERROR_TREATMENT
</programlisting>

<para><emphasis>control</emphasis> is evaluated. It will be a constant at install time under the constant evaluation rules. If it is non-zero, <emphasis>e1</emphasis> is installed at this point and <emphasis>e2</emphasis> is ignored and never processed. If <emphasis>control</emphasis> is zero then <emphasis>e2</emphasis> is installed at this point and <emphasis>e1</emphasis> is ignored and never processed.</para>


</sect2>
<sect2>
<title>continue</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>3</member>
</simplelist>

<programlisting>
-&gt; ERROR_TREATMENT
</programlisting>

<para>If an operation with a <emphasis>continue</emphasis> <literal>ERROR_TREATMENT</literal> causes an error, some value of the correct <literal>SHAPE</literal> shall be delivered. This value shall have the same properties as is specified in <emphasis>make_value</emphasis>. </para>

</sect2>
<sect2>
<title>error_jump</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>4</member>
</simplelist>

<programlisting>
<emphasis>lab</emphasis>:     LABEL
-&gt; ERROR_TREATMENT
</programlisting>

<para><emphasis>error_jump</emphasis> produces an <literal>ERROR_TREATMENT</literal> which requires that control be passed to <emphasis>lab</emphasis> if it is invoked. <emphasis>lab</emphasis> will be in scope.</para>

<para>If a construction has an <emphasis>error_jump</emphasis> <literal>ERROR_TREATMENT</literal> and the jump is taken, the canonical order specifies only that the jump occurs after evaluating the construction. It is not specified how many further constructions are evaluated.</para>

<para>This rule implies that a further construction is needed to guarantee that errors have been processed. This is not yet included. The effect of nearby procedure calls or exits also needs definition.</para>


</sect2>
<sect2>
<title>trap</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>5</member>
</simplelist>

<programlisting>
<emphasis>trap_list</emphasis>:   LIST(ERROR_CODE)
-&gt; ERROR_TREATMENT
</programlisting>

<para>The list of <literal>ERROR_CODES</literal> in <emphasis>trap_list</emphasis> specifies a set of possible exceptional behaviours. If any of these occur in an construction with <literal>ERROR_TREATMENT</literal> <emphasis>trap</emphasis>, the TDF exception handling is invoked (see -XREF-spec10.html#17section 7.8). </para>

<para>The observations on canonical ordering in <emphasis>error_jump</emphasis> apply equally here.</para>

</sect2>
<sect2>
<title>wrap</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>6</member>
</simplelist>

<programlisting>
-&gt; ERROR_TREATMENT
</programlisting>

<para><emphasis>wrap</emphasis> is an <literal>ERROR_TREATMENT</literal> which will only be used in constructions with integer operands and delivering <literal>EXP</literal> <literal>INTEGER</literal>(<emphasis>v</emphasis>) where either the lower bound of <emphasis>v</emphasis> is zero or the construction is not one of <emphasis>mult, power, div0, div1, div2, rem0, rem1, rem2</emphasis>. The result will be evaluated and any bits in the result lying outside the representing <literal>VARIETY</literal> will be discarded (see -XREF-spec10.html#51Representing integers).</para>

</sect2>
<sect2>
<title>impossible</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>7</member>
</simplelist>

<programlisting>
-&gt; ERROR_TREATMENT
</programlisting>

<para><emphasis>impossible</emphasis> is an <literal>ERROR_TREATMENT</literal> which means that this error will not occur in the construct concerned.</para>

<para>impossible is possibly a misnomer. If an error occurs the result is undefined.</para>

</sect2>
</sect1>

<sect1>
<title>EXP</title>
<simplelist type='horiz' columns='2'>
<member>Number of encoding bits:</member><member>7</member>
<member>Is coding extendable:</member><member>yes</member>
</simplelist>

<para><literal>EXP</literal>s are pieces of TDF which are translated into program. <literal>EXP</literal> is by far the richest <literal>SORT</literal>. There are few primitive <literal>EXP</literal>s: most of the constructions take arguments which are a mixture of <literal>EXP</literal>s and other <literal>SORT</literal>s. There are constructs delivering <literal>EXP</literal>s that correspond to the declarations, program structure, procedure calls, assignments, pointer manipulation, arithmetic operations, tests etc. of programming languages.</para>

<sect2>
<title>exp_apply_token</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>1</member>
</simplelist>

<programlisting>
<emphasis>token_value</emphasis>: TOKEN
<emphasis>token_args</emphasis>:  BITSTREAM <emphasis>param_sorts(token_value)</emphasis>
-&gt; EXP <emphasis>x</emphasis>
</programlisting>

<para>The token is applied to the arguments encoded in the <literal>BITSTREAM</literal> <emphasis>token_args</emphasis> to give an <literal>EXP</literal>. </para>

<para>If there is a definition for <emphasis>token_value</emphasis> in the <literal>CAPSULE</literal> then <emphasis>token_args</emphasis> is a <literal>BITSTREAM</literal> encoding of the <literal>SORT</literal>s of its parameters, in the order specified.</para>



</sect2>
<sect2>
<title>exp_cond</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>2</member>
</simplelist>

<programlisting>
<emphasis>control</emphasis>: EXP INTEGER(<emphasis>v</emphasis>)
<emphasis>e1</emphasis>:      BITSTREAM EXP <emphasis>x</emphasis>
<emphasis>e2</emphasis>:      BITSTREAM EXP <emphasis>y</emphasis>
-&gt; EXP (<emphasis>control</emphasis> ? <emphasis>x</emphasis> : <emphasis>y</emphasis>)
</programlisting>

<para><emphasis>control</emphasis> is evaluated. It will be a constant at install time under the constant evaluation rules. If it is non-zero, <emphasis>e1</emphasis> is installed at this point and <emphasis>e2</emphasis> is ignored and never processed. If <emphasis>control</emphasis> is zero then <emphasis>e2</emphasis> is installed at this point and <emphasis>e1</emphasis> is ignored and never processed.</parA>



</sect2>
<sect2>
<title>abs</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>3</member>
</simplelist>

<programlisting>
<emphasis>ov_err</emphasis>:      ERROR_TREATMENT
<emphasis>arg1</emphasis>:        EXP INTEGER(<emphasis>v</emphasis>)
-&gt; EXP INTEGER(<emphasis>v</emphasis>)
</programlisting>

<para>The absolute value of the result produced by <emphasis>arg1</emphasis> is delivered. </para>

<para>If the result cannot be expressed in the <literal>VARIETY</literal> being used to represent <emphasis>v</emphasis>, an overflow error is caused and is handled in the way specified by <emphasis>ov_err</emphasis>.</para>



</sect2>
<sect2>
<title>add_to_ptr</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>4</member>
</simplelist>

<programlisting>
<emphasis>arg1</emphasis>:        EXP POINTER(<emphasis>x</emphasis>)
<emphasis>arg2</emphasis>:        EXP OFFSET(<emphasis>y</emphasis>, <emphasis>z</emphasis>)
-&gt; EXP POINTER(<emphasis>z</emphasis>)
</programlisting>

<para><emphasis>arg1</emphasis> is evaluated, giving <emphasis>p</emphasis>, and <emphasis>arg2</emphasis> is evaluated and the results are added to produce the answer. The result is derived from the pointer delivered by <emphasis>arg1</emphasis>. The intention is to produce a <literal>POINTER</literal> displaced from the argument <literal>POINTER</literal> by the given amount.</para>

<para><emphasis>x</emphasis> will include <emphasis>y</emphasis>.</para>

<para><emphasis>arg1</emphasis> may deliver a null <literal>POINTER</literal>. In this case the result is derived from a null <literal>POINTER</literal> which counts as an original <literal>POINTER</literal>. Further <literal>OFFSET</literal>s may be added to the result, but the only other useful operation on the result of adding a number of <literal>OFFSET</literal>s to a null <literal>POINTER</literal> is to <emphasis>subtract_ptrs</emphasis> a null <literal>POINTER</literal> from it.</para>

<para>The result will be less than or equal (in the sense of <emphasis>pointer_test</emphasis>) to the result of applying <emphasis>add_to_ptr</emphasis> to the original pointer from which <emphasis>p</emphasis> is derived and the size of the space allocated for the original pointer.</para>

<para>In the simple representation of <literal>POINTER</literal> arithmetic (see -XREF-spec10.html#26Memory Model) add_to_ptr is represented by addition. The constraint &quot;x includes y&quot; ensures that no padding has to be inserted in this case.</para>



</sect2>
<sect2>
<title>and</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>5</member>
</simplelist>

<programlisting>
<emphasis>arg1</emphasis>:        EXP INTEGER(<emphasis>v</emphasis>)
<emphasis>arg2</emphasis>:        EXP INTEGER(<emphasis>v</emphasis>)
-&gt; EXP INTEGER(<emphasis>v</emphasis>)
</programlisting>

<para>The arguments are evaluated producing integer values of the same <literal>VARIETY</literal>, <emphasis>v</emphasis>. The result is the bitwise <emphasis>and</emphasis> of the two values in the representing <literal>VARIETY</literal>. The result is delivered with the same <literal>SHAPE</literal> as the arguments. </para>

<para>See -XREF-spec10.html#51Representing integers.</para>



</sect2>
<sect2>
<title>apply_proc</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>6</member>
</simplelist>

<programlisting>
<emphasis>result_shape</emphasis>:    SHAPE
<emphasis>p</emphasis>:       EXP PROC
<emphasis>params</emphasis>:      LIST(EXP)
<emphasis>var_param</emphasis>:   OPTION(EXP)
-&gt; EXP <emphasis>result_shape</emphasis>
</programlisting>

<para><emphasis>p, params</emphasis> and <emphasis>var_param</emphasis> (if present) are evaluated in any interleaved order. The procedure, <emphasis>p</emphasis>, is applied to the parameters. The result of the procedure call, which will have <emphasis>result_shape</emphasis>, is delivered as the result of the construction.</para>

<para>The canonical order of evaluation is as if the definition were in-lined. That is, the actual parameters are evaluated interleaved in any order and used to initialise variables which are identified by the formal parameters during the evaluation of the procedure body. When this is complete the body is evaluated. So <emphasis>apply_proc</emphasis> is evaluated like a <emphasis>variable</emphasis> construction, and obeys similar rules for order of evaluation.</para>

<para>If <emphasis>p</emphasis> delivers a null procedure the effect is undefined.</para>

<para><emphasis>var_param</emphasis> is intended to communicate parameters which vary in <literal>SHAPE</literal> from call to call. Access to these parameters during the procedure is performed by using <literal>OFFSET</literal> arithmetic. Note that it is necessary to place these values on <emphasis>var_param_alignment</emphasis> because of the definition of <emphasis>make_proc</emphasis>.</para>

<para>The optional <emphasis>var_param</emphasis> should not be confused with variable argument lists in the C (<emphasis>&lt;stdarg.h&gt;</emphasis> or <emphasis>&lt;varargs.h&gt;</emphasis>) sense, which are communicated by extending the <emphasis>params</emphasis> list. This is discussed further in -XREF-spec10.html#18section 7.9. If the number of arguments in the <emphasis>params</emphasis> list differs from the number of elements in the <emphasis>params_intro</emphasis> of the corresponding <emphasis>make_proc</emphasis>, then <emphasis>var_param</emphasis> must not be present.</para>

<para>All calls to the same procedure will yield results of the same <literal>SHAPE</literal>.</para>

<para>For notes on the intended implementation of procedures see -XREF-spec10.html#18section 7.9.</para>



</sect2>
<sect2>
<title>apply_general_proc</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>7</member>
</simplelist>

<programlisting>
<emphasis>result_shape</emphasis>:    SHAPE
<emphasis>prcprops</emphasis>:    OPTION(PROCPROPS)
<emphasis>p</emphasis>:       EXP PROC
<emphasis>callers_intro</emphasis>:   LIST(OTAGEXP)
<emphasis>callee_pars</emphasis>: CALLEES
<emphasis>postlude</emphasis>:    EXP TOP
-&gt; EXP <emphasis>result_shape</emphasis>
</programlisting>

<para><emphasis>p</emphasis>, <emphasis>callers_intro</emphasis> and <emphasis>callee_pars</emphasis> are evaluated in any order. The procedure, <emphasis>p</emphasis>, is applied to the parameters. The result of the procedure call, which will have <emphasis>result_shape</emphasis>, is delivered as the result of the construction.</para>

<para>If <emphasis>p</emphasis> delivers a null procedure the effect is undefined.</para>

<para>Any <literal>TAG</literal> introduced by an <literal>OTAGEXP</literal> in <emphasis>callers_intro</emphasis> is available in <emphasis>postlude</emphasis> which will be evaluated after the application.</para>

<para><emphasis>postlude</emphasis> will not contain any <emphasis>local_allocs</emphasis> or calls of procedures with untidy returns. If <emphasis>prcprops</emphasis> include <emphasis>untidy</emphasis>, <emphasis>postlude</emphasis> will be <emphasis>make_top</emphasis>.</para>

<para>The canonical order of evaluation is as if the definition of <emphasis>p</emphasis> were inlined in a manner dependent on <emphasis>prcprops</emphasis>.</para>

<para>If none of the <literal>PROCPROPS</literal> <emphasis>var_callers</emphasis>, <emphasis>var_callees</emphasis> and <emphasis>check_stack</emphasis> are present the inlining is as follows, supposing that P is the body of the definition of <emphasis>p</emphasis>:</para>

<para>Let R<emphasis>i</emphasis> be the value of the <literal>EXP</literal> of the i<emphasis>th</emphasis> <literal>OTAGEXP</literal> in <emphasis>callers_intro</emphasis> and T<emphasis>i</emphasis> be its <literal>TAG</literal> (if it is present). Let E<emphasis>i</emphasis> be the i<emphasis>th</emphasis> value in <emphasis>callee_pars</emphasis>.

<para>Let r<emphasis>i</emphasis> be the i<emphasis>th</emphasis> formal caller parameter <literal>TAG</literal> of <emphasis>p</emphasis>.</para>

<para>Let e<emphasis>i</emphasis> be the i<emphasis>th</emphasis> formal callee parameter <literal>TAG</literal> of <emphasis>p</emphasis>.</para>

<para>Each R<emphasis>i</emphasis> is used to initialise a variable which is identified by r<emphasis>i</emphasis>; there will be exactly as many R<emphasis>i</emphasis> as r<emphasis>i</emphasis>.The scope of these variable definitions is a sequence consisting of three components - the identification of a <literal>TAG</literal> <emphasis>res</emphasis> with the result of a binding of P, followed by a binding of <emphasis>postlude</emphasis>, followed by an <emphasis>obtain_tag</emphasis> of <emphasis>res</emphasis> giving the result of the inlined procedure call.</para>

<para>The binding of P consists of using each E<emphasis>i</emphasis> to initialise a variable identified with e<emphasis>i</emphasis>; there will be exactly as many E<emphasis>i</emphasis> as e<emphasis>i</emphasis>. The scope of these variable definitions is P modified so that the first <emphasis>return</emphasis> or <emphasis>untidy_return</emphasis> encountered in P gives the result of the binding. If it ends with a <emphasis>return</emphasis>, any space generated by <emphasis>local_allocs</emphasis> within the binding is freed (in the sense of <emphasis>local_free</emphasis>) at this point. If it ends with <emphasis>untidy_return</emphasis>, no freeing will take place.</para>

<para>The binding of <emphasis>postlude</emphasis> consists of identifying each T<emphasis>i</emphasis> (if present) with the contents of the variable identified by r<emphasis>i</emphasis>. The scope of these identifications is <emphasis>postlude</emphasis>.</para>

<para>If the <literal>PROCPROPS</literal> <emphasis>var_callers</emphasis> is present, the inlining process is modified by:</para>
<para>A compound variable is constructed initialised to R<emphasis>i</emphasis> in order; the alignment and padding of each individual R<emphasis>i</emphasis> will be given by an exact application of <emphasis>parameter_alignment</emphasis> on the <literal>SHAPE</literal> of R<emphasis>i</emphasis>. Each r<emphasis>i</emphasis> is then identified with a pointer to the copy of R<emphasis>i</emphasis> within the compound variable; there will be at least as many R<emphasis>i</emphasis> as r<emphasis>i</emphasis>. The evaluation then continues as above with the scope of these identifications being the sequence.</para>

<para>If the <literal>PROCPROPS</literal> <emphasis>var_callees</emphasis> is present, the inlining process is modified by:</para>
<para>The binding of P is done by generating (as if by <emphasis>local_alloc</emphasis>) a pointer to space for a compound value constructed from each E<emphasis>i</emphasis> in order (just as for <emphasis>var_callers</emphasis>). Each e<emphasis>i</emphasis> is identified with a pointer to the copy of E<emphasis>i</emphasis> within the generated space; there will be at least as many e<emphasis>i</emphasis> as E<emphasis>i</emphasis>. P is evaluated within the scope of these identifications as before. Note that the generation of space for these callee parameters is a <emphasis>local_alloc</emphasis> with the binding of P, and hence will not be freed if P ends with an <emphasis>untidy_return</emphasis>.</para>



</sect2>
<sect2>
<title>assign</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>8</member>
</simplelist>

<programlisting>
<emphasis>arg1</emphasis>:        EXP POINTER(<emphasis>x</emphasis>)
<emphasis>arg2</emphasis>:        EXP <emphasis>y</emphasis>
-&gt; EXP TOP
</programlisting>

<para>The value produced by <emphasis>arg2</emphasis> will be put in the space indicated by <emphasis>arg1</emphasis>. </para>

<para><emphasis>x</emphasis> will include <emphasis>alignment</emphasis>(<emphasis>y</emphasis>).</para>

<para><emphasis>y</emphasis> will not be a <literal>BITFIELD</literal>.</para>

<para>If the space which the pointer indicates does not lie wholly within the space indicated by the original pointer from which it is derived, the effect is undefined.</para>

<para>If the value delivered by <emphasis>arg1</emphasis> is a null pointer the effect is undefined.</para>

<para>See -XREF-spec10.html#48Overlapping and -XREF-spec10.html#50Incomplete assignment.</para>

<para>The constraint &quot;x will include alignment(y)&quot; ensures in the simple memory model that no change is needed to the <literal>POINTER</literal>.</para>



</sect2>
<sect2>
<title>assign_with_mode</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>9</member>
</simplelist>

<programlisting>
<emphasis>md</emphasis>:      TRANSFER_MODE
<emphasis>arg1</emphasis>:        EXP POINTER(<emphasis>x</emphasis>)
<emphasis>arg2</emphasis>:        EXP <emphasis>y</emphasis>
-&gt; EXP TOP
</programlisting>

<para>The value produced by <emphasis>arg2</emphasis> will be put in the space indicated by <emphasis>arg1</emphasis>.  The assignment will be carried out as specified by the <literal>TRANSFER_MODE</literal> (q.v.).</para>

<para>If <emphasis>md</emphasis> consists of <emphasis>standard_transfer_mode</emphasis> only, then <emphasis>assign_with_mode</emphasis> is the same as <emphasis>assign</emphasis>.</para>

<para><emphasis>x</emphasis> will include <emphasis>alignment</emphasis>(<emphasis>y</emphasis>).</para>

<para><emphasis>y</emphasis> will not be a <literal>BITFIELD</literal>.</para>

<para>If the space which the pointer indicates does not lie wholly within the space indicated by the original pointer from which it is derived, the effect is undefined.</para>

<para>If the value delivered by <emphasis>arg1</emphasis> is a null pointer the effect is undefined.</para>

<para>See -XREF-spec10.html#48Overlapping and -XREF-spec10.html#50Incomplete assignment.</para>



</sect2>
<sect2>
<title>bitfield_assign</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>10</member>
</simplelist>

<programlisting>
<emphasis>arg1</emphasis>:        EXP POINTER(<emphasis>x</emphasis>)
<emphasis>arg2</emphasis>:        EXP OFFSET(<emphasis>y</emphasis>, <emphasis>z</emphasis>)
<emphasis>arg3</emphasis>:        EXP BITFIELD(<emphasis>v</emphasis>)
-&gt; EXP TOP
</programlisting>

<para>The value delivered by <emphasis>arg3</emphasis> is assigned at a displacement given by <emphasis>arg2</emphasis> from the pointer delivered by <emphasis>arg1</emphasis>. </para>

<para><emphasis>x</emphasis> will include <emphasis>y</emphasis> and <emphasis>z</emphasis> will include <emphasis>v</emphasis>.</para>

<para><emphasis>arg2</emphasis>, <literal>BITFIELD</literal>(<emphasis>v</emphasis>) will be <emphasis>variety-enclosed</emphasis> (see -XREF-spec10.html#66section 7.24).</para>



</sect2>
<sect2>
<title>bitfield_assign_with_mode</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>11</member>
</simplelist>

<programlisting>
<emphasis>md</emphasis>:      TRANSFER_MODE
<emphasis>arg1</emphasis>:        EXP POINTER(<emphasis>x</emphasis>)
<emphasis>arg2</emphasis>:        EXP OFFSET(<emphasis>y</emphasis>, <emphasis>z</emphasis>)
<emphasis>arg3</emphasis>:        EXP BITFIELD(<emphasis>v</emphasis>)
-&gt; EXP TOP
</programlisting>

<para>The value delivered by <emphasis>arg3</emphasis> is assigned at a displacement given by <emphasis>arg2</emphasis> from the pointer delivered by <emphasis>arg1</emphasis>.The assignment will be carried out as specified by the <literal>TRANSFER_MODE</literal> (q.v.). </para>

<para>If <emphasis>md</emphasis> consists of <emphasis>standard_transfer_mode</emphasis> only, then <emphasis>bitfield_assign_with_mode</emphasis> is the same as <emphasis>bitfield_assign</emphasis>.</para>

<para><emphasis>x</emphasis> will include <emphasis>y</emphasis> and <emphasis>z</emphasis> will include <emphasis>v</emphasis>.</para>

<para><emphasis>arg2</emphasis>, <literal>BITFIELD</literal>(<emphasis>v</emphasis>) will be <emphasis>variety-enclosed</emphasis>.(see -XREF-spec10.html#66section 7.24).</para>



</sect2>
<sect2>
<title>bitfield_contents</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>12</member>
</simplelist>

<programlisting>
<emphasis>v</emphasis>:       BITFIELD_VARIETY
<emphasis>arg1</emphasis>:        EXP POINTER(<emphasis>x</emphasis>)
<emphasis>arg2</emphasis>:        EXP OFFSET(<emphasis>y</emphasis>, <emphasis>z</emphasis>)
-&gt; EXP BITFIELD(<emphasis>v</emphasis>)
</programlisting>

<para>The bitfield of <literal>BITFIELD_VARIETY</literal> <emphasis>v</emphasis>, located at the displacement delivered by <emphasis>arg2</emphasis> from the pointer delivered by <emphasis>arg1</emphasis> is extracted and delivered. </para>

<para><emphasis>x</emphasis> will include <emphasis>y</emphasis> and <emphasis>z</emphasis> will include <emphasis>v</emphasis>.</para>

<para><emphasis>arg2</emphasis>, <literal>BITFIELD</literal>(<emphasis>v</emphasis>) will be <emphasis>variety_enclosed</emphasis> (see -XREF-spec10.html#66section 7.24).</para>



</sect2>
<sect2>
<title>bitfield_contents_with_mode</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>13</member>
</simplelist>

<programlisting>
<emphasis>md</emphasis>:      TRANSFER_MODE
<emphasis>v</emphasis>:       BITFIELD_VARIETY
<emphasis>arg1</emphasis>:        EXP POINTER(<emphasis>x</emphasis>)
<emphasis>arg2</emphasis>:        EXP OFFSET(<emphasis>y</emphasis>, <emphasis>z</emphasis>)
-&gt; EXP BITFIELD(<emphasis>v</emphasis>)
</programlisting>

<para>The bitfield of <literal>BITFIELD_VARIETY</literal> <emphasis>v</emphasis>, located at the displacement delivered by <emphasis>arg2</emphasis> from the pointer delivered by <emphasis>arg1</emphasis> is extracted and delivered.The operation will be carried out as specified by the <literal>TRANSFER_MODE</literal> (q.v.). </para>

<para>If <emphasis>md</emphasis> consists of <emphasis>standard_transfer_mode</emphasis> only, then <emphasis>bitfield_contents_with_mode</emphasis> is the same as <emphasis>bitfield_contents</emphasis>.</para>

<para><emphasis>x</emphasis> will include <emphasis>y</emphasis> and <emphasis>z</emphasis> will include <emphasis>v</emphasis>.</para>

<para><emphasis>arg2</emphasis>, <literal>BITFIELD</literal>(<emphasis>v</emphasis>) will be <emphasis>variety_enclosed</emphasis> (see -XREF-spec10.html#66section 7.24).</para>



</sect2>
<sect2>
<title>case</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>14</member>
</simplelist>

<programlisting>
<emphasis>exhaustive</emphasis>:  BOOL
<emphasis>control</emphasis>: EXP INTEGER(<emphasis>v</emphasis>)
<emphasis>branches</emphasis>:    LIST(CASELIM)
-&gt; EXP (<emphasis>exhaustive</emphasis> ? BOTTOM : TOP)
</programlisting>

<para><emphasis>control</emphasis> is evaluated to produce an integer value, <emphasis>c</emphasis>. Then <emphasis>c</emphasis> is tested to see if it lies inclusively between <emphasis>lower</emphasis> and <emphasis>upper</emphasis>, for each element of <emphasis>branches</emphasis>. If this tests succeeds, control passes to the label <emphasis>branch</emphasis> belonging to that <literal>CASELIM</literal> (see -XREF-#M56section 5.13). If <emphasis>c</emphasis> lies between no pair, the construct delivers a value of <literal>SHAPE TOP</literal>. The order in which the comparisons are made is undefined.</para>

<para>The sets of <literal>SIGNED_NAT</literal>s in <emphasis>branches</emphasis> will be disjoint.</para>

<para>If <emphasis>exhaustive</emphasis> is true the value delivered by <emphasis>control</emphasis> will lie between one of the <emphasis>lower</emphasis>/<emphasis>upper</emphasis> pairs.</para>



</sect2>
<sect2>
<title>change_bitfield_to_int</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>15</member>
</simplelist>

<programlisting>
<emphasis>v</emphasis>:       VARIETY
<emphasis>arg1</emphasis>:        EXP BITFIELD(<emphasis>bv</emphasis>)
-&gt; EXP INTEGER(<emphasis>v</emphasis>)
</programlisting>

<para><emphasis>arg1</emphasis> is evaluated and converted to a <literal>INTEGER</literal>(<emphasis>v</emphasis>).</para>

<para>If <emphasis>arg1</emphasis> exceed the bounds of <emphasis>v</emphasis>, the effect is undefined.</para>



</sect2>
<sect2>
<title>change_floating_variety</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>16</member>
</simplelist>

<programlisting>
<emphasis>flpt_err</emphasis>:    ERROR_TREATMENT
<emphasis>r</emphasis>:       FLOATING_VARIETY
<emphasis>arg1</emphasis>:        EXP FLOATING(<emphasis>f</emphasis>)
-&gt; EXP FLOATING(<emphasis>r</emphasis>)
</programlisting>

<para><emphasis>arg1</emphasis> is evaluated and will produce floating point value, <emphasis>fp</emphasis>. The value <emphasis>fp</emphasis> is delivered, changed to the representation of the <literal>FLOATING_VARIETY</literal> <emphasis>r</emphasis>.</para>

<para>Either <emphasis>r</emphasis> and <emphasis>f</emphasis> will both real or both complex.</para>

<para>If there is a floating point error it is handled by <emphasis>flpt_err</emphasis>.</para>

<para>See -XREF-spec10.html#60Floating point errors.</para>



</sect2>
<sect2>
<title>change_variety</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>17</member>
</simplelist>

<programlisting>
<emphasis>ov_err</emphasis>:      ERROR_TREATMENT
<emphasis>r</emphasis>:       VARIETY
<emphasis>arg1</emphasis>:        EXP INTEGER(<emphasis>v</emphasis>)
-&gt; EXP INTEGER(<emphasis>r</emphasis>)
</programlisting>

<para><emphasis>arg1</emphasis> is evaluated and will produce an integer value, <emphasis>a</emphasis>. The value <emphasis>a</emphasis> is delivered, changed to the representation of the <literal>VARIETY</literal> <emphasis>r</emphasis>.</para>

<para>If <emphasis>a</emphasis> is not contained in the <literal>VARIETY</literal> being used to represent <emphasis>r</emphasis>, an overflow occurs and is handled according to <emphasis>ov_err</emphasis>.</para>



</sect2>
<sect2>
<title>change_int_to_bitfield</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>18</member>
</simplelist>

<programlisting>
<emphasis>bv</emphasis>:      BITFIELD_VARIETY
<emphasis>arg1</emphasis>:        EXP INTEGER(<emphasis>v</emphasis>)
-&gt; EXP BITFIELD(<emphasis>bv</emphasis>)
</programlisting>

<para><emphasis>arg1</emphasis> is evaluated and converted to a <literal>BITFIELD</literal>(<emphasis>bv</emphasis>).</para>

<para>If <emphasis>arg1</emphasis> exceed the bounds of <emphasis>bv</emphasis>, the effect is undefined.</para>



</sect2>
<sect2>
<title>complex_conjugate</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>19</member>
</simplelist>

<programlisting>
<emphasis>c</emphasis>:       EXP FLOATING(<emphasis>cv</emphasis>)
-&gt; EXP FLOATING(<emphasis>cv</emphasis>)
</programlisting>

<para>Delivers the complex conjugate of <emphasis>c</emphasis>. </para>

<para><emphasis>cv</emphasis> will be a complex floating variety.</para>



</sect2>
<sect2>
<title>component</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>20</member>
</simplelist>

<programlisting>
<emphasis>sha</emphasis>:     SHAPE
<emphasis>arg1</emphasis>:        EXP COMPOUND(EXP OFFSET(<emphasis>x</emphasis>, <emphasis>y</emphasis>))
<emphasis>arg2</emphasis>:        EXP OFFSET(<emphasis>x</emphasis>, <emphasis>alignment</emphasis>(<emphasis>sha</emphasis>))
-&gt; EXP <emphasis>sha</emphasis>
</programlisting>

<para><emphasis>arg1</emphasis> is evaluated to produce a <literal>COMPOUND</literal> value. The component of this value at the <literal>OFFSET</literal> given by <emphasis>arg2</emphasis> is delivered. This will have <literal>SHAPE</literal> <emphasis>sha</emphasis>.</para>

<para><emphasis>arg2</emphasis> will be a constant and non-negative (see -XREF-spec10.html#7Constant evaluation).</para>

<para>If <emphasis>sha</emphasis> is a <literal>BITFIELD</literal> then <emphasis>arg2</emphasis>, <emphasis>sha</emphasis> will be <emphasis>variety_enclosed</emphasis> (see -XREF-spec10.html#66section 7.24).</para>



</sect2>
<sect2>
<title>concat_nof</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>21</member>
</simplelist>

<programlisting>
<emphasis>arg1</emphasis>:        EXP NOF(<emphasis>n</emphasis>, <emphasis>s</emphasis>)
<emphasis>arg2</emphasis>:        EXP NOF(<emphasis>m</emphasis>, <emphasis>s</emphasis>)
-&gt; EXP NOF(<emphasis>n</emphasis>+<emphasis>m</emphasis>, <emphasis>s</emphasis>)
</programlisting>

<para><emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated and their results concatenated. In the result the components derived from <emphasis>arg1</emphasis> will have lower indices than those derived from <emphasis>arg2</emphasis>.</para>



</sect2>
<sect2>
<title>conditional</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>22</member>
</simplelist>

<programlisting>
<emphasis>altlab_intro</emphasis>:    LABEL
<emphasis>first</emphasis>:       EXP <emphasis>x</emphasis>
<emphasis>alt</emphasis>:     EXP <emphasis>z</emphasis>
-&gt; EXP (<emphasis>x</emphasis> LUB <emphasis>z</emphasis>)
</programlisting>

<para><emphasis>first</emphasis> is evaluated. If <emphasis>first</emphasis> produces a result, <emphasis>f</emphasis>, this value is delivered as the result of the whole construct, and <emphasis>alt</emphasis> is not evaluated.</para>

<para>If <emphasis>goto</emphasis>(<emphasis>altlab_intro</emphasis>) or any other jump (including <emphasis>long_jump</emphasis>) to <emphasis>altlab_intro</emphasis> is obeyed during the evaluation of <emphasis>first</emphasis>, then the evaluation of <emphasis>first</emphasis> will stop, <emphasis>alt</emphasis> will be evaluated and its result delivered as the result of the construction.</para>

<para>The lifetime of <emphasis>altlab_intro</emphasis> is the evaluation of <emphasis>first</emphasis>. <emphasis>altlab_intro</emphasis> will not be used within <emphasis>alt</emphasis>.</para>

<para>The actual order of evaluation of the constituents shall be indistinguishable in all observable effects (apart from time) from evaluating all the obeyed parts of <emphasis>first</emphasis> before any obeyed part of <emphasis>alt</emphasis>. Note that this specifically includes any defined error handling.</para>

<para>For LUB see -XREF-spec10.html#70Least Upper Bound.</para>



</sect2>
<sect2>
<title>contents</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>23</member>
</simplelist>

<programlisting>
<emphasis>s</emphasis>:       SHAPE
<emphasis>arg1</emphasis>:        EXP POINTER(<emphasis>x</emphasis>)
-&gt; EXP <emphasis>s</emphasis>
</programlisting>

<para>A value of <literal>SHAPE</literal> <emphasis>s</emphasis> will be extracted from the start of the space indicated by the pointer, and this is delivered. </para>

<para><emphasis>x</emphasis> will include <emphasis>alignment</emphasis>(<emphasis>s</emphasis>).</para>

<para><emphasis>s</emphasis> will not be a <literal>BITFIELD</literal>.</para>

<para>If the space which the pointer indicates does not lie wholly within the space indicated by the original pointer from which it is derived, the effect is undefined.</para>

<para>If the value delivered by <emphasis>arg1</emphasis> is a null pointer the effect is undefined.</para>

<para>The constraint &quot;x will include alignment(s)&quot; ensures in the simple memory model that no change is needed to the <literal>POINTER</literal>.</para>



</sect2>
<sect2>
<title>contents_with_mode</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>24</member>
</simplelist>

<programlisting>
<emphasis>md</emphasis>:      TRANSFER_MODE
<emphasis>s</emphasis>:       SHAPE
<emphasis>arg1</emphasis>:        EXP POINTER(<emphasis>x</emphasis>)
-&gt; EXP <emphasis>s</emphasis>
</programlisting>

<para>A value of <literal>SHAPE</literal> <emphasis>s</emphasis> will be extracted from the start of the space indicated by the pointer, and this is delivered.  The operation will be carried out as specified by the <literal>TRANSFER_MODE</literal> (q.v.).</para>

<para>If <emphasis>md</emphasis> consists of <emphasis>standard_transfer_mode</emphasis> only, then <emphasis>contents_with_mode</emphasis> is the same as <emphasis>contents</emphasis>.</para>

<para><emphasis>x</emphasis> will include <emphasis>alignment</emphasis>(<emphasis>s</emphasis>).</para>

<para><emphasis>s</emphasis> will not be a <literal>BITFIELD</literal>.</para>

<para>If the space which the pointer indicates does not lie wholly within the space indicated by the original pointer from which it is derived, the effect is undefined.</para>

<para>If the value delivered by <emphasis>arg1</emphasis> is a null pointer the effect is undefined.</para>



</sect2>
<sect2>
<title>current_env</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>25</member>
</simplelist>

<programlisting>
-&gt; EXP POINTER(<emphasis>fa</emphasis>)
</programlisting>

<para>A value of <literal>SHAPE POINTER</literal>(<emphasis>fa</emphasis>) is created and delivered. It gives access to the variables, identities and parameters in the current procedure activation which are declared as having <literal>ACCESS</literal> <emphasis>visible</emphasis>. </para>

<para>If the immediately enclosing procedure is defined by <emphasis>make_general_proc</emphasis>, then <emphasis>fa</emphasis> is the set union of <emphasis>local_alignment</emphasis> and the alignments of the kinds of parameters defined. That is to say, if there are caller parameters, then the alignment includes <emphasis>callers_alignment</emphasis>(<emphasis>x</emphasis>) where <emphasis>x</emphasis> is true if and only if the <literal>PROCPROPS</literal> <emphasis>var_callers</emphasis> is present; if there are callee parameters, the alignment includes <emphasis>callees_alignment</emphasis>(<emphasis>x</emphasis>) where <emphasis>x</emphasis> is true if and only if the <literal>PROCPROPS</literal> <emphasis>var_callees</emphasis> is present.</para>

<para>If the immediately enclosing procedure is defined by <emphasis>make_proc</emphasis>, then <emphasis>fa</emphasis> = { <emphasis>locals_alignment</emphasis>, <emphasis>callers_alignment</emphasis>(<emphasis>false</emphasis>) }.</para>

<para>If an <literal>OFFSET</literal> produced by <emphasis>env_offset</emphasis> is added to a <literal>POINTER</literal> produced by <emphasis>current_env</emphasis> from an activation of the procedure which contains the declaration of the <literal>TAG</literal> used by <emphasis>env_offset</emphasis>, then the result is an original <literal>POINTER</literal>, notwithstanding the normal rules for <emphasis>add_to_ptr</emphasis> (see -XREF-spec10.html#44Original pointers).</para>

<para>If an <literal>OFFSET</literal> produced by <emphasis>env_offset</emphasis> is added to such a pointer from an inappropriate procedure the effect is undefined.</para>



</sect2>
<sect2>
<title>div0</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>26</member>
</simplelist>

<programlisting>
<emphasis>div_by_0_err</emphasis>:    ERROR_TREATMENT
<emphasis>ov_err</emphasis>:      ERROR_TREATMENT
<emphasis>arg1</emphasis>:        EXP INTEGER(<emphasis>v</emphasis>)
<emphasis>arg2</emphasis>:        EXP INTEGER(<emphasis>v</emphasis>)
-&gt; EXP INTEGER(<emphasis>v</emphasis>)
</programlisting>

<para><emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated and will produce integer values, <emphasis>a</emphasis> and <emphasis>b</emphasis>, of the same <literal>VARIETY</literal>, <emphasis>v</emphasis>. Either the value <emphasis>a</emphasis> D1 <emphasis>b</emphasis> or the value <emphasis>a</emphasis> D2 <emphasis>b</emphasis> is delivered as the result of the construct, with the same <literal>SHAPE</literal> as the arguments. Different occurrences of <emphasis>div0</emphasis> in the same capsule can use D1 or D2 independently.</para>

<para>If <emphasis>b</emphasis> is zero a div_by_zero error occurs and is handled by <emphasis>div_by_0_err</emphasis>.</para>

<para>If <emphasis>b</emphasis> is not zero and the result cannot be expressed in the <literal>VARIETY</literal> being used to represent <emphasis>v</emphasis> an overflow occurs and is handled by <emphasis>ov_err</emphasis>.</para>

<para>Producers may assume that shifting and <emphasis>div0</emphasis> by a constant which is a power of two yield equally good code.</para>

<para>See -XREF-spec10.html#10Division and modulus for the definitions of D1, D2, M1 and M2.</para>



</sect2>
<sect2>
<title>div1</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>27</member>
</simplelist>

<programlisting>
<emphasis>div_by_0_err</emphasis>:    ERROR_TREATMENT
<emphasis>ov_err</emphasis>:      ERROR_TREATMENT
<emphasis>arg1</emphasis>:        EXP INTEGER(<emphasis>v</emphasis>)
<emphasis>arg2</emphasis>:        EXP INTEGER(<emphasis>v</emphasis>)
-&gt; EXP INTEGER(<emphasis>v</emphasis>)
</programlisting>

<para><emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated and will produce integer values, <emphasis>a</emphasis> and <emphasis>b</emphasis>, of the same <literal>VARIETY</literal>, <emphasis>v</emphasis>. The value <emphasis>a</emphasis> D1 <emphasis>b</emphasis> is delivered as the result of the construct, with the same <literal>SHAPE</literal> as the arguments.</para>

<para>If <emphasis>b</emphasis> is zero a div_by_zero error occurs and is handled by <emphasis>div_by_0_err</emphasis>.</para>

<para>If <emphasis>b</emphasis> is not zero and the result cannot be expressed in the <literal>VARIETY</literal> being used to represent <emphasis>v</emphasis> an overflow occurs and is handled by <emphasis>ov_err</emphasis>.</para>

<para>Producers may assume that shifting and <emphasis>div1</emphasis> by a constant which is a power of two yield equally good code.</para>

<para>See -XREF-spec10.html#10Division and modulus for the definitions of D1, D2, M1 and M2.</para>



</sect2>
<sect2>
<title>div2</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>28</member>
</simplelist>

<programlisting>
<emphasis>div_by_0_err</emphasis>:    ERROR_TREATMENT
<emphasis>ov_err</emphasis>:      ERROR_TREATMENT
<emphasis>arg1</emphasis>:        EXP INTEGER(<emphasis>v</emphasis>)
<emphasis>arg2</emphasis>:        EXP INTEGER(<emphasis>v</emphasis>)
-&gt; EXP INTEGER(<emphasis>v</emphasis>)
</programlisting>

<para><emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated and will produce integer values, <emphasis>a</emphasis> and <emphasis>b</emphasis>, of the same <literal>VARIETY</literal>, <emphasis>v</emphasis>. The value <emphasis>a</emphasis> D2 <emphasis>b</emphasis> is delivered as the result of the construct, with the same <literal>SHAPE</literal> as the arguments.</para>

<para>If <emphasis>b</emphasis> is zero a div_by_zero error occurs and is handled by <emphasis>div_by_0_err</emphasis>.</para>

<para>If <emphasis>b</emphasis> is not zero and the result cannot be expressed in the <literal>VARIETY</literal> being used to represent <emphasis>v</emphasis> an overflow occurs and is handled by <emphasis>ov_err</emphasis>.</para>

<para>Producers may assume that shifting and <emphasis>div2</emphasis> by a constant which is a power of two yield equally good code if the lower bound of <emphasis>v</emphasis> is zero.</para>

<para>See -XREF-spec10.html#10Division and modulus for the definitions of D1, D2, M1 and M2.</para>



</sect2>
<sect2>
<title>env_offset</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>29</member>
</simplelist>

<programlisting>
<emphasis>fa</emphasis>:      ALIGNMENT
<emphasis>y</emphasis>:       ALIGNMENT
<emphasis>t</emphasis>:       TAG <emphasis>x</emphasis>
-&gt; EXP OFFSET(<emphasis>fa</emphasis>, <emphasis>y</emphasis>)
</programlisting>

<para><emphasis>t</emphasis> will be the tag of a <emphasis>variable</emphasis>, <emphasis>identify</emphasis> or procedure parameter with the <emphasis>visible</emphasis> property within a procedure defined by <emphasis>make_general_proc</emphasis> or <emphasis>make_proc</emphasis>.</para>

<para>If it is defined in a make_general_proc, let P be its associated <literal>PROCPROPS</literal>; otherwise let P be the <literal>PROCPROPS</literal> {<emphasis>locals_alignment</emphasis>, <emphasis>caller_alignment</emphasis>(<emphasis>false</emphasis>)}.</para>

<para>If <emphasis>t</emphasis> is the <literal>TAG</literal> of a <emphasis>variable</emphasis> or <emphasis>identify, fa</emphasis> will contain <emphasis>locals_alignment</emphasis>; if it is a caller parameter <emphasis>fa</emphasis> will contain a <emphasis>caller_alignment</emphasis>(<emphasis>b</emphasis>) where <emphasis>b</emphasis> is true if and only if P contains <emphasis>var_callers</emphasis> ; if it is a callee parameter <emphasis>fa</emphasis> will contain a <emphasis>callee_alignment</emphasis>(<emphasis>b</emphasis>) where <emphasis>b</emphasis> is true if and only if P contains <emphasis>var_callees</emphasis>.</para>

<para>If t is the <literal>TAG</literal> of a <emphasis>variable</emphasis> or parameter, the result is the <literal>OFFSET</literal> of its position, within any procedure environment which derives from the procedure containing the declaration of the variable or parameter, relative to its environment pointer. In this case <emphasis>x</emphasis> will be <literal>POINTER</literal>(<emphasis>y).</emphasis></para>

<para>If t is the <literal>TAG</literal> of an <emphasis>identify</emphasis>, the result will be an <literal>OFFSET</literal> of space which holds the value. This pointer will not be used to alter the value. In this case <emphasis>y</emphasis> will be <emphasis>alignment</emphasis>(<emphasis>x</emphasis>).</para>

<para>See -XREF-spec10.html#19section 7.10.</para>



</sect2>
<sect2>
<title>env_size</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>30</member>
</simplelist>

<programlisting>
<emphasis>proctag</emphasis>: TAG PROC
-&gt; EXP OFFSET(<emphasis>locals_alignment</emphasis>, {})
</programlisting>

<para>Delivers an <literal>OFFSET</literal> of a space sufficient to contain all the variables and identifications, explicit or implicit in the procedure identified by <emphasis>proctag</emphasis>. This will not include the space required for any <emphasis>local_allocs</emphasis> or procedure calls within the procedure. </para>

<para><emphasis>proctag</emphasis> will be defined in the current <literal>CAPSULE</literal> by a <literal>TAGDEF</literal> identification of a <emphasis>make_proc</emphasis> or a <emphasis>make_general_proc</emphasis>.</para>



</sect2>
<sect2>
<title>fail_installer</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>31</member>
</simplelist>

<programlisting>
<emphasis>message</emphasis>: STRING<emphasis>(k, n)</emphasis>
-&gt; EXP BOTTOM
</programlisting>

<para>Any attempt to use this operation to produce code will result in a failure of the installation process. <emphasis>message</emphasis> will give information about the reason for this failure which should be passed to the installation manager. </para>



</sect2>
<sect2>
<title>float_int</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>32</member>
</simplelist>

<programlisting>
<emphasis>flpt_err</emphasis>:    ERROR_TREATMENT
<emphasis>f</emphasis>:       FLOATING_VARIETY
<emphasis>arg1</emphasis>:        EXP INTEGER(<emphasis>v</emphasis>)
-&gt; EXP FLOATING(<emphasis>f</emphasis>)
</programlisting>

<para><emphasis>arg1</emphasis> is evaluated to produce an integer value, which is converted to the representation of <emphasis>f</emphasis> and delivered.</para>

<para>If <emphasis>f</emphasis> is complex the real part of the result will be derived from <emphasis>arg1</emphasis> and the imaginary part will be zero.</para>

<para>If there is a floating point error it is handled by <emphasis>flpt_err</emphasis>. See -XREF-spec10.html#60Floating point errors.</para>



</sect2>
<sect2>
<title>floating_abs</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>33</member>
</simplelist>

<programlisting>
<emphasis>flpt_err</emphasis>:    ERROR_TREATMENT
<emphasis>arg1</emphasis>:        EXP FLOATING(<emphasis>f</emphasis>)
-&gt; EXP FLOATING(<emphasis>f</emphasis>)
</programlisting>

<para><emphasis>arg1</emphasis> is evaluated and will produce a floating point value, <emphasis>a</emphasis>, of the <literal>FLOATING_VARIETY</literal>, <emphasis>f</emphasis>. The absolute value of <emphasis>a</emphasis> is delivered as the result of the construct, with the same <literal>SHAPE</literal> as the argument.</para>

<para>Though <emphasis>floating_abs</emphasis> cannot produce an overflow it can give an invalid operand exception which is handled by <emphasis>flpt_err</emphasis>.</para>

<para><emphasis>f</emphasis> will not be complex.</para>

<para>See also -XREF-spec10.html#64Floating point accuracy.</para>



</sect2>
<sect2>
<title>floating_div</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>34</member>
</simplelist>

<programlisting>
<emphasis>flpt_err</emphasis>:    ERROR_TREATMENT
<emphasis>arg1</emphasis>:        EXP FLOATING(<emphasis>f</emphasis>)
<emphasis>arg2</emphasis>:        EXP FLOATING(<emphasis>f</emphasis>)
-&gt; EXP FLOATING(<emphasis>f</emphasis>)
</programlisting>

<para><emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated and will produce floating point values, <emphasis>a</emphasis> and <emphasis>b</emphasis>, of the same <literal>FLOATING_VARIETY</literal>, <emphasis>f</emphasis>. The value <emphasis>a</emphasis>/<emphasis>b</emphasis> is delivered as the result of the construct, with the same <literal>SHAPE</literal> as the arguments.</para>

<para>If there is a floating point error it is handled by <emphasis>flpt_err</emphasis>. See -XREF-spec10.html#60Floating point errors.</para>

<para>See also -XREF-spec10.html#64Floating point accuracy.</para>



</sect2>
<sect2>
<title>floating_minus</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>35</member>
</simplelist>

<programlisting>
<emphasis>flpt_err</emphasis>:    ERROR_TREATMENT
<emphasis>arg1</emphasis>:        EXP FLOATING(<emphasis>f</emphasis>)
<emphasis>arg2</emphasis>:        EXP FLOATING(<emphasis>f</emphasis>)
-&gt; EXP FLOATING(<emphasis>f</emphasis>)
</programlisting>

<para><emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated and will produce floating point values, <emphasis>a</emphasis> and <emphasis>b</emphasis>, of the same <literal>FLOATING_VARIETY</literal>, <emphasis>f</emphasis>. The value <emphasis>a</emphasis>-<emphasis>b</emphasis> is delivered as the result of the construct, with the same <literal>SHAPE</literal> as the arguments.</para>

<para>If there is a floating point error it is handled by <emphasis>flpt_err</emphasis>. See -XREF-spec10.html#60Floating point errors.</para>

<para>See also -XREF-spec10.html#64Floating point accuracy.</para>



</sect2>
<sect2>
<title>floating_maximum</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>36</member>
</simplelist>

<programlisting>
<emphasis>flpt_err</emphasis>:    ERROR_TREATMENT
<emphasis>arg1</emphasis>:        EXP FLOATING(<emphasis>f</emphasis>)
<emphasis>arg2</emphasis>:        EXP FLOATING(<emphasis>f</emphasis>)
-&gt; EXP FLOATING(<emphasis>f</emphasis>)
</programlisting>

<para>The maximum of the values delivered by <emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> is the result. <emphasis>f</emphasis> will not be complex. </para>

<para>If <emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are incomparable, <emphasis>flpt_err</emphasis> will be invoked.</para>

<para>See also -XREF-spec10.html#64Floating point accuracy.</para>



</sect2>
<sect2>
<title>floating_minimum</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>37</member>
</simplelist>

<programlisting>
<emphasis>flpt_err</emphasis>:    ERROR_TREATMENT
<emphasis>arg1</emphasis>:        EXP FLOATING(<emphasis>f</emphasis>)
<emphasis>arg2</emphasis>:        EXP FLOATING(<emphasis>f</emphasis>)
-&gt; EXP FLOATING(<emphasis>f</emphasis>)
</programlisting>

<para>The minimum of the values delivered by <emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> is the result. <emphasis>f</emphasis> will not be complex. </para>

<para>If <emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are incomparable, <emphasis>flpt_err</emphasis> will be invoked.</para>

<para>See also -XREF-spec10.html#64Floating point accuracy.</para>



</sect2>
<sect2>
<title>floating_mult</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>38</member>
</simplelist>

<programlisting>
<emphasis>flpt_err</emphasis>:    ERROR_TREATMENT
<emphasis>arg1</emphasis>:        LIST(EXP)
-&gt; EXP FLOATING(<emphasis>f</emphasis>)
</programlisting>

<para>The arguments, <emphasis>arg1</emphasis>, are evaluated producing floating point values all of the same <literal>FLOATING_VARIETY</literal>, <emphasis>f</emphasis>. These values are multiplied in any order and the result of this multiplication is delivered as the result of the construct, with the same <literal>SHAPE</literal> as the arguments. </para>

<para>If there is a floating point error it is handled by <emphasis>flpt_err</emphasis>. See -XREF-spec10.html#60Floating point errors.</para>

<note>
<para>Separate floating_mult operations cannot in general be combined, because rounding errors need to be controlled. The reason for allowing floating_mult to take a variable number of arguments is to make it possible to specify that a number of multiplications can be re-ordered.</para>
</note>
<para>If <emphasis>arg1</emphasis> contains one element the result is the value of that element. There will be at least one element in <emphasis>arg1</emphasis>.</para>

<para>See also -XREF-spec10.html#64Floating point accuracy.</para>



</sect2>
<sect2>
<title>floating_negate</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>39</member>
</simplelist>

<programlisting>
<emphasis>flpt_err</emphasis>:    ERROR_TREATMENT
<emphasis>arg1</emphasis>:        EXP FLOATING(<emphasis>f</emphasis>)
-&gt; EXP FLOATING(<emphasis>f</emphasis>)
</programlisting>

<para><emphasis>arg1</emphasis> is evaluated and will produce a floating point value, <emphasis>a</emphasis>, of the <literal>FLOATING_VARIETY</literal>, <emphasis>f</emphasis>. The value -<emphasis>a</emphasis> is delivered as the result of the construct, with the same <literal>SHAPE</literal> as the argument.</para>

<para>Though <emphasis>floating_negate</emphasis> cannot produce an overflow it can give an invalid operand exception which is handled by <emphasis>flpt_err</emphasis>.</para>

<para>See also -XREF-spec10.html#64Floating point accuracy.</para>



</sect2>
<sect2>
<title>floating_plus</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>40</member>
</simplelist>

<programlisting>
<emphasis>flpt_err</emphasis>:    ERROR_TREATMENT
<emphasis>arg1</emphasis>:        LIST(EXP)
-&gt; EXP FLOATING(<emphasis>f</emphasis>)
</programlisting>

<para>The arguments, <emphasis>arg1</emphasis>, are evaluated producing floating point values, all of the same <literal>FLOATING_VARIETY</literal>, <emphasis>f</emphasis>. These values are added in any order and the result of this addition is delivered as the result of the construct, with the same <literal>SHAPE</literal> as the arguments. </para>

<para>If there is a floating point error it is handled by <emphasis>flpt_err</emphasis>. See -XREF-spec10.html#60Floating point errors.</para>

<para>Note that separate floating_plus operations cannot in general be combined, because rounding errors need to be controlled. The reason for allowing floating_plus to take a variable number of arguments is to make it possible to specify that a number of multiplications can be re-ordered.</para>

<para>If <emphasis>arg1</emphasis> contains one element the result is the value of that element. There will be at least one element in <emphasis>arg1</emphasis>.</para>

<para>See also -XREF-spec10.html#64Floating point accuracy.</para>



</sect2>
<sect2>
<title>floating_power</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>41</member>
</simplelist>

<programlisting>
<emphasis>flpt_err</emphasis>:    ERROR_TREATMENT
<emphasis>arg1</emphasis>:        EXP FLOATING(<emphasis>f</emphasis>)
<emphasis>arg2</emphasis>:        EXP INTEGER(<emphasis>v</emphasis>)
-&gt; EXP FLOATING(<emphasis>f</emphasis>)
</programlisting>

<para>The result of <emphasis>arg1</emphasis> is raised to the power given by <emphasis>arg2</emphasis>. </para>

<para>If there is a floating point error it is handled by <emphasis>flpt_err</emphasis>. See -XREF-spec10.html#60Floating point errors.</para>

<para>See also -XREF-spec10.html#64Floating point accuracy.</para>



</sect2>
<sect2>
<title>floating_test</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>42</member>
</simplelist>

<programlisting>
<emphasis>prob</emphasis>:        OPTION(NAT)
<emphasis>flpt_err</emphasis>:    ERROR_TREATMENT
<emphasis>nt</emphasis>:      NTEST
<emphasis>dest</emphasis>:        LABEL
<emphasis>arg1</emphasis>:        EXP FLOATING(<emphasis>f</emphasis>)
<emphasis>arg2</emphasis>:        EXP FLOATING(<emphasis>f</emphasis>)
-&gt; EXP TOP
</programlisting>

<para><emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated and will produce floating point values, <emphasis>a</emphasis> and <emphasis>b</emphasis>, of the same <literal>FLOATING_VARIETY</literal>, <emphasis>f</emphasis>. These values are compared using <emphasis>nt</emphasis>.</para>

<para>If <emphasis>f</emphasis> is complex then <emphasis>nt</emphasis> will be <emphasis>equal</emphasis> or <emphasis>not_equal</emphasis>.</para>

<para>If <emphasis>a nt b</emphasis>, this construction yields <literal>TOP</literal>. Otherwise control passes to <emphasis>dest</emphasis>.</para>

<para>If <emphasis>prob</emphasis> is present<emphasis>, prob</emphasis>/100 gives the probability that control will continue to the next construct (ie. not pass to <emphasis>dest</emphasis>). If <emphasis>prob</emphasis> is absent this probability is unknown.</para>

<para>If there is a floating point error it is handled by <emphasis>flpt_err</emphasis>. See -XREF-spec10.html#60Floating point errors.</para>

<para>See also -XREF-spec10.html#64Floating point accuracy.</para>



</sect2>
<sect2>
<title>goto</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>43</member>
</simplelist>

<programlisting>
<emphasis>dest</emphasis>:        LABEL
-&gt; EXP BOTTOM
</programlisting>

<para>Control passes to the <literal>EXP</literal> labelled <emphasis>dest</emphasis>. This construct will only be used where <emphasis>dest</emphasis> is in scope. </para>



</sect2>
<sect2>
<title>goto_local_lv</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>44</member>
</simplelist>

<programlisting>
<emphasis>arg1</emphasis>:        EXP POINTER(<emphasis>{code</emphasis>})
-&gt; EXP BOTTOM
</programlisting>

<para><emphasis>arg1</emphasis> is evaluated. The label from which the value delivered by <emphasis>arg1</emphasis> was created will be within its lifetime and this construction will be obeyed in the same activation of the same procedure as the creation of the <literal>POINTER(</literal><emphasis>{code</emphasis><literal>})</literal> by <emphasis>make_local_lv</emphasis>. Control passes to this activation of this <literal>LABEL</literal>.</para>

<para>If <emphasis>arg1</emphasis> delivers a null <literal>POINTER</literal> the effect is undefined.</para>



</sect2>
<sect2>
<title>identify</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>45</member>
</simplelist>

<programlisting>
<emphasis>opt_access</emphasis>:  OPTION(ACCESS)
<emphasis>name_intro</emphasis>:  TAG <emphasis>x</emphasis>
<emphasis>definition</emphasis>:  EXP <emphasis>x</emphasis>
<emphasis>body</emphasis>:        EXP <emphasis>y</emphasis>
-&gt; EXP <emphasis>y</emphasis>
</programlisting>

<para><emphasis>definition</emphasis> is evaluated to produce a value, <emphasis>v</emphasis>. Then <emphasis>body</emphasis> is evaluated. During this evaluation, <emphasis>v</emphasis> is bound to <emphasis>name_intro</emphasis>. This means that inside <emphasis>body</emphasis> an evaluation of <emphasis>obtain_tag</emphasis>(<emphasis>name_intro</emphasis>) will produce the value, <emphasis>v</emphasis>.</para>

<para>The value delivered by <emphasis>identify</emphasis> is that produced by <emphasis>body</emphasis>.</para>

<para>The <literal>TAG</literal> given for <emphasis>name_intro</emphasis> will not be reused within the current <literal>UNIT</literal>. No rules for the hiding of one <literal>TAG</literal> by another are given: this will not happen. The lifetime of <emphasis>name_intro</emphasis> is the evaluation of <emphasis>body</emphasis>.</para>

<para>If <emphasis>opt_access</emphasis> contains <emphasis>visible</emphasis>, it means that the value must not be aliased while the procedure containing this declaration is not the current procedure. Hence if there are any copies of this value they will need to be refreshed when the procedure is returned to. The easiest implementation when <emphasis>opt_access</emphasis> is <emphasis>visible</emphasis> may be to keep the value in memory, but this is not a necessary requirement.</para>

<para>The order in which the constituents of <emphasis>definition</emphasis> and <emphasis>body</emphasis> are evaluated shall be indistinguishable in all observable effects (apart from time) from completely evaluating <emphasis>definition</emphasis> before starting <emphasis>body</emphasis>. See the note about order in -XREF-#M193sequence.</para>



</sect2>
<sect2>
<title>ignorable</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>46</member>
</simplelist>

<programlisting>
<emphasis>arg1</emphasis>:        EXP <emphasis>x</emphasis>
-&gt; EXP <emphasis>x</emphasis>
</programlisting>

<para>If the result of this construction is discarded, <emphasis>arg1</emphasis> need not be evaluated, though evaluation is permitted. If the result is used it is the result of <emphasis>arg1</emphasis>. </para>



</sect2>
<sect2>
<title>imaginary_part</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>47</member>
</simplelist>

<programlisting>
<emphasis>arg1</emphasis>:        EXP <emphasis>c</emphasis>
-&gt; EXP FLOATING (<emphasis>float_of_complex(c)</emphasis>)
</programlisting>

<para><emphasis>c</emphasis> will be complex. Delivers the imaginary part of the value produced by <emphasis>arg1</emphasis>.</para>



</sect2>
<sect2>
<title>initial_value</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>48</member>
</simplelist>

<programlisting>
<emphasis>init</emphasis>:        EXP <emphasis>s</emphasis>
-&gt; EXP <emphasis>s</emphasis>
</programlisting>

<para>Any tag used as an argument of an <emphasis>obtain_tag</emphasis> in <emphasis>init</emphasis> will be global or defined within <emphasis>init</emphasis>. </para>

<para>All labels used in <emphasis>init</emphasis> will be defined within <emphasis>init</emphasis>.</para>

<para><emphasis>init</emphasis> will be evaluated once only before any procedure application, other than those involved in this or other <emphasis>initial_value</emphasis> constructions, but after all load-time constant initialisations of TAGDEFs. The result of this evaluation is the value of the construction.</para>

<para>The order of evaluation of the different <emphasis>initial_values</emphasis> in a program is undefined.</para>

<para>See -XREF-spec10.html#73section 7.29.</para>


</sect2>
<sect2>
<title>integer_test</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>49</member>
</simplelist>

<programlisting>
<emphasis>prob</emphasis>:        OPTION(NAT)
<emphasis>nt</emphasis>:      NTEST
<emphasis>dest</emphasis>:        LABEL
<emphasis>arg1</emphasis>:        EXP INTEGER(<emphasis>v</emphasis>)
<emphasis>arg2</emphasis>:        EXP INTEGER(<emphasis>v</emphasis>)
-&gt; EXP TOP
</programlisting>

<para><emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated and will produce integer values, <emphasis>a</emphasis> and <emphasis>b</emphasis>, of the same <literal>VARIETY</literal>, <emphasis>v</emphasis>. These values are compared using <emphasis>nt</emphasis>.</para>

<para>If <emphasis>a nt b</emphasis>, this construction yields <literal>TOP</literal>. Otherwise control passes to <emphasis>dest</emphasis>.</para>

<para>If <emphasis>prob</emphasis> is present, <emphasis>prob</emphasis>/100 gives the probability that control will continue to the next construct (ie. not pass to <emphasis>dest</emphasis>). If <emphasis>prob</emphasis> is absent this probability is unknown.</para>



</sect2>
<sect2>
<title>labelled</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>50</member>
</simplelist>

<programlisting>
<emphasis>labs_intro</emphasis>:  LIST(LABEL)
<emphasis>starter</emphasis>: EXP <emphasis>x</emphasis>
<emphasis>places</emphasis>:      LIST(EXP)
-&gt; EXP <emphasis>w</emphasis>
</programlisting>

<para>The lists <emphasis>labs_intro</emphasis> and <emphasis>places</emphasis> shall have the same number of elements. </para>

<para>To evaluate the construction <emphasis>starter</emphasis> is evaluated. If its evaluation runs to completion producing a value, then this is delivered as the result of the whole construction. If a <emphasis>goto</emphasis> one of the <literal>LABEL</literal>s in <emphasis>labs_intro</emphasis> or any other jump to one of these <literal>LABEL</literal>s is evaluated, then the evaluation of <emphasis>starter</emphasis> stops and the corresponding element of <emphasis>places</emphasis> is evaluated. In the canonical ordering all the operations which are evaluated from <emphasis>starter</emphasis> are completed before any from an element of <emphasis>places</emphasis> is started. If the evaluation of the member of <emphasis>places</emphasis> produces a result this is the result of the construction.</para>

<para>If a jump to any of the <emphasis>labs_intro</emphasis> is obeyed then evaluation continues similarly. Such jumping may continue indefinitely, but if any <emphasis>places</emphasis> terminates, then the value it produces is the value delivered by the construction.</para>

<para>The <literal>SHAPE</literal> <emphasis>w</emphasis> is the LUB of <emphasis>x</emphasis> and all the <emphasis>places</emphasis>. See -XREF-spec10.html#70Least Upper Bound.</para>

<para>The actual order of evaluation of the constituents shall be indistinguishable in all observable effects (apart from time) from that described above. Note that this specifically includes any defined error handling.</para>

<para>The lifetime of each of the <literal>LABEL</literal>s in <emphasis>labs_intro</emphasis>, is the evaluation of <emphasis>starter</emphasis> and all the elements of <emphasis>places</emphasis>.</para>



</sect2>
<sect2>
<title>last_local</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>51</member>
</simplelist>

<programlisting>
<emphasis>x</emphasis>:       EXP OFFSET(<emphasis>y</emphasis>, <emphasis>z</emphasis>)
-&gt; EXP POINTER(<emphasis>alloca_alignment</emphasis>)
</programlisting>

<para>If the last use of <emphasis>local_alloc</emphasis> in the current activation of the current procedure was after the last use of <emphasis>local_free</emphasis> or <emphasis>local_free_all</emphasis>, then the value returned is the last <literal>POINTER</literal> allocated with <emphasis>local_alloc</emphasis>. </para>

<para>If the last use of <emphasis>local_free</emphasis> in the current activation of the current procedure was after the last use of <emphasis>local_alloc</emphasis>, then the result is the <literal>POINTER</literal> last allocated which is still active.</para>

<para>The result <literal>POINTER</literal> will have been created by <emphasis>local_alloc</emphasis> with the value of its <emphasis>arg1</emphasis> equal to the value of <emphasis>x</emphasis>.</para>

<para>If the last use of <emphasis>local_free_all</emphasis> in the current activation of the current procedure was after the last use of <emphasis>local_alloc</emphasis>, or if there has been no use of <emphasis>local_alloc</emphasis> in the current activation of the current procedure, then the result is undefined.</para>

<para>The <literal>ALIGNMENT</literal>, <emphasis>alloca_alignment</emphasis>, includes the set union of all the <literal>ALIGNMENT</literal>s which can be produced by <emphasis>alignment</emphasis> from any <literal>SHAPE</literal>. See -XREF-spec10.html#34Special alignments.</para>



</sect2>
<sect2>
<title>local_alloc</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>52</member>
</simplelist>

<programlisting>
<emphasis>arg1</emphasis>:        EXP OFFSET(<emphasis>x</emphasis>, <emphasis>y</emphasis>)
-&gt; EXP POINTER(<emphasis>alloca_alignment</emphasis>)
</programlisting>

<para>The <emphasis>arg1</emphasis> expression is evaluated and space is allocated sufficient to hold a value of the given size. -XREF-M339The result is an original pointer to this space. </para>

<para><emphasis>x</emphasis> will not consist entirely of bitfield alignments.</para>

<para>The initial contents of the space are not specified.</para>

<para>This allocation is as if on the stack of the current procedure, and the lifetime of the pointer ends when the current activation of the current procedure ends with a <emphasis>return</emphasis>, <emphasis>return_to_label</emphasis> or <emphasis>tail_call</emphasis> or if there is a long jump out of the activation. Any use of the pointer thereafter is undefined. Note the specific exclusion of the procedure ending with <emphasis>untidy_return</emphasis>; in this case the calling procedure becomes the current activation.</para>

<para>The uses of <emphasis>local_alloc</emphasis> within the procedure are ordered dynamically as they occur, and this order affects the meaning of <emphasis>local_free</emphasis> and <emphasis>last_local</emphasis>.</para>

<para><emphasis>arg1</emphasis> may be a zero <literal>OFFSET</literal>. In this case suppose the result is <emphasis>p</emphasis>. Then a subsequent use, in the same activation of the procedure, of</para>

<para><emphasis>local_free</emphasis>(<emphasis>offset_zero</emphasis>(<emphasis>alloca_alignment</emphasis>), <emphasis>p</emphasis>)</para>

<para>will return the <emphasis>alloca</emphasis> stack to the state it was in immediately before the use of <emphasis>local_alloc</emphasis>.</para>

<para>Note that if a procedure which uses <emphasis>local_alloc</emphasis> is inlined, it may be necessary to use <emphasis>local_free</emphasis> to get the correct semantics.</para>

<para>See also -XREF-spec10.html#22section 7.12.</para>



</sect2>
<sect2>
<title>local_alloc_check</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>53</member>
</simplelist>

<programlisting>
<emphasis>arg1</emphasis>:        EXP OFFSET(<emphasis>x</emphasis>, <emphasis>y</emphasis>)
-&gt; EXP POINTER(<emphasis>alloca_alignment</emphasis>)
</programlisting>

<para>If the <literal>OFFSET</literal> <emphasis>arg1</emphasis> can be accomodated within the limit of the local_alloc stack (see -XREF-#M130section 5.16.108), the action is precisely the same as <emphasis>local_alloc</emphasis>.</para>

<para>If not, normal action is stopped and a TDF exception is raised with ERROR_CODE <emphasis>stack_overflow</emphasis>.</para>



</sect2>
<sect2>
<title>local_free</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>54</member>
</simplelist>

<programlisting>
<emphasis>a</emphasis>:       EXP OFFSET(<emphasis>x</emphasis>, <emphasis>y</emphasis>)
<emphasis>p</emphasis>:       EXP POINTER(<emphasis>alloca_alignment</emphasis>)
-&gt; EXP TOP
</programlisting>

<para>The <literal>POINTER</literal>, <emphasis>p</emphasis>, will be an original pointer to space allocated by <emphasis>local_alloc</emphasis> within the current call of the current procedure. It and all spaces allocated after it by <emphasis>local_alloc</emphasis> will no longer be used. This <literal>POINTER</literal> will have been created by <emphasis>local_alloc</emphasis> with the value of its <emphasis>arg1</emphasis> equal to the value of <emphasis>a</emphasis>. </para>

<para>Any subsequent use of pointers to the spaces no longer used will be undefined.</para>



</sect2>
<sect2>
<title>local_free_all</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>55</member>
</simplelist>

<programlisting>
-&gt; EXP TOP
</programlisting>

<para>Every space allocated by <emphasis>local_alloc</emphasis> within the current call of the current procedure will no longer be used. </para>

<para>Any use of a pointer to space allocated before this operation within the current call of the current procedure is undefined.</para>

<para>Note that if a procedure which uses <emphasis>local_free_all</emphasis> is inlined, it may be necessary to use <emphasis>local_free</emphasis> to get the correct semantics.</para>



</sect2>
<sect2>
<title>long_jump</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>56</member>
</simplelist>

<programlisting>
<emphasis>arg1</emphasis>:        EXP POINTER(<emphasis>fa</emphasis>)
<emphasis>arg2</emphasis>:        EXP POINTER({<emphasis>code</emphasis>})
-&gt; EXP BOTTOM
</programlisting>

<para><emphasis>arg1</emphasis> will be a pointer produced by an application of <emphasis>curent_env</emphasis> in a currently active procedure.</para>

<para>The frame produced by <emphasis>arg1</emphasis> is reinstated as the current procedure. This frame will still be active. Evaluation recommences at the label given by <emphasis>arg2</emphasis>. This operation will only be used during the lifetime of that label.</para>

<para>Only <literal>TAG</literal>s declared to have <emphasis>long_jump_access</emphasis> will be defined at the re-entry.</para>

<para>If <emphasis>arg2</emphasis> delivers a null <literal>POINTER(</literal>{<emphasis>code</emphasis><literal>})</literal> the effect is undefined.</para>



</sect2>
<sect2>
<title>make_complex</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>57</member>
</simplelist>

<programlisting>
<emphasis>c</emphasis>:       FLOATING_VARIETY
<emphasis>arg1</emphasis>:        EXP FLOATING(<emphasis>f</emphasis>)
<emphasis>arg2</emphasis>:        EXP FLOATING(<emphasis>f</emphasis>)
-&gt; EXP FLOATING(<emphasis>c</emphasis>)
</programlisting>

<para><emphasis>c</emphasis> will be complex and derived from the same parameters as <emphasis>f</emphasis>.</para>

<para>Delivers a complex number with <emphasis>arg1</emphasis> delivering the real part and <emphasis>arg2</emphasis> the imaginary.</para>



</sect2>
<sect2>
<title>make_compound</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>58</member>
</simplelist>

<programlisting>
<emphasis>arg1</emphasis>:        EXP OFFSET(<emphasis>base</emphasis>, <emphasis>y</emphasis>)
<emphasis>arg2</emphasis>:        LIST(EXP)
-&gt; EXP COMPOUND(<emphasis>arg1</emphasis>)
</programlisting>

<para>Let the <emphasis>i</emphasis>th component (<emphasis>i</emphasis> starts at one) of <emphasis>arg2</emphasis> be <emphasis>x</emphasis>[<emphasis>i</emphasis>]. The list may be empty.</para>

<para>The components <emphasis>x</emphasis>[2 * <emphasis>k</emphasis>] are values which are to be placed at <literal>OFFSET</literal>s given by <emphasis>x</emphasis>[2 * <emphasis>k</emphasis> - 1]. These <literal>OFFSET</literal>s will be constants and non-negative.</para>

<para>The <literal>OFFSET</literal> <emphasis>x</emphasis>[2 * <emphasis>k</emphasis> - 1] will have the <literal>SHAPE</literal> <literal>OFFSET</literal>(<emphasis>z</emphasis><emphasis>k</emphasis>, <emphasis>alignment</emphasis>(<emphasis>shape</emphasis>(<emphasis>x</emphasis>[2 * <emphasis>k</emphasis>]))), where <emphasis>shape</emphasis> gives the <literal>SHAPE</literal> of the component and <emphasis>base</emphasis> includes <emphasis>z</emphasis><emphasis>k</emphasis>.</para>

<para><emphasis>arg1</emphasis> will be a constant non-negative <literal>OFFSET</literal>, see -XREF-#M169offset_pad.</para>

<para>The values <emphasis>x</emphasis>[2 * <emphasis>k</emphasis> - 1] will be such that the components when in place either do not overlap or exactly coincide, in the sense that the <literal>OFFSET</literal>s are equal and the values have the same <literal>SHAPE</literal>. If they coincide the corresponding values <emphasis>x</emphasis>[2 * <emphasis>k</emphasis>] will have <literal>VARIETY SHAPE</literal>s and will be <emphasis>ored</emphasis> together.</para>

<para>The <literal>SHAPE</literal> of a <emphasis>x</emphasis>[2 * <emphasis>k</emphasis>] component can be <literal>TOP</literal>. In this case the component is evaluated, but no value is placed at the corresponding <literal>OFFSET</literal>.</para>

<para>If <emphasis>x[2 * k]</emphasis> is a <literal>BITFIELD</literal> then <emphasis>x[2 * k - 1]</emphasis>, <emphasis>shape(x[2 * k])</emphasis> will be <emphasis>variety-enclosed</emphasis> (see -XREF-spec10.html#66section 7.24).</para>



</sect2>
<sect2>
<title>make_floating</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>59</member>
</simplelist>

<programlisting>
<emphasis>f</emphasis>:       FLOATING_VARIETY
<emphasis>rm</emphasis>:      ROUNDING_MODE
<emphasis>negative</emphasis>:    BOOL
<emphasis>mantissa</emphasis>:    STRING<emphasis>(k, n)</emphasis>
<emphasis>base</emphasis>:        NAT
<emphasis>exponent</emphasis>:    SIGNED_NAT
-&gt; EXP FLOATING(<emphasis>f</emphasis>)
</programlisting>

<para><emphasis>f</emphasis> will not be complex.</para>

<para><emphasis>mantissa</emphasis> will be a <literal>STRING</literal> of 8-bit integers, each of which is either 46 or is greater than or equal to 48. Those values, <emphasis>c</emphasis>, which lie between 48 and 63 will represent the digit <emphasis>c</emphasis>-48. A decimal point is represented by 46.</para>

<para>The <literal>BOOL</literal> <emphasis>negative</emphasis> determines the sign of the result, if true the result will be negative, if false, positive.</para>

<para>A floating point number, <emphasis>mantissa</emphasis>*(<emphasis>base</emphasis>exponent) is created and rounded to the representation of <emphasis>f</emphasis> as specified by <emphasis>rm</emphasis>. <emphasis>rm</emphasis> will not be <emphasis>round_as_state</emphasis>. <emphasis>mantissa</emphasis> is read as a sequence of digits to base <emphasis>base</emphasis> and may contain one point symbol.</para>

<para><emphasis>base</emphasis> will be one of the numbers 2, 4, 8, 10, 16. Note that in base 16 the digit 10 is represented by the character number 58 etc.</para>

<para>The result will lie in <emphasis>f</emphasis>.</para>



</sect2>
<sect2>
<title>make_general_proc</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>60</member>
</simplelist>

<programlisting>
<emphasis>result_shape</emphasis>:    SHAPE
<emphasis>prcprops</emphasis>:    OPTION(PROCPROPS)
<emphasis>caller_intro</emphasis>:    LIST(TAGSHACC)
<emphasis>callee_intro</emphasis>:    LIST(TAGSHACC)
<emphasis>body</emphasis>:        EXP BOTTOM
-&gt; EXP PROC
</programlisting>

<para>Evaluation of <emphasis>make_general_proc</emphasis> delivers a <literal>PROC</literal>. When this procedure is applied to parameters using <emphasis>apply_general_proc</emphasis>, space is allocated to hold the actual values of the parameters <emphasis>caller_intro</emphasis> and <emphasis>callee_intro</emphasis> . The values produced by the actual parameters are used to initialise these spaces. Then <emphasis>body</emphasis> is evaluated. During this evaluation the <literal>TAG</literal>s in <emphasis>caller_intro</emphasis> and <emphasis>callee_intro</emphasis> are bound to original <literal>POINTER</literal>s to these spaces. The lifetime of these <literal>TAG</literal>s is the evaluation of <emphasis>body</emphasis>. </para>

<para>The <literal>SHAPE</literal> of <emphasis>body</emphasis> will be <literal>BOTTOM</literal>. <emphasis>caller_intro</emphasis> and <emphasis>callee_intro</emphasis> may be empty.</para>

<para>The <literal>TAG</literal>s introduced in the parameters will not be reused within the current <literal>UNIT</literal>.</para>

<para>The <literal>SHAPE</literal>s in the parameters specify the <literal>SHAPE</literal> of the corresponding <literal>TAG</literal>s.</para>

<para>The <literal>OPTION(ACCESS)</literal> (in <emphasis>params_intro</emphasis>) specifies the <literal>ACCESS</literal> properties of the corresponding parameter, just as for a variable declaration.</para>

<para>In <emphasis>body</emphasis> the only <literal>TAG</literal>s which may be used as an argument of <emphasis>obtain_tag</emphasis> are those which are declared by <emphasis>identify</emphasis> or <emphasis>variable</emphasis> constructions in <emphasis>body</emphasis> and which are in scope, or <literal>TAG</literal>s which are declared by <emphasis>make_id_tagdef</emphasis>, <emphasis>make_var_tagdef</emphasis> or <emphasis>common_tagdef</emphasis> or are in <emphasis>caller_intro</emphasis> or <emphasis>callee_intro</emphasis>. If a <emphasis>make_proc</emphasis> occurs in <emphasis>body</emphasis> its <literal>TAG</literal>s are not in scope.</para>

<para>The argument of every <emphasis>return</emphasis> or <emphasis>untidy_return</emphasis> construction in <emphasis>body</emphasis> will have <literal>SHAPE</literal> <emphasis>result_shape</emphasis>. Every <emphasis>apply_general_proc</emphasis> using the procedure will specify the <literal>SHAPE</literal> of its result to be <emphasis>result_shape</emphasis>.</para>

<para>The presence or absence of each of the <literal>PROCPROPS</literal> <emphasis>var_callers</emphasis>, <emphasis>var_callees, check_stack</emphasis> and <emphasis>untidy</emphasis> in <emphasis>prcprops</emphasis> will be reflected in every <emphasis>apply_general_proc</emphasis> or <emphasis>tail_call</emphasis> on this procedure.</para>

<para>The definition of the canonical ordering of the evaluation of <emphasis>apply_general_proc</emphasis> gives the definition of these <literal>PROCPROPS</literal>.</para>

<para>If <emphasis>prcprocs</emphasis> contains <emphasis>check_stack</emphasis>, a TDF exception will be raised if the static space required for the procedure call (in the sense of <emphasis>env_size</emphasis>) would exceed the limit given by <emphasis>set_stack_limit</emphasis>.</para>

<para>If <emphasis>prcprops</emphasis> contains <emphasis>no_long_jump_dest</emphasis>, the body of the procedure will never contain the destination label of a <emphasis>long_jump</emphasis>.</para>

<para>For notes on the intended implementation of procedures see -XREF-spec10.html#18section 7.9.</para>



</sect2>
<sect2>
<title>make_int</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>61</member>
</simplelist>

<programlisting>
<emphasis>v</emphasis>:       VARIETY
<emphasis>value</emphasis>:       SIGNED_NAT
-&gt; EXP INTEGER(<emphasis>v</emphasis>)
</programlisting>

<para>An integer value is delivered of which the value is given by <emphasis>value</emphasis>, and the <literal>VARIETY</literal> by <emphasis>v</emphasis>. The <literal>SIGNED_NAT</literal> <emphasis>value</emphasis> will lie between the bounds of <emphasis>v</emphasis>. </para>



</sect2>
<sect2>
<title>make_local_lv</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>62</member>
</simplelist>

<programlisting>
<emphasis>lab</emphasis>:     LABEL
-&gt; EXP POINTER(<emphasis>{code</emphasis>})
</programlisting>

<para>A <literal>POINTER(</literal><emphasis>{code</emphasis><literal>})</literal> <emphasis>lv</emphasis> is created and delivered. It can be used as an argument to <emphasis>goto_local_lv</emphasis> or <emphasis>long_jump</emphasis>. If and when one of these is evaluated with <emphasis>lv</emphasis> as an argument, control will pass to <emphasis>lab</emphasis>. </para>



</sect2>
<sect2>
<title>make_nof</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>63</member>
</simplelist>

<programlisting>
<emphasis>arg1</emphasis>:        LIST(EXP)
-&gt; EXP NOF(<emphasis>n</emphasis>, <emphasis>s</emphasis>)
</programlisting>

<para>Creates an array of <emphasis>n</emphasis> values of <literal>SHAPE</literal> <emphasis>s</emphasis>, containing the given values produced by evaluating the members of <emphasis>arg1</emphasis> in the same order as they occur in the list. </para>

<para><emphasis>n</emphasis> will not be zero.</para>



</sect2>
<sect2>
<title>make_nof_int</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>64</member>
</simplelist>

<programlisting>
<emphasis>v</emphasis>:       VARIETY
<emphasis>str</emphasis>:     STRING<emphasis>(k, n)</emphasis>
-&gt; EXP NOF(<emphasis>n</emphasis>, INTEGER(<emphasis>v</emphasis>))
</programlisting>

<para>An <literal>NOF INTEGER</literal> is delivered. The conversions are carried out as if the elements of <emphasis>str</emphasis> were <literal>INTEGER</literal>(<emphasis>var_limits</emphasis>(0, 2<emphasis>k</emphasis>-1)). <emphasis>n</emphasis> may be zero.</para>



</sect2>
<sect2>
<title>make_null_local_lv</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>65</member>
</simplelist>

<programlisting>
-&gt; EXP POINTER({<emphasis>code</emphasis>})
</programlisting>

<para>Makes a null <literal>POINTER</literal>({<emphasis>code</emphasis>}) which can be detected by <emphasis>pointer_test</emphasis>. The effect of <emphasis>goto_local_lv</emphasis> or <emphasis>long_jump</emphasis> applied to this value is undefined. </para>

<para>All null <literal>POINTER</literal>({<emphasis>code</emphasis>}) are equal to each other and unequal to any other <literal>POINTER</literal>s.</para>



</sect2>
<sect2>
<title>make_null_proc</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>66</member>
</simplelist>

<programlisting>
-&gt; EXP PROC
</programlisting>

<para>A null <literal>PROC</literal> is created and delivered. The null <literal>PROC</literal> may be tested for by using <emphasis>proc_test</emphasis>. The effect of using it as the first argument of <emphasis>apply_proc</emphasis> is undefined. </para>

<para>All null <literal>PROC</literal> are equal to each other and unequal to any other <literal>PROC</literal>.</para>



</sect2>
<sect2>
<title>make_null_ptr</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>67</member>
</simplelist>

<programlisting>
<emphasis>a</emphasis>:       ALIGNMENT
-&gt; EXP POINTER(<emphasis>a</emphasis>)
</programlisting>

<para>A null <literal>POINTER</literal>(<emphasis>a</emphasis>) is created and delivered. The null <literal>POINTER</literal> may be tested for by <emphasis>pointer_test</emphasis>. </para>

<para><emphasis>a</emphasis> will not include <emphasis>code</emphasis>.</para>

<para>All null <literal>POINTER</literal>(<emphasis>x</emphasis>) are equal to each other and unequal to any other <literal>POINTER</literal>(<emphasis>x</emphasis>).</para>



</sect2>
<sect2>
<title>make_proc</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>68</member>
</simplelist>

<programlisting>
<emphasis>result_shape</emphasis>:    SHAPE
<emphasis>params_intro</emphasis>:    LIST(TAGSHACC)
<emphasis>var_intro</emphasis>:   OPTION(TAGACC)
<emphasis>body</emphasis>:        EXP BOTTOM
-&gt; EXP PROC
</programlisting>

<para>Evaluation of <emphasis>make_proc</emphasis> delivers a <literal>PROC</literal>. When this procedure is applied to parameters using <emphasis>apply_proc</emphasis>, space is allocated to hold the actual values of the parameters <emphasis>params_intro</emphasis> and <emphasis>var_intro</emphasis> (if present). The values produced by the actual parameters are used to initialise these spaces. Then <emphasis>body</emphasis> is evaluated. During this evaluation the <literal>TAG</literal>s in <emphasis>params_intro</emphasis> and <emphasis>var_intro</emphasis> are bound to original <literal>POINTER</literal>s to these spaces. The lifetime of these <literal>TAG</literal>s is the evaluation of <emphasis>body</emphasis>. </para>

<para>If <emphasis>var_intro</emphasis> is present, it may be used for one of two purposes, with different consequences for corresponding uses of <emphasis>apply_proc</emphasis>. See -XREF-spec10.html#18section 7.9. The <literal>ALIGNMENT</literal>, <emphasis>var_param_alignment</emphasis>, includes the set union of all the <literal>ALIGNMENT</literal>s which can be produced by <emphasis>alignment</emphasis> from any <literal>SHAPE</literal>. Note that <emphasis>var_intro</emphasis> does not contain an <literal>ACCESS</literal> component and so cannot be marked <emphasis>visible</emphasis>. Hence it is not a possible argument of <emphasis>env_offset</emphasis>. If present, <emphasis>var_intro</emphasis> is an original pointer.</para>

<para>The <literal>SHAPE</literal> of <emphasis>body</emphasis> will be <literal>BOTTOM</literal>. <emphasis>params_intro</emphasis> may be empty.</para>

<para>The <literal>TAG</literal>s introduced in the parameters will not be reused within the current <literal>UNIT</literal>.</para>

<para>The <literal>SHAPE</literal>s in the parameters specify the <literal>SHAPE</literal> of the corresponding <literal>TAG</literal>s.</para>

<para>The <literal>OPTION(ACCESS</literal>) (in <emphasis>params_intro</emphasis>) specifies the <literal>ACCESS</literal> properties of the corresponding parameter, just as for a variable declaration.</para>

<para>In <emphasis>body</emphasis> the only <literal>TAG</literal>s which may be used as an argument of <emphasis>obtain_tag</emphasis> are those which are declared by <emphasis>identify</emphasis> or <emphasis>variable</emphasis> constructions in <emphasis>body</emphasis> and which are in scope, or <literal>TAG</literal>s which are declared by <emphasis>make_id_tagdef</emphasis>, <emphasis>make_var_tagdef</emphasis> or <emphasis>common_tagdef</emphasis> or are in <emphasis>params_intro</emphasis> or <emphasis>var_intro</emphasis>. If a <emphasis>make_proc</emphasis> occurs in <emphasis>body</emphasis> its <literal>TAG</literal>s are not in scope.</para>

<para>The argument of every <emphasis>return</emphasis> construction in <emphasis>body</emphasis> will have <literal>SHAPE</literal> <emphasis>result_shape</emphasis>. Every <emphasis>apply_proc</emphasis> using the procedure will specify the <literal>SHAPE</literal> of it result to be <emphasis>result_shape</emphasis>.</para>

<para>For notes on the intended implementation of procedures see -XREF-spec10.html#18section 7.9.</para>



</sect2>
<sect2>
<title>make_stack_limit</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>116</member>
</simplelist>

<programlisting>
<emphasis>stack_base</emphasis>:  EXP POINTER(<emphasis>fa</emphasis>)
<emphasis>frame_size</emphasis>:  EXP OFFSET(<emphasis>locals_alignment</emphasis>, <emphasis>x</emphasis>)
<emphasis>alloc_size</emphasis>:  EXP OFFSET(<emphasis>alloca_alignment</emphasis>, <emphasis>y</emphasis>)
-&gt; EXP POINTER(<emphasis>fb</emphasis>)
</programlisting>

<para>This creates a POINTER suitable for use with <emphasis>set_stack_limit</emphasis>. </para>

<para><emphasis>fa</emphasis> and <emphasis>fb</emphasis> will include <emphasis>locals_alignment</emphasis> and, if <emphasis>alloc_size</emphasis> is not the zero offset, will also contain <emphasis>alloca_alignment</emphasis>.</para>

<para>The result will be the same as if given by:
<para>Assume <emphasis>stack_base</emphasis> is the current frame-pointer as given by <emphasis>current_env</emphasis> in a hypothetical procedure P with <emphasis>env_size</emphasis> equal to <emphasis>frame_size</emphasis> and which has generated <emphasis>alloc_size</emphasis> by a <emphasis>local_alloc</emphasis>. If P then calls Q, the result will be the same as that of a <emphasis>current_env</emphasis> performed immediately in the body of Q.</para>
<para>If the following construction is performed:</para>
<para>set_stack_limit(make_stack_limit(current_env, F, A))</para>
<para>the frame space and local_alloc space that would be available for use by this supposed call of Q will not be reused by procedure calls with <emphasis>check_stack</emphasis> or uses of <emphasis>local_alloc_check</emphasis> after the <emphasis>set_stack_limit</emphasis>. Any attempt to do so will raise a TDF exception, <emphasis>stack_overflow</emphasis>.</para>




</sect2>
<sect2>
<title>make_top</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>69</member>
</simplelist>

<programlisting>
-&gt; EXP TOP
</programlisting>

<para><emphasis>make_top</emphasis> delivers a value of <literal>SHAPE TOP</literal> (i.e. <emphasis>void</emphasis>).</para>



</sect2>
<sect2>
<title>make_value</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>70</member>
</simplelist>

<programlisting>
<emphasis>s</emphasis>:       SHAPE
-&gt; EXP <emphasis>s</emphasis>
</programlisting>

<para>This <literal>EXP</literal> creates some value with the representation of the <literal>SHAPE</literal> <emphasis>s</emphasis>. This value will have the correct size, but its representation is not specified. It can be assigned, be the result of a <emphasis>contents</emphasis>, a parameter or result of a procedure, or the result of any construction (like <emphasis>sequence</emphasis>) which delivers the value delivered by an internal <literal>EXP</literal>. But if it is used for arithmetic or as a <literal>POINTER</literal> for taking <emphasis>contents</emphasis> or <emphasis>add_to_ptr</emphasis> etc. the effect is undefined. </para>

<para>Installers will usually be able to implement this operation by producing no code.</para>

<para>Note that a floating point NaN is a possible value for this purpose.</para>

<para>The <literal>SHAPE</literal> <emphasis>s</emphasis> will not be <literal>BOTTOM</literal>.</para>



</sect2>
<sect2>
<title>maximum</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>71</member>
</simplelist>

<programlisting>
<emphasis>arg1</emphasis>:        EXP INTEGER(<emphasis>v</emphasis>)
<emphasis>arg2</emphasis>:        EXP INTEGER(<emphasis>v</emphasis>)
-&gt; EXP INTEGER(<emphasis>v</emphasis>)
</programlisting>

<para>The arguments will be evaluated and the maximum of the values delivered is the result. </para>



</sect2>
<sect2>
<title>minimum</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>72</member>
</simplelist>

<programlisting>
<emphasis>arg1</emphasis>:        EXP INTEGER(<emphasis>v</emphasis>)
<emphasis>arg2</emphasis>:        EXP INTEGER(<emphasis>v</emphasis>)
-&gt; EXP INTEGER(<emphasis>v</emphasis>)
</programlisting>

<para>The arguments will be evaluated and the minimum of the values delivered is the result. </para>



</sect2>
<sect2>
<title>minus</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>73</member>
</simplelist>

<programlisting>
<emphasis>ov_err</emphasis>:      ERROR_TREATMENT
<emphasis>arg1</emphasis>:        EXP INTEGER(<emphasis>v</emphasis>)
<emphasis>arg2</emphasis>:        EXP INTEGER(<emphasis>v</emphasis>)
-&gt; EXP INTEGER(<emphasis>v</emphasis>)
</programlisting>

<para><emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated and will produce integer values, <emphasis>a</emphasis> and <emphasis>b</emphasis>, of the same <literal>VARIETY</literal>, <emphasis>v</emphasis>. The difference <emphasis>a</emphasis>-<emphasis>b</emphasis> is delivered as the result of the construct, with the same <literal>SHAPE</literal> as the arguments.</parA>

<para>If the result cannot be expressed in the <literal>VARIETY</literal> being used to represent <emphasis>v</emphasis>, an overflow error is caused and is handled in the way specified by <emphasis>ov_err</emphasis>.</para>



</sect2>
<sect2>
<title>move_some</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>74</member>
</simplelist>

<programlisting>
<emphasis>md</emphasis>:      TRANSFER_MODE
<emphasis>arg1</emphasis>:        EXP POINTER(<emphasis>x</emphasis>)
<emphasis>arg2</emphasis>:        EXP POINTER(<emphasis>y</emphasis>)
<emphasis>arg3</emphasis>:        EXP OFFSET(<emphasis>z</emphasis>, <emphasis>t</emphasis>)
-&gt; EXP TOP
</programlisting>

<para>The arguments are evaluated to produce <emphasis>p1</emphasis>, <emphasis>p2</emphasis>, and <emphasis>sz</emphasis> respectively. A quantity of data measured by <emphasis>sz</emphasis> in the space indicated by <emphasis>p1</emphasis> is moved to the space indicated by <emphasis>p2</emphasis>. The operation will be carried out as specified by the <literal>TRANSFER_MODE</literal> (q.v.). </para>

<para><emphasis>x</emphasis> will include <emphasis>z</emphasis> and <emphasis>y</emphasis> will include <emphasis>z</emphasis>.</para>

<para><emphasis>sz</emphasis> will be a non-negative <literal>OFFSET</literal>, see -XREF-#M169offset_pad.</para>

<para>If the spaces of size <emphasis>sz</emphasis> to which <emphasis>p1</emphasis> and <emphasis>p2</emphasis> point do not lie entirely within the spaces indicated by the original pointers from which they are derived, the effect of the operation is undefined.</para>

<para>If the value delivered by <emphasis>arg1</emphasis> or <emphasis>arg2</emphasis> is a null pointer the effect is undefined.</para>

<para>See -XREF-spec10.html#48Overlapping.</para>



</sect2>
<sect2>
<title>mult</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>75</member>
</simplelist>

<programlisting>
<emphasis>ov_err</emphasis>:      ERROR_TREATMENT
<emphasis>arg1</emphasis>:        EXP INTEGER(<emphasis>v</emphasis>)
<emphasis>arg2</emphasis>:        EXP INTEGER(<emphasis>v</emphasis>)
-&gt; EXP INTEGER(<emphasis>v</emphasis>)
</programlisting>

<para><emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated and will produce integer values, <emphasis>a</emphasis> and <emphasis>b</emphasis>, of the same <literal>VARIETY</literal>, <emphasis>v</emphasis>. The product <emphasis>a</emphasis>*<emphasis>b</emphasis> is delivered as the result of the construct, with the same <literal>SHAPE</literal> as the arguments.</para>

<para>If the result cannot be expressed in the <literal>VARIETY</literal> being used to represent <emphasis>v</emphasis>, an overflow error is caused and is handled in the way specified by <emphasis>ov_err</emphasis>.</para>



</sect2>
<sect2>
<title>n_copies</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>76</member>
</simplelist>

<programlisting>
<emphasis>n</emphasis>:       NAT
<emphasis>arg1</emphasis>:        EXP <emphasis>x</emphasis>
-&gt; EXP NOF(<emphasis>n</emphasis>, <emphasis>x</emphasis>)
</programlisting>

<para><emphasis>arg1</emphasis> is evaluated and an <literal>NOF</literal> value is delivered which contains <emphasis>n</emphasis> copies of this value. <emphasis>n</emphasis> can be zero or one or greater.</parA>

<para>Producers are encouraged to use <emphasis>n_copies</emphasis> to initialise arrays of known size.</para>



</sect2>
<sect2>
<title>negate</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>77</member>
</simplelist>

<programlisting>
<emphasis>ov_err</emphasis>:      ERROR_TREATMENT
<emphasis>arg1</emphasis>:        EXP INTEGER(<emphasis>v</emphasis>)
-&gt; EXP INTEGER(<emphasis>v</emphasis>)
</programlisting>

<para><emphasis>arg1</emphasis> is evaluated and will produce an integer value, <emphasis>a</emphasis>. The value -<emphasis>a</emphasis> is delivered as the result of the construct, with the same <literal>SHAPE</literal> as the argument.</para>

<para>If the result cannot be expressed in the <literal>VARIETY</literal> being used to represent <emphasis>v</emphasis>, an overflow error is caused and is handled in the way specified by <emphasis>ov_err</emphasis>.</para>



</sect2>
<sect2>
<title>not</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>78</member>
</simplelist>

<programlisting>
<emphasis>arg1</emphasis>:        EXP INTEGER(<emphasis>v</emphasis>)
-&gt; EXP INTEGER(<emphasis>v</emphasis>)
</programlisting>

<para>The argument is evaluated producing an integer value, of <literal>VARIETY</literal>, <emphasis>v</emphasis>. The result is the bitwise <emphasis>not</emphasis> of this value in the representing <literal>VARIETY</literal>. The result is delivered as the result of the construct, with the same <literal>SHAPE</literal> as the arguments. </para>

<para>See -XREF-spec10.html#51Representing integers.</para>



</sect2>
<sect2>
<title>obtain_tag</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>79</member>
</simplelist>

<programlisting>
<emphasis>t</emphasis>:       TAG <emphasis>x</emphasis>
-&gt; EXP <emphasis>x</emphasis>
</programlisting>

<para>The value with which the <literal>TAG</literal> <emphasis>t</emphasis> is bound is delivered. The <literal>SHAPE</literal> of the result is the <literal>SHAPE</literal> of the value with which the <literal>TAG</literal> is bound. </para>



</sect2>
<sect2>
<title>offset_add</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>80</member>
</simplelist>

<programlisting>
<emphasis>arg1</emphasis>:        EXP OFFSET(<emphasis>x</emphasis>, <emphasis>y</emphasis>)
<emphasis>arg2</emphasis>:        EXP OFFSET(<emphasis>z</emphasis>, <emphasis>t</emphasis>)
-&gt; EXP OFFSET(<emphasis>x</emphasis>, <emphasis>t</emphasis>)
</programlisting>

<para>The two arguments deliver <literal>OFFSET</literal>s. The result is the sum of these <literal>OFFSET</literal>s, as an <literal>OFFSET</literal>. </para>

<para><emphasis>y</emphasis> will include <emphasis>z</emphasis>.</para>

<para>The effect of the constraint &quot;y will include z&quot; is that, in the simple representation of pointer arithmetic, this operation can be represented by addition. offset_add can lose information, so that offset_subtract does not have the usual relation with it.</para>



</sect2>
<sect2>
<title>offset_div</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>81</member>
</simplelist>

<programlisting>
<emphasis>v</emphasis>:       VARIETY
<emphasis>arg1</emphasis>:        EXP OFFSET(<emphasis>x</emphasis>, <emphasis>x</emphasis>)
<emphasis>arg2</emphasis>:        EXP OFFSET(<emphasis>x</emphasis>, <emphasis>x</emphasis>)
-&gt; EXP INTEGER(<emphasis>v</emphasis>)
</programlisting>

<para>The two arguments deliver <literal>OFFSET</literal>s, <emphasis>a</emphasis> and <emphasis>b</emphasis>. The result is <emphasis>a/b</emphasis>, as an <literal>INTEGER</literal> of <literal>VARIETY</literal>, <emphasis>v</emphasis>. Division is interpreted in the same sense (with respect to remainder) as in <emphasis>div0</emphasis>. </para>

<para>The value produced by <emphasis>arg2</emphasis> will be non-zero.</para>



</sect2>
<sect2>
<title>offset_div_by_int</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>82</member>
</simplelist>

<programlisting>
<emphasis>arg1</emphasis>:        EXP OFFSET(<emphasis>x</emphasis>, <emphasis>x</emphasis>)
<emphasis>arg2</emphasis>:        EXP INTEGER(<emphasis>v</emphasis>)
-&gt; EXP OFFSET(<emphasis>x</emphasis>, <emphasis>x</emphasis>)
</programlisting>

<para>The result is the <literal>OFFSET</literal> produced by <emphasis>arg1</emphasis> divided by <emphasis>arg2</emphasis>, as an <literal>OFFSET</literal>(<emphasis>x</emphasis>, <emphasis>x</emphasis>). </para>

<para>The value produced by <emphasis>arg2</emphasis> will be greater than zero.</para>

<para>The following identity will apply for all A and n:</para>

<para><emphasis>offset_mult</emphasis>(<emphasis>offset_div_by_int</emphasis>(A, n), n) = A</para>



</sect2>
<sect2>
<title>offset_max</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>83</member>
</simplelist>

<programlisting>
<emphasis>arg1</emphasis>:        EXP OFFSET(<emphasis>x</emphasis>, <emphasis>y</emphasis>)
<emphasis>arg2</emphasis>:        EXP OFFSET(<emphasis>z</emphasis>, <emphasis>y</emphasis>)
-&gt; EXP OFFSET(<emphasis>unite_alignments</emphasis>(<emphasis>x</emphasis>, <emphasis>z</emphasis>), <emphasis>y</emphasis>)
</programlisting>

<para>The two arguments deliver <literal>OFFSET</literal>s. The result is the maximum of these <literal>OFFSET</literal>s, as an <literal>OFFSET</literal>. </para>

<para>See -XREF-spec10.html#31Comparison of pointers and offsets.</para>

<para>In the simple memory model this operation is represented by maximum. The constraint that the second <literal>ALIGNMENT</literal> parameters are both y is to permit the representation of <literal>OFFSET</literal>s in installers by a simple homomorphism.</para>



</sect2>
<sect2>
<title>offset_mult</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>84</member>
</simplelist>

<programlisting>
<emphasis>arg1</emphasis>:        EXP OFFSET(<emphasis>x</emphasis>, <emphasis>x</emphasis>)
<emphasis>arg2</emphasis>:        EXP INTEGER(<emphasis>v</emphasis>)
-&gt; EXP OFFSET(<emphasis>x</emphasis>, <emphasis>x</emphasis>)
</programlisting>

<para>The first argument gives an <literal>OFFSET</literal>, <emphasis>off</emphasis>, and the second an integer, <emphasis>n</emphasis>. The result is the product of these, as an offset. </para>

<para>The result shall be equal to <emphasis>offset_adding off n</emphasis> times to <emphasis>offset_zero</emphasis>(<emphasis>x</emphasis>).</para>



</sect2>
<sect2>
<title>offset_negate</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>85</member>
</simplelist>

<programlisting>
<emphasis>arg1</emphasis>:        EXP OFFSET(<emphasis>x</emphasis>, <emphasis>x</emphasis>)
-&gt; EXP OFFSET(<emphasis>x</emphasis>, <emphasis>x</emphasis>)
</programlisting>

<para>The inverse of the argument is delivered. </para>

<para>In the simple memory model this can be represented by negate.</para>



</sect2>
<sect2>
<title>offset_pad</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>86</member>
</simplelist>

<programlisting>
<emphasis>a</emphasis>:       ALIGNMENT
<emphasis>arg1</emphasis>:        EXP OFFSET(<emphasis>z</emphasis>, <emphasis>t</emphasis>)
-&gt; EXP OFFSET(<emphasis>unite_alignments</emphasis>(<emphasis>z</emphasis>, <emphasis>a</emphasis>), <emphasis>a</emphasis>)
</programlisting>

<para><emphasis>arg1</emphasis> is evaluated giving <emphasis>off</emphasis>. The next greater or equal <literal>OFFSET</literal> at which a value of <literal>ALIGNMENT</literal> <emphasis>a</emphasis> can be placed is delivered. That is, there shall not exist an <literal>OFFSET</literal> of the same <literal>SHAPE</literal> as the result which is greater than or equal to <emphasis>off</emphasis> and less than the result, in the sense of <emphasis>offset_test</emphasis>.</para>

<para><emphasis>off</emphasis> will be a non-negative <literal>OFFSET</literal>, that is it will be greater than or equal to a zero <literal>OFFSET</literal> of the same <literal>SHAPE</literal> in the sense of <emphasis>offset_test</emphasis>.</para>

<para>In the simple memory model this operation can be represented by ((off + a - 1) / a) * a. In the simple model this is the only operation which is not represented by a simple corresponding integer operation.</para>



</sect2>
<sect2>
<title>offset_subtract</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>87</member>
</simplelist>

<programlisting>
<emphasis>arg1</emphasis>:        EXP OFFSET(<emphasis>x</emphasis>, <emphasis>y</emphasis>)
<emphasis>arg2</emphasis>:        EXP OFFSET(<emphasis>x</emphasis>, <emphasis>z</emphasis>)
-&gt; EXP OFFSET(<emphasis>z</emphasis>, <emphasis>y</emphasis>)
</programlisting>

<para>The two arguments deliver offsets, <emphasis>p</emphasis> and <emphasis>q</emphasis>. The result is <emphasis>p</emphasis>-<emphasis>q</emphasis>, as an offset. </para>

<para>Note that <emphasis>x</emphasis> will include <emphasis>y</emphasis>, <emphasis>x</emphasis> will include <emphasis>z</emphasis> and <emphasis>z</emphasis> will include <emphasis>y</emphasis>, by the constraints on <literal>OFFSET</literal>s.</para>

<para>offset_subtract and offset_add do not have the conventional relationship because offset_add can lose information, which cannot be regenerated by offset_subtract.</para>



</sect2>
<sect2>
<title>offset_test</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>88</member>
</simplelist>

<programlisting>
<emphasis>prob</emphasis>:        OPTION(NAT)
<emphasis>nt</emphasis>:      NTEST
<emphasis>dest</emphasis>:        LABEL
<emphasis>arg1</emphasis>:        EXP OFFSET(<emphasis>x</emphasis>, <emphasis>y</emphasis>)
<emphasis>arg2</emphasis>:        EXP OFFSET(<emphasis>x</emphasis>, <emphasis>y</emphasis>)
-&gt; EXP TOP
</programlisting>

<para><emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated and will produce offset values, <emphasis>a</emphasis> and <emphasis>b</emphasis>. These values are compared using <emphasis>nt</emphasis>.</para>

<para>If <emphasis>a nt b</emphasis>, this construction yields <literal>TOP</literal>. Otherwise control passes to <emphasis>dest</emphasis>.</para>

<para>If <emphasis>prob</emphasis> is present, <emphasis>prob</emphasis>/100 gives the probability that control will continue to the next construct (ie. not pass to <emphasis>dest</emphasis>). If <emphasis>prob</emphasis> is absent this probability is unknown.</para>

<para><emphasis>a greater_than_or_equal b</emphasis> is equivalent to <emphasis>offset_max</emphasis>(<emphasis>a</emphasis>, <emphasis>b</emphasis>) = <emphasis>a</emphasis>, and similarly for the other comparisons.</para>

<para>In the simple memory model this can be represented by integer_test.</para>



</sect2>
<sect2>
<title>offset_zero</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>89</member>
</simplelist>

<programlisting>
<emphasis>a</emphasis>:       ALIGNMENT
-&gt; EXP OFFSET(<emphasis>a</emphasis>, <emphasis>a</emphasis>)
</programlisting>

<para>A zero offset of <literal>SHAPE OFFSET</literal>(<emphasis>a</emphasis>, <emphasis>a</emphasis>). </para>

<para><emphasis>offset_pad</emphasis>(<emphasis>b</emphasis>, <emphasis>offset_zero</emphasis>(<emphasis>a</emphasis>)) is a zero offset of <literal>SHAPE OFFSET</literal>(<emphasis>unite_alignments</emphasis>(<emphasis>a</emphasis>, <emphasis>b</emphasis>), <emphasis>b</emphasis>).</para>



</sect2>
<sect2>
<title>or</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>90</member>
</simplelist>

<programlisting>
<emphasis>arg1</emphasis>:        EXP INTEGER(<emphasis>v</emphasis>)
<emphasis>arg2</emphasis>:        EXP INTEGER(<emphasis>v</emphasis>)
-&gt; EXP INTEGER(<emphasis>v</emphasis>)
</programlisting>

<para>The arguments are evaluated producing integer values of the same <literal>VARIETY</literal>, <emphasis>v</emphasis>. The result is the bitwise <emphasis>or</emphasis> of these two integers in the representing <literal>VARIETY</literal>. The result is delivered as the result of the construct, with the same <literal>SHAPE</literal> as the arguments. </para>

<para>See -XREF-spec10.html#51Representing integers.</para>



</sect2>
<sect2>
<title>plus</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>91</member>
</simplelist>

<programlisting>
<emphasis>ov_err</emphasis>:      ERROR_TREATMENT
<emphasis>arg1</emphasis>:        EXP INTEGER(<emphasis>v</emphasis>)
<emphasis>arg2</emphasis>:        EXP INTEGER(<emphasis>v</emphasis>)
-&gt; EXP INTEGER(<emphasis>v</emphasis>)
</programlisting>

<para><emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated and will produce integer values, <emphasis>a</emphasis> and <emphasis>b</emphasis>, of the same <literal>VARIETY</literal>, <emphasis>v</emphasis>. The sum <emphasis>a</emphasis>+<emphasis>b</emphasis> is delivered as the result of the construct, with the same <literal>SHAPE</literal> as the arguments.</para>

<para>If the result cannot be expressed in the <literal>VARIETY</literal> being used to represent <emphasis>v</emphasis>, an overflow error is caused and is handled in the way specified by <emphasis>ov_err</emphasis>.</para>



</sect2>
<sect2>
<title>pointer_test</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>92</member>
</simplelist>

<programlisting>
<emphasis>prob</emphasis>:        OPTION(NAT)
<emphasis>nt</emphasis>:      NTEST
<emphasis>dest</emphasis>:        LABEL
<emphasis>arg1</emphasis>:        EXP POINTER(<emphasis>x</emphasis>)
<emphasis>arg2</emphasis>:        EXP POINTER(<emphasis>x</emphasis>)
-&gt; EXP TOP
</programlisting>

<para><emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated and will produce pointer values, <emphasis>a</emphasis> and <emphasis>b</emphasis>, which will be derived from the same original pointer. These values are compared using <emphasis>nt</emphasis>.</para>

<para>If <emphasis>a nt b</emphasis>, this construction yields <literal>TOP</literal>. Otherwise control passes to <emphasis>dest</emphasis>.</para>

<para>If <emphasis>prob</emphasis> is present, <emphasis>prob</emphasis>/100 gives the probability that control will continue to the next construct (ie. not pass to <emphasis>dest</emphasis>). If <emphasis>prob</emphasis> is absent this probability is unknown.</para>

<para>The effect of this construction is the same as:</para>

<para><emphasis>offset_test</emphasis>(<emphasis>prob, nt</emphasis>, <emphasis>dest</emphasis>, <emphasis>subtract_ptrs</emphasis>(<emphasis>arg1</emphasis> , <emphasis>arg2</emphasis>), <emphasis>offset_zero</emphasis>(<emphasis>x</emphasis>))</para>

<para>In the simple memory model this construction can be represented by integer_test.</para>



</sect2>
<sect2>
<title>power</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>93</member>
</simplelist>

<programlisting>
<emphasis>ov_err</emphasis>:      ERROR_TREATMENT
<emphasis>arg1</emphasis>:        EXP INTEGER(<emphasis>v</emphasis>)
<emphasis>arg2</emphasis>:        EXP INTEGER(<emphasis>w</emphasis>)
-&gt; EXP INTEGER(<emphasis>v</emphasis>)
</programlisting>

<para><emphasis>arg2</emphasis> will be non-negative. The result is the result of <emphasis>arg1</emphasis> raised to the power given by <emphasis>arg2</emphasis>.</para>

<para>If the result cannot be expressed in the <literal>VARIETY</literal> being used to represent <emphasis>v</emphasis>, an overflow error is caused and is handled in the way specified by <emphasis>ov_err</emphasis>.</para>



</sect2>
<sect2>
<title>proc_test</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>94</member>
</simplelist>

<programlisting>
<emphasis>prob</emphasis>:        OPTION(NAT)
<emphasis>nt</emphasis>:      NTEST
<emphasis>dest</emphasis>:        LABEL
<emphasis>arg1</emphasis>:        EXP PROC
<emphasis>arg2</emphasis>:        EXP PROC
-&gt; EXP TOP
</programlisting>

<para><emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated and will produce <literal>PROC</literal> values, <emphasis>a</emphasis> and <emphasis>b</emphasis>. These values are compared using <emphasis>nt</emphasis>. The only permitted values of <emphasis>nt</emphasis> are <emphasis>equal</emphasis> and <emphasis>not_equal</emphasis>.</para>

<para>If <emphasis>a nt b</emphasis>, this construction yields <literal>TOP</literal>. Otherwise control passes to <emphasis>dest</emphasis>.</para>

<para>If <emphasis>prob</emphasis> is present, <emphasis>prob</emphasis>/100 gives the probability that control will continue to the next construct (ie. not pass to <emphasis>dest</emphasis>). If <emphasis>prob</emphasis> is absent this probability is unknown.</para>

<para>Two <literal>PROC</literal>s are equal if they were produced by the same instantiation of <emphasis>make_proc</emphasis> or if they were both made with <emphasis>make_null_proc</emphasis>. Otherwise they are unequal.</para>



</sect2>
<sect2>
<title>profile</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>95</member>
</simplelist>

<programlisting>
<emphasis>uses</emphasis>:        NAT
-&gt; EXP TOP
</programlisting>

<para>The integer <emphasis>uses</emphasis> gives the number of times which this construct is expected to be evaluated. </para>

<para>All uses of <emphasis>profile</emphasis> in the same capsule are to the same scale. They will be mutually consistent.</para>



</sect2>
<sect2>
<title>real_part</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>96</member>
</simplelist>

<programlisting>
<emphasis>arg1</emphasis>:        EXP <emphasis>c</emphasis>
-&gt; EXP FLOATING (<emphasis>float_of_complex(c)</emphasis>)
</programlisting>

<para><emphasis>c</emphasis> will be complex. Delivers the real part of the value produced by <emphasis>arg1</emphasis>.</para>



</sect2>
<sect2>
<title>rem0</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>97</member>
</simplelist>

<programlisting>
<emphasis>div_by_0_err</emphasis>:    ERROR_TREATMENT
<emphasis>ov_err</emphasis>:      ERROR_TREATMENT
<emphasis>arg1</emphasis>:        EXP INTEGER(<emphasis>v</emphasis>)
<emphasis>arg2</emphasis>:        EXP INTEGER(<emphasis>v</emphasis>)
-&gt; EXP INTEGER(<emphasis>v</emphasis>)
</programlisting>

<para><emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated and will produce integer values, <emphasis>a</emphasis> and <emphasis>b</emphasis>, of the same <literal>VARIETY</literal>, <emphasis>v</emphasis>. The value <emphasis>a</emphasis> M1 <emphasis>b</emphasis> or the value <emphasis>a</emphasis> M2 <emphasis>b</emphasis> is delivered as the result of the construct, with the same <literal>SHAPE</literal> as the arguments. Different occurrences of <emphasis>rem0</emphasis> in the same capsule can use M1 or M2 independently.</para>

<para>The following equivalence shall hold:</para>

<programlisting>
<emphasis>x = plus(mult(div0(x, y), y), rem0(x, y))</emphasis>
</programlisting>

<para>if all the <literal>ERROR_TREATMENT</literal>s are <emphasis>impossible</emphasis>, and <emphasis>x</emphasis> and <emphasis>y</emphasis> have no side effects. </para>

<para>If <emphasis>b</emphasis> is zero a div_by_zero error occurs and is handled by <emphasis>div_by_0_err</emphasis>.</para>

<para>If <emphasis>b</emphasis> is not zero and <emphasis>div0</emphasis>(<emphasis>a</emphasis>, <emphasis>b</emphasis>) cannot be expressed in the <literal>VARIETY</literal> being used to represent <emphasis>v</emphasis> an overflow may occur in which case it is handled by <emphasis>ov_err</emphasis>.</para>

<para>Producers may assume that suitable masking and <emphasis>rem0</emphasis> by a power of two yield equally good code.</para>

<para>See -XREF-spec10.html#10Division and modulus for the definitions of D1, D2, M1 and M2.</para>



</sect2>
<sect2>
<title>rem1</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>98</member>
</simplelist>

<programlisting>
<emphasis>div_by_0_err</emphasis>:    ERROR_TREATMENT
<emphasis>ov_err</emphasis>:      ERROR_TREATMENT
<emphasis>arg1</emphasis>:        EXP INTEGER(<emphasis>v</emphasis>)
<emphasis>arg2</emphasis>:        EXP INTEGER(<emphasis>v</emphasis>)
-&gt; EXP INTEGER(<emphasis>v</emphasis>)
</programlisting>

<para><emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated and will produce integer values, <emphasis>a</emphasis> and <emphasis>b</emphasis>, of the same <literal>VARIETY</literal>, <emphasis>v</emphasis>. The value <emphasis>a</emphasis> M1 <emphasis>b</emphasis> is delivered as the result of the construct, with the same <literal>SHAPE</literal> as the arguments.</para>

<para>If <emphasis>b</emphasis> is zero a div_by_zero error occurs and is handled by <emphasis>div_by_0_err</emphasis>.</para>

<para>If <emphasis>b</emphasis> is not zero and <emphasis>div1</emphasis>(<emphasis>a</emphasis>, <emphasis>b</emphasis>) cannot be expressed in the <literal>VARIETY</literal> being used to represent <emphasis>v</emphasis> an overflow may occur, in which case it is handled by <emphasis>ov_err</emphasis>.</para>

<para>Producers may assume that suitable masking and <emphasis>rem1</emphasis> by a power of two yield equally good code.</para>

<para>See -XREF-spec10.html#10Division and modulus for the definitions of D1, D2, M1 and M2.</para>



</sect2>
<sect2>
<title>rem2</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>99</member>
</simplelist>

<programlisting>
<emphasis>div_by_0_err</emphasis>:    ERROR_TREATMENT
<emphasis>ov_err</emphasis>:      ERROR_TREATMENT
<emphasis>arg1</emphasis>:        EXP INTEGER(<emphasis>v</emphasis>)
<emphasis>arg2</emphasis>:        EXP INTEGER(<emphasis>v</emphasis>)
-&gt; EXP INTEGER(<emphasis>v</emphasis>)
</programlisting>

<para><emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated and will produce integer values, <emphasis>a</emphasis> and <emphasis>b</emphasis>, of the same <literal>VARIETY</literal>, <emphasis>v</emphasis>. The value <emphasis>a</emphasis> M2 <emphasis>b</emphasis> is delivered as the result of the construct, with the same <literal>SHAPE</literal> as the arguments.</para>

<para>If <emphasis>b</emphasis> is zero a div_by_zero error occurs and is handled by <emphasis>div_by_0_err</emphasis>.</para>

<para>If <emphasis>b</emphasis> is not zero and <emphasis>div2</emphasis>(<emphasis>a</emphasis>, <emphasis>b</emphasis>) cannot be expressed in the <literal>VARIETY</literal> being used to represent <emphasis>v</emphasis> an overflow may occur, in which case it is handled by <emphasis>ov_err</emphasis>.</para>

<para>Producers may assume that suitable masking and <emphasis>rem2</emphasis> by a power of two yield equally good code if the lower bound of <emphasis>v</emphasis> is zero.</para>

<para>See -XREF-spec10.html#10Division and modulus for the definitions of D1, D2, M1 and M2.</para>



</sect2>
<sect2>
<title>repeat</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>100</member>
</simplelist>

<programlisting>
<emphasis>replab_intro</emphasis>:    LABEL
<emphasis>start</emphasis>:       EXP TOP
<emphasis>body</emphasis>:        EXP <emphasis>y</emphasis>
-&gt; EXP <emphasis>y</emphasis>
</programlisting>

<para><emphasis>start</emphasis> is evaluated. Then <emphasis>body</emphasis> is evaluated.</para>

<para>If <emphasis>body</emphasis> produces a result, this is the result of the whole construction. However if <emphasis>goto</emphasis> or any other jump to <emphasis>replab_intro</emphasis> is encountered during the evaluation then the current evaluation stops and <emphasis>body</emphasis> is evaluated again. In the canonical order all evaluated components are completely evaluated before any of the next iteration of <emphasis>body</emphasis>. The lifetime of <emphasis>replab_intro</emphasis> is the evaluation of <emphasis>body</emphasis>.</para>

<para>The actual order of evaluation of the constituents shall be indistinguishable in all observable effects (apart from time) from that described above. Note that this specifically includes any defined error handling.</para>



</sect2>
<sect2>
<title>return</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>101</member>
</simplelist>

<programlisting>
<emphasis>arg1</emphasis>:        EXP <emphasis>x</emphasis>
-&gt; EXP BOTTOM
</programlisting>

<para><emphasis>arg1</emphasis> is evaluated to produce a value, <emphasis>v</emphasis>. The evaluation of the immediately enclosing procedure ceases and <emphasis>v</emphasis> is delivered as the result of the procedure.</para>

<para>Since the <emphasis>return</emphasis> construct can never produce a value, the <literal>SHAPE</literal> of its result is <literal>BOTTOM</literal>.</para>

<para>All uses of <emphasis>return</emphasis> in the <emphasis>body</emphasis> of a <emphasis>make_proc</emphasis> or <emphasis>make_general_proc</emphasis> will have <emphasis>arg1</emphasis> with the same <literal>SHAPE</literal>.</para>



</sect2>
<sect2>
<title>return_to_label</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>102</member>
</simplelist>

<programlisting>
<emphasis>lab_val</emphasis>: EXP POINTER <emphasis>code_alignment</emphasis>
-&gt; EXP BOTTOM
</programlisting>

<para><emphasis>lab_val</emphasis> will be a label value in the calling procedure.</para>

<para>The evaluation of the immediately enclosing procedure ceases and control is passed to the calling procedure at the label given by <emphasis>lab_val</emphasis>.</para>



</sect2>
<sect2>
<title>round_with_mode</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>103</member>
</simplelist>

<programlisting>
<emphasis>flpt_err</emphasis>:    ERROR_TREATMENT
<emphasis>mode</emphasis>:        ROUNDING_MODE
<emphasis>r</emphasis>:       VARIETY
<emphasis>arg1</emphasis>:        EXP FLOATING(<emphasis>f</emphasis>)
-&gt; EXP INTEGER(<emphasis>r</emphasis>)
</programlisting>

<para><emphasis>arg</emphasis> is evaluated to produce a floating point value, <emphasis>v</emphasis>. This is rounded to an integer of <literal>VARIETY</literal>, <emphasis>r</emphasis>, using the <literal>ROUNDING_MODE</literal>, <emphasis>mode</emphasis>. This is the result of the construction.</para>

<para>If <emphasis>f</emphasis> is complex the result is derived from the real part of <emphasis>arg1</emphasis>.</para>

<para>If there is a floating point error it is handled by <emphasis>flpt_err</emphasis>. See -XREF-spec10.html#60Floating point errors.</para>



</sect2>
<sect2>
<title>rotate_left</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>104</member>
</simplelist>

<programlisting>
<emphasis>arg1</emphasis>:        EXP INTEGER(<emphasis>v</emphasis>)
<emphasis>arg2</emphasis>:        EXP INTEGER(<emphasis>w</emphasis>)
-&gt; EXP INTEGER(<emphasis>v</emphasis>)
</programlisting>

<para>The value delivered by <emphasis>arg1</emphasis> is rotated left <emphasis>arg2</emphasis> places. </para>

<para><emphasis>arg2</emphasis> will be non-negative and will be strictly less than the number of bits needed to represent <emphasis>v</emphasis>.</para>

<para>The use of this construct assumes knowledge of the representational variety of <emphasis>v</emphasis>.</para>



</sect2>
<sect2>
<title>rotate_right</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>105</member>
</simplelist>

<programlisting>
<emphasis>arg1</emphasis>:        EXP INTEGER(<emphasis>v</emphasis>)
<emphasis>arg2</emphasis>:        EXP INTEGER(<emphasis>w</emphasis>)
-&gt; EXP INTEGER(<emphasis>v</emphasis>)
</programlisting>

<para>The value delivered by <emphasis>arg1</emphasis> is rotated right <emphasis>arg2</emphasis> places. </para>

<para><emphasis>arg2</emphasis> will be non-negative and will be strictly less than the number of bits needed to represent <emphasis>v</emphasis>.</para>

<para>The use of this construct assumes knowledge of the representational variety of <emphasis>v</emphasis>.</para>



</sect2>
<sect2>
<title>sequence</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>106</member>
</simplelist>

<programlisting>
<emphasis>statements</emphasis>:  LIST(EXP)
<emphasis>result</emphasis>:      EXP <emphasis>x</emphasis>
-&gt; EXP <emphasis>x</emphasis>
</programlisting>

<para>The statements are evaluated in the same order as the list, <emphasis>statements</emphasis>, and their results are discarded. Then <emphasis>result</emphasis> is evaluated and its result forms the result of the construction. </para>

<para>A canonical order is one in which all the components of each statement are completely evaluated before any component of the next statement is started. A similar constraint applies between the last statement and the <emphasis>result</emphasis>. The actual order in which the statements and their components are evaluated shall be indistinguishable in all observable effects (apart from time) from a canonical order.</para>

<para>Note that this specifically includes any defined error handling. However, if in any canonical order the effect of the program is undefined, the actual effect of the sequence is undefined.</para>

<para>Hence constructions with <emphasis>impossible</emphasis> error handlers may be performed before or after those with specified error handlers, if the resulting order is otherwise acceptable.</para>



</sect2>
<sect2>
<title>set_stack_limit</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>107</member>
</simplelist>

<programlisting>
<emphasis>lim</emphasis>:     EXP POINTER({<emphasis>locals_alignment, alloca_alignment}</emphasis>)
-&gt; EXP TOP
</programlisting>

<para><emphasis>set_stack_limit</emphasis> sets the limits of remaining free stack space to <emphasis>lim</emphasis>. This include both the frame stack limit and the local_alloc stack. Note that, in implementations where the frame stack and local_alloc stack are distinct, this pointer will have a special representation, appropriate to its frame alignment. Thus the pointer should always be generated using <emphasis>make_stack_limit</emphasis> or its equivalent formation.</para>

<para>Any later <emphasis>apply_general_proc</emphasis> with <literal>PROCPROPS</literal> including <emphasis>check_stack</emphasis> up to the dynamically next <emphasis>set_stack_limit</emphasis> will check that the frame required for the procedure will be within the frame stack limit. If it is not, normal execution is stopped and a TDF exception with ERROR_CODE <emphasis>stack_overflow</emphasis> is raised.</para>

<para>Any later <emphasis>local_alloc_check</emphasis> will check that the locally allocated space required is within the local_alloc stack limit. If it is not, normal execution is stopped and a TDF exception with ERROR_CODE <emphasis>stack_overflow</emphasis> is raised.</para>



</sect2>
<sect2>
<title>shape_offset</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>108</member>
</simplelist>

<programlisting>
<emphasis>s</emphasis>:       SHAPE
-&gt; EXP OFFSET(<emphasis>alignment</emphasis>(<emphasis>s</emphasis>), {})
</programlisting>

<para>This construction delivers the This construction delivers the &quot;size&quot; of a value of the given <literal>SHAPE</literal>. quot;sizeThis construction delivers the &quot;size&quot; of a value of the given <literal>SHAPE</literal>. quot; of a value of the given <literal>SHAPE</literal>. </para>

<para>Suppose that a value of <literal>SHAPE</literal>, <emphasis>s</emphasis>, is placed in a space indicated by a <literal>POINTER</literal>(<emphasis>x</emphasis>), <emphasis>p</emphasis>, where <emphasis>x</emphasis> includes <emphasis>alignment(s</emphasis>). Suppose that a value of <literal>SHAPE</literal>, <emphasis>t</emphasis>, where <emphasis>a</emphasis> is <emphasis>alignment</emphasis>(<emphasis>t</emphasis>) and <emphasis>x</emphasis> includes <emphasis>a</emphasis>, is placed at</para>

<para><emphasis>add_to_ptr</emphasis>(<emphasis>p</emphasis>, <emphasis>offset_pad(a, shape_offset</emphasis>(<emphasis>s</emphasis>)))</para>

<para>Then the values shall not overlap. This shall be true for all legal <emphasis>s</emphasis>, <emphasis>x</emphasis> and <emphasis>t</emphasis>.</para>



</sect2>
<sect2>
<title>shift_left</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>109</member>
</simplelist>

<programlisting>
<emphasis>ov_err</emphasis>:      ERROR_TREATMENT
<emphasis>arg1</emphasis>:        EXP INTEGER(<emphasis>v</emphasis>)
<emphasis>arg2</emphasis>:        EXP INTEGER(<emphasis>w</emphasis>)
-&gt; EXP INTEGER(<emphasis>v</emphasis>)
</programlisting>

<para><emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated and will produce integer values, <emphasis>a</emphasis> and <emphasis>b</emphasis>. The value <emphasis>a</emphasis> shifted left <emphasis>b</emphasis> places is delivered as the result of the construct, with the same <literal>SHAPE</literal> as <emphasis>a</emphasis>.</para>

<para><emphasis>b</emphasis> will be non-negative and will be strictly less than the number of bits needed to represent <emphasis>v</emphasis>.</para>

<para>If the result cannot be expressed in the <literal>VARIETY</literal> being used to represent <emphasis>v</emphasis>, an overflow error is caused and is handled in the way specified by <emphasis>ov_err</emphasis>.</para>

<para>Producers may assume that <emphasis>shift_left</emphasis> and multiplication by a power of two yield equally efficient code.</para>



</sect2>
<sect2>
<title>shift_right</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>110</member>
</simplelist>

<programlisting>
<emphasis>arg1</emphasis>:        EXP INTEGER(<emphasis>v</emphasis>)
<emphasis>arg2</emphasis>:        EXP INTEGER(<emphasis>w</emphasis>)
-&gt; EXP INTEGER(<emphasis>v</emphasis>)
</programlisting>

<para><emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated and will produce integer values, <emphasis>a</emphasis> and <emphasis>b</emphasis>. The value <emphasis>a</emphasis> shifted right <emphasis>b</emphasis> places is delivered as the result of the construct, with the same <literal>SHAPE</literal> as <emphasis>arg1</emphasis>.</para>

<para><emphasis>b</emphasis> will be non-negative and will be strictly less than the number of bits needed to represent <emphasis>v</emphasis>.</para>

<para>If the lower bound of <emphasis>v</emphasis> is negative, the sign will be propagated.</para>



</sect2>
<sect2>
<title>subtract_ptrs</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>111</member>
</simplelist>

<programlisting>
<emphasis>arg1</emphasis>:        EXP POINTER(<emphasis>y</emphasis>)
<emphasis>arg2</emphasis>:        EXP POINTER(<emphasis>x</emphasis>)
-&gt; EXP OFFSET(<emphasis>x</emphasis>, <emphasis>y</emphasis>)
</programlisting>

<para><emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated to produce pointers <emphasis>p1</emphasis> and <emphasis>p2</emphasis>, which will be derived from the same original pointer. The result, <emphasis>r</emphasis>, is the <literal>OFFSET</literal> from <emphasis>p2</emphasis> to <emphasis>p1</emphasis>. Both arguments will be derived from the same original pointer.</para>

<para>Note that <emphasis>add_to_ptr</emphasis>(<emphasis>p2</emphasis>, <emphasis>r</emphasis>) = <emphasis>p1</emphasis>.</para>



</sect2>
<sect2>
<title>tail_call</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>112</member>
</simplelist>

<programlisting>
<emphasis>prcprops</emphasis>:    OPTION(PROCPROPS)
<emphasis>p</emphasis>:       EXP PROC
<emphasis>callee_pars</emphasis>: CALLEES
-&gt; EXP BOTTOM
</programlisting>

<para><emphasis>p</emphasis> is called in the sense of <emphasis>apply_general_proc</emphasis> with the caller parameters of the immediately enclosing proc and <literal>CALLEES</literal> given by <emphasis>callee_pars</emphasis> and <literal>PROCPROPS</literal> <emphasis>prcprops</emphasis>.</para>

<para>The result of the call is delivered as the result of the immediately enclosing proc in the sense of <emphasis>return</emphasis>. The <literal>SHAPE</literal> of the result of <emphasis>p</emphasis> will be identical to the <literal>SHAPE</literal> specified as the result of immediately enclosing procedure.</para>

<para>No pointers to any callee parameters, variables, identifications or local allocations defined in immediately enclosing procedure will be accessed either in the body of <emphasis>p</emphasis> or after the return.</para>

<para>The presence or absence of each of the <literal>PROCPROPS</literal> <emphasis>check_stack</emphasis> and <emphasis>untidy</emphasis>, in <emphasis>prcprops</emphasis> will be reflected in the <literal>PROCPROPS</literal> of the immediately enclosing procedure.</para>



</sect2>
<sect2>
<title>untidy_return</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>113</member>
</simplelist>

<programlisting>
<emphasis>arg1</emphasis>:        EXP <emphasis>x</emphasis>
-&gt; EXP BOTTOM
</programlisting>

<para><emphasis>arg1</emphasis> is evaluated to produce a value, <emphasis>v</emphasis>. The evaluation of the immediately enclosing procedure ceases and <emphasis>v</emphasis> is delivered as the result of the procedure, in such a manner as that pointers to any callee parameters or local allocations are valid in the calling procedure.</para>

<para><emphasis>untidy_return</emphasis> can only occur in a procedure defined by <emphasis>make_general_proc</emphasis> with <literal>PROCPROPS</literal> including <emphasis>untidy</emphasis>.</para>



</sect2>
<sect2>
<title>variable</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>114</member>
</simplelist>

<programlisting>
<emphasis>opt_access</emphasis>:  OPTION(ACCESS)
<emphasis>name_intro</emphasis>:  TAG POINTER(<emphasis>alignment(x</emphasis>))
<emphasis>init</emphasis>:        EXP <emphasis>x</emphasis>
<emphasis>body</emphasis>:        EXP <emphasis>y</emphasis>
-&gt; EXP <emphasis>y</emphasis>
</programlisting>

<para><emphasis>init</emphasis> is evaluated to produce a value, <emphasis>v</emphasis>. Space is allocated to hold a value of <literal>SHAPE</literal> <emphasis>x</emphasis> and this is initialised with <emphasis>v</emphasis>. Then <emphasis>body</emphasis> is evaluated. During this evaluation, an original <literal>POINTER</literal> pointing to the allocated space is bound to <emphasis>name_intro</emphasis>. This means that inside <emphasis>body</emphasis> an evaluation of <emphasis>obtain_tag</emphasis>(<emphasis>name_intro</emphasis>) will produce a <literal>POINTER</literal> to this space. The lifetime of <emphasis>name_intro</emphasis> is the evaluation of <emphasis>body</emphasis>.</para>

<para>The value delivered by <emphasis>variable</emphasis> is that produced by <emphasis>body</emphasis>.</para>

<para>If <emphasis>opt_access</emphasis> contains <emphasis>visible</emphasis>, it means that the contents of the space may be altered while the procedure containing this declaration is not the current procedure. Hence if there are any copies of this value they will need to be refreshed from the variable when the procedure is returned to. The easiest implementation when <emphasis>opt_access</emphasis> is <emphasis>visible</emphasis> may be to keep the value in memory, but this is not a necessary requirement.</para>

<para>The <literal>TAG</literal> given for <emphasis>name_intro</emphasis> will not be reused within the current <literal>UNIT</literal>. No rules for the hiding of one <literal>TAG</literal> by another are given: this will not happen.</para>

<para>The order in which the constituents of <emphasis>init</emphasis> and <emphasis>body</emphasis> are evaluated shall be indistinguishable in all observable effects (apart from time) from completely evaluating <emphasis>init</emphasis> before starting <emphasis>body</emphasis>. See the note about order in -XREF-#M193sequence.</para>

<para>When compiling languages which permit uninitialised variable declarations, <emphasis>make_value</emphasis> may be used to provide an initialisation.</para>



</sect2>
<sect2>
<title>xor</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>115</member>
</simplelist>

<programlisting>
<emphasis>arg1</emphasis>:        EXP INTEGER(<emphasis>v</emphasis>)
<emphasis>arg2</emphasis>:        EXP INTEGER(<emphasis>v</emphasis>)
-&gt; EXP INTEGER(<emphasis>v</emphasis>)
</programlisting>

<para>The arguments are evaluated producing integer values of the same <literal>VARIETY</literal>, <emphasis>v</emphasis>. The result is the bitwise <emphasis>xor</emphasis> of these two integers in the representing <literal>VARIETY</literal>. The result is delivered as the result of the construct, with the same <literal>SHAPE</literal> as the arguments. </para>

<para>See -XREF-spec10.html#51Representing integers.</para>

</sect2>
</sect1>



<sect1>
<title>EXTERNAL</title>
<simplelist type='horiz' columns='2'>

<member>Number of encoding bits:</member><member>2</member>
<member>Is coding extendable:</member><member>yes</member>
</simplelist>

<para>An <literal>EXTERNAL</literal> defines the classes of external name available for connecting the internal names inside a <literal>CAPSULE</literal> to the world outside the <literal>CAPSULE</literal>.</para>



<sect2>
<title>string_extern</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>1</member>
</simplelist>

<programlisting>
<emphasis>s</emphasis>:       BYTE_ALIGN TDFIDENT(<emphasis>n</emphasis>)
-&gt; EXTERNAL
</programlisting>

<para><emphasis>string_extern</emphasis> produces an <literal>EXTERNAL</literal> identified by the <literal>TDFIDENT</literal> <emphasis>s</emphasis>.</para>



</sect2>
<sect2>
<title>unique_extern</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>2</member>
</simplelist>

<programlisting>
<emphasis>u</emphasis>:       BYTE_ALIGN UNIQUE
-&gt; EXTERNAL
</programlisting>

<para><emphasis>unique_extern</emphasis> produces an <literal>EXTERNAL</literal> identified by the <literal>UNIQUE</literal> <emphasis>u</emphasis>.</para>



</sect2>
<sect2>
<title>chain_extern</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>3</member>
</simplelist>

<programlisting>
<emphasis>s</emphasis>:       BYTE_ALIGN TDFIDENT
<emphasis>prev</emphasis>:        TDFINT
-&gt; EXTERNAL
</programlisting>

<para>This construct is redundant and should not be used. </para>




</sect2>
</sect1>

<sect1>
<title>EXTERN_LINK</title>
<simplelist type='horiz' columns='2'>

<member>Number of encoding bits:</member><member>0</member>
<member>Is coding extendable:</member><member>no</member>
</simplelist>

<para>An auxiliary <literal>SORT</literal> providing a list of <literal>LINKEXTERN</literal>.</para>



<sect2>
<title>make_extern_link</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>0</member>
</simplelist>

<programlisting>
<emphasis>el</emphasis>:      SLIST(LINKEXTERN)
-&gt; EXTERN_LINK
</programlisting>

<para><emphasis>make_capsule</emphasis> requires a <literal>SLIST</literal>(<literal>EXTERN_LINK</literal>) to express the links between the linkable entities and the named (by <literal>EXTERNAL</literal>s) values outside the <literal>CAPSULE</literal>.</para>




</sect2>
</sect1>

<sect1>
<title>FLOATING_VARIETY</title>
<simplelist type='horiz' columns='2'>

<member>Number of encoding bits:</member><member>3</member>
<member>Is coding extendable:</member><member>yes</member>
</simplelist>

<para>These describe kinds of floating point number.</para>



<sect2>
<title>flvar_apply_token</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>1</member>
</simplelist>

<programlisting>
<emphasis>token_value</emphasis>: TOKEN
<emphasis>token_args</emphasis>:  BITSTREAM <emphasis>param_sorts(token_value)</emphasis>
-&gt; FLOATING_VARIETY
</programlisting>

<para>The token is applied to the arguments to give a <literal>FLOATING_VARIETY</literal></para>
<para>If there is a definition for <emphasis>token_value</emphasis> in the <literal>CAPSULE</literal> then <emphasis>token_args</emphasis> is a <literal>BITSTREAM</literal> encoding of the <literal>SORT</literal>s of its parameters, in the order specified.</para>



</sect2>
<sect2>
<title>flvar_cond</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>2</member>
</simplelist>

<programlisting>
<emphasis>control</emphasis>: EXP INTEGER(<emphasis>v</emphasis>)
<emphasis>e1</emphasis>:      BITSTREAM FLOATING_VARIETY
<emphasis>e2</emphasis>:      BITSTREAM FLOATING_VARIETY
-&gt; FLOATING_VARIETY
</programlisting>

<para>The <emphasis>control</emphasis> is evaluated. It will be a constant at install time under the constant evaluation rules. If it is non-zero, <emphasis>e1</emphasis> is installed at this point and <emphasis>e2</emphasis> is ignored and never processed. If <emphasis>control</emphasis> is zero then <emphasis>e2</emphasis> is installed at this point and <emphasis>e1</emphasis> is ignored and never processed. </para>



</sect2>
<sect2>
<title>flvar_parms</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>3</member>
</simplelist>

<programlisting>
<emphasis>base</emphasis>:        NAT
<emphasis>mantissa_digs</emphasis>:   NAT
<emphasis>min_exponent</emphasis>:    NAT
<emphasis>max_exponent</emphasis>:    NAT
-&gt; FLOATING_VARIETY
</programlisting>

<para><emphasis>base</emphasis> is the base with respect to which the remaining numbers refer. <emphasis>base</emphasis> will be a power of 2.</para>

<para><emphasis>mantissa_digs</emphasis> is the required number of <emphasis>base</emphasis> digits, <emphasis>q</emphasis>, such that any number with <emphasis>q</emphasis> digits can be rounded to a floating point number of the variety and back again without any change to the <emphasis>q</emphasis> digits.</para>

<para><emphasis>min_exponent</emphasis> is the negative of the required minimum integer such that <emphasis>base</emphasis> raised to that power can be represented as a non-zero floating point number in the <literal>FLOATING_VARIETY</literal>.</para>

<para><emphasis>max_exponent</emphasis> is the required maximum integer such that <emphasis>base</emphasis> raised to that power can be represented in the <literal>FLOATING_VARIETY</literal>.</para>

<para>A TDF translator is required to make available a representing <literal>FLOATING_VARIETY</literal> such that, if only values within the given requirements are produced, no overflow error will occur. Where several such representative <literal>FLOATING_VARIETY</literal>s exist, the translator will choose one to minimise space requirements or maximise the speed of operations.</para>

<para>All numbers of the form xb1 M*<emphasis>base N+1-q</emphasis> are required to be represented exactly where M and N are integers such that
<emphasis>base</emphasis><emphasis>q-1</emphasis> M &lt; <emphasis>base</emphasis><emphasis>q</emphasis>
-<emphasis>min_exponent</emphasis> N <emphasis>max_exponent</emphasis></para>

<para>Zero will also be represented exactly in any <literal>FLOATING_VARIETY</literal>.</para>



</sect2>
<sect2>
<title>complex_parms</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>4</member>
</simplelist>

<programlisting>
<emphasis>base</emphasis>:        NAT
<emphasis>mantissa_digs</emphasis>:   NAT
<emphasis>min_exponent</emphasis>:    NAT
<emphasis>max_exponent</emphasis>:    NAT
-&gt; FLOATING_VARIETY
</programlisting>

<para>A <literal>FLOATING_VARIETY</literal> described by <emphasis>complex_parms</emphasis> holds a complex number which is likely to be represented by its real and imaginary parts, each of which is as if defined by <emphasis>flvar_parms</emphasis> with the same arguments. </para>



</sect2>
<sect2>
<title>float_of_complex</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>5</member>
</simplelist>

<programlisting>
<emphasis>csh</emphasis>:     SHAPE
-&gt; FLOATING_VARIETY
</programlisting>

<para><emphasis>csh</emphasis> will be a complex <literal>SHAPE</literal>.</para>

<para>Delivers the <literal>FLOATING_VARIETY</literal> required for the real (or imaginary) part of a complex <literal>SHAPE</literal> <emphasis>csh</emphasis>.</para>



</sect2>
<sect2>
<title>complex_of_float</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>6</member>
</simplelist>

<programlisting>
<emphasis>fsh</emphasis>:     SHAPE
-&gt; FLOATING_VARIETY
</programlisting>

<para><emphasis>fsh</emphasis> will be a floating <literal>SHAPE</literal>.</para>

<para>Delivers <literal>FLOATING_VARIETY</literal> required for a complex number whose real (and imaginary) parts have <literal>SHAPE</literal> <emphasis>fsh</emphasis>.</para>




</sect2>
</sect1>

<sect1>
<title>GROUP</title>
<simplelist type='horiz' columns='2'>

<member>Number of encoding bits:</member><member>0</member>
<member>Is coding extendable:</member><member>no</member>
</simplelist>

<para>A <literal>GROUP</literal> is a list of <literal>UNIT</literal>s with the same unit identification.</para>



<sect2>
<title>make_group</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>0</member>
</simplelist>

<programlisting>
<emphasis>us</emphasis>:      SLIST(UNIT)
-&gt; GROUP
</programlisting>

<para><emphasis>make_capsule</emphasis> contains a list of <literal>GROUPS</literal>. Each member of this list has a different unit identification deduced from the <emphasis>prop_name</emphasis> argument of <emphasis>make_capsule</emphasis>.</para>




</sect2>
</sect1>

<sect1>
<title>LABEL</title>
<simplelist type='horiz' columns='2'>

<member>Number of encoding bits:</member><member>1</member>
<member>Is coding extendable:</member><member>yes</member>

</simplelist>
<para>A <literal>LABEL</literal> marks an <literal>EXP</literal> in certain constructions, and is used in jump-like constructions to change the control to the labelled construction.</para>



<sect2>
<title>label_apply_token</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>2</member>
</simplelist>

<programlisting>
<emphasis>token_value</emphasis>: TOKEN
<emphasis>token_args</emphasis>:  BITSTREAM <emphasis>param_sorts(token_value)</emphasis>
-&gt; LABEL <emphasis>x</emphasis>
</programlisting>

<para>The token is applied to the arguments to give a <literal>LABEL</literal>. </para>

<para>If there is a definition for <emphasis>token_value</emphasis> in the <literal>CAPSULE</literal> then <emphasis>token_args</emphasis> is a <literal>BITSTREAM</literal> encoding of the <literal>SORT</literal>s of its parameters, in the order specified.</para>



</sect2>
<sect2>
<title>make_label</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>1</member>
</simplelist>

<programlisting>
<emphasis>labelno</emphasis>: TDFINT
-&gt; LABEL
</programlisting>

<para>Labels are represented in TDF by integers, but they are not linkable. Hence the definition and all uses of a <literal>LABEL</literal> occur in the same <literal>UNIT</literal>. </para>




</sect2>
</sect1>

<sect1>
<title>LINK</title>
<simplelist type='horiz' columns='2'>

<member>Number of encoding bits:</member><member>0</member>
<member>Is coding extendable:</member><member>no</member>

</simplelist>
<para>A <literal>LINK</literal> expresses the connection between two variables of the same <literal>SORT</literal>.</para>

<sect2>
<title>make_link</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>0</member>
</simplelist>

<programlisting>
<emphasis>unit_name</emphasis>:   TDFINT
<emphasis>capsule_name</emphasis>:    TDFINT
-&gt; LINK
</programlisting>

<para>A <literal>LINK</literal> defines a linkable entity declared inside a <literal>UNIT</literal> as <emphasis>unit_name</emphasis> to correspond to a <literal>CAPSULE</literal> linkable entity having the same linkable entity identification. The <literal>CAPSULE</literal> linkable entity is <emphasis>capsule_name</emphasis>. </para>

<para>A <literal>LINK</literal> is normally constructed by the TDF builder in the course of resolving sharing and name clashes when constructing a composite <literal>CAPSULE</literal>.</para>


</sect2>
</sect1>

<sect1>
<title>LINKEXTERN</title>
<simplelist type='horiz' columns='2'>

<member>Number of encoding bits:</member><member>0</member>
<member>Is coding extendable:</member><member>no</member>
</simplelist>

<para>A value of <literal>SORT LINKEXTERN</literal> expresses the connection between the name by which an object is known inside a <literal>CAPSULE</literal> and a name by which it is known outside.</para>



<sect2>
<title>make_linkextern</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>0</member>
</simplelist>

<programlisting>
<emphasis>internal</emphasis>:    TDFINT
<emphasis>ext</emphasis>:     EXTERNAL
-&gt; LINKEXTERN
</programlisting>

<para><emphasis>make_linkextern</emphasis> produces a <literal>LINKEXTERN</literal> connecting an object identified within a <literal>CAPSULE</literal> by a <literal>TAG</literal>, <literal>TOKEN</literal>, <literal>AL_TAG</literal> or any linkable entity constructed from <emphasis>internal</emphasis>, with an <literal>EXTERNAL</literal>, <emphasis>ext</emphasis>. The <literal>EXTERNAL</literal> is an identifier which linkers and similar programs can use.</para>




</sect2>
</sect1>

<sect1>
<title>LINKS</title>
<simplelist type='horiz' columns='2'>

<member>Number of encoding bits:</member><member>0</member>
<member>Is coding extendable:</member><member>no</member>

</simplelist>


<sect2>
<title>make_links</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>0</member>
</simplelist>
<programlisting>
<emphasis>ls</emphasis>:      SLIST(LINK)
-&gt; LINKS
</programlisting>

<para><emphasis>make_unit</emphasis> uses a <literal>SLIST</literal>(<literal>LINKS</literal>) to define which linkable entities within a <literal>UNIT</literal> correspond to the <literal>CAPSULE</literal> linkable entities. Each <literal>LINK</literal> in a <literal>LINKS</literal> has the same linkable entity identification.</para>




</sect2>
</sect1>

<sect1>
<title>NAT</title>
<simplelist type='horiz' columns='2'>

<member>Number of encoding bits:</member><member>3</member>
<member>Is coding extendable:</member><member>yes</member>

</simplelist>
<para>These are non-negative integers of unlimited size.</para>




<sect2>
<title>nat_apply_token</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>1</member>
</simplelist>

<programlisting>
<emphasis>token_value</emphasis>: TOKEN
<emphasis>token_args</emphasis>:  BITSTREAM <emphasis>param_sorts(token_value)</emphasis>
-&gt; NAT
</programlisting>

<para>The token is applied to the arguments to give a <literal>NAT</literal>. </para>

<para>If there is a definition for <emphasis>token_value</emphasis> in the <literal>CAPSULE</literal> then <emphasis>token_args</emphasis> is a <literal>BITSTREAM</literal> encoding of the <literal>SORT</literal>s of its parameters, in the order specified.</para>



</sect2>
<sect2>
<title>nat_cond</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>2</member>
</simplelist>

<programlisting>
<emphasis>control</emphasis>: EXP INTEGER(<emphasis>v</emphasis>)
<emphasis>e1</emphasis>:      BITSTREAM NAT
<emphasis>e2</emphasis>:      BITSTREAM NAT
-&gt; NAT
</programlisting>

<para>The <emphasis>control</emphasis> is evaluated. It will be a constant at install time under the constant evaluation rules. If it is non-zero, <emphasis>e1</emphasis> is installed at this point and <emphasis>e2</emphasis> is ignored and never processed. If <emphasis>control</emphasis> is zero then <emphasis>e2</emphasis> is installed at this point and <emphasis>e1</emphasis> is ignored and never processed. </para>



</sect2>
<sect2>
<title>computed_nat</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>3</member>
</simplelist>

<programlisting>
<emphasis>arg</emphasis>:     EXP INTEGER(<emphasis>v</emphasis>)
-&gt; NAT
</programlisting>

<para><emphasis>arg</emphasis> will be an install-time non-negative constant. The result is that constant.</para>



</sect2>
<sect2>
<title>error_val</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>4</member>

</simplelist>
<programlisting>
<emphasis>err</emphasis>:     ERROR_CODE
-&gt; NAT
</programlisting>

<para>Gives the <literal>NAT</literal> corresponding to the <literal>ERROR_CODE</literal> <emphasis>err</emphasis>. Each distinct <literal>ERROR_CODE</literal> will give a different <literal>NAT</literal>. </para>



</sect2>
<sect2>
<title>make_nat</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>5</member>

</simplelist>
<programlisting>
<emphasis>n</emphasis>:       TDFINT
-&gt; NAT
</programlisting>

<para><emphasis>n</emphasis> is a non-negative integer of unbounded magnitude.</para>




</sect2>
</sect1>
<sect1>

<title>NTEST</title>
<simplelist type='horiz' columns='2'>

<member>Number of encoding bits:</member><member>4</member>
<member>Is coding extendable:</member><member>yes</member>
</simplelist>

<para>These describe the comparisons which are possible in the various <emphasis>test</emphasis> constructions. Note that <emphasis>greater_than</emphasis> is not necessarily the same as <emphasis>not_less_than_or_equal</emphasis>, since the result need not be defined (e.g. in IEEE floating point).</para>



<sect2>
<title>ntest_apply_token</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>1</member>

</simplelist>
<programlisting>
<emphasis>token_value</emphasis>: TOKEN
<emphasis>token_args</emphasis>:  BITSTREAM <emphasis>param_sorts(token_value)</emphasis>
-&gt; NTEST
</programlisting>

<para>The token is applied to the arguments to give a <literal>NTEST</literal>. </para>

<para>If there is a definition for <emphasis>token_value</emphasis> in the <literal>CAPSULE</literal> then <emphasis>token_args</emphasis> is a <literal>BITSTREAM</literal> encoding of the <literal>SORT</literal>s of its parameters, in the order specified.</para>



</sect2>
<sect2>
<title>ntest_cond</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>2</member>
</simplelist>

<programlisting>
<emphasis>control</emphasis>: EXP INTEGER(<emphasis>v</emphasis>)
<emphasis>e1</emphasis>:      BITSTREAM NTEST
<emphasis>e2</emphasis>:      BITSTREAM NTEST
-&gt; NTEST
</programlisting>

<para>The <emphasis>control</emphasis> is evaluated. It will be a constant at install time under the constant evaluation rules. If it is non-zero, <emphasis>e1</emphasis> is installed at this point and <emphasis>e2</emphasis> is ignored and never processed. If <emphasis>control</emphasis> is zero then <emphasis>e2</emphasis> is installed at this point and <emphasis>e1</emphasis> is ignored and never processed. </para>



</sect2>
<sect2>
<title>equal</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>3</member>
</simplelist>

<programlisting>
-&gt; NTEST
</programlisting>

<para>Signifies Signifies &quot;equal&quot; test. quot;equalSignifies &quot;equal&quot; test. quot; test. </para>



</sect2>
<sect2>
<title>greater_than</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>4</member>
</simplelist>

<programlisting>
-&gt; NTEST
</programlisting>

<para>Signifies Signifies &quot;greater than&quot; test. quot;greater thanSignifies &quot;greater than&quot; test. quot; test. </para>



</sect2>
<sect2>
<title>greater_than_or_equal</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>5</member>
</simplelist>

<programlisting>
-&gt; NTEST
</programlisting>

<para>Signifies Signifies &quot;greater than or equal&quot; test. quot;greater than or equalSignifies &quot;greater than or equal&quot; test. quot; test. </para>



</sect2>
<sect2>
<title>less_than</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>6</member>
</simplelist>

<programlisting>
-&gt; NTEST
</programlisting>

<para>Signifies Signifies &quot;less than&quot; test. quot;less thanSignifies &quot;less than&quot; test. quot; test. </para>



</sect2>
<sect2>
<title>less_than_or_equal</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>7</member>
</simplelist>

<programlisting>
-&gt; NTEST
</programlisting>

<para>Signifies Signifies &quot;less than or equal&quot; test. quot;less than or equalSignifies &quot;less than or equal&quot; test. quot; test. </para>



</sect2>
<sect2>
<title>not_equal</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>8</member>
</simplelist>

<programlisting>
-&gt; NTEST
</programlisting>

<para>Signifies Signifies &quot;not equal&quot; test. quot;not equalSignifies &quot;not equal&quot; test. quot; test. </para>



</sect2>
<sect2>
<title>not_greater_than</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>9</member>

</simplelist>
<programlisting>
-&gt; NTEST
</programlisting>

<para>Signifies Signifies &quot;not greater than&quot; test. quot;not greater thanSignifies &quot;not greater than&quot; test. quot; test. </para>



</sect2>
<sect2>
<title>not_greater_than_or_equal</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>10</member>
</simplelist>

<programlisting>
-&gt; NTEST
</programlisting>

<para>Signifies Signifies &quot;not (greater than or equal)&quot; test. quot;not (greater than or equal)Signifies &quot;not (greater than or equal)&quot; test. quot; test. </para>



</sect2>
<sect2>
<title>not_less_than</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>11</member>
</simplelist>

<programlisting>
-&gt; NTEST
</programlisting>

<para>Signifies Signifies &quot;not less than&quot; test. quot;not less thanSignifies &quot;not less than&quot; test. quot; test. </para>



</sect2>
<sect2>
<title>not_less_than_or_equal</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>12</member>
</simplelist>

<programlisting>
-&gt; NTEST
</programlisting>

<para>Signifies Signifies &quot;not (less than or equal)&quot; test. quot;not (less than or equal)Signifies &quot;not (less than or equal)&quot; test. quot; test. </para>



</sect2>
<sect2>
<title>less_than_or_greater_than</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>13</member>
</simplelist>

<programlisting>
-&gt; NTEST
</programlisting>

<para>Signifies Signifies &quot;less than or greater than&quot; test. quot;less than or greater thanSignifies &quot;less than or greater than&quot; test. quot; test. </para>



</sect2>
<sect2>
<title>not_less_than_and_not_greater_than</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>14</member>
</simplelist>

<programlisting>
-&gt; NTEST
</programlisting>

<para>Signifies Signifies &quot;not less than and not greater than&quot; test. quot;not less than and not greater thanSignifies &quot;not less than and not greater than&quot; test. quot; test. </para>



</sect2>
<sect2>
<title>comparable</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>15</member>
</simplelist>

<programlisting>
-&gt; NTEST
</programlisting>

<para>Signifies Signifies &quot;comparable&quot; test. quot;comparableSignifies &quot;comparable&quot; test. quot; test. </para>

<para>With all operands <literal>SHAPE</literal>s except <literal>FLOATING</literal>, this comparison is always true.</para>



</sect2>
<sect2>
<title>not_comparable</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>16</member>
</simplelist>

<programlisting>
-&gt; NTEST
</programlisting>

<para>Signifies Signifies &quot;not comparable&quot; test. quot;not comparableSignifies &quot;not comparable&quot; test. quot; test. </para>

<para>With all operands <literal>SHAPE</literal>s except <literal>FLOATING</literal>, this comparison is always false.</para>




</sect2>
<sect2>
<title>OTAGEXP</title>
<simplelist type='horiz' columns='2'>

<member>Number of encoding bits:</member><member>0</member>
<member>Is coding extendable:</member><member>no</member>
</simplelist>
<para>This is a auxilliary <literal>SORT</literal> used in <emphasis>apply_general_proc</emphasis>.</para>



<sect2>
<title>make_otagexp</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>0</member>
</simplelist>

<programlisting>
<emphasis>tgopt</emphasis>:       OPTION(TAG <emphasis>x</emphasis>)
<emphasis>e</emphasis>:       EXP <emphasis>x</emphasis>
-&gt; OTAGEXP
</programlisting>

<para><emphasis>e</emphasis> is evaluated and its value is the actual caller parameter. If <emphasis>tgopt</emphasis> is present, the <literal>TAG</literal> will be bound to the final value of caller parameter in the <emphasis>postlude</emphasis> part of the <emphasis>apply_general_proc</emphasis>.</para>


</sect2>
</sect1>

<sect1>
<title>PROCPROPS</title>
<simplelist type='horiz' columns='2'>

<member>Number of encoding bits:</member><member>4</member>
<member>Is coding extendable:</member><member>yes</member>
</simplelist>

<para><literal>PROCPROPS</literal> is a set of properties ascribed to procedure definitions and calls.</para>



<sect2>
<title>procprops_apply_token</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>1</member>
</simplelist>

<programlisting>
<emphasis>token_value</emphasis>: TOKEN
<emphasis>token_args</emphasis>:  BITSTREAM <emphasis>param_sorts(token_value)</emphasis>
-&gt; PROCPROPS
</programlisting>

<para>The token is applied to the arguments to give a <literal>PROCPROPS</literal>. </para>

<para>If there is a definition for <emphasis>token_value</emphasis> in the <literal>CAPSULE</literal> then <emphasis>token_args</emphasis> is a <literal>BITSTREAM</literal> encoding of the <literal>SORT</literal>s of its parameters in the order specified.</para>



</sect2>
<sect2>
<title>procprops_cond</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>2</member>
</simplelist>

<programlisting>
<emphasis>control</emphasis>: EXP INTEGER(<emphasis>v</emphasis>)
<emphasis>e1</emphasis>:      BITSTREAM PROCPROPS
<emphasis>e2</emphasis>:      BITSTREAM PROCPROPS
-&gt; PROCPROPS
</programlisting>

<para>The <emphasis>control</emphasis> is evaluated. It will be a constant at install time under the constant evaluation rules. If it is non-zero, <emphasis>e1</emphasis> is installed at this point and <emphasis>e2</emphasis> is ignored and never processed. If <emphasis>control</emphasis> is zero then <emphasis>e2</emphasis> is installed at this point and <emphasis>e1</emphasis> is ignored and never processed. </para>



</sect2>
<sect2>
<title>add_procprops</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>3</member>
</simplelist>

<programlisting>
<emphasis>arg1</emphasis>:        PROCPROPS
<emphasis>arg2</emphasis>:        PROCPROPS
-&gt; PROCPROPS
</programlisting>

<para>Delivers the join of <emphasis>arg1</emphasis> and <emphasis>arg2</emphasis>. </para>



</sect2>
<sect2>
<title>check_stack</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>4</member>
</simplelist>

<programlisting>
-&gt; PROCPROPS
</programlisting>

<para>The procedure body is required to check for stack overflow. </para>



</sect2>
<sect2>
<title>inline</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>5</member>

</simplelist>
<programlisting>
-&gt; PROCPROPS
</programlisting>

<para>The procedure body is a good candidate for inlining at its application. </para>



</sect2>
<sect2>
<title>no_long_jump_dest</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>6</member>
</simplelist>

<programlisting>
-&gt; PROCPROPS
</programlisting>

<para>The procedure body will contain no label which is the destination of a long_jump. </para>



</sect2>
<sect2>
<title>untidy</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>7</member>
</simplelist>

<programlisting>
-&gt; PROCPROPS
</programlisting>

<para>The procedure body may be exited using an <emphasis>untidy_return</emphasis>. </para>



</sect2>
<sect2>
<title>var_callees</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>8</member>
</simplelist>

<programlisting>
-&gt; PROCPROPS
</programlisting>

<para>Applications of the procedure may have different numbers of actual callee parameters. </para>



</sect2>
<sect2>
<title>var_callers</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>9</member>
</simplelist>

<programlisting>
-&gt; PROCPROPS
</programlisting>

<para>Applications of the procedure may have different numbers of actual caller parameters. </para>




</sect2>
</sect1>

<sect1>
<title>PROPS</title>

<para>A <literal>PROPS</literal> is an assemblage of program information. This standard offers various ways of constructing a <literal>PROPS</literal> - i.e. it defines kinds of information which it is useful to express. These are: </para>

<itemizedlist>
<listitem>
<para>definitions of <literal>AL_TAG</literal>s standing for <literal>ALIGNMENT</literal>s;</para>
</listitem>
<listitem>
<para>declarations of <literal>TAG</literal>s standing for <literal>EXP</literal>s;</para>
</listitem>
<listitem>
<para>definitions of the <literal>EXP</literal>s for which <literal>TAG</literal>s stand;</para>
</listitem>
<listitem>
<para>declarations of <literal>TOKEN</literal>s standing for pieces of TDF program;</para>
</listitem>
<listitem>
<para>definitions of the pieces of TDF program for which <literal>TOKEN</literal>s stand;</para>
</listitem>
<listitem>
<para>linkage and naming information;</para>
</listitem>
<listitem>
<para>version information</para>
</listitem>
</itemizedlist>

<para><literal>PROPS</literal> giving diagnostic information are described in a separate document.</para>

<para>The standard can be extended by the definition of new kinds of <literal>PROPS</literal> information and new <literal>PROPS</literal> constructs for expressing them; and private standards can define new kinds of information and corresponding constructs without disruption to adherents to the present standard.</para>

<para>Each <literal>GROUP</literal> of <literal>UNIT</literal>s is identified by a unit identification - a <literal>TDFIDENT</literal>. All the <literal>UNIT</literal>s in that <literal>GROUP</literal> are of the same kind.</para>

<para>In addition there is a <emphasis>tld</emphasis> <literal>UNIT</literal>, see -XREF-spec11.html#17The TDF encoding.</para>


</sect1>

<sect1>
<title>ROUNDING_MODE</title>
<simplelist type='horiz' columns='2'>

<member>Number of encoding bits:</member><member>3</member>
<member>Is coding extendable:</member><member>yes</member>
</simplelist>

<para><literal>ROUNDING_MODE</literal> specifies the way rounding is to be performed in floating point arithmetic.</para>



<sect2>
<title>rounding_mode_apply_token</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>1</member>
</simplelist>

<programlisting>
<emphasis>token_value</emphasis>: TOKEN
<emphasis>token_args</emphasis>:  BITSTREAM <emphasis>param_sorts(token_value)</emphasis>
-&gt; ROUNDING_MODE
</programlisting>

<para>The token is applied to the arguments to give a <literal>ROUNDING_MODE</literal>. </para>

<para>If there is a definition for <emphasis>token_value</emphasis> in the <literal>CAPSULE</literal> then <emphasis>token_args</emphasis> is a <literal>BITSTREAM</literal> encoding of the <literal>SORT</literal>s of its parameters, in the order specified.</para>



</sect2>
<sect2>
<title>rounding_mode_cond</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>2</member>
</simplelist>

<programlisting>
<emphasis>control</emphasis>: EXP INTEGER(<emphasis>v</emphasis>)
<emphasis>e1</emphasis>:      BITSTREAM ROUNDING_MODE
<emphasis>e2</emphasis>:      BITSTREAM ROUNDING_MODE
-&gt; ROUNDING_MODE
</programlisting>

<para>The <emphasis>control</emphasis> is evaluated. It will be a constant at install time under the constant evaluation rules. If it is non-zero, <emphasis>e1</emphasis> is installed at this point and <emphasis>e2</emphasis> is ignored and never processed. If <emphasis>control</emphasis> is zero then <emphasis>e2</emphasis> is installed at this point and <emphasis>e1</emphasis> is ignored and never processed. </para>



</sect2>
<sect2>
<title>round_as_state</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>3</member>
</simplelist>

<programlisting>
-&gt; ROUNDING_MODE
</programlisting>

<para>Round as specified by the current state of the machine. </para>



</sect2>
<sect2>
<title>to_nearest</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>4</member>
</simplelist>

<programlisting>
-&gt; ROUNDING_MODE
</programlisting>

<para>Signifies rounding to nearest. The effect when the number lies half-way is not specified. </para>



</sect2>
<sect2>
<title>toward_larger</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>5</member>
</simplelist>

<programlisting>
-&gt; ROUNDING_MODE
</programlisting>

<para>Signifies rounding toward next largest. </para>



</sect2>
<sect2>
<title>toward_smaller</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>6</member>
</simplelist>

<programlisting>
-&gt; ROUNDING_MODE
</programlisting>

<para>Signifies rounding toward next smallest. </para>



</sect2>
<sect2>
<title>toward_zero</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>7</member>
</simplelist>

<programlisting>
-&gt; ROUNDING_MODE
</programlisting>

<para>Signifies rounding toward zero. </para>




</sect2>
</sect1>

<sect1>
<title>SHAPE</title>
<simplelist type='horiz' columns='2'>

<member>Number of encoding bits:</member><member>4</member>
<member>Is coding extendable:</member><member>yes</member>
</simplelist>

<para><literal>SHAPE</literal>s express symbolic size and representation information about run time values.</para>

<para><literal>SHAPE</literal>s are constructed from primitive <literal>SHAPE</literal>s which describe values such as procedures and integers, and recursively from compound construction in terms of other <literal>SHAPE</literal>s.</para>



<sect2>
<title>shape_apply_token</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>1</member>
</simplelist>

<programlisting>
<emphasis>token_value</emphasis>: TOKEN
<emphasis>token_args</emphasis>:  BITSTREAM <emphasis>param_sorts(token_value)</emphasis>
-&gt; SHAPE
</programlisting>

<para>The token is applied to the arguments to give a <literal>SHAPE</literal>. </para>

<para>If there is a definition for <emphasis>token_value</emphasis> in the <literal>CAPSULE</literal> then <emphasis>token_args</emphasis> is a <literal>BITSTREAM</literal> encoding of the <literal>SORT</literal>s of its parameters, in the order specified.</para>



</sect2>
<sect2>
<title>shape_cond</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>2</member>
</simplelist>

<programlisting>
<emphasis>control</emphasis>: EXP INTEGER(<emphasis>v</emphasis>)
<emphasis>e1</emphasis>:      BITSTREAM SHAPE
<emphasis>e2</emphasis>:      BITSTREAM SHAPE
-&gt; SHAPE
</programlisting>

<para>The <emphasis>control</emphasis> is evaluated. It will be a constant at install time under the constant evaluation rules. If it is non-zero, <emphasis>e1</emphasis> is installed at this point and <emphasis>e2</emphasis> is ignored and never processed. If <emphasis>control</emphasis> is zero then <emphasis>e2</emphasis> is installed at this point and <emphasis>e1</emphasis> is ignored and never processed. </para>



</sect2>
<sect2>
<title>bitfield</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>3</member>
</simplelist>

<programlisting>
<emphasis>bf_var</emphasis>:      BITFIELD_VARIETY
-&gt; SHAPE
</programlisting>

<para>A <literal>BITFIELD</literal> is used to represent a pattern of bits which will be packed, provided that the <emphasis>variety_enclosed</emphasis> constraints are not violated. (see See -XREF-spec10.html#66section 7.24)</para>

<para>A <literal>BITFIELD_VARIETY</literal> specifies the number of bits and whether they are considered to be signed.</para>

<para>There are very few operations on <literal>BITFIELD</literal>s, which have to be converted to <literal>INTEGER</literal>s before arithmetic can be performed on them.</para>

<para>An installer may place a limit on the number of bits it implements. See -XREF-spec10.html#68Permitted limits.</para>



</sect2>
<sect2>
<title>bottom</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>4</member>
</simplelist>

<programlisting>
-&gt; SHAPE
</programlisting>

<para><literal>BOTTOM</literal> is the <literal>SHAPE</literal> which describes a piece of program which does not evaluate to any result. Examples include <emphasis>goto</emphasis> and <emphasis>return</emphasis>.</para>

<para>If <literal>BOTTOM</literal> is a parameter to any other <literal>SHAPE</literal> constructor, the result is <literal>BOTTOM</literal>.</para>



</sect2>
<sect2>
<title>compound</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>5</member>
</simplelist>

<programlisting>
<emphasis>sz</emphasis>:      EXP OFFSET(<emphasis>x</emphasis>, y)
-&gt; SHAPE
</programlisting>

<para>The <literal>SHAPE</literal> constructor <literal>COMPOUND</literal> describes cartesian products and unions. </para>

<para>The alignments <emphasis>x</emphasis> and <emphasis>y</emphasis> will be <emphasis>alignment</emphasis>(<emphasis>sx</emphasis>) and <emphasis>alignment</emphasis>(<emphasis>sy</emphasis>) for some <literal>SHAPE</literal>s <emphasis>sx</emphasis> and <emphasis>sy</emphasis>.</para>

<para><emphasis>sz</emphasis> will evaluate to a constant, non-negative <literal>OFFSET</literal> (see -XREF-#M169offset_pad). The resulting <literal>SHAPE</literal> describes a value whose size is given by <emphasis>sz</emphasis>.</para>



</sect2>
<sect2>
<title>floating</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>6</member>
</simplelist>

<programlisting>
<emphasis>fv</emphasis>:      FLOATING_VARIETY
-&gt; SHAPE
</programlisting>

<para>Most of the floating point arithmetic operations, <emphasis>floating_plus</emphasis>, <emphasis>floating_minus</emphasis> etc., are defined to work in the same way on different kinds of floating point number. If these operations have more than one argument the arguments have to be of the same kind, and the result is of the same kind. </para>

<para>See -XREF-spec10.html#57Representing floating point.</para>

<para>An installer may limit the <literal>FLOATING_VARIETY</literal>s it can represent. A statement of any such limits shall be part of the specification of an installer. See -XREF-spec10.html#57Representing floating point.</para>



</sect2>
<sect2>
<title>integer</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>7</member>
</simplelist>

<programlisting>
<emphasis>var</emphasis>:     VARIETY
-&gt; SHAPE
</programlisting>

<para>The different kinds of <literal>INTEGER</literal> are distinguished by having different <literal>VARIETY</literal>s. A fundamental <literal>VARIETY</literal> (not a <literal>TOKEN</literal> or conditional) is represented by two <literal>SIGNED_NAT</literal>s, respectively the lower and upper bounds (inclusive) of the set of values belonging to the <literal>VARIETY</literal>. </para>

<para>Most architectures require that dyadic integer arithmetic operations take arguments of the same size, and so TDF does likewise. Because TDF is completely architecture neutral and makes no assumptions about word length, this means that the <literal>VARIETY</literal>s of the two arguments must be identical. An example illustrates this. A piece of TDF which attempted to add two values whose <literal>SHAPE</literal>s were:</para>

<programlisting>
INTEGER(0, 60000)  <emphasis>and</emphasis>  INTEGER(0, 30000)
</programlisting>

<para>would be undefined. The reason is that without knowledge of the target architecture's word length, it is impossible to guarantee that the two values are going to be represented in the same number of bytes. On a 16-bit machine they probably would, but not on a 15-bit machine. The only way to ensure that two <literal>INTEGER</literal>s are going to be represented in the same way in all machines is to stipulate that their <literal>VARIETY</literal>s are exactly the same. </para>

<para>When any construct delivering an <literal>INTEGER</literal> of a given <literal>VARIETY</literal> produces a result which is not representable in the space which an installer has chosen to represent that <literal>VARIETY</literal>, an integer overflow occurs. Whether it occurs in a particular case depends on the target, because the installers' decisions on representation are inherently target-defined.</para>

<para>A particular installer may limit the ranges of integers that it implements. See -XREF-spec10.html#51Representing integers.</para>



</sect2>
<sect2>
<title>nof</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>8</member>
</simplelist>

<programlisting>
<emphasis>n</emphasis>:       NAT
<emphasis>s</emphasis>:       SHAPE
-&gt; SHAPE
</programlisting>

<para>The <literal>NOF</literal> constructor describes the <literal>SHAPE</literal> of a value consisting of an array of <emphasis>n</emphasis> values of the same <literal>SHAPE</literal>, <emphasis>s</emphasis>. </para>



</sect2>
<sect2>
<title>offset</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>9</member>
</simplelist>

<programlisting>
<emphasis>arg1</emphasis>:        ALIGNMENT
<emphasis>arg2</emphasis>:        ALIGNMENT
-&gt; SHAPE
</programlisting>

<para>The <literal>SHAPE</literal> constructor <literal>OFFSET</literal> describes values which represent the differences between <literal>POINTER</literal>s, that is they measure offsets in memory. It should be emphasised that these are in general run-time values. </para>

<para>An <literal>OFFSET</literal> measures the displacement from the value indicated by a <literal>POINTER</literal>(<emphasis>arg1</emphasis>) to the value indicated by a <literal>POINTER</literal>(<emphasis>arg2</emphasis>). Such an offset is only defined if the <literal>POINTER</literal>s are derived from the same original <literal>POINTER</literal>.</para>

<para>An <literal>OFFSET</literal> may also measure the displacement from a <literal>POINTER</literal> to the start of a <literal>BITFIELD_VARIETY</literal>, or from the start of one <literal>BITFIELD_VARIETY</literal> to the start of another. Hence, unlike the argument of <emphasis>pointer</emphasis>, <emphasis>arg1</emphasis> or <emphasis>arg2</emphasis> may consist entirely of <literal>BITFIELD_VARIETY</literal>s.</para>

<para>The set <emphasis>arg1</emphasis> will include the set <emphasis>arg2</emphasis>.</para>

<para>See -XREF-spec10.html#26Memory Model.</para>



</sect2>
<sect2>
<title>pointer</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>10</member>
</simplelist>

<programlisting>
<emphasis>arg</emphasis>:     ALIGNMENT
-&gt; SHAPE
</programlisting>

<para>A <literal>POINTER</literal> is a value which points to space allocated in a computer's memory. The <literal>POINTER</literal> constructor takes an <literal>ALIGNMENT</literal> argument. This argument will not consist entirely of <literal>BITFIELD_VARIETY</literal>s. See -XREF-spec10.html#26Memory Model. </para>



</sect2>
<sect2>
<title>proc</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>11</member>
</simplelist>

<programlisting>
-&gt; SHAPE
</programlisting>

<para><literal>PROC</literal> is the <literal>SHAPE</literal> which describes pieces of program.</para>



</sect2>
<sect2>
<title>top</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>12</member>
</simplelist>

<programlisting>
-&gt; SHAPE
</programlisting>

<para><literal>TOP</literal> is the <literal>SHAPE</literal> which describes pieces of program which return no useful value. <emphasis>assign</emphasis> is an example: it performs an assignment, but does not deliver any useful value.</para>




</sect2>
</sect1>

<sect1>
<title>SIGNED_NAT</title>
<simplelist type='horiz' columns='2'>

<member>Number of encoding bits:</member><member>3</member>
<member>Is coding extendable:</member><member>yes</member>
</simplelist>

<para>These are positive or negative integers of unbounded size.</para>



<sect2>
<title>signed_nat_apply_token</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>1</member>

</simplelist>
<programlisting>
<emphasis>token_value</emphasis>: TOKEN
<emphasis>token_args</emphasis>:  BITSTREAM <emphasis>param_sorts(token_value)</emphasis>
-&gt; SIGNED_NAT
</programlisting>

<para>The token is applied to the arguments to give a <literal>SIGNED_NAT</literal>. </para>

<para>If there is a definition for <emphasis>token_value</emphasis> in the <literal>CAPSULE</literal> then <emphasis>token_args</emphasis> is a <literal>BITSTREAM</literal> encoding of the <literal>SORT</literal>s of its parameters, in the order specified.</para>



</sect2>
<sect2>
<title>signed_nat_cond</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>2</member>
</simplelist>

<programlisting>
<emphasis>control</emphasis>: EXP INTEGER(<emphasis>v</emphasis>)
<emphasis>e1</emphasis>:      BITSTREAM SIGNED_NAT
<emphasis>e2</emphasis>:      BITSTREAM SIGNED_NAT
-&gt; SIGNED_NAT
</programlisting>

<para>The <emphasis>control</emphasis> is evaluated. It will be a constant at install time under the constant evaluation rules. If it is non-zero, <emphasis>e1</emphasis> is installed at this point and <emphasis>e2</emphasis> is ignored and never processed. If <emphasis>control</emphasis> is zero then <emphasis>e2</emphasis> is installed at this point and <emphasis>e1</emphasis> is ignored and never processed. </para>



</sect2>
<sect2>
<title>computed_signed_nat</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>3</member>
</simplelist>

<programlisting>
<emphasis>arg</emphasis>:     EXP INTEGER(<emphasis>v</emphasis>)
-&gt; SIGNED_NAT
</programlisting>

<para><emphasis>arg</emphasis> will be an install-time constant. The result is that constant.</para>



</sect2>
<sect2>
<title>make_signed_nat</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>4</member>
</simplelist>

<programlisting>
<emphasis>neg</emphasis>:     TDFBOOL
<emphasis>n</emphasis>:       TDFINT
-&gt; SIGNED_NAT
</programlisting>

<para><emphasis>n</emphasis> is a non-negative integer of unbounded magnitude. The result is negative if and only if <emphasis>neg</emphasis> is true.</para>



</sect2>
<sect2>
<title>snat_from_nat</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>5</member>

</simplelist>
<programlisting>
<emphasis>neg</emphasis>:     BOOL
<emphasis>n</emphasis>:       NAT
-&gt; SIGNED_NAT
</programlisting>

<para>The result is negated if and only if <emphasis>neg</emphasis> is true. </para>




</sect2>
</sect1>

<sect1>
<title>SORTNAME</title>
<simplelist type='horiz' columns='2'>

<member>Number of encoding bits:</member><member>5</member>
<member>Is coding extendable:</member><member>yes</member>
</simplelist>

<para>These are the names of the <literal>SORT</literal>s which can be parameters of <literal>TOKEN</literal> definitions.</para>



<sect2>
<title>access</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>1</member>
</simplelist>

<programlisting>
-&gt; SORTNAME
</programlisting>

<sect2>
<title>Aal_tag</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>2</member>
</simplelist>

<programlisting>
-&gt; SORTNAME
</programlisting>

</sect2>
<sect2>
<title>alignment_sort</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>3</member>
</simplelist>

<programlisting>
-&gt; SORTNAME
</programlisting>

</sect2>
<sect2>
<title>Abitfield_variety</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>4</member>
</simplelist>

<programlisting>
-&gt; SORTNAME
</programlisting>

</sect2>
<sect2>
<title>Abool</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>5</member>
</simplelist>

<programlisting>
-&gt; SORTNAME
</programlisting>

</sect2>
<sect2>
<title>Aerror_treatment</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>6</member>
</simplelist>

<programlisting>
-&gt; SORTNAME
</programlisting>

</sect2>
<sect2>
<title>Aexp</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>7</member>

</simplelist>
<programlisting>
-&gt; SORTNAME
</programlisting>

<para>The <literal>SORT</literal> of <literal>EXP</literal>. </para>



</sect2>
<sect2>
<title>Afloating_variety</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>8</member>
</simplelist>

<programlisting>
-&gt; SORTNAME
</programlisting>

</sect2>
<sect2>
<title>foreign_sort</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>9</member>
</simplelist>

<programlisting>
<emphasis>foreign_name</emphasis>:    STRING<emphasis>(k, n)</emphasis>
-&gt; SORTNAME
</programlisting>

<para>This <literal>SORT</literal> enables unanticipated kinds of information to be placed in TDF. </para>



</sect2>
<sect2>
<title>Alabel</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>10</member>
</simplelist>

<programlisting>
-&gt; SORTNAME
</programlisting>

</sect2>
<sect2>
<title>Anat</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>11</member>
</simplelist>

<programlisting>
-&gt; SORTNAME
</programlisting>

</sect2>
<sect2>
<title>Antest</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>12</member>
</simplelist>

<programlisting>
-&gt; SORTNAME
</programlisting>

</sect2>
<sect2>
<title>Aprocprops</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>13</member>
</simplelist>

<programlisting>
-&gt; SORTNAME
</programlisting>

</sect2>
<sect2>
<title>Arounding_mode</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>14</member>
</simplelist>

<programlisting>
-&gt; SORTNAME
</programlisting>

</sect2>
<sect2>
<title>Ashape</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>15</member>
</simplelist>

<programlisting>
-&gt; SORTNAME
</programlisting>

</sect2>
<sect2>
<title>Asigned_nat</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>16</member>
</simplelist>

<programlisting>
-&gt; SORTNAME
</programlisting>

</sect2>
<sect2>
<title>Astring</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>17</member>
</simplelist>

<programlisting>
-&gt; SORTNAME
</programlisting>

</sect2>
<sect2>
<title>Atag</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>18</member>
</simplelist>

<programlisting>
-&gt; SORTNAME
</programlisting>

<para>The <literal>SORT</literal> of <literal>TAG</literal>. </para>


</sect2>
<sect2>
<title>Atransfer_mode</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>19</member>
</simplelist>

<programlisting>
-&gt; SORTNAME
</programlisting>

</sect2>
<sect2>
<title>Atoken</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>20</member>
</simplelist>

<programlisting>
<emphasis>result</emphasis>:      SORTNAME
<emphasis>params</emphasis>:      LIST(SORTNAME)
-&gt; SORTNAME
</programlisting>

<para>The <literal>SORTNAME</literal> of a <literal>TOKEN</literal>. Note that it can have tokens as parameters, but not as result. </para>



</sect2>
<sect2>
<title>variety</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>21</member>
</simplelist>

<programlisting>
-&gt; SORTNAME
</programlisting>


</sect2>
</sect1>

<sect1>
<title>STRING</title>
<simplelist type='horiz' columns='2'>

<member>Number of encoding bits:</member><member>3</member>
<member>Is coding extendable:</member><member>yes</member>
</simplelist>



<sect2>
<title>string_apply_token</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>1</member>
</simplelist>

<programlisting>
<emphasis>token_value</emphasis>: TOKEN
<emphasis>token_args</emphasis>:  BITSTREAM <emphasis>param_sorts(token_value)</emphasis>
-&gt; STRING<emphasis>(k, n)</emphasis>
</programlisting>

<para>The token is applied to the arguments to give a <literal>STRING</literal> </para>

<para>If there is a definition for <emphasis>token_value</emphasis> in the <literal>CAPSULE</literal> then <emphasis>token_args</emphasis> is a <literal>BITSTREAM</literal> encoding of the <literal>SORT</literal>s of its parameters, in the order specified.</para>



</sect2>
<sect2>
<title>string_cond</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>2</member>

</simplelist>
<programlisting>
<emphasis>control</emphasis>: EXP INTEGER(<emphasis>v</emphasis>)
<emphasis>e1</emphasis>:      BITSTREAM STRING
<emphasis>e2</emphasis>:      BITSTREAM STRING
-&gt; STRING<emphasis>(k, n)</emphasis>
</programlisting>

<para>The <emphasis>control</emphasis> is evaluated. It will be a constant at install time under the constant evaluation rules. If it is non-zero, <emphasis>e1</emphasis> is installed at this point and <emphasis>e2</emphasis> is ignored and never processed. If <emphasis>control</emphasis> is zero then <emphasis>e2</emphasis> is installed at this point and <emphasis>e1</emphasis> is ignored and never processed. </para>



</sect2>
<sect2>
<title>concat_string</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>3</member>
</simplelist>

<programlisting>
<emphasis>arg1</emphasis>:        STRING<emphasis>(k, n)</emphasis>
<emphasis>arg2</emphasis>:        STRING<emphasis>(k, m)</emphasis>
-&gt; STRING<emphasis>(k, n+m)</emphasis>
</programlisting>

<para>Gives a <literal>STRING</literal> which is the concatenation of <emphasis>arg1</emphasis> with <emphasis>arg2</emphasis>. </para>



</sect2>
<sect2>
<title>make_string</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>4</member>
</simplelist>

<programlisting>
<emphasis>arg</emphasis>:     TDFSTRING<emphasis>(k, n)</emphasis>
-&gt; STRING<emphasis>(k, n)</emphasis>
</programlisting>

<para>Delivers the <literal>STRING</literal> identical to the <emphasis>arg</emphasis>. </para>




</sect2>
</sect1>

<sect1>
<title>TAG</title>
<simplelist type='horiz' columns='2'>

<member>Number of encoding bits:</member><member>1</member>
<member>Is coding extendable:</member><member>yes</member>
<member>Linkable entity identification:</member><member><emphasis>tag</emphasis></member>
</simplelist>
<para>These are used to name values and variables in the run time program.</para>



<sect2>
<title>tag_apply_token</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>2</member>
</simplelist>

<programlisting>
<emphasis>token_value</emphasis>: TOKEN
<emphasis>token_args</emphasis>:  BITSTREAM <emphasis>param_sorts(token_value)</emphasis>
-&gt; TAG <emphasis>x</emphasis>
</programlisting>

<para>The token is applied to the arguments to give a <literal>TAG</literal>. </para>

<para>If there is a definition for <emphasis>token_value</emphasis> in the <literal>CAPSULE</literal> then <emphasis>token_args</emphasis> is a <literal>BITSTREAM</literal> encoding of the <literal>SORT</literal>s of its parameters, in the order specified.</para>



</sect2>
<sect2>
<title>make_tag</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>1</member>
</simplelist>

<programlisting>
<emphasis>tagno</emphasis>:       TDFINT
-&gt; TAG <emphasis>x</emphasis>
</programlisting>

<para><emphasis>make_tag</emphasis> produces a <literal>TAG</literal> identified by <emphasis>tagno</emphasis>.</para>



</sect2>
</sect1>

<sect1>
<title>TAGACC</title>
<simplelist type='horiz' columns='2'>

<member>Number of encoding bits:</member><member>0</member>
<member>Is coding extendable:</member><member>no</member>

</simplelist>
<para>Constructs a pair of a <literal>TAG</literal> and an <literal>OPTION(ACCESS)</literal> for use in <emphasis>make_proc</emphasis>.</para>



<sect2>
<title>make_tagacc</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>0</member>
</simplelist>

<programlisting>
<emphasis>tg</emphasis>:      TAG POINTER <emphasis>var_param_alignment</emphasis>
<emphasis>acc</emphasis>:     OPTION(ACCESS)
-&gt; TAGACC
</programlisting>

<para>Constructs the pair for <emphasis>make_proc</emphasis>. </para>




</sect2>
</sect1>

<sect1>
<title>TAGDEC</title>
<simplelist type='horiz' columns='2'>

<member>Number of encoding bits:</member><member>2</member>
<member>Is coding extendable:</member><member>yes</member>
</simplelist>

<para>A <literal>TAGDEC</literal> declares a <literal>TAG</literal> for incorporation into a <literal>TAGDEC_PROPS.</literal></para>



<sect2>
<title>make_id_tagdec</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>1</member>
</simplelist>

<programlisting>
<emphasis>t_intro</emphasis>: TDFINT
<emphasis>acc</emphasis>:     OPTION(ACCESS)
<emphasis>signature</emphasis>:   OPTION(STRING)
<emphasis>x</emphasis>:       SHAPE
-&gt; TAGDEC
</programlisting>

<para>A <literal>TAGDEC</literal> announcing that the <literal>TAG</literal> <emphasis>t_intro</emphasis> identifies an <literal>EXP</literal> of <literal>SHAPE</literal> <emphasis>x</emphasis> is constructed. </para>

<para><emphasis>acc</emphasis> specifies the <literal>ACCESS</literal> properties of the <literal>TAG</literal>.</para>

<para>If there is a <emphasis>make_id_tagdec</emphasis> for a <literal>TAG</literal> then all other <emphasis>make_id_tagdec</emphasis> for the same <literal>TAG</literal> will specify the same <literal>SHAPE</literal> and there will be no <emphasis>make_var_tagdec</emphasis> or <emphasis>common_tagdec</emphasis> for the <literal>TAG</literal>.</para>

<para>If two <emphasis>make_id_tagdecs</emphasis> specify the same tag and both have <emphasis>signatures</emphasis> present, the strings will be identical. Possible uses of this signature argument are outlined in -XREF-spec10.html#72section 7.28.</para>



</sect2>
<sect2>
<title>make_var_tagdec</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>2</member>
</simplelist>

<programlisting>
<emphasis>t_intro</emphasis>: TDFINT
<emphasis>acc</emphasis>:     OPTION(ACCESS)
<emphasis>signature</emphasis>:   OPTION(STRING)
<emphasis>x</emphasis>:       SHAPE
-&gt; TAGDEC
</programlisting>

<para>A <literal>TAGDEC</literal> announcing that the <literal>TAG</literal> <emphasis>t_intro</emphasis> identifies an <literal>EXP</literal> of <literal>SHAPE POINTER</literal>(<emphasis>alignment</emphasis> (<emphasis>x</emphasis>)) is constructed. </para>

<para><emphasis>acc</emphasis> specifies the <literal>ACCESS</literal> properties of the <literal>TAG</literal>.</para>

<para>If there is a <emphasis>make_var_tagdec</emphasis> for a <literal>TAG</literal> then all other <emphasis>make_var_tagdec</emphasis>s for the same <literal>TAG</literal> will specify <literal>SHAPE</literal>s with identical <literal>ALIGNMENT</literal> and there will be no <emphasis>make_id_tagdec</emphasis> or <emphasis>common_tagdec</emphasis> for the <literal>TAG</literal>.</para>

<para>If two <emphasis>make_var_tagdec</emphasis>s specify the same tag and both have <emphasis>signature</emphasis> present, the strings will be identical. Possible uses of this signature argument are outlined in -XREF-spec10.html#72section 7.28.</para>



</sect2>
<sect2>
<title>common_tagdec</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>3</member>
</simplelist>

<programlisting>
<emphasis>t_intro</emphasis>: TDFINT
<emphasis>acc</emphasis>:     OPTION(ACCESS)
<emphasis>signature</emphasis>:   OPTION(STRING)
<emphasis>x</emphasis>:       SHAPE
-&gt; TAGDEC
</programlisting>

<para>A <literal>TAGDEC</literal> announcing that the <literal>TAG</literal> <emphasis>t_intro</emphasis> identifies an <literal>EXP</literal> of <literal>SHAPE POINTER</literal>(<emphasis>alignment</emphasis> (<emphasis>x</emphasis>)) is constructed. </para>

<para><emphasis>acc</emphasis> specifies the <literal>ACCESS</literal> properties of the <literal>TAG</literal>.</para>

<para>If there is a <emphasis>common_tagdec</emphasis> for a <literal>TAG</literal> then there will be no <emphasis>make_id_tagdec</emphasis> or <emphasis>make_var_tagdec</emphasis> for that <literal>TAG</literal>. If there is more than one <emphasis>common_tagdec</emphasis> for a <literal>TAG</literal> the one having the maximum <literal>SHAPE</literal> shall be taken to apply for the <literal>CAPSULE</literal>. Each pair of such <literal>SHAPE</literal>s will have a maximum. The maximum of two <literal>SHAPE</literal>s, <emphasis>a</emphasis> and <emphasis>b</emphasis>, is defined as follows:</para>


<itemizedlist>
<listitem>
<para>If the <emphasis>a</emphasis> is equal to <emphasis>b</emphasis> the maximum is <emphasis>a</emphasis>.</para>
</listitem>
<listitem>
<para>If <emphasis>a</emphasis> and <emphasis>b</emphasis> are <literal>COMPOUND</literal>(<emphasis>x</emphasis>) and <literal>COMPOUND</literal>(<emphasis>y</emphasis>) respectively and <emphasis>a</emphasis> is an initial segment of <emphasis>b</emphasis>, then <emphasis>b</emphasis> is the maximum. Similarly if <emphasis>b</emphasis> is an initial segment of <emphasis>a</emphasis> then <emphasis>a</emphasis> is the maximum.</para>
</listitem>
<listitem>
<para>If <emphasis>a</emphasis> and <emphasis>b</emphasis> are <literal>NOF</literal>(<emphasis>n</emphasis>, <emphasis>x</emphasis>) and <literal>NOF</literal>(<emphasis>m</emphasis>, <emphasis>x</emphasis>) respectively and <emphasis>n</emphasis> is less than or equal to <emphasis>m</emphasis>, then <emphasis>b</emphasis> is the maximum. Similarly if <emphasis>m</emphasis> is less than or equal to <emphasis>n</emphasis> then <emphasis>a</emphasis> is the maximum.</para>
</listitem>
<listitem>
<para>Otherwise <emphasis>a</emphasis> and <emphasis>b</emphasis> have no maximum.</para>
</listitem>
</itemizedlist>

<para>If two <emphasis>common_tagdecs</emphasis> specify the same tag and both have <emphasis>signatures</emphasis> present, the strings will be identical. Possible uses of this signature argument are outlined in -XREF-spec10.html#72section 7.28. </para>




</sect2>
</sect1>

<sect1>
<title>TAGDEC_PROPS</title>
<simplelist type='horiz' columns='2'>

<member>Number of encoding bits:</member><member>0</member>
<member>Is coding extendable:</member><member>no</member>
<member>Unit identification:</member><member><emphasis>tagdec</emphasis></member>
</simplelist>

<sect2>
<title>make_tagdecs</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>0</member>
</simplelist>

<programlisting>
<emphasis>no_labels</emphasis>:   TDFINT
<emphasis>tds</emphasis>:     SLIST(TAGDEC)
-&gt; TAGDEC_PROPS
</programlisting>

<para><emphasis>no_labels</emphasis> is the number of local <literal>LABEL</literal>s used in <emphasis>tds</emphasis>. <emphasis>tds</emphasis> is a list of <literal>TAGDEC</literal>s which declare the <literal>SHAPE</literal>s associated with <literal>TAG</literal>s.</para>


</sect2>
</sect1>

<sect1>
<title>TAGDEF</title>
<simplelist type='horiz' columns='2'>

<member>Number of encoding bits:</member><member>2</member>
<member>Is coding extendable:</member><member>yes</member>

</simplelist>
<para>A value of <literal>SORT TAGDEF</literal> gives the definition of a <literal>TAG</literal> for incorporation into a <literal>TAGDEF_PROPS</literal>.</para>




<sect2>
<title>make_id_tagdef</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>1</member>
</simplelist>

<programlisting>
<emphasis>t</emphasis>:       TDFINT
<emphasis>signature</emphasis>:   OPTION(STRING)
<emphasis>e</emphasis>:       EXP <emphasis>x</emphasis>
-&gt; TAGDEF
</programlisting>

<para><emphasis>make_id_tagdef</emphasis> produces a <literal>TAGDEF</literal> defining the <literal>TAG</literal> <emphasis>x</emphasis> constructed from the <literal>TDFINT</literal>, <emphasis>t</emphasis>. This <literal>TAG</literal> is defined to stand for the value delivered by <emphasis>e</emphasis>.</para>

<para><emphasis>e</emphasis> will be a constant which can be evaluated at load_time or <emphasis>e</emphasis> will be some <emphasis>initial_value</emphasis>(E) (see -XREF-#M125section 5.16.48).</para>

<para><emphasis>t</emphasis> will be declared in the <literal>CAPSULE</literal> using <emphasis>make_id_tagdec</emphasis>. If both the <emphasis>make_id_tagdec</emphasis> and <emphasis>make_id_tagdef</emphasis> have <emphasis>signatures</emphasis> present, the strings will be identical.</para>

<para>If <emphasis>x</emphasis> is <literal>PROC</literal> and the <literal>TAG</literal> represented by <emphasis>t</emphasis> is named externally via a <literal>CAPSULE_LINK</literal>, e will be some <emphasis>make_proc</emphasis> or <emphasis>make_general_proc</emphasis>.</para>

<para>There will not be more than one <literal>TAGDEF</literal> defining <emphasis>t</emphasis> in a <literal>CAPSULE</literal>.</para>



</sect2>
<sect2>
<title>make_var_tagdef</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>2</member>
</simplelist>

<programlisting>
<emphasis>t</emphasis>:       TDFINT
<emphasis>opt_access</emphasis>:  OPTION(ACCESS)
<emphasis>signature</emphasis>:   OPTION(STRING)
<emphasis>e</emphasis>:       EXP <emphasis>x</emphasis>
-&gt; TAGDEF
</programlisting>

<para><emphasis>make_var_tagdef</emphasis> produces a <literal>TAGDEF</literal> defining the <literal>TAG POINTER</literal>(<emphasis>alignment(x)</emphasis>) constructed from the <literal>TDFINT</literal>, <emphasis>t</emphasis>. This <literal>TAG</literal> stands for a variable which is initialised with the value delivered by <emphasis>e</emphasis>. The <literal>TAG</literal> is bound to an original pointer which has the evaluation of the program as its lifetime.</para>

<para>If <emphasis>opt_access</emphasis> contains <emphasis>visible</emphasis>, the meaning is that the variable may be used by agents external to the capsule, and so it must not be optimised away. If it contains constant, the initialising value will remain in it throughout the program.</para>

<para><emphasis>e</emphasis> will be a constant which can be evaluated at load_time or <emphasis>e</emphasis> will be some <emphasis>initial_value</emphasis>(<emphasis>e1</emphasis>) (see -XREF-#M125section 5.16.48).</para>

<para><emphasis>t</emphasis> will be declared in the <literal>CAPSULE</literal> using <emphasis>make_var_tagdec</emphasis>. If both the <emphasis>make_var_tagdec</emphasis> and <emphasis>make_var_tagdef</emphasis> have <emphasis>signatures</emphasis> present, the strings will be identical.</para>

<para>There will not be more than one <literal>TAGDEF</literal> defining <emphasis>t</emphasis> in a <literal>CAPSULE</literal>.</para>



</sect2>
<sect2>
<title>common_tagdef</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>3</member>
</simplelist>

<programlisting>
<emphasis>t</emphasis>:       TDFINT
<emphasis>opt_access</emphasis>:  OPTION(ACCESS)
<emphasis>signature</emphasis>:   OPTION(STRING)
<emphasis>e</emphasis>:       EXP <emphasis>x</emphasis>
-&gt; TAGDEF
</programlisting>

<para><emphasis>common_tagdef</emphasis> produces a <literal>TAGDEF</literal> defining the <literal>TAG</literal> <literal>POINTER</literal>(<emphasis>alignment(x)</emphasis>) constructed from the <literal>TDFINT</literal>, <emphasis>t</emphasis>. This <literal>TAG</literal> stands for a variable which is initialised with the value delivered by <emphasis>e</emphasis>. The <literal>TAG</literal> is bound to an original pointer which has the evaluation of the program as its lifetime.</para>

<para>If <emphasis>opt_access</emphasis> contains <emphasis>visible</emphasis>, the meaning is that the variable may be used by agents external to the capsule, and so it must not be optimised away. If it contains constant, the initialising value will remain in it throughout the program.</para>

<para><emphasis>e</emphasis> will be a constant evaluable at load_time or <emphasis>e</emphasis> will be some <emphasis>initial_value</emphasis>(E) (see -XREF-#M125section 5.16.48 ).</para>

<para><emphasis>t</emphasis> will be declared in the <literal>CAPSULE</literal> using <emphasis>common_tagdec</emphasis>.If both the <emphasis>common_tagdec</emphasis> and

<para><emphasis>common_tagdef</emphasis> have <emphasis>signatures</emphasis> present, the string.</para>

<para>will be identical. Let the maximum <literal>SHAPE</literal> of these (see -XREF-#M331common_tagdec) be <emphasis>s</emphasis>.</para>

<para>There may be any number of <emphasis>common_tagdef</emphasis> definitions for <emphasis>t</emphasis> in a <literal>CAPSULE</literal>. Of the <emphasis>e</emphasis> parameters of these, one will be a maximum. This maximum definition is chosen as the definition of <emphasis>t</emphasis>. Its value of <emphasis>e</emphasis> will have <literal>SHAPE</literal> <emphasis>s</emphasis>.</para>

<para>The maximum of two <emphasis>common_tagdef</emphasis> <literal>EXP</literal>s, <emphasis>a</emphasis> and <emphasis>b</emphasis>, is defined as follows:</para>

<itemizedlist>
<listitem>
<para>If <emphasis>a</emphasis> has the form <emphasis>make_value</emphasis>(<emphasis>s</emphasis>), <emphasis>b</emphasis> is the maximum.</para>
</listitem>
<listitem>
<para>If <emphasis>b</emphasis> has the form <emphasis>make_value</emphasis>(<emphasis>s</emphasis>), <emphasis>a</emphasis> is the maximum.</para>
</listitem>
<listitem>
<para>If <emphasis>a</emphasis> and <emphasis>b</emphasis> have <literal>SHAPE COMPOUND</literal>(<emphasis>x</emphasis>) and <literal>COMPOUND</literal>(<emphasis>y</emphasis>) respectively and the value produced by <emphasis>a</emphasis> is an initial segment of the value produced by <emphasis>b</emphasis>, then <emphasis>b</emphasis> is the maximum. Similarly if <emphasis>b</emphasis> is an initial segment of <emphasis>a</emphasis> then <emphasis>a</emphasis> is the maximum.</para>
</listitem>
<listitem>
<para>If <emphasis>a</emphasis> and <emphasis>b</emphasis> have <literal>SHAPE NOF</literal>(<emphasis>n</emphasis>, <emphasis>x</emphasis>) and <literal>NOF</literal>(<emphasis>m</emphasis>, <emphasis>x</emphasis>) respectively and the value produced by <emphasis>a</emphasis> is an initial segment of the value produced by <emphasis>b</emphasis>, then <emphasis>b</emphasis> is the maximum. Similarly if <emphasis>b</emphasis> is an initial segment of <emphasis>a</emphasis> then <emphasis>a</emphasis> is the maximum.</para>
</listitem>
<listitem>
<para>If the value produced by <emphasis>a</emphasis> is equal to the value produced by <emphasis>b</emphasis> the maximum is <emphasis>a</emphasis>.</para>
</listitem>
<listitem>
<para>Otherwise <emphasis>a</emphasis> and <emphasis>b</emphasis> have no maximum.</para>
</listitem>
</itemizedlist>

</sect2>
</sect1>

<sect1>
<title>TAGDEF_PROPS</title>
<simplelist type='horiz' columns='2'>

<member>Number of encoding bits:</member><member>0</member>
<member>Is coding extendable:</member><member>no</member>
<member>Unit identification:</member><member><emphasis>tagdef</emphasis></member>

</simplelist>


<sect2>
<title>make_tagdefs</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>0</member>
</simplelist>

<programlisting>
<emphasis>no_labels</emphasis>:   TDFINT
<emphasis>tds</emphasis>:     SLIST(TAGDEF)
-&gt; TAGDEF_PROPS
</programlisting>

<para><emphasis>no_labels</emphasis> is the number of local <literal>LABEL</literal>s used in <emphasis>tds</emphasis>. <emphasis>tds</emphasis> is a list of <literal>TAGDEF</literal>s which give the <literal>EXP</literal>s which are the definitions of values associated with <literal>TAG</literal>s.</para>




</sect2>
</sect1>

<sect1>
<title>TAGSHACC</title>
<simplelist type='horiz' columns='2'>

<member>Number of encoding bits:</member><member>0</member>
<member>Is coding extendable:</member><member>no</member>
</simplelist>



<sect2>
<title>make_tagshacc</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>0</member>
</simplelist>

<programlisting>
<emphasis>sha</emphasis>:     SHAPE
<emphasis>opt_access</emphasis>:  OPTION(ACCESS)
<emphasis>tg_intro</emphasis>:    TAG
-&gt; TAGSHACC
</programlisting>

<para>This is an auxiliary construction to make the elements of <emphasis>params_intro</emphasis> in <emphasis>make_proc</emphasis>. </para>


</sect2>
</sect1>

<sect1>
<title>TDFBOOL</title>

<para>A <literal>TDFBOOL</literal> is the TDF encoding of a boolean. See -XREF-spec11.html#4Fundamental encoding. </para>


</sect1>

<sect1>
<title>TDFIDENT</title>

<para>A <literal>TDFIDENT</literal>(<emphasis>k</emphasis>, <emphasis>n</emphasis>) encodes a sequence of <emphasis>n</emphasis> unsigned integers of size <emphasis>k</emphasis> bits. <emphasis>k</emphasis> will be a multiple of 8. See -XREF-spec11.html#4Fundamental encoding. </para>

<para>This construction will not be used inside a <literal>BITSTREAM</literal>.</para>




</sect1>
<sect1>
<title>TDFINT</title>

<para>A <literal>TDFINT</literal> is the TDF encoding of an unbounded unsigned integer constant. See -XREF-spec11.html#4Fundamental encoding. </para>




</sect1>
<sect1>
<title>TDFSTRING</title>

<para>A <literal>TDFSTRING</literal>(<emphasis>k</emphasis>, <emphasis>n</emphasis>) encodes a sequence of <emphasis>n</emphasis> unsigned integers of size <emphasis>k</emphasis> bits. See -XREF-spec11.html#4Fundamental encoding. </para>




</sect1>

<sect1>
<title>TOKDEC</title>
<simplelist type='horiz' columns='2'>
<member>Number of encoding bits:</member><member>1</member>
<member>Is coding extendable:</member><member>yes</member>
</simplelist>
<para>A <literal>TOKDEC</literal> declares a <literal>TOKEN</literal> for incorporation into a <literal>UNIT</literal>.</para>



<sect2>
<title>make_tokdec</title>

<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>1</member>
</simplelist>

<programlisting>
<emphasis>tok</emphasis>:     TDFINT
<emphasis>signature</emphasis>:   OPTION(STRING)
<emphasis>s</emphasis>:       SORTNAME
-&gt; TOKDEC
</programlisting>

<para>The sort of the token <emphasis>tok</emphasis> is declared to be <emphasis>s</emphasis>. Note that <emphasis>s</emphasis> will always be a token <literal>SORT</literal>, with a list of parameter <literal>SORT</literal>s (possible empty) and a result <literal>SORT</literal>. </para>

<para>If <emphasis>signature</emphasis> is present, it will be produced by <emphasis>make_string</emphasis>.</para>

<para>If two <emphasis>make_tokdecs</emphasis> specify the same token and both have <emphasis>signatures</emphasis> present, the strings will be identical. Possible uses of this signature argument are outlined in -XREF-spec10.html#72section 7.28.</para>

</sect2>
</sect1>

<sect1>
<title>TOKDEC_PROPS</title>
<simplelist type='horiz' columns='2'>

<member>Number of encoding bits:</member><member>0</member>
<member>Is coding extendable:</member><member>no</member>
<member>Unit identification:</member><member><emphasis>tokdec</emphasis></member>
</simplelist>


<sect2>
<title>make_tokdecs</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>0</member>
</simplelist>
<programlisting>
<emphasis>tds</emphasis>:     SLIST(TOKDEC)
-&gt; TOKDEC_PROPS
</programlisting>

<para><emphasis>tds</emphasis> is a list of <literal>TOKDEC</literal>s which gives the sorts associated with <literal>TOKEN</literal>s.</para>

</sect2>
</sect1>

<sect1>
<title>TOKDEF</title>
<simplelist type='horiz' columns='2'>

<member>Number of encoding bits:</member><member>1</member>
<member>Is coding extendable:</member><member>yes</member>
</simplelist>

<para>A <literal>TOKDEF</literal> gives the definition of a <literal>TOKEN</literal> for incorporation into a <literal>TOKDEF_PROPS</literal>.</para>



<sect2>
<title>make_tokdef</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>1</member>
</simplelist>

<programlisting>
<emphasis>tok</emphasis>:     TDFINT
<emphasis>signature</emphasis>:   OPTION(STRING)
<emphasis>def</emphasis>:     BITSTREAM TOKEN_DEFN
-&gt; TOKDEF
</programlisting>

<para>A <literal>TOKDEF</literal> is constructed which defines the <literal>TOKEN</literal> <emphasis>tok</emphasis> to stand for the fragment of TDF, <emphasis>body</emphasis>, which may be of any <literal>SORT</literal> with a <literal>SORTNAME</literal>, except for <emphasis>token</emphasis>. The <literal>SORT</literal> of the result, <emphasis>result_sort</emphasis>, is given by the first component of the <literal>BITSTREAM</literal>. See -XREF-#M362token_definition. </para>

<para>If <emphasis>signature</emphasis> is present, it will be produced by <emphasis>make_string</emphasis>.</para>

<para><emphasis>tok</emphasis> may have been introduced by a <emphasis>make_tokdec</emphasis>. If both the <emphasis>make_tokdec</emphasis> and <emphasis>make_tokdef</emphasis> have <emphasis>signatures</emphasis> present, the strings will be identical.</para>

<para>At the application of this <literal>TOKEN</literal> actual pieces of TDF having <literal>SORT</literal> <emphasis>sn</emphasis>[<emphasis>i</emphasis>] are supplied to correspond to the <emphasis>tk</emphasis>[<emphasis>i</emphasis>]. The application denotes the piece of TDF obtained by substituting these actual parameters for the corresponding <literal>TOKEN</literal>s within <emphasis>body</emphasis>.</para>


</sect2>

<sect1>
<title>TOKDEF_PROPS</title>
<simplelist type='horiz' columns='2'>

<member>Number of encoding bits:</member><member>0</member>
<member>Is coding extendable:</member><member>no</member>
<member>Unit identification:</member><member><emphasis>tokdef</emphasis></member>

</simplelist>

<sect2>
<title>make_tokdefs</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>0</member>

</simplelist>
<programlisting>
<emphasis>no_labels</emphasis>:   TDFINT
<emphasis>tds</emphasis>:     SLIST(TOKDEF)
-&gt; TOKDEF_PROPS
</programlisting>

<para><emphasis>no_labels</emphasis> is the number of local <literal>LABEL</literal>s used in <emphasis>tds</emphasis>. <emphasis>tds</emphasis> is a list of <literal>TOKDEF</literal>s which gives the definitions associated with <literal>TOKEN</literal>s.</para>




</sect2>
</sect1>

<sect1>
<title>TOKEN</title>
<simplelist type='horiz' columns='2'>

<member>Number of encoding bits:</member><member>2</member>
<member>Is coding extendable:</member><member>yes</member>
<member>Linkable entity identification:</member><member><emphasis>token</emphasis></member>
</simplelist>

<para>These are used to stand for functions evaluated at installation time. They are represented by <literal>TDFINT</literal>s.</para>



<sect2>
<title>token_apply_token</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>1</member>
</simplelist>

<programlisting>
<emphasis>token_value</emphasis>: TOKEN
<emphasis>token_args</emphasis>:  BITSTREAM <emphasis>param_sorts(token_value)</emphasis>
-&gt; TOKEN
</programlisting>

<para>The token is applied to the arguments to give a <literal>TOKEN</literal>. </para>

<para>If there is a definition for <emphasis>token_value</emphasis> in the <literal>CAPSULE</literal> then <emphasis>token_args</emphasis> is a <literal>BITSTREAM</literal> encoding of the <literal>SORT</literal>s of its parameters, in the order specified.</para>



</sect2>
<sect2>
<title>make_tok</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>2</member>

</simplelist>
<programlisting>
<emphasis>tokno</emphasis>:       TDFINT
-&gt; TOKEN
</programlisting>

<para><emphasis>make_tok</emphasis> constructs a <literal>TOKEN</literal> identified by <emphasis>tokno</emphasis>.</para>



</sect2>
<sect2>
<title>use_tokdef</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>3</member>
</simplelist>

<programlisting>
<emphasis>tdef</emphasis>:        BITSTREAM TOKEN_DEFN
-&gt; TOKEN
</programlisting>

<para><emphasis>tdef</emphasis> is used to supply the definition, as in <emphasis>make_tokdef</emphasis>. Note that <literal>TOKEN</literal>s are only used in <emphasis>x_apply_token</emphasis> constructions.</para>




</sect2>
</sect1>

<sect1>
<title>TOKEN_DEFN</title>
<simplelist type='horiz' columns='2'>

<member>Number of encoding bits:</member><member>1</member>
<member>Is coding extendable:</member><member>yes</member>
</simplelist>

<para>An auxiliary <literal>SORT</literal> used in <emphasis>make_tokdef</emphasis> and <emphasis>use_tokdef</emphasis>.</para>


<sect2>
<title>token_definition</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>1</member>

</simplelist>

<programlisting>
<emphasis>result_sort</emphasis>: SORTNAME
<emphasis>tok_params</emphasis>:  LIST(TOKFORMALS)
<emphasis>body</emphasis>:        <emphasis>result_sort</emphasis>
-&gt; TOKEN_DEFN
</programlisting>

<para>Makes a token definition. <emphasis>result_sort</emphasis> is the <literal>SORT</literal> of body. <emphasis>tok_params</emphasis> is a list of formal <literal>TOKEN</literal>s and their <literal>SORT</literal>s. <emphasis>body</emphasis> is the definition, which can use the formal <literal>TOKEN</literal>s defined in <emphasis>tok_params</emphasis>. </para>

<para>The effect of applying the definition of a <literal>TOKEN</literal> is as if the following sequence was obeyed.</para>

<para>First, the actual parameters (if any) are expanded to produce expressions of the appropriate <literal>SORT</literal>s. During this expansion all token applications in the actual parameters are expanded.</para>

<para>Second, the definition is copied, making fresh <literal>TAG</literal>s and <literal>LABEL</literal>s where these are introduced in <emphasis>identify</emphasis>, <emphasis>variable</emphasis>, <emphasis>labelled</emphasis>, <emphasis>conditional</emphasis>, <emphasis>make_proc, make_general_proc</emphasis> and <emphasis>repeat</emphasis> constructions. Any other <literal>TAG</literal>s or <literal>LABEL</literal>s used in <emphasis>body</emphasis> will be provided by the context (see below) of the <literal>TOKEN_DEFN</literal> or by the expansions of the actual parameters.</para>

<para>Third, the actual parameter expressions are substituted for the formal parameter tokens in <emphasis>tok_params</emphasis> to give the final result.</para>

<para>The context of a <literal>TOKEN_DEFN</literal> is the set of names (<literal>TOKEN</literal>s, <literal>TAG</literal>s, <literal>LABEL</literal>s, <literal>AL_TAG</literal>s etc.) &quot;in scope&quot; at the site of the <literal>TOKEN_DEFN</literal>.</para>

<para>Thus, in a <emphasis>make_tokdef</emphasis>, the context consists of the set of <literal>TOKEN</literal>s defined in its tokdef <literal>UNIT</literal>, together with the set of linkable entities defined by the <emphasis>make_links</emphasis> of that <literal>UNIT</literal>. Note that this does not include <literal>LABEL</literal>s and the only <literal>TAG</literal>s included are &quot;global&quot; ones.</para>

<para>In a <emphasis>use_tokdef</emphasis>, the context may be wider, since the site of the <literal>TOKEN_DEFN</literal> need not be in a tokdef <literal>UNIT</literal>; it may be an actual parameter of a token application. If this happens to be within an EXP, there may be <literal>TAG</literal>s or <literal>LABEL</literal>s locally within scope; these will be in the context of the <literal>TOKEN_DEFN</literal>, together with the global names of the enclosing UNIT as before.</para>

<para>Previous versions of the specification limited token definitions to be non-recursive. There is no intrinsic reason for the limitation on recursive <literal>TOKEN</literal>s. Since the UNIT structure implies different namespaces, there is very little implementation advantage to be gained from retaining the limitation.</para>




</sect2>
</sect1>

<sect1>
<title>TOKFORMALS</title>
<simplelist type='horiz' columns='2'>

<member>Number of encoding bits:</member><member>0</member>
<member>Is coding extendable:</member><member>no</member>

</simplelist>


<sect2>
<title>make_tokformals</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>0</member>
</simplelist>

<programlisting>
<emphasis>sn</emphasis>:      SORTNAME
<emphasis>tk</emphasis>:      TDFINT
-&gt; TOKFORMALS
</programlisting>

<para>An auxiliary construction to make up the elements of the lists in <emphasis>token_definition</emphasis>. </para>




</sect2>
</sect1>

<sect1>
<title>TRANSFER_MODE</title>
<simplelist type='horiz' columns='2'>

<member>Number of encoding bits:</member><member>3</member>
<member>Is coding extendable:</member><member>yes</member>
</simplelist>

<para>A <literal>TRANSFER_MODE</literal> controls the operation of <emphasis>assign_with_mode</emphasis>, <emphasis>contents_with_mode</emphasis> and <emphasis>move_some</emphasis>.</para>

<para>A <literal>TRANSFER_MODE</literal> acts like a set of the values <emphasis>overlap, trap_on_nil, complete</emphasis> and <emphasis>volatile</emphasis>. The <literal>TRANSFER_MODE</literal> <emphasis>standard_transfer_mode</emphasis> acts like the empty set. <emphasis>add_modes</emphasis> acts like set union.</para>



<sect2>
<title>transfer_mode_apply_token</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>1</member>
</simplelist>

<programlisting>
<emphasis>token_value</emphasis>: TOKEN
<emphasis>token_args</emphasis>:  BITSTREAM <emphasis>param_sorts(token_value)</emphasis>
-&gt; TRANSFER_MODE
</programlisting>

<para>The token is applied to the arguments encoded in the <literal>BITSTREAM</literal> <emphasis>token_args</emphasis> to give a <literal>TRANSFER_MODE</literal>. </para>

<para>The notation <emphasis>param_sorts(token_value)</emphasis> is intended to mean the following. The token definition or token declaration for <emphasis>token_value</emphasis> gives the <literal>SORT</literal>s of its arguments in the <literal>SORTNAME</literal> component. The <literal>BITSTREAM</literal> in <emphasis>token_args</emphasis> consists of these <literal>SORT</literal>s in the given order. If no token declaration or definition exists in the <literal>CAPSULE</literal>, the <literal>BITSTREAM</literal> cannot be read.</para>



</sect2>
<sect2>
<title>transfer_mode_cond</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>2</member>
</simplelist>

<programlisting>
<emphasis>control</emphasis>: EXP INTEGER(<emphasis>v</emphasis>)
<emphasis>e1</emphasis>:      BITSTREAM TRANSFER_MODE
<emphasis>e2</emphasis>:      BITSTREAM TRANSFER_MODE
-&gt; TRANSFER_MODE
</programlisting>

<para><emphasis>control</emphasis> is evaluated. It will be a constant at install time under the constant evaluation rules. If it is non-zero, <emphasis>e1</emphasis> is installed at this point and <emphasis>e2</emphasis> is ignored and never processed. If <emphasis>control</emphasis> is zero then <emphasis>e2</emphasis> is installed at this point and <emphasis>e1</emphasis> is ignored and never processed.</para>



</sect2>
<sect2>
<title>add_modes</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>3</member>
</simplelist>

<programlisting>
<emphasis>md1</emphasis>:     TRANSFER_MODE
<emphasis>md2</emphasis>:     TRANSFER_MODE
-&gt; TRANSFER_MODE
</programlisting>

<para>A construction qualified by <emphasis>add_modes</emphasis> has both <literal>TRANSFER_MODES</literal> <emphasis>md1</emphasis> and <emphasis>md2</emphasis>. If <emphasis>md1</emphasis> is <emphasis>standard_transfer_mode</emphasis> then the result is <emphasis>md2</emphasis> and symmetrically. This operation is associative and commutative. </para>



</sect2>
<sect2>
<title>overlap</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>4</member>
</simplelist>

<programlisting>
-&gt; TRANSFER_MODE
</programlisting>

<para>If <emphasis>overlap</emphasis> is used to qualify a <emphasis>move_some</emphasis> or an <emphasis>assign_with_mode</emphasis> for which <emphasis>arg2</emphasis> is a <emphasis>contents</emphasis> or <emphasis>contents_with_mode</emphasis>, then the source and destination might overlap. The transfer shall be made as if the data were copied from the source to an independent place and thence to the destination. </para>

<para>See -XREF-spec10.html#48Overlapping.</para>



</sect2>
<sect2>
<title>standard_transfer_mode</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>5</member>
</simplelist>

<programlisting>
-&gt; TRANSFER_MODE
</programlisting>

<para>This <literal>TRANSFER_MODE</literal> implies no special properties. </para>



</sect2>
<sect2>
<title>trap_on_nil</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>6</member>
</simplelist>

<programlisting>
-&gt; TRANSFER_MODE
</programlisting>

<para>If <emphasis>trap_on_nil</emphasis> is used to qualify a <emphasis>contents_with_mode</emphasis> operation with a nil pointer argument, or an <emphasis>assign_with_mode</emphasis> whose arg1 is a nil pointer, or a <emphasis>move_some</emphasis> with either argument a nil pointer, the TDF exception <emphasis>nil_access</emphasis> is raised. </para>



</sect2>
<sect2>
<title>volatile</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>7</member>
</simplelist>

<programlisting>
-&gt; TRANSFER_MODE
</programlisting>

<para>If <emphasis>volatile</emphasis> is used to qualify a construction it shall not be optimised away. </para>

<para>This is intended to implement ANSI C's volatile construction. In this use, any volatile identifier should be declared as a <literal>TAG</literal> with used_as_volatile <literal>ACCESS</literal>.</para>



</sect2>
<sect2>
<title>complete</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>8</member>
</simplelist>

<programlisting>
-&gt; TRANSFER_MODE
</programlisting>

<para>A transfer qualified with complete shall leave the destination unchanged if the evaluation of the value transferred is left with a jump. </para>




</sect2>

</sect1>

<sect1>
<title>UNIQUE</title>
<simplelist type='horiz' columns='2'>

<member>Number of encoding bits:</member><member>0</member>
<member>Is coding extendable:</member><member>no</member>
</simplelist>

<para>These are used to provide world-wide unique names for <literal>TOKEN</literal>s and <literal>TAG</literal>s.</para>

<para>This implies a registry for allocating <literal>UNIQUE</literal> values.</para>



<sect2>
<title>make_unique</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>0</member>
</simplelist>

<programlisting>
<emphasis>text</emphasis>:        SLIST(TDFIDENT)
-&gt; UNIQUE
</programlisting>

<para>Two <literal>UNIQUE</literal> values are equal if and only if they were constructed with equal arguments. </para>




</sect2>
</sect1>

<sect1>
<title>UNIT</title>
<simplelist type='horiz' columns='2'>

<member>Number of encoding bits:</member><member>0</member>
<member>Is coding extendable:</member><member>no</member>
</simplelist>

<para>A <literal>UNIT</literal> gathers together a <literal>PROPS</literal> and <literal>LINK</literal>s which relate the names by which objects are known inside the <literal>PROPS</literal> and names by which they are to be known across the whole of the enclosing <literal>CAPSULE</literal>.</para>



<sect2>
<title>make_unit</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>0</member>

</simplelist>
<programlisting>
<emphasis>local_vars</emphasis>:  SLIST(TDFINT)
<emphasis>lks</emphasis>:     SLIST(LINKS)
<emphasis>properties</emphasis>:  BYTESTREAM PROPS
-&gt; UNIT
</programlisting>

<para><emphasis>local_vars</emphasis> gives the number of linkable entities of each kind. These numbers correspond (in the same order) to the variable sorts in <emphasis>cap_linking</emphasis> in <emphasis>make_capsule</emphasis>. The linkable entities will be represented by <literal>TDFINT</literal>s in the range 0 to the corresponding <emphasis>nl</emphasis>-1.</para>

<para><emphasis>lks</emphasis> gives the <literal>LINK</literal>s for each kind of entity in the same order as in <emphasis>local_vars</emphasis>.</para>

<para>The <emphasis>properties</emphasis> will be a <literal>PROPS</literal> of a form dictated by the unit identification, see -XREF-#M53make_capsule.</para>

<para>The length of <emphasis>lks</emphasis> will be either 0 or equal to the length of <emphasis>cap_linking</emphasis> in <emphasis>make_capsule</emphasis>.</para>




</sect2>
</sect1>

<sect1>
<title>VARIETY</title>
<simplelist type='horiz' columns='2'>

<member>Number of encoding bits:</member><member>2</member>
<member>Is coding extendable:</member><member>yes</member>
</simplelist>

<para>These describe the different kinds of integer which can occur at run time. The fundamental construction consists of a <literal>SIGNED_NAT</literal> for the lower bound of the range of possible values, and a <literal>SIGNED_NAT</literal> for the upper bound (inclusive at both ends).</para>

<para>There is no limitation on the magnitude of these bounds in TDF, but an installer may specify limits. See -XREF-spec10.html#51Representing integers.</para>



<sect2>
<title>var_apply_token</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>1</member>
</simplelist>

<programlisting>
<emphasis>token_value</emphasis>: TOKEN
<emphasis>token_args</emphasis>:  BITSTREAM <emphasis>param_sorts(token_value)</emphasis>
-&gt; VARIETY
</programlisting>

<para>The token is applied to the arguments to give a <literal>VARIETY</literal>. </para>

<para>If there is a definition for <emphasis>token_value</emphasis> in the <literal>CAPSULE</literal> then <emphasis>token_args</emphasis> is a <literal>BITSTREAM</literal> encoding of the <literal>SORT</literal>s of its parameters, in the order specified.</para>



</sect2>
<sect2>
<title>var_cond</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>2</member>
</simplelist>

<programlisting>
<emphasis>control</emphasis>: EXP INTEGER(<emphasis>v</emphasis>)
<emphasis>e1</emphasis>:      BITSTREAM VARIETY
<emphasis>e2</emphasis>:      BITSTREAM VARIETY
-&gt; VARIETY
</programlisting>

<para>The <emphasis>control</emphasis> is evaluated. It will be a constant at install time under the constant evaluation rules. If it is non-zero, <emphasis>e1</emphasis> is installed at this point and <emphasis>e2</emphasis> is ignored and never processed. If <emphasis>control</emphasis> is zero then <emphasis>e2</emphasis> is installed at this point and <emphasis>e1</emphasis> is ignored and never processed. </para>



</sect2>
<sect2>
<title>var_limits</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>3</member>
</simplelist>

<programlisting>
<emphasis>lower_bound</emphasis>: SIGNED_NAT
<emphasis>upper_bound</emphasis>: SIGNED_NAT
-&gt; VARIETY
</programlisting>

<para><emphasis>lower_bound</emphasis> is the lower limit (inclusive) of the range of values which shall be representable in the resulting <literal>VARIETY</literal>, and <emphasis>upper_bound</emphasis> is the upper limit (inclusive).</para>


</sect2>
<sect2>
<title>var_width</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>4</member>
</simplelist>

<programlisting>
<emphasis>signed_width</emphasis>:    BOOL
<emphasis>width</emphasis>:       NAT
-&gt; VARIETY
</programlisting>

<para>If <emphasis>signed_width</emphasis> is <emphasis>true</emphasis> then this construction is equivalent to <emphasis>var_limits</emphasis>(-2<<emphasis>width</emphasis>-1, 2<emphasis>width</emphasis>-1-1). If <emphasis>signed_width</emphasis> is <emphasis>false</emphasis> then this construction is <emphasis>var_limits</emphasis> (0, 2<emphasis>width</emphasis>-1). </para>




</sect2>
</sect1>

<sect1>
<title>VERSION_PROPS</title>
<simplelist type='horiz' columns='2'>

<member>Number of encoding bits:</member><member>0</member>
<member>Is coding extendable:</member><member>no</member>
<member>Unit identification:</member><member><emphasis>versions</emphasis></member>
</simplelist>
<para>This <literal>UNIT</literal> gives information about version numbers and user information.</para>



<sect2>
<title>make_versions</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>0</member>
</simplelist>

<programlisting>
<emphasis>version_info</emphasis>:    SLIST(VERSION)
-&gt; VERSION_PROPS
</programlisting>

<para>Contains version information. </para>




</sect2>
</sect1>

<sect1>
<title>VERSION</title>
<simplelist type='horiz' columns='2'>

<member>Number of encoding bits:</member><member>1</member>
<member>Is coding extendable:</member><member>yes</member>
</simplelist>



<sect2>
<title>make_version</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>1</member>
</simplelist>

<programlisting>
<emphasis>major_version</emphasis>:   TDFINT
<emphasis>minor_version</emphasis>:   TDFINT
-&gt; VERSION
</programlisting>

<para>The major and minor version numbers of the TDF used. An increase in minor version number means an extension of facilities, an increase in major version number means an incompatible change. TDF with the same major number but a lower minor number than the installer shall install correctly. </para>

<para>For TDF conforming to this specification the major number will be 4 and the minor number will be 0.</para>

<para>Every <literal>CAPSULE</literal> will contain at least one <emphasis>make_version</emphasis> construct.</para>



</sect2>
<sect2>
<title>user_info</title>
<simplelist type='horiz' columns='2'>

<member>Encoding number:</member><member>2</member>
</simplelist>

<programlisting>
<emphasis>information</emphasis>: STRING(<emphasis>k, n</emphasis>)
-&gt; VERSION
</programlisting>

<para>This is (usually character) information included in the TDF for labelling purposes. </para>

<para><emphasis>information</emphasis> will be produced by <emphasis>make_string</emphasis>.</para>

</sect2>
</sect1>
</chapter>

<chapter>
<title>Supplementary UNIT</title>
<para> </para>

<sect1>
<title>LINKINFO_PROPS</title>

<simplelist type='horiz' columns='2'>
<member>Number of encoding bits:</member> <member>0</member>
<member>Is coding extendable:</member> <member>no</member>
<member>Unit identification:</member><member><emphasis>linkinfo</emphasis></member>
</simplelist>

<para>This is an additional <literal>UNIT</literal> which gives extra information about linking.</para>

<sect2>
<title>make_linkinfos</title>
<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>0</member>
</simplelist>

<programlisting>
<emphasis>no_labels</emphasis>:   TDFINT
<emphasis>tds</emphasis>:     SLIST(LINKINFO)
-&gt; LINKINFO_PROPS
</programlisting>

<para>Makes the <literal>UNIT</literal>.</para>
</sect2>
</sect1>

<sect1>
<title>LINKINFO</title>

<simplelist type='horiz' columns='2'>
<member>Number of encoding bits:</member><member>2</member>
<member>Is coding extendable:</member><member>yes</member>
</simplelist>

<sect2>
<title>static_name_def</title>

<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>1</member>
</simplelist>

<programlisting>
<emphasis>assexp</emphasis>:      EXP POINTER <emphasis>x</emphasis>
<emphasis>id</emphasis>:      TDFSTRING<emphasis>(k, n)</emphasis>
-&gt; LINKINFO
</programlisting>

<para><emphasis>assexp</emphasis> will be an <emphasis>obtain_tag</emphasis> construction which refers to a <literal>TAG</literal> which is defined with <emphasis>make_id_tagdef</emphasis>, <emphasis>make_var_tagdef</emphasis> or <emphasis>common_tagdef</emphasis>. This <literal>TAG</literal> will not be linked to an <literal>EXTERNAL</literal>.</para>

<para>The name <emphasis>id</emphasis> shall be used (but not exported, i.e. <emphasis>static</emphasis>) to identify the definition for subsequent linking.</para>

<para>This construction is likely to be needed for profiling, so that useful names appear for statically defined objects. It may also be needed when C++ is translated into C, in order to identify global initialisers.</para>

</sect2>
<sect2>
<title>make_comment</title>

<simplelist type='horiz' columns='2'>
<member>Encoding number:</member> <member>2</member>
</simplelist>

<programlisting>
<emphasis>n</emphasis>:       TDFSTRING<emphasis>(k, n)</emphasis>
-&gt; LINKINFO
</programlisting>

<para><emphasis>n</emphasis> shall be incorporated into the object file as a comment, if this facility exists. Otherwise the construct is ignored.</para>

</sect2>
<sect2>
<title>make_weak_defn</title>

<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>3</member>
</simplelist>

<programlisting>
<emphasis>namer</emphasis>:       EXP POINTER <emphasis>x</emphasis>
<emphasis>val</emphasis>:     EXP POINTER <emphasis>y</emphasis>
-&gt; LINKINFO
</programlisting>

<para><emphasis>namer</emphasis> and <emphasis>val</emphasis> will be <emphasis>obtain_tag</emphasis> constructions which refer to <literal>TAG</literal>s which are defined with <emphasis>make_id_tagdef</emphasis>, <emphasis>make_var_tagdef</emphasis> or <emphasis>common_tagdef</emphasis>. They shall be made synonymous.</para>

</sect2>
<sect2>
<title>make_weak_symbol</title>

<simplelist type='horiz' columns='2'>
<member>Encoding number:</member><member>4</member>
</simplelist>

<programlisting>
<emphasis>id</emphasis>:      TDFSTRING<emphasis>(k, n)</emphasis>
<emphasis>val</emphasis>:     EXP POINTER <emphasis>x</emphasis>
-&gt; LINKINFO
</programlisting>

<para><emphasis>val</emphasis> will be an <emphasis>obtain_tag</emphasis> construction which refers to a <literal>TAG</literal> which is defined with <emphasis>make_id_tagdef</emphasis>, <emphasis>make_var_tagdef</emphasis> or <emphasis>common_tagdef</emphasis>.</para>

<para>This <literal>TAG</literal> shall be made <emphasis>weak</emphasis> (in the same sense as in the SVID ABI Symbol Table), and <emphasis>id</emphasis> shall be synonymous with it.</para>
</sect2>
</sect1>
</chapter>






<chapter>
<title>Notes</title>

<para> </para>

<sect1>
<title>Binding</title>

<para>The following constructions introduce <literal>TAG</literal>s: <emphasis>identify</emphasis>, <emphasis>variable</emphasis>, <emphasis>make_proc</emphasis>, <emphasis>make_general_proc</emphasis>, <emphasis>make_id_tagdec</emphasis>, <emphasis>make_var_tagdec</emphasis>, <emphasis>common_tagdec</emphasis>.</para>

<para>During the evaluation of <emphasis>identify</emphasis> and <emphasis>variable</emphasis> a value, <emphasis>v</emphasis>, is produced which is bound to the <literal>TAG</literal> during the evaluation of an <literal>EXP</literal> or <literal>EXP</literal>s. The <literal>TAG</literal> is &quot;in scope&quot; for these <literal>EXP</literal>s. This means that in the <literal>EXP</literal> a use of the <literal>TAG</literal> is permissible and will refer to the declaration.</para>

<para>The <emphasis>make_proc</emphasis> and <emphasis>make_general_proc</emphasis> construction introduces <literal>TAG</literal>s which are bound to the actual parameters on each call of the procedure. These <literal>TAG</literal>s are &quot;in scope&quot; for the body of the procedure.</para>

<para>If a <emphasis>make_proc</emphasis> or <emphasis>make_general_proc</emphasis> construction occurs in the body of another <emphasis>make_proc</emphasis> or <emphasis>make_general_proc</emphasis>, the <literal>TAG</literal>s of the inner procedure are not in scope in the outer procedure, nor are the <literal>TAG</literal>s of the outer in scope in the inner.</para>

<para>The <emphasis>apply_general_proc</emphasis> construction permits the introduction of <literal>TAG</literal>s whose scope is the <emphasis>postlude</emphasis> argument. These are bound to the values of caller parameters after the evaluation of the body of the procedure.</para>

<para>The <emphasis>make_id_tagdec</emphasis>, <emphasis>make_var_tagdec</emphasis> and <emphasis>common_tagdec</emphasis> constructions introduce <literal>TAG</literal>s which are &quot;in scope&quot; throughout all the <emphasis>tagdef</emphasis> <literal>UNIT</literal>s. These <literal>TAG</literal>s may have values defined for them in the <emphasis>tagdef</emphasis> <literal>UNIT</literal>s, or values may be supplied by linking.</para>

<para>-XREF-M3-XREF-M4-XREF-M5The following constructions introduce <literal>LABEL</literal>s: <emphasis>conditional</emphasis>, <emphasis>repeat</emphasis>, <emphasis>labelled</emphasis>.</para>

<para>The construction themselves define <literal>EXP</literal>s for which these <literal>LABEL</literal>s are &quot;in scope&quot;. This means that in the <literal>EXP</literal>s a use of the <literal>LABEL</literal> is permissible and will refer to the introducing construction.</para>

<para><literal>TAG</literal>s, <literal>LABEL</literal>s and <literal>TOKEN</literal>s (as <literal>TOKEN</literal> parameters) introduced in the body of a <literal>TOKEN</literal> definition are systematically renamed in their scope each time the <literal>TOKEN</literal> definition is applied. The scope will be completely included by the <literal>TOKEN</literal> definition.</para>

<para>Each of the values introduced in a <literal>UNIT</literal> will be named by a different <literal>TAG</literal>, and the labelling constructions will use different labels, so no visibility rules are needed. The set of <literal>TAG</literal>s and <literal>LABEL</literal>s used in a simple <literal>UNIT</literal> are considered separately from those in another simple <literal>UNIT</literal>, so no question of visibility arises. The compound and link <literal>UNIT</literal>s provide a method of relating the items in one simple <literal>UNIT</literal> to those in another, but this is through the intermediary of another set of <literal>TAG</literal>s and <literal>TOKEN</literal>s at the <literal>CAPSULE</literal> level.</para>

</sect1>
<sect1>
<title>Character codes</title>

<para>TDF does not have a concept of characters. It transmits integers of various sizes. So if a producer wishes to communicate characters to an installer, it will usually have to do so by encoding them in some way as integers.</para>

<para>An ANSI C producer sending a TDF program to a set of normal C environments may well choose to encode its characters using the ASCII codes, an EBCDIC based producer transmitting to a known set of EBCDIC environments might use the code directly, and a wide character producer might likewise choose a specific encoding. For some programs this way of proceeding is necessary, because the codes are used both to represent characters and for arithmetic, so the particular encoding is enforced. In these cases it will not be possible to translate the characters to another encoding because the character codes will be used in the TDF as ordinary integers, which must not be translated.</para>

<para>Some producers may wish to transmit true characters, in the sense that something is needed to represent particular printing shapes and nothing else. These representations will have to be transformed into the correct character encoding on the target machine.</para>

<para>Probably the best way to do this is to use <literal>TOKEN</literal>s. A fixed representation for the printing marks could be chosen in terms of integers and <literal>TOKEN</literal>s introduced to represent the translation from these integers to local character codes, and from strings of integers to strings of local character codes. These definitions could be bound on the target machine and the installer should be capable of translating these constructions into efficient machine code. To make this a standard, unique <literal>TOKEN</literal>s should be used.</para>

<para>But this raises the question, who chooses the fixed representation and the unique <literal>TOKEN</literal>s and their specification? Clearly TDF provides a mechanism for performing the standardisation without itself defining a standard.</para>

<para>Here TDF gives rise to the need for extra standards, especially in the specification of globally named unique <literal>TOKEN</literal>s.</para>

</sect1>
<sect1>
<title>Constant evaluation</title>

<para>Some constructions require an <literal>EXP</literal> argument which is &quot;constant at install time&quot;. For an <literal>EXP</literal> to satisfy this condition it must be constructed according to the following rules after substitution of token definitions and selection of <emphasis>exp_cond</emphasis> branches.</para>

<para>If it contains <emphasis>obtain_tag</emphasis> then the tag will be introduced within the <literal>EXP</literal>, or defined with <emphasis>make_id_tagdef</emphasis> within the current capsule.</para>

<para>It may not contain any of the following constructions: <emphasis>apply_proc, apply_general_proc, assign_with_mode</emphasis>, <emphasis>contents_with_mode</emphasis>, <emphasis>continue</emphasis>, <emphasis>current_env</emphasis>, <emphasis>error_jump</emphasis>, <emphasis>goto_local_lv</emphasis>, <emphasis>make_local_lv</emphasis>, <emphasis>move_some</emphasis>, <emphasis>repeat</emphasis>, <emphasis>round_as_state</emphasis>.</para>

<para>Unless it is the <literal>EXP</literal> argument of a <literal>TAGDEF</literal>, a &quot;constant at install time&quot; may not contain <emphasis>env_offset</emphasis> or <emphasis>env_size</emphasis>.</para>

<para>Any use of <emphasis>contents</emphasis> or <emphasis>assign</emphasis> will be applied only to <literal>POINTER</literal>s derived from <emphasis>variable</emphasis> constructions.</para>

<para>If it contains <emphasis>labelled</emphasis> there will only be jumps to the <literal>LABEL</literal>s from within <emphasis>starter</emphasis>, not from within any of the <emphasis>places</emphasis>.</para>

<para>Any use of <emphasis>obtain_tag</emphasis> defined with <emphasis>make_id_tagdef</emphasis> will occur after the end of the <emphasis>make_id_tagdef</emphasis>.</para>

<para>Note specifically that a constant <literal>EXP</literal> forming the defining value of a <literal>TAGDEF</literal> construct may contain <emphasis>env_offset</emphasis> and/or <emphasis>env_size</emphasis>.</para>

</sect1>
<sect1>
<title>Division and modulus</title>

<para>Two classes of division (D) and remainder (M) construct are defined. The two classes have the same definition if both operands have the same sign. Neither is defined if the second argument is zero.</para>

<sect2>
<title>Class 1</title>

<programlisting>
<emphasis>p</emphasis> D1 <emphasis>q</emphasis> = <emphasis>n</emphasis>
</programlisting>

<para>where:</para>

<programlisting>
<emphasis>p</emphasis> = <emphasis>n</emphasis>*<emphasis>q</emphasis> + (<emphasis>p</emphasis> M1 <emphasis>q</emphasis>)
sign(<emphasis>p</emphasis> M1 <emphasis>q</emphasis>) = sign(<emphasis>q</emphasis>)
0 &lt;= |<emphasis>p</emphasis> M1 <emphasis>q</emphasis>| &lt; |<emphasis>q</emphasis>|
</programlisting>
</sect2>

<sect2>
<title>Class 2</title>

<programlisting>
<emphasis>p</emphasis> D2 <emphasis>q</emphasis> = <emphasis>n</emphasis>
</programlisting>

<para>where:</para>

<programlisting>
<emphasis>p</emphasis> = <emphasis>n</emphasis>*<emphasis>q</emphasis> + (<emphasis>p</emphasis> M2 <emphasis>q</emphasis>)
sign(<emphasis>p</emphasis> M2 <emphasis>q</emphasis>) = sign(<emphasis>p</emphasis>)
0 &lt;= |<emphasis>p</emphasis> M2 <emphasis>q</emphasis>| &lt; |<emphasis>q</emphasis>|
</programlisting>

</sect2>

</sect1>
<sect1>
<title>Equality of EXPs</title>

<para>A definition of equality of <literal>EXP</literal>s would be a considerable part of a formal specification of TDF, and is not given here.</para>

</sect1>
<sect1>
<title>Equality of SHAPEs</title>

<para>Equality of <literal>SHAPE</literal>s is defined recursively:</para>

<itemizedlist>
<listitem>
<para>Two <literal>SHAPE</literal>s are equal if they are both <literal>BOTTOM</literal>, or both <literal>TOP</literal> or both <literal>PROC</literal>.</para>
</listitem>
<listitem>
<para>Two <literal>SHAPE</literal>s are equal if they are both <emphasis>integer</emphasis> or both <emphasis>floating</emphasis>, or both <emphasis>bitfield</emphasis>, and the corresponding parameters are equal.</para>
</listitem>
<listitem>
<para>Two <literal>SHAPE</literal>s are equal if they are both <literal>NOF</literal>, the numbers of items are equal and the <literal>SHAPE</literal> parameters are equal.</para>
</listitem>
<listitem>
<para>Two <literal>OFFSET</literal>s or two <literal>POINTER</literal>s are equal if their <literal>ALIGNMENT</literal> parameters are pairwise equal.</para>
</listitem>
<listitem>
<para>Two <literal>COMPOUND</literal>s are equal if their <literal>OFFSET</literal> <literal>EXP</literal>s are equal.</para>
</listitem>
<listitem>
<para>No other pairs of <literal>SHAPE</literal>s are equal.</para>
</listitem>
</itemizedlist>

</sect1>
<sect1>
<title>Equality of ALIGNMENTs</title>

<para>Two <literal>ALIGNMENT</literal>s are equal if and only if they are equal sets.</para>

</sect1>
<sect1>
<title>Exceptions and jumps</title>

<para>TDF allows simply for labels and jumps within a procedure, by means of the <emphasis>conditional</emphasis>, <emphasis>labelled</emphasis> and <emphasis>repeat</emphasis> constructions, and the <emphasis>goto</emphasis>, <emphasis>case</emphasis> and various <emphasis>test</emphasis> constructions. But there are two more complex jumping situations.</para>

<para>First there is the jump, known to stay within a procedure, but to a computed destination. Many languages have discouraged this kind of construction, but it is still available in Cobol (implicitly), and it can be used to provide other facilities (see below). TDF allows it by means of the <literal>POINTER(</literal>{<emphasis>code</emphasis><literal>})</literal>. TDF is arranged so that this can usually be implemented as the address of the label. The <emphasis>goto_local_lv</emphasis> construction just jumps to the label.</para>

<para>The other kind of construction needed is the jump out of a procedure to a label which is still active, restoring the environment of the destination procedure: the long jump. Related to this is the notion of exception. Unfortunately long jumps and exceptions do not co-exist well. Exceptions are commonly organised so that any necessary destruction operations are performed as the stack of frames is traversed; long jumps commonly go directly to the destination. TDF must provide some facility which can express both of these concepts. Furthermore exceptions come in several different versions, according to how the exception handlers are discriminated and whether exception handling is initiated if there is no handler which will catch the exception.</para>

<para>Fortunately the normal implementations of these concepts provide a suggestion as to how they can be introduced into TDF. The local label value provides the destination address, the environment (produced by <emphasis>current_env</emphasis>) provides the stack frame for the destination, and the stack re-setting needed by the local label jumps themselves provides the necessary stack information. If more information is needed, such as which exception handlers are active, this can be created by producing the appropriate TDF.</para>

<para>So TDF takes the long jump as the basic construction, and its parameters are a local label value and an environment. Everything else can be built in terms of these.</para>

<para>The TDF arithmetic constructions allows one to specify a <literal>LABEL</literal> as destination if the result of the operation is exceptional. This is sufficient for the kind of explicit exception handling found in C++ and, in principle, could also be used to implement the kind of &quot;automatic&quot; exception detection and handling found in Ada, for example.</para>

<para>However many architectures have facilities for automatically trapping on exceptions without explicit testing. To take advantage of this, there is a <emphasis>trap</emphasis> <literal>ERROR_TREATMENT</literal> with associated <literal>ERROR_CODE</literal>s. The action taken on an exception with <emphasis>trap</emphasis> <literal>ERROR_TREATMENT</literal> will be to &quot;throw&quot; the <literal>ERROR_CODE</literal>. Since each language has its own idea of how to interpret the <literal>ERROR_CODE</literal> and handle exceptions, the onus is on the producer writer to describe how to throw an <literal>ERROR_CODE</literal>.</para>

<para>The producer writer must give a definition of a <literal>TOKEN</literal> <emphasis>~Throw</emphasis> : <literal>NAT</literal> -&gt; <literal>EXP</literal> where the <literal>NAT</literal> will be the <emphasis>error_val</emphasis> of some <literal>ERROR_CODE</literal>. The expansion of this token will be consistent with the interpretation of the relevant <literal>ERROR_CODE</literal> and the method of handling exceptions. Usually this will consist of decoding the <literal>ERROR_CODE</literal> and doing a long_jump on some globals set up by the procedure in which the exception handling takes place.</para>

<para>The translator writer will provide a parameterless <literal>EXP TOKEN</literal>, <emphasis>~Set_signal_handler</emphasis>. This <literal>TOKEN</literal> will use <emphasis>~Throw</emphasis> and must be applied before any possible exceptions. This implies that the definition of both <emphasis>~Throw</emphasis> and <emphasis>~Set_signal_handler</emphasis> must be bound before translation of any <literal>CAPSULE</literal> which uses them, presumeably by linking with some TDF libraries.</para>

<para>These tokens are specified in more detail in the companion document, -XREF-register.htmlTDF Token Register.</para>

</sect1>
<sect1>
<title>Procedures</title>

<para>The <emphasis>var_intro</emphasis> of a <emphasis>make_proc</emphasis>, if present, may be used under one of two different circumstances. In one circumstance, the <literal>POINTER TAG</literal> provided by the <emphasis>var_intro</emphasis> is used to access the actual <emphasis>var_param</emphasis> of an <emphasis>apply_proc</emphasis>. If this is the case, all uses of <emphasis>apply_proc</emphasis> which have the effect of calling this procedure will have the <emphasis>var_param</emphasis> option present, and they will all have precisely the same number of <emphasis>params</emphasis> as <emphasis>params_intro</emphasis> in the <emphasis>make_proc</emphasis>. The body of the <emphasis>make_proc</emphasis> can access elements of the <emphasis>var_param</emphasis> by using <literal>OFFSET</literal> arithmetic relative to the <literal>POINTER TAG</literal>. This provides a method of supplying a variable number of parameters, by composing them into a compound value which is supplied as the <emphasis>var_param</emphasis>.</para>

<para>However, this has proved to be unsatisfactory for the implementation of variable number of parameters in C - one cannot choose the <literal>POINTER</literal> alignment of the <literal>TAG</literal> a priori in non-prototype calls.</para>

<para>An alternative circumstance for using <emphasis>var_intro</emphasis> is where all uses of <emphasis>apply_proc</emphasis> which have the effect of calling this procedure may have more <emphasis>params</emphasis> present than the number of <emphasis>params_intro</emphasis>, and none of them will have their <emphasis>var_param</emphasis> option present. The body of the <emphasis>make_proc</emphasis> can access the additional params by using installer-defined <literal>TOKEN</literal>s specified in the companion document -XREF-register.htmlTDF Token Register, analogous to the use of variable argument lists in C. A local variable <emphasis>v</emphasis> of shape <emphasis>~va_list</emphasis> must be initialised to <emphasis>~__va_start</emphasis>(<emphasis>p</emphasis>), where <emphasis>p</emphasis> is the <literal>POINTER</literal> obtained from the <emphasis>var_intro</emphasis>. Successive elements of the <emphasis>params</emphasis> list can then be obtained by successive applications of <emphasis>~va_arg</emphasis>(<emphasis>v</emphasis>,<emphasis>s</emphasis>) where <emphasis>s</emphasis> is the <literal>SHAPE</literal> of element obtained. Finally, <emphasis>~va_end</emphasis>(<emphasis>v</emphasis>) completes the use of <emphasis>v</emphasis>.</para>

<para>The definition of caller parameters in general procedures addesses this difficulty in a different way, by describing the layout of caller parameters qualified by <literal>PROCPROPS</literal> <emphasis>var_callers</emphasis>. This allows both the call and the body to have closely associated views of the <literal>OFFSET</literal>s within a parameter set, regardless of whether or not the particular parameter has been named. The installer-defined <literal>TOKEN</literal> <emphasis>~next_caller_offset</emphasis> provides access to successive caller parameters, by using <literal>OFFSET</literal>s relative to the current frame pointer <emphasis>current_env</emphasis>, adjusting for any differences there may be between the closely associated views. The <emphasis>caller_intro</emphasis> list of the <emphasis>make_general_proc</emphasis> must not be empty, then the sequence of <literal>OFFSET</literal>s can start with an appropriate <emphasis>env_offset</emphasis>. Similar consideration applies to accessing within the callee parameters, using the installer-defined <literal>TOKEN</literal> <emphasis>~next_callee_offset</emphasis>.</para>

<para>All uses of <emphasis>return</emphasis>, <emphasis>untidy_return</emphasis> and <emphasis>tail_call</emphasis> in a procedure will return values of the same <literal>SHAPE</literal>, and this will be the <emphasis>result_shape</emphasis> specified in all uses of <emphasis>apply_proc</emphasis> or <emphasis>apply_general_proc</emphasis> calling the procedure.</para>

<para>The use of <emphasis>untidy_return</emphasis> gives a generalisation of <emphasis>local_alloc</emphasis>. It extends the validity of pointers allocated by <emphasis>local_alloc</emphasis> within the immediatly enclosing procedure into the calling procedure. The original space of these pointers may be invalidated by <emphasis>local_free</emphasis> just as if it had been generated by <emphasis>local_alloc</emphasis> in the calling procedure.</para>

<para>The <literal>PROCPROPS</literal> <emphasis>check_stack</emphasis> may be used to check that limit set by set_stack_limit is not exceeded by the allocation of the static locals of a procedure body to be obeyed. If it is exceeded then the producer-defined <literal>TOKEN</literal> <emphasis>~Throw</emphasis>: <literal>NAT</literal> -&gt; <literal>EXP</literal> will be invoked as <emphasis>~Throw</emphasis>(<emphasis>error_val</emphasis>(<emphasis>stack_overflow</emphasis>)). Note that this will not include any space generated by <literal>local_alloc</literal>; an explicit test is required to do check these.</para>

<para>Any <literal>SHAPE</literal> is permitted as the <emphasis>result_shape</emphasis> in an <emphasis>apply_proc</emphasis> or <emphasis>apply_general_proc</emphasis>.</para>

<para>-XREF-S392</para>

</sect1>
<sect1>
<title>Frames</title>

<para>TDF states that while a particular procedure activation is current, it is possible to create a <literal>POINTER</literal>, by using <emphasis>current_env</emphasis>, which gives access to all the declared variables and identifications of the activation which are alive and which have been marked as <emphasis>visible</emphasis>. The construction <emphasis>env_offset</emphasis> gives the <literal>OFFSET</literal> of one of these relative to such a <literal>POINTER</literal>. These constructions may serve for several purposes.</para>

<para>One significant purpose is to implement such languages as Pascal which have procedures declared inside other procedures. One way of implementing this is by means of a &quot;display&quot;, that is, a tuple of frame pointers of active procedures.</para>

<para>Another purpose is to find active variables satisfying some criterion in all the procedure activations. This is commonly required for garbage collection. TDF does not force the installer to implement a frame pointer register, since some machines do not work best in this way. Instead, a frame pointer is created only if required by <emphasis>current_env</emphasis>. The implication of this is that this sort of garbage collection needs the collaboration of the producer to create TDF which makes the correct calls on <emphasis>current_env</emphasis> and <emphasis>env_offset</emphasis> and place suitable values in known positions.</para>

<para>Programs compiled especially to provide good diagnostic information can also use these operations.</para>

<para>In general any program which wishes to manipulate the frames of procedures other than the current one can use <emphasis>current_env</emphasis> and <emphasis>env_offset</emphasis> to do so.</para>

<para>A frame consists of three components, the caller parameters, callee parameters and locals of the procedure involved. Since each component may have different internal methods of access within the frame, each has a different special frame alignment associated with pointers within them. These are <emphasis>callers_alignment</emphasis>, <emphasis>callees_alignment</emphasis> and <emphasis>locals_alignment</emphasis>. The <literal>POINTER</literal> produced by <emphasis>current_env</emphasis> will be some union of these special alignments depending on how the procedure was defined.</para>

<para>Each of these frame alignments are considered to contain any <literal>ALIGNMENT</literal> produced by <emphasis>alignment</emphasis> from any <literal>SHAPE</literal>. Note that this does not say that they are the set union of all such <literal>ALIGNMENT</literal>s. This is because the interpretation of pointer and offset operations (notably <emphasis>add_to_pointer</emphasis>) may be different depending on the implementation of the frames; they may involve extra indirections.</para>

<para>Accordingly, because of the constraints on <emphasis>add_to_ptr</emphasis>, an <literal>OFFSET</literal> produced by <emphasis>env_offset</emphasis> can only be added to a <literal>POINTER</literal> produced by <emphasis>current_env</emphasis>. It is a further constraint that such an <literal>OFFSET</literal> will only be added to a <literal>POINTER</literal> produced from <emphasis>current_env</emphasis> used on the procedure which declared the <literal>TAG</literal>.</para>

</sect1>
<sect1>
<title>Lifetimes</title>

<para><literal>TAG</literal>s are bound to values during the evaluation of <literal>EXP</literal>s, which are specified by the construction which introduces the <literal>TAG</literal>. The evaluation of these <literal>EXP</literal>s is called the lifetime of the activation of the <literal>TAG</literal>.</para>

<para>Note that lifetime is a different concept from that of scope. For example, if the <literal>EXP</literal> contains the application of a procedure, the evaluation of the body of the procedure is within the lifetime of the <literal>TAG</literal>, but the <literal>TAG</literal> will not be in scope.</para>

<para>A similar concept applies to <literal>LABEL</literal>s.</para>

</sect1>
<sect1>
<title>Alloca</title>

<para>The constructions involving <emphasis>alloca</emphasis> (<emphasis>last_local</emphasis>, <emphasis>local_alloc</emphasis>, <emphasis>local_free</emphasis>, <emphasis>local_free_all</emphasis>) as well as the <emphasis>untidy_return</emphasis> construction imply a stack-like implementation which is related to procedure calls. They may be implemented using the same stack as the procedure frames, if there is such a stack, or it may be more convenient to implement them separately. However note that if the <emphasis>alloca</emphasis> mechanism is implemented as a stack, this may be an upward or a downward growing stack.</para>

<para>The state of this notional stack is referred to here as the <emphasis>alloca</emphasis> state. The construction <emphasis>local_alloc</emphasis> creates a new space on the <emphasis>alloca</emphasis> stack, the size of this space being given by an <literal>OFFSET</literal>. In the special case that this <literal>OFFSET</literal> is zero, <emphasis>local_alloc</emphasis> in effect gives the current <emphasis>alloca</emphasis> state (normally a <literal>POINTER</literal> to the top of the stack).</para>

<para>A use of <emphasis>local_free_all</emphasis> returns the <emphasis>alloca</emphasis> state to what it was on entry to the current procedure.</para>

<para>The construction <emphasis>last_local</emphasis> gives a <literal>POINTER</literal> to the top item on the stack, but it is necessary to give the size of this (as an <literal>OFFSET</literal>) because this cannot be deduced if the stack is upward growing. This top item will be the whole of an item previously allocated with <emphasis>local_alloc</emphasis>.</para>

<para>The construction <emphasis>local_free</emphasis> returns the state of the <emphasis>alloca</emphasis> machine to what it was when its parameter <literal>POINTER</literal> was allocated. The <literal>OFFSET</literal> parameter will be the same value as that with which the <literal>POINTER</literal> was allocated.</para>

<para>The <literal>ALIGNMENT</literal> of the <literal>POINTER</literal> delivered by <emphasis>local_alloc</emphasis> is <emphasis>alloca_alignment</emphasis>. This shall include the set union of all the <literal>ALIGNMENT</literal>s which can be produced by <emphasis>alignment</emphasis> from any <literal>SHAPE</literal>.</para>

<para>-XREF-M24-XREF-M25The use of <emphasis>alloca_alignment</emphasis> arises so that the <emphasis>alloca</emphasis> stack can hold any kind of value. The sizes of spaces allocated must be rounded up to the appropriate <literal>ALIGNMENT</literal>. Since this includes all value <literal>ALIGNMENT</literal>s a value of any <literal>ALIGNMENT</literal> can be assigned into this space. Note that there is no necessary relation with the special frame alignments (see -XREF-#19section 7.10) though they must both contain all the <literal>ALIGNMENT</literal>s which can be produced by <emphasis>alignment</emphasis> from any <literal>SHAPE</literal>.</para>

<para>Stack pushing is <emphasis>local_alloc</emphasis>. Stack popping can be performed by use of <emphasis>last_local</emphasis> and <emphasis>local_free</emphasis>. Remembering the state of the <emphasis>alloca</emphasis> stack and returning to it can be performed by using <emphasis>local_alloc</emphasis> with a zero <literal>OFFSET</literal> and <emphasis>local_free</emphasis>.</para>

<para>Note that stack pushing can also be achieved by the use of a procedure call with <emphasis>untidy_return</emphasis>.</para>

<para>A transfer of control to a local label by means of <emphasis>goto</emphasis>, <emphasis>goto_local_lv</emphasis>, any <emphasis>test</emphasis> construction or any <emphasis>error_jump</emphasis> will not change the <emphasis>alloca</emphasis> stack.</para>

<note>
<para>If an installer implements identify and variable by creating space on a stack when they come into existence, rather than doing the allocation for identify and variable at the start of a procedure activation, then it may have to consider making the alloca stack into a second stack.</para>
</note>

</sect1>
<sect1>
<title>Memory Model</title>

<para>The layout of data in memory is entirely determined by the calculation of <literal>OFFSET</literal>s relative to <literal>POINTER</literal>s. That is, it is determined by <literal>OFFSET</literal> arithmetic and the <emphasis>add_to_ptr</emphasis> construction.</para>

<para>A <literal>POINTER</literal> is parameterised by the <literal>ALIGNMENT</literal> of the data indicated. An <literal>ALIGNMENT</literal> is a set of all the different kinds of basic value which can be indicated by a <literal>POINTER</literal>. That is, it is a set chosen from all <literal>VARIETY</literal>s, all <literal>FLOATING_VARIETY</literal>s, <emphasis>all</emphasis> <literal>BITFIELD_VARIETY</literal>s<emphasis>, proc</emphasis>, <emphasis>code</emphasis>, <emphasis>pointer</emphasis> and <emphasis>offset</emphasis>. There are also three special <literal>ALIGNMENT</literal>s, <emphasis>frame_alignment</emphasis>, <emphasis>alloca_alignment</emphasis> and <emphasis>var_param_alignment</emphasis>.</para>

<para>The parameter of a <literal>POINTER</literal> will not consist entirely of <literal>BITFIELD_VARIETY</literal>s.</para>

<para>The implication of this is that the <literal>ALIGNMENT</literal> of all procedures is the same, the <literal>ALIGNMENT</literal> of all <literal>POINTER</literal>s is the same and the <literal>ALIGNMENT</literal> of all <literal>OFFSET</literal>s is the same.</para>

<para>At present this corresponds to the state of affairs for all machines. But it is certainly possible that, for example, 64-bit pointers might be aligned on 64-bit boundaries while 32-bit pointers are aligned on 32-bit boundaries. In this case it will become necessary to add different kinds of pointer to TDF. This will not present a problem, because, to use such pointers, similar changes will have to be made in languages to distinguish the kinds of pointer if they are to be mixed.</para>

<para>The difference between two <literal>POINTER</literal>s is measured by an <literal>OFFSET</literal>. Hence an <literal>OFFSET</literal> is parameterised by two <literal>ALIGNMENT</literal>s, that of the starting <literal>POINTER</literal> and that of the end <literal>POINTER</literal>. The <literal>ALIGNMENT</literal> set of the first must include the <literal>ALIGNMENT</literal> set of the second.</para>

<para>The parameters of an <literal>OFFSET</literal> may consist entirely of <literal>BITFIELD_VARIETY</literal>s.</para>

<para>The operations on <literal>OFFSET</literal>s are subject to various constraints on <literal>ALIGNMENT</literal>s. It is important not to read into offset arithmetic what is not there. Accordingly some rules of the algebra of <literal>OFFSET</literal>s are given below.</para>

<itemizedlist>
<listitem>
<para><emphasis>offset_add</emphasis> is associative.</para>
</listitem>
<listitem>
<para><emphasis>offset_mult</emphasis> corresponds to repeated offset_addition.</para>
</listitem>
<listitem>
<para><emphasis>offset_max</emphasis> is commutative, associative and idempotent.</para>
</listitem>
<listitem>
<para><emphasis>offset_add</emphasis> distributes over <emphasis>offset_max</emphasis> where they form legal expressions.</para>
</listitem>
<listitem>
<para><emphasis>offset_test</emphasis>(<emphasis>prob</emphasis>, &gt;= , <emphasis>a</emphasis>, <emphasis>b</emphasis>) continues if <emphasis>offset_max</emphasis>(<emphasis>a</emphasis>,<emphasis>b</emphasis>) = <emphasis>a</emphasis>.</para>
</listitem>
</itemizedlist>


<sect2>
<title>Simple model</title>

<para>An example of the representation of <literal>OFFSET</literal> arithmetic is given below. This is not a definition, but only an example. In order to make this clear a machine with bit addressing is hypothesized. This machine is referred to as the simple model.</para>

<para>In this machine <literal>ALIGNMENT</literal>s will be represented by the number by which the bit address of data must be divisible. For example, 8-bit bytes might have an <literal>ALIGNMENT</literal> of 8, longs of 32 and doubles of 64. <literal>OFFSET</literal>s will be represented by the displacement in bits from a <literal>POINTER</literal>. <literal>POINTER</literal>s will be represented by the bit address of the data. Only one memory space will exist. Then in this example a possible conforming implementation would be as follows.</para>

<itemizedlist>
<listitem>
<para><emphasis>add_to_ptr</emphasis> is addition.</para>
</listitem>
<listitem>
<para><emphasis>offset_add</emphasis> is addition.</para>
</listitem>
<listitem>
<para><emphasis>offset_div</emphasis> and <emphasis>offset_div_by_int</emphasis> are exact division.</para>
</listitem>
<listitem>
<para><emphasis>offset_max</emphasis> is maximum.</para>
</listitem>
<listitem>
<para><emphasis>offset_mult</emphasis> is multiply.</para>
</listitem>
<listitem>
<para><emphasis>offset_negate</emphasis> is negate.</para>
</listitem>
<listitem>
<para><emphasis>offset_pad</emphasis>(<emphasis>a</emphasis>, <emphasis>x</emphasis>) is ((<emphasis>x</emphasis> + <emphasis>a</emphasis> - 1) / <emphasis>a</emphasis>) * <emphasis>a</emphasis></para>
</listitem>
<listitem>
<para><emphasis>offset_subtract</emphasis> is subtract.</para>
</listitem>
<listitem>
<para><emphasis>offset_test</emphasis> is <emphasis>integer_test</emphasis>.</para>
</listitem>
<listitem>
<para><emphasis>offset_zero</emphasis> is 0.</para>
</listitem>
<listitem>
<para><emphasis>shape_offset</emphasis>(<emphasis>s</emphasis>) is the minimum number of bits needed to be moved to move a value of <literal>SHAPE</literal> <emphasis>s</emphasis>.</para>
</listitem>
</itemizedlist>


<para>Note that these operations only exist where the constraints on the parameters are satisfied. Elsewhere the operations are undefined.</para>

<para>All the computations in this representation are obvious, but there is one point to make concerning <emphasis>offset_max</emphasis>, which has the following arguments and result.</para>

<programlisting>
<emphasis>arg1</emphasis>:        EXP OFFSET(<emphasis>x</emphasis>, <emphasis>y</emphasis>)
<emphasis>arg2</emphasis>:        EXP OFFSET(<emphasis>z</emphasis>, <emphasis>y</emphasis>)
-&gt; EXP OFFSET(<emphasis>unite_alignments</emphasis>(<emphasis>x</emphasis>, <emphasis>z</emphasis>), <emphasis>y</emphasis>)
</programlisting>

<para>The <literal>SHAPE</literal>s could have been chosen to be:</para>

<programlisting>
<emphasis>arg1</emphasis>:        EXP OFFSET(<emphasis>x</emphasis>, <emphasis>y</emphasis>)
<emphasis>arg2</emphasis>:        EXP OFFSET(<emphasis>z</emphasis>, <emphasis>t</emphasis>)
-&gt; EXP OFFSET(<emphasis>unite_alignments</emphasis>(<emphasis>x</emphasis>, <emphasis>z</emphasis>),
<emphasis>intersect_alignments</emphasis>(<emphasis>y</emphasis>, <emphasis>t</emphasis>))
</programlisting>

<para>where <emphasis>unite_alignments</emphasis> is set union and <emphasis>intersect_alignments</emphasis> is set intersection. This would have expressed the most general reality. The representation of <emphasis>unite_alignments</emphasis>(<emphasis>x</emphasis>, <emphasis>z</emphasis>) is the maximum of the representations of <emphasis>x</emphasis> and <emphasis>z</emphasis> in the simple model. Unfortunately the representation of <emphasis>intersect_alignments</emphasis>(<emphasis>y</emphasis>, <emphasis>t</emphasis>) is not the minimum of the representations of <emphasis>y</emphasis> and <emphasis>t</emphasis>. In other words the simple model representation is not a homomorphism if <emphasis>intersect_alignments</emphasis> is used. Because the choice of representation in the installer is an important consideration the actual definition was chosen instead. It seems unlikely that this will affect practical programs significantly.</para>

</sect2>

<sect2>
<title>Comparison of pointers and offsets</title>

<para>Two <literal>POINTER</literal>s to the same <literal>ALIGNMENT</literal>, <emphasis>a</emphasis>, are equal if and only if the result of <emphasis>subtract_ptrs</emphasis> applied to them is equal to <emphasis>offset_zero</emphasis>(<emphasis>a</emphasis>).</para>

<para>The comparison of <literal>OFFSET</literal>s is reduced to the definition of <emphasis>offset_max</emphasis> and the equality of <literal>OFFSET</literal>s by the note in -XREF-spec8.html#M172offset_test.</para>

</sect2>

<sect2>
<title>Circular types in languages</title>

<para>It is assumed that circular types in programming languages will always involve the <literal>SHAPE</literal>s <literal>PROC</literal> or <literal>POINTER</literal>(<emphasis>x</emphasis>) on the circular path in their TDF representation. Since the <literal>ALIGNMENT</literal> of <literal>POINTER</literal> is {<emphasis>pointer</emphasis>} and does not involve the <literal>ALIGNMENT</literal> of the thing pointed at, circular <literal>SHAPE</literal>s are not needed. The circularity is always broken in <literal>ALIGNMENT</literal> (or <literal>PROC</literal>).</para>

</sect2>

<sect2>
<title>Special alignments</title>

<para>There are seven special <literal>ALIGNMENT</literal>s. One of these is <emphasis>code_alignment</emphasis>, the <literal>ALIGNMENT</literal> of the <literal>POINTER</literal> delivered by <emphasis>make_local_lv</emphasis>.</para>

<para>The <literal>ALIGNMENT</literal> of a parameter of <literal>SHAPE</literal> <emphasis>s</emphasis> is given by <emphasis>parameter_alignment</emphasis>(<emphasis>s</emphasis>) which will always contain <emphasis>alignment</emphasis>(<emphasis>s</emphasis>).</para>

<para>The other five special <literal>ALIGNMENT</literal>s are <emphasis>alloca_alignment</emphasis>, <emphasis>callees_alignment, callers_alignment, locals_alignment</emphasis> and <emphasis>var_param_alignment</emphasis>. Each of these contains the set union of all the <literal>ALIGNMENT</literal>s which can be produced by <emphasis>alignment</emphasis> from any <literal>SHAPE</literal>. But they need not be equal to that set union, nor need there be any relation between them.</para>

<para>In particular they are not equal (in the sense of -XREF-#15Equality of <literal>ALIGNMENT</literal>s).</para>

<para>Each of these five refer to alignments of various components of a frame.</para>

<para>Notice that pointers and offsets such as <literal>POINTER</literal>(<emphasis>callees_alignment</emphasis>(true)) and <literal>OFFSET</literal>(<emphasis>callees_alignment</emphasis>(true), <emphasis>x</emphasis>) etc. can have some special representation and that <emphasis>add_to_ptr</emphasis> and <emphasis>offset_add</emphasis> can operate correctly on these representations. However it is necessary that</para>

<programlisting>
<emphasis>alignment</emphasis>(POINTER(<emphasis>A</emphasis>))={<emphasis>pointer</emphasis>}
</programlisting>

<para>for any <literal>ALIGNMENT</literal> <emphasis>A</emphasis>.</para>

</sect2>

<sect2>
<title>Atomic assignment</title>

<para>At least one <literal>VARIETY</literal> shall exist such that <emphasis>assign</emphasis> and <emphasis>assign_with_mode</emphasis> are atomic operations. This <literal>VARIETY</literal> shall be specified as part of the installer specification. It shall be capable of representing the numbers 0 to 127.</para>

<note>
<para>It is not necessary for this to be the same <literal>VARIETY</literal> on each machine. Normal practice will be to use a <literal>TOKEN</literal> for this <literal>VARIETY</literal> and choose the definition of the <literal>TOKEN</literal> on the target machine.</para>
</note>
</sect2>
</sect1>
<sect1>
<title>Order of evaluation</title>

<para>The order of evaluation is specified in certain constructions in terms of equivalent effect with a canonical order of evaluation. These constructions are <emphasis>conditional</emphasis>, <emphasis>identify</emphasis>, <emphasis>labelled</emphasis>, <emphasis>repeat</emphasis>, <emphasis>sequence</emphasis> and <emphasis>variable</emphasis>. Let these be called the order-specifying constructions.</para>

<para>The constructions which change control also specify a canonical order. These are <emphasis>apply_proc</emphasis>, <emphasis>apply_general_proc</emphasis>, <emphasis>case</emphasis>, <emphasis>goto</emphasis>, <emphasis>goto_local_lv</emphasis>, <emphasis>long_jump</emphasis>, <emphasis>return</emphasis>, u<emphasis>ntidy_return, return_to_label, tail_call,</emphasis> the <emphasis>test</emphasis> constructions and all instructions containing the <emphasis>error_jump</emphasis> and <emphasis>trap</emphasis> <literal>ERROR_TREATMENT</literal>s.</para>

<para>The order of evaluation of the components of other constructions is as follows. The components may be evaluated in any order and with their components - down to the TDF leaf level - interleaved in any order. The constituents of the order specifying constructions may also be interleaved in any order, but the order of the operations within an order specifying operation shall be equivalent in effect to a canonical order.</para>

<para>Note that the rule specifying when error_jumps or traps are to be taken (-XREF-spec8.html#M68<emphasis>error_jump</emphasis>) relaxes the strict rule that everything has to be &quot;as if&quot; completed by the end of certain constructions. Without this rule pipelines would have to stop at such points, in order to be sure of processing any errors. Since this is not normally needed, it would be an expensive requirement. Hence this rule. However a construction will be required to force errors to be processed in the cases where this is important.</para>


</sect1>
<sect1>
<title>Original pointers</title>

<para>Certain constructions are specified as producing original pointers. They allocate space to hold values and produce pointers indicating that new space. All other pointer values are derived pointers, which are produced from original pointers by a sequence of <emphasis>add_to_ptr</emphasis> operations. Counting original pointers as being derived from themselves, every pointer is derived from just one original pointer.</para>

<para>A null pointer is counted as an original pointer.</para>

<para>-XREF-M47If procedures are called which come from outside the TDF world (such as <emphasis>calloc</emphasis>) it is part of their interface with TDF to state if they produce original pointers, and what is the lifetime of the pointer.</para>

<para>As a special case, original pointers can be produced by using <emphasis>current_env</emphasis> and <emphasis>env_offset</emphasis> (see -XREF-spec8.html#M101<emphasis>current_env</emphasis>).</para>

<para>Note that:</para>

<programlisting>
<emphasis>add_to_ptr(p, offset_add(q, r))</emphasis>
</programlisting>

<para>is equivalent to:</para>

<programlisting>
<emphasis>add_to_ptr(add_to_ptr(p, q), r)</emphasis>
</programlisting>

<para>In the case that <emphasis>p</emphasis> is the result of <emphasis>current_env</emphasis> and <emphasis>q</emphasis> is the result of <emphasis>env_offset</emphasis>:</para>

<programlisting>
<emphasis>add_to_ptr(p, q)</emphasis>
</programlisting>

<para>is defined to be an original pointer. For any such expression <emphasis>q</emphasis> will be produced by <emphasis>env_offset</emphasis> applied to a <literal>TAG</literal> introduced in the procedure in which <emphasis>current_env</emphasis> was used to make <emphasis>p</emphasis>.</para>


</sect1>
<sect1>
<title>Overlapping</title>

<para>In the case of <emphasis>move_some</emphasis>, or <emphasis>assign</emphasis> or <emphasis>assign_with_mode</emphasis> in which <emphasis>arg2</emphasis> is a <emphasis>contents</emphasis> or <emphasis>contents_with_mode</emphasis>, it is possible that the source and destination of the transfer might overlap.</para>

<para>In this case, if the operation is <emphasis>move_some</emphasis> or <emphasis>assign_with_mode</emphasis> and the <literal>TRANSFER_MODE</literal> contains <emphasis>overlap</emphasis>, then the transfer shall be performed correctly, that is, as if the data were copied from the source to an independent place and then to the destination.</para>

<para>In all cases, if the source and destination do not overlap the transfer shall be performed correctly.</para>

<para>Otherwise the effect is undefined.</para>

</sect1>
<sect1>
<title>Incomplete assignment</title>

<para>If the <emphasis>arg2</emphasis> component of an <emphasis>assign</emphasis> or <emphasis>assign_with_mode</emphasis> operation is left by means of a jump, the question arises as to what value is in the destination of the transfer.</para>

<para>If the <literal>TRANSFER_MODE</literal> <emphasis>complete</emphasis> is used, the destination shall be left unchanged if the <emphasis>arg2</emphasis> component is left by means of a jump. If <emphasis>complete</emphasis> is not used and <emphasis>arg2</emphasis> is left by a jump, the destination may be affected in any way.</para>


</sect1>
<sect1>
<title>
Representing integers</title>

<para>Integer <literal>VARIETY</literal>s shall be represented by a range of integers which includes those specified by the given bounds. This representation shall be twos-complement.</para>

<para>If the lower bound of the <literal>VARIETY</literal> is non-negative, the representing range shall be from 0 to 2<emphasis>8n</emphasis>-1 for some <emphasis>n</emphasis>. <emphasis>n</emphasis> is called the number of bytes in the representation. The number of bits in the representation is 8<emphasis>n</emphasis>.</para>

<para>If the lower bound of the <literal>VARIETY</literal> is negative the representing range shall be from -2<emphasis>8n-1</emphasis> to 2<emphasis>8n-1</emphasis>-1 for some <emphasis>n</emphasis>. <emphasis>n</emphasis> is called the number of bytes in the representation. The number of bits in the representation is 8<emphasis>n</emphasis></para>

<para>Installers may limit the size of <literal>VARIETY</literal> that they implement. A statement of such limits shall be part of the specification of the installer. In no case may such limits be less than 64 bits, signed or unsigned.</para>

<note>
<para>It is intended that there should be no upper limit allowed at some future date.</para>
</note>

<para>Operations are performed in the representing <literal>VARIETY</literal>. If the result of an operation does not lie within the bounds of the stated <literal>VARIETY</literal>, but does lie in the representation, the value produced in that representation shall be as if the <literal>VARIETY</literal> had the lower and upper bounds of the representation. The implication of this is usually that a number in a <literal>VARIETY</literal> is represented by that same number in the representation.</para>

<para>If the bounds of a <literal>VARIETY</literal>, <emphasis>v</emphasis>, include those of a <literal>VARIETY</literal>, <emphasis>w</emphasis>, the representing <literal>VARIETY</literal> for <emphasis>v</emphasis> shall include or be equal to the representing <literal>VARIETY</literal> for <emphasis>w</emphasis>.</para>

<para>The representations of two <literal>VARIETY</literal>s of the form <emphasis>var_limits</emphasis>(0, 2<emphasis>n</emphasis>-1) and <emphasis>var_limits</emphasis>(-2<emphasis>n-1</emphasis>, 2<emphasis>n-1</emphasis>-1) shall have the same number of bits and the mapping of their <literal>ALIGNMENT</literal>s into the target alignment shall be the same.</para>


</sect1>
<sect1>
<title>Overflow and Integers</title>

<para>It is necessary first to define what overflow means for integer operations and second to specify what happens when it occurs. The intention of TDF is to permit the simplest possible implementation of common constructions on all common machines while allowing precise effects to be achieved, if necessary at extra cost.</para>

<para>Integer varieties may be represented in the computer by a range of integers which includes the bounds given for the variety. An arithmetic operation may therefore yield a result which is within the stated variety, or outside the stated variety but inside the range of representing values, or outside that range. Most machines provide instructions to detect the latter case; testing for the second case is possible but a little more costly.</para>

<para>In the first two cases the result is defined to be the value in the representation. Overflow occurs only in the third case.</para>

<para>If the <literal>ERROR_TREATMENT</literal> is <emphasis>impossible</emphasis> overflow will not occur. If it should happen to do so the effect of the operation is undefined.</para>

<para>If the <literal>ERROR_TREATMENT</literal> is <emphasis>error_jump</emphasis> a <literal>LABEL</literal> is provided to jump to if overflow occurs.</para>

<para>If the <literal>ERROR_TREATMENT</literal> is <emphasis>trap(overflow),</emphasis> a producer-defined <literal>TOKEN</literal> <emphasis>~Throw</emphasis>: <literal>NAT</literal> -&gt; <literal>EXP</literal> must be provided. On an overflow, the installer will arrange that <emphasis>~Throw</emphasis>(<emphasis>error_val</emphasis>(<emphasis>overflow</emphasis>)) is evaluated.</para>

<para>The <emphasis>wrap</emphasis> <literal>ERROR_TREATMENT</literal> is provided so that a useful defined result may be produced in certain cases where it is usually easily available on most machines. This result is available on the assumption that machines use binary arithmetic for integers. This is certainly so at present, and there is no close prospect of other bases being used.</para>

<para>If a precise result is required further arithmetic and testing may be needed which the installer may be able to optimise away if the word lengths happen to suit the problem. In extreme cases it may be necessary to use a larger variety.</para>


</sect1>
<sect1>
<title>Representing floating point</title>

<para><literal>FLOATING_VARIETY</literal>s shall be implemented by a representation which has at least the properties specified.</para>

<para>Installers may limit the size of <literal>FLOATING_VARIETY</literal> which they implement. A statement of such limits shall be part of the specification of an installer.</para>

<para>The limit may also permit or exclude infinities.</para>

<para>Any installer shall implement at least one <literal>FLOATING_VARIETY</literal> with the following properties (c.f. IEEE doubles):</para>

<itemizedlist>
<listitem>
<para><emphasis>mantissa_digs</emphasis> shall not be less than 53.</para>
</listitem>
<listitem>
<para><emphasis>min_exponent</emphasis> shall not be less than 1023.</para>
</listitem>
<listitem>
<para><emphasis>max_exponent</emphasis> shall not be less than 1022.</para>
</listitem>
</itemizedlist>

<para>Operations are performed and overflows detected in the representing <literal>FLOATING_VARIETY</literal>.</para>

<para>There shall be at least two <literal>FLOATING_VARIETY</literal>s, one occupying the same number of bytes and having the same alignment as a <literal>VARIETY</literal> representation, and one occupying twice as many bytes.</para>

</sect1>
<sect1>
<title>Floating point errors</title>

<para>The only permitted <literal>ERROR_TREATMENT</literal>s for operations delivering <literal>FLOATING_VARIETY</literal>s are <emphasis>impossible, error_jump</emphasis> and <emphasis>trap</emphasis> (overflow).</para>

<para>The kinds of floating point error which can occur depend on the machine architecture (especially whether it has IEEE floating point) and on the definitions in the ABI being obeyed.</para>

<para>Possible floating point errors depend on the state of the machine and may include overflow, divide by zero, underflow, invalid operation and inexact. The setting of this state is performed outside TDF (at present).</para>

<para>If an <emphasis>error_jump</emphasis> or <emphasis>trap</emphasis> is taken as the result of a floating point error the operations to test what kind of error it was are outside the TDF definition (at present).</para>

</sect1>
<sect1>
<title>Rounding and floating point</title>

<para>Each machine has a rounding state which shall be one of <emphasis>to_nearest</emphasis>, <emphasis>toward_larger</emphasis>, <emphasis>toward_smaller</emphasis>, <emphasis>toward_zero</emphasis>. For each operation delivering a <literal>FLOATING_VARIETY</literal>, except for <emphasis>make_floating</emphasis>, any rounding necessary shall be performed according to the rounding state.</para>

</sect1>
<sect1>
<title>Floating point accuracy</title>

<para>While it is understood that most implementations will use IEEE floating arithmetic operations, there are machines which use other formats and operations. It is intended that they should not be excluded from having TDF implementations.</para>

<para>For TDF to have reasonably consistent semantics across many platforms, one must have some <emphasis>minimum</emphasis> requirements on the accuracies of the results of the floating point operations defined in TDF. The provisional requirements sketched below would certainly be satisfied by an IEEE implementation.</para>

<para>Let <emphasis>@</emphasis> be some primitive dyadic arithmetic operator and <emphasis>@'</emphasis> be its TDF floating-point implementation. Let <emphasis>F</emphasis> be some non-complex <literal>FLOATING_VARIETY</literal> and <emphasis>F'</emphasis> be a representational variety of <emphasis>F</emphasis>.</para>

<sect2>
<title>Condition 1</title>

<para>If <emphasis>a</emphasis>, <emphasis>b</emphasis> and <emphasis>a @ b</emphasis> can all be represented exactly in <emphasis>F</emphasis>, then they will also be represented exactly in <emphasis>F'</emphasis>. Extending the '-notation in the obvious manner:</para>

<programlisting>
<emphasis>(a @ b)' = (a' @' b')</emphasis>
</programlisting>

<para>This equality will also hold using the TDF equality test, i.e.:</para>

<programlisting>
<emphasis>(a @ b)' =' (a' @' b')</emphasis>
</programlisting>

</sect2>

<sect2>
<title>Condition 2</title>

<para>The operator <emphasis>@'</emphasis> is monotonic in the sense apposite to the operator <emphasis>@</emphasis>. For example, consider the operator +; if <emphasis>x</emphasis> is any number and <emphasis>a</emphasis> and <emphasis>b</emphasis> are as above:</para>

<programlisting>
<emphasis>(x &gt; b) =&gt; ((a' +' x') &gt;=  (a + b)')</emphasis>
</programlisting>

<para>and: </para>

<programlisting>
<emphasis>(x &lt; b) =&gt;  ((a' +' x') &lt;= (a + b)')</emphasis>
</programlisting>

<para>and so on, reflecting the weakening of the ordering after the operation from &gt; to &gt;= and &lt; to &lt;=. Once again, the inequalities will hold for their TDF equivalents e.g., &gt;=' and &gt;'.</para>

<para>Similar conditions can be expressed for the monadic operations.</para>

<para>For the floating-point test operation, there are obvious analogues to both conditions. The weakening of the ordering in the monotonicity condition, however, may lead to surprising results, arising mainly from the uncertainty of the result of equality between floating numbers which cannot be represented exactly in <emphasis>F</emphasis>.</para>

<para>Accuracy requirements for complex <literal>FLOATING_VARIETY</literal>s could follow directly by considering the above conditions applied to real and imaginary parts independently. The following proviso is added for some complex operations however, to allow for possible intermediate error conditions. With <emphasis>floating_div</emphasis>, <emphasis>floating_mult</emphasis> and <emphasis>floating_power</emphasis> for complex <literal>FLOATING_VARIETY</literal>s, errors are guaranteed not to occur only if the square of the modulus of each argument is representable and the square of the modulus of the result is representable. Whenever these additional constraints are not met, the operation will either complete with the accuracy conditions above applying, or it will complete according to the <literal>ERROR_TREATMENT</literal> specified.</para>

</sect2>

</sect1>
<sect1>
<title>Representing bitfields</title>

<para><literal>BITFIELD_VARIETY</literal>s specify a number of bits and shall be represented by exactly that number of bits in twos-complement notation. Producers may expect them to be packed as closely as possible.</para>
<para>Installers may limit the number of bits permitted in <literal>BITFIELD_VARIETY</literal>s. Such a limit shall be not less than 32 bits, signed or unsigned.</para>

<note>
<para>It is intended that there should be no upper limit allowed at some future date.</para>
</note>

<para>Some offsets of which the second parameter contains a <literal>BITFIELD</literal> alignment are subject to a constraint defined below. This constraint is referred to as <emphasis>variety_enclosed.</emphasis></para>

<para>The intent of this constraint is to force <literal>BITFIELD</literal>s to be implemented (in memory) as being included in some properly aligned <literal>VARIETY</literal> value. The constraint applies to:</para>

<programlisting>
<emphasis>x</emphasis>: <emphasis>offset</emphasis>(<emphasis>p</emphasis>, <emphasis>b</emphasis>)
</programlisting>

<para>and to:</para>

<programlisting>
<emphasis>sh = bitfield</emphasis>(<emphasis>bfvar_bits(s, n)</emphasis>)
</programlisting>

<para>where <emphasis>alignment(sh)</emphasis> is included in <emphasis>b</emphasis>. The constraint is as follows:</para>

<para>There will exist a <literal>VARIETY</literal>, <emphasis>v</emphasis>, and <emphasis>r</emphasis>: <emphasis>offset</emphasis>(<emphasis>p</emphasis>, <emphasis>q</emphasis>) where <emphasis>v</emphasis> is in <emphasis>q</emphasis>.</para>

<programlisting>
<emphasis>offset_pad</emphasis>(<emphasis>b, r</emphasis>) &lt;= <emphasis>x</emphasis>
</programlisting>

<para>and:</para>

<programlisting>
<emphasis>offset_pad</emphasis>(<emphasis>b, r</emphasis> + <emphasis>sz</emphasis>(<emphasis>v</emphasis>)) &gt;= <emphasis>offset_pad</emphasis>( <emphasis>b</emphasis>, <emphasis>x</emphasis> + <emphasis>sz</emphasis>(<emphasis>sh</emphasis>))
</programlisting>

<para>where the comparisons are in the sense of <emphasis>offset_test</emphasis>, + is <emphasis>offset_add</emphasis> and <emphasis>sz</emphasis> is <emphasis>shape_offset</emphasis>.</para>

</sect1>
<sect1>
<title>Permitted limits</title>

<para>An installer may specify limits on the sizes of some of the data <literal>SHAPE</literal>s which it implements. In each case there is a minimum set of limits such that all installers shall implement at least the specified <literal>SHAPE</literal>s. Part of the description of an installer shall be the limits it imposes. Installers are encouraged not to impose limits if possible, though it is not expected that this will be feasible for floating point numbers.</para>

</sect1>
<sect1>
<title>Least Upper Bound</title>

<para>The LUB of two <literal>SHAPE</literal>s, <emphasis>a</emphasis> and <emphasis>b</emphasis> is defined as follows:</para>

<itemizedlist>
<listitem>
<para>If <emphasis>a</emphasis> and <emphasis>b</emphasis> are equal shapes, then <emphasis>a</emphasis>.</para>
</listitem>
<listitem>
<para>If <emphasis>a</emphasis> is <literal>BOTTOM</literal> then <emphasis>b</emphasis>.</para>
</listitem>
<listitem>
<para>If <emphasis>b</emphasis> is <literal>BOTTOM</literal> then <emphasis>a</emphasis>.</para>
</listitem>
<listitem>
<para>Otherwise <literal>TOP</literal>.</para>
</listitem>
</itemizedlist>

</sect1>
<sect1>
<title>Read-only areas</title>

<para>Consider three scenarios in increasingly static order:</para>

<itemizedlist>
<listitem>
<para>Dynamic loading. A new module is loaded, initialising procedures are obeyed and the results of these are then marked as read-only.</para>
</listitem>
<listitem>
<para>Normal loading. An <emphasis>ld</emphasis> program is obeyed which produces various (possibly circular) structures which are put into an area which will be read-only when the program is obeyed.</para>
</listitem>
<listitem>
<para>Using ROM. Data structures are created (again possibly circular) and burnt into ROM for use by a separate program.</para>
</listitem>
</itemizedlist>

<para>In each case program is obeyed to create a structure, which is then frozen. The special case when the data is, say, just a string is not sufficiently general.</para>

<para>This TDF specification takes the attitude that the use of read-only areas is a property of how TDF is used - a part of the installation process - and there should not be TDF constructions to say that some values in a <literal>CAPSULE</literal> are read-only. Such constructions could not be sufficiently general.</para>

</sect1>
<sect1>
<title>Tag and Token signatures</title>

<para>In a TDF program there will usually be references to <literal>TAG</literal>s which are not defined in TDF; their definitions are intended to be supplied by a host system in system specific libraries.</para>

<para>These <literal>TAG</literal>s will be declared (but not defined) in a TDF <literal>CAPSULE</literal> and will be specified by external linkages of the <literal>CAPSULE</literal> with <literal>EXTERNAL</literal>s containg either <literal>TDFIDENT</literal>s or <literal>UNIQUE</literal>s. In previous versions of TDF, the external names required by system linking could only be derived from those <literal>EXTERNAL</literal>s.</para>

<para>Version 4.0 gives an alternative method of constructing extra-TDF names. Each global <literal>TAG</literal> declaration can now contain a <literal>STRING</literal> signature field which may be used to derive the external name required by the system.</para>

<para>This addition is principally motivated by the various &quot;name mangling&quot; schemes of C++. The <literal>STRING</literal> signature can be constructed by concatenations and token expansions. Suitable usages of <literal>TOKEN</literal>s can ensure that the particular form of name-mangling can be deferred to installation time and hence allow, at least conceptually, linking with different C++ libraries.</para>

<para>As well as <literal>TAG</literal> declarations, <literal>TAG</literal> definitions are allowed to have signatures. The restriction that the signature (if present) of a <literal>TAG</literal> definition being identical to its corresponding definition could allow type checking across separately compiled <literal>CAPSULE</literal>s.</para>

<para>Similar considerations apply to <literal>TOKEN</literal>s; although token names are totally internal to TDF, it would allow one to check that a token declared in one <literal>CAPSULE</literal> has the same &quot;type&quot; as its definition in another.</para>

</sect1>
<sect1>
<title>Dynamic initialisation</title>

<para>The dynamic initialisation of global variables is required for languages like C++. Previous to version 4.0, the only initialisations permissable were load-time ones; in particular no procedure calls were allowed in forming the initialising value. Version 4.0 introduces the constructor <emphasis>initial_value</emphasis> to remedy this situation.</para>

<para>Several different implementation strategies could be considered for this. Basically, one must ensure that all the initial_value expressions are transformed into assignments to globals in some procedure. One might expect that there would be one such procedure invented for each <literal>CAPSULE</literal> and that somehow this procedure is called before the main program.</para>

<para>This raises problems on how we can name this procedure so that it can be identified as being a special initialising procedure. Some UNIX linkers reserve a name like <emphasis>__init</emphasis> specially so that all instances of it from different modules can be called before the main procedure. Other cases may require a pre-pass on the <emphasis>.o</emphasis> files prior to system linking.</para>

</sect1>
</chapter>


<chapter>
<title>The bit encoding of TDF</title>

<para>This is a description of the encoding used for TDF.</para>

<para>-XREF-#1Section 8.1 defines the basic level of encoding, in which integers consisting of a specified number of bits are appended to the sequence of bytes. -XREF-#4Section 8.2 defines the second level of encoding, in which fundamental kinds of value are encoded in terms of integers of specified numbers of bits. -XREF-#17Section 8.4 defines the third level, in which TDF is encoded using the previously defined concepts.</para>

<sect1>
<title>The Basic Encoding</title>

<para>TDF consists of a sequence of 8-bit bytes used to encode integers of a varying number of bits, from 1 to 32. These integers will be called basic integers.</para>

<para>TDF is encoded into bytes in increasing byte index, and within the byte the most significant end is filled before the least significant. Let the bits within a byte be numbered from 0 to 7, 0 denoting the least significant bit and 7 the most significant. Suppose that the bytes up to <emphasis>n</emphasis>-1 have been filled and that the next free bit in byte <emphasis>n</emphasis> is bit <emphasis>k</emphasis>. Then bits <emphasis>k</emphasis>+1 to 7 are full and bits 0 to <emphasis>k</emphasis> remain to be used. Now an integer of <emphasis>d</emphasis> bits is to be appended.</para>

<para>If <emphasis>d</emphasis> is less than or equal to <emphasis>k</emphasis>, the <emphasis>d</emphasis> bits will occupy bits <emphasis>k</emphasis>-<emphasis>d</emphasis>+1 to <emphasis>k</emphasis> of byte <emphasis>n</emphasis>, and the next free bit will be at bit <emphasis>k-d</emphasis>. Bit 0 of the integer will be at bit <emphasis>k</emphasis>-<emphasis>d</emphasis>+1 of the byte, and bit <emphasis>d</emphasis>-1 of the integer will be at bit <emphasis>k</emphasis>.</para>

<para>If <emphasis>d</emphasis> is equal to <emphasis>k</emphasis>+1, the <emphasis>d</emphasis> bits will occupy bits 0 to <emphasis>k</emphasis> of byte <emphasis>n</emphasis> and the next free bit will be bit 7 of byte <emphasis>n</emphasis>+1. Bit <emphasis>d</emphasis>-1 of the integer will be at bit <emphasis>k</emphasis> of the byte.</para>

<para>If <emphasis>d</emphasis> is greater than <emphasis>k</emphasis>+1, the most significant <emphasis>k</emphasis>+1 bits of the integer will be in byte <emphasis>n</emphasis>, with bit <emphasis>d</emphasis>-1 at bit <emphasis>k</emphasis> of the byte. The remaining <emphasis>d</emphasis>-<emphasis>k</emphasis>-1 least significant bits are then encoded into the bytes, starting at byte <emphasis>n</emphasis>+1, bit 7, using the same algorithm (i.e. recursively).</para>

</sect1>

<sect1>
<title>Fundamental encodings</title>

<para>This section describes the encoding of <literal>TDFINT</literal>, <literal>TDFBOOL</literal>, <literal>TDFSTRING</literal>, <literal>TDFIDENT</literal>, <literal>BITSTREAM</literal>, <literal>BYTESTREAM</literal>, <literal>BYTE_ALIGN</literal> and extendable integers.</para>

<sect2>
<title>TDFINT</title>

<para><literal>TDFINT</literal> encodes non-negative integers of unbounded size. The encoding uses octal digits encoded in 4-bit basic integers. The most significant octal digit is encoded first, the least significant last. For all digits except the last the 4-bit integer is the value of the octal digit. For the last digit the 4-bit integer is the value of the octal digit plus 8.</para>

</sect2>
<sect2>
<title>TDFBOOL</title>

<para><literal>TDFBOOL</literal> encodes a boolean, true or false. The encoding uses a 1-bit basic integer, with 1 encoding true and 0 encoding false.</para>
</sect2>

<sect2>
<title>TDFSTRING</title>

<para><literal>TDFSTRING</literal> encodes a sequence containing <emphasis>n</emphasis> non-negative integers, each of <emphasis>k</emphasis> bits. The encoding consists of, first a <literal>TDFINT</literal> giving the number of bits, second a <literal>TDFINT</literal> giving the number of integers, which may be zero. Thirdly it contains <emphasis>n</emphasis> <emphasis>k</emphasis>-bit basic integers, giving the sequence of integers required, the first integer being first in this sequence.</para>

</sect2>

<sect2>
<title>TDFIDENT</title>

<para><literal>TDFIDENT</literal> also encodes a sequence containing <emphasis>n</emphasis> non-negative integers. These integers will all consist of the same number of bits, which will be a multiple of 8. It is a property of the encoding of the other constructions that TDFIDENTS will start on either bit 7 or bit 3 of a byte and end on bit 7 or bit 3 of a byte. It thus has some alignment properties which are useful to permit fast copying of sections of TDF.</para>

<para>The encoding consists of, first a <literal>TDFINT</literal> giving the number of bits, second a <literal>TDFINT</literal> giving the number of integers, which may be zero. If the next free bit is not bit 7 of some byte, it is moved on to bit 7 of the next byte.</para>

<para>Thirdly it contains <emphasis>n</emphasis> <emphasis>k</emphasis>-bit integers.</para>

<para>If the next free bit is not bit 7 of some byte, it is moved on to bit 7 of the next byte.</para>

</sect2>
</sect1>

<sect1>
<title>BITSTREAM</title>

<para>It can be useful to be able to skip a TDF construction without reading through it. <literal>BITSTREAM</literal> provides a means of doing this.</para>

<para>A <literal>BITSTREAM</literal> encoding of <emphasis>X</emphasis> consists of a <literal>TDFINT</literal> giving the number of bits of encoding which are occupied by the <emphasis>X</emphasis>. Hence to skip over a <literal>BITSTREAM</literal> while decoding, one should read the <literal>TDFINT</literal> and then advance the bit index by that number of bits. To read the contents of a <literal>BITSTREAM</literal> encoding of <emphasis>X</emphasis>, one should read and ignore a <literal>TDFINT</literal> and then decode an <emphasis>X</emphasis>. There will be no spare bits at the end of the <emphasis>X</emphasis>, so reading can continue directly.</para>

<sect2>
<title>BYTESTREAM</title>

<para>It can be useful to be able to skip a TDF construction without reading through it. <literal>BYTESTREAM</literal> provides a means of doing this while remaining byte aligned, so facilitating copying the TDF. A <literal>BYTESTREAM</literal> will always start when the bit position is 3 or 7.</para>

<para>A <literal>BYTESTREAM</literal> encoding of <emphasis>X</emphasis> starts with a <literal>TDFINT</literal> giving a number, <emphasis>n</emphasis>. After this, if the current bit position is not bit 7 of some byte, it is moved to bit 7 of the next byte. The next <emphasis>n</emphasis> bytes are an encoding of <emphasis>X</emphasis>. There may be some spare bits left over at the end of <emphasis>X</emphasis>.</para>

<para>Hence to skip over a <literal>BYTESTREAM</literal> while decoding one should read a <literal>TDFINT</literal>, <emphasis>n</emphasis>, move to the next byte alignment (if the bit position is not 7) and advance the bit index over <emphasis>n</emphasis> bytes. To read a <literal>BYTESTREAM</literal> encoding of <emphasis>X</emphasis> one should read a <literal>TDFINT</literal>, <emphasis>n</emphasis>, and move to the next byte, <emphasis>b</emphasis> (if the bit position is not 7), and then decode an <emphasis>X</emphasis>. Finally the bit position should be moved to <emphasis>n</emphasis> bytes after <emphasis>b</emphasis>.</para>

</sect2>

<sect2>
<title>BYTE_ALIGN</title>

<para><literal>BYTE_ALIGN</literal> leaves the bit position alone if it is 7, and otherwise moves to bit 7 of the next byte.</para>

</sect2>

<sect2>
<title>Extendable integer encoding</title>

<para><emphasis>d</emphasis>-bit extendable integer encoding enables an integer greater than zero to be encoded given <emphasis>d</emphasis>, a number of bits.</para>

<para>If the integer is between 1 and 2<emphasis>d</emphasis> - 1 inclusive, a <emphasis>d</emphasis>-bit basic integer is encoded.</para>

<para>If the integer, <emphasis>i</emphasis>, is greater than or equal to 2<emphasis>d</emphasis>, a <emphasis>d</emphasis>-bit basic integer encoding of zero is inserted and then <emphasis>i</emphasis> - 2<emphasis>d</emphasis> + 1 is encoded as a <emphasis>d</emphasis>-bit extendable encodin, and so on, recursively.</para>

</sect2>
</sect1>

<sect1>
<title>The TDF encoding</title>

<para>The descriptions of SORTS and constructors contain encoding information which is interpreted as follows to define the TDF encoding.</para>

<itemizedlist>
<listitem>
<para>A TDF CAPSULE is an encoding of the <literal>SORT CAPSULE</literal>.</para>
</listitem>
<listitem>
<para>For each <literal>SORT</literal> a number of encoding bits, <emphasis>b,</emphasis> is specified. If this is zero, there will only be one construction for the class, and its encoding will consist of the encodings of its components, in the given order.</para>
</listitem>
<listitem>
<para>-XREF-M18If the number of encoding bits, <emphasis>b</emphasis>, is not zero the <literal>SORT</literal> is described as extendable or as not extendable. For each construction there is an encoding number given. If the <literal>SORT</literal> is extendable, this number is output as an extendable integer. If the <literal>SORT</literal> is described as not extendable, the number is output as a basic integer. This is followed by the encodings of the components of the construction in the order given in the description of the construct.</para>
</listitem>
<listitem>
<para>-XREF-M21For the classes which are named <literal>SLIST</literal>(<emphasis>x</emphasis>) - e.g. <literal>SLIST</literal>(<literal>UNIT</literal>) - the encoding consists of a <literal>TDFINT</literal>, <emphasis>n</emphasis>, followed by <emphasis>n</emphasis> encodings of <emphasis>x</emphasis>.</para>
</listitem>
<listitem>
<para>-XREF-M22For the classes which are named <literal>LIST</literal>(<emphasis>x</emphasis>) - e.g. <literal>LIST</literal>(<literal>EXP</literal>) - the encoding consists of a 1-bit integer which will be 0, followed by an <literal>SLIST</literal>(<emphasis>x</emphasis>). The 1-bit integer is to allow for extensions to other representations of <literal>LIST</literal>s.</para>
</listitem>
<listitem>
<para>-XREF-M23-XREF-M24For the classes which are named <literal>OPTION</literal>( <emphasis>x</emphasis>) the encoding consists of a 1-bit basic integer. If this is zero, the option is absent and there is no more encoding. If the integer is 1, the option is present and an encoding of <emphasis>x</emphasis> follows.</para>
</listitem>
<listitem>
<para><literal>BITSTREAMS</literal> occur in only two kinds of place. One is the constructions with the form <emphasis>x_cond</emphasis>, which are the install-time conditionals. For each of these the class encoded in the <literal>BITSTREAM</literal> is the same as the class which is the result of the <emphasis>x_cond</emphasis> construction. The other kind of place is as the <emphasis>token_args</emphasis> component of a construction with the form <emphasis>x_apply_token</emphasis>. This component always gives the parameters of the <literal>TOKEN</literal>. It can only be decoded if there is a token definition or a token declaration for the particular token being applied, i.e. for the <emphasis>token_value</emphasis> component of the construction. In this case the <literal>SORTS</literal> and hence the classes of the actual token arguments are given by the declaration or definition, and encodings of these classes are placed in sequence after the number of bits. If the declaration or definition are not available, the <literal>BITSTREAM</literal> can only be skipped.</para>
</listitem>
<listitem>
<para><literal>BYTESTREAM</literal> <emphasis>X</emphasis> occurs in only one place, the encoding of the <literal>SORT UNIT</literal>. The <literal>SORT</literal> <emphasis>X</emphasis> is determined by the <literal>UNIT</literal> identification which is given for each of the relevant <literal>SORTS</literal>.</para>
</listitem>
<listitem>
<para>The <emphasis>tld</emphasis> <literal>UNIT</literal> is encoded specially. It is always the first <literal>UNIT</literal> in a Capsule and is used to pass information to the TDF linker. The first entry in a <emphasis>tld</emphasis> <literal>UNIT</literal> is a <literal>TDFINT</literal> giving the format of the remainder of the <literal>UNIT</literal>. Currently, the linker supports formats 0 and 1, but others may be added to give greater functionality while retaining compatibility. With format 0, the remainder of <literal>UNIT</literal> is identical to a now obsolete <emphasis>tld2</emphasis> <literal>UNIT</literal>. With format 1, the remainder of the <literal>UNIT</literal> is as follows: If <emphasis>n</emphasis> is the number of <literal>EXTERN_LINK</literal> s in the <emphasis>external_linkage</emphasis> argument of <emphasis>make_capsule</emphasis>, the remainder consists of <emphasis>n</emphasis> sequences. These sequences are in the order given by <emphasis>external_linkage</emphasis>. Each element of a sequence consist of one <literal>TDFINT</literal> per linkable entity in the corresponding <emphasis>el</emphasis> of the <emphasis>make_extern_link</emphasis> in the same order. These integers will describe properties of the correponding external links. (In format 0, there are only two sequences, the first describing the token external links and the second describing the tag external links.)

<itemizedlist>
<listitem>
<para>Bit 0: 1 means &quot;used in this capsule&quot;, 0 means &quot;not used in this capsule&quot;.</para>
</listitem>
<listitem>
<para>Bit 1: 1 means &quot;declared in this capsule&quot;, 0 means &quot;not declared in this capsule&quot;.</para>
</listitem>
<listitem>
<para>Bit 2: 0 means &quot;not defined in this capsule, 1 means &quot;defined in this capsule&quot;.</para>
</listitem>
<listitem>
<para>Bit 3: 0 means &quot;is uniquely defined&quot;, 1 means &quot; may be multiply defined&quot;.</para>
</listitem>
</itemizedlist>
</listitem>
</itemizedlist>

</sect1>

<sect1>
<title>File Formats</title>

<para>There may be various kinds of files which contain TDF bitstream information. Each will start with a 4-byte &quot;magic-number&quot; identifying the kind of file followed by two <literal>TDFINT</literal>s giving the major and minor version numbers of the TDF involved.</para>

<para>A CAPSULE file will have a magic-number <emphasis>&quot;TDFC&quot;</emphasis>. The encoding of the CAPSULE will be byte-aligned following the version numbers.</para>

<para>A TDF library file will have a magic-number <emphasis>&quot;TDFL&quot;</emphasis>. These files are constructed by the TDF linker.</para>

<para>A TDF archive file will have a magic-number <emphasis>&quot;TDFA&quot;</emphasis>.</para>

<para>Other file formats introduced should follow a similar pattern.</para>

<note>
<para>The TDF linker will refuse to link TDF files with different major version numbers. The resulting minor version number is the maximum of component minor version numbers.</para>
</note>
</chapter>
