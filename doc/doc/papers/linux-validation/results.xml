<?xml version="1.0" standalone="no"?>
<!DOCTYPE chapter SYSTEM "minidocbook.dtd">

<!--
  $Id$
-->


<chapter>
	<title>Descriptions and Results of Project phases</title>

	<para>In the next paragraphs, we describe the way we accomplished
		the various tasks of the project and we summarize their results.</para>

	<section>
		<title>Linux installation</title>

		<para>At the beginning of the project, we installed the Linux operating
			system release 1.1 on an Intel/i386 machine. In December 1995, after a few
			months of work on the Intel/i386 platform, we installed Linux on the
			second platform for the project, which is a Dec/Alpha. Linux was first
			released on this platform at the beginning of 1995.</para>

		<section>
			<title>Linux/i386 installation (including the source code for commands)</title>

			<para>A machine with Linux 1.1.59 from the Slackware
				distribution, including the native compilation chain and libraries from GNU, was
				setup for the project.</para>
				<para>The Linux system is available on several anonymous ftp
				sites. The one we used was at  sunsite.unc.edu, where a distribution of the
				sources and binaries of the Intel/Linux commands from Slackware was available
				under the /pub/Linux/distributions/slackware directory. Note that the current
				Slackware distribution at the time of writing of this report is based on Linux
				3.0.</para>

			<para>In the Slackware Linux distribution for Intel/ix86, the
				delivery of the source code for commands is split into a large number of
				<firstterm>packages</firstterm>. The contents of each source package must be compiled
				and installed individually. For example, the &awk; command,
				actually &gawk;, belongs to the <code>bin</code> package which contains
				56 commands, while the &bc; command belongs to the <code>bc</code>
				package which contains only this one command.  Consequently, we did not
				download the whole set of sources for the Linux commands, but selected a
				few packages containing the sources of the commands we intended to build
				first. We also had a look at the Caldera Linux source distribution, and
				it appeared to be organized in the same way.</para> <para>
				A Slackware Linux package for source code distribution is
				made of a compressed tar files (usually only one), optional patch
				file(s), and a shell script. The execution of this shell script installs
				the source files from the tar file(s), applies patches if necessary,
				optionally performs a self-configuration step, runs the makefile(s) for
				the compilation, and finally generates a binary package which holds the
				resulting executables. This procedure has been adapted to fit the
				NAT-NAT, DRA-NAT and DRA-DRA development steps on two platforms, as
				described in the section <ulink url="linux_re.htm#4846">Setting up the
				build environment</ulink>.</para>

			<para>Note that each package has a private version number. Thus
				packages can be maintained and released independently. Moreover, some packages
				(e.g. the <code>bin</code> package) are a collection of several &ldquo;subpackages&rdquo;, each
				of which has its own version number.</para>
		</section>

		<section>
			<title>Linux/Alpha installation</title>

			<para>The Linux Operating System port to the Digital Alpha architecture
				started two years ago. The first user-installable distribution was
				available in January 95, from the BLADE distribution, and was a 32-bit
				version. Then came a 64-bit version which was made compatible with Digital
				Unix with respect to basic C language types:</para>

			<table>
				<col align="center"/>
				<col align="center"/>

				<thead>
					<tr>
						<th>Type</th>
						<th>Size</th>
					</tr>
				</thead>

				<tbody>
					<tr>
						<td><code>int</code></td>
						<td>32-bit</td>
					</tr>

					<tr>
						<td><code>long</code></td>
						<td>64-bit</td>
					</tr>

					<tr>
						<td>pointer</td>
						<td>64-bit</td>
					</tr>
				</tbody>
			</table>

			<para>While it is still under development, Linux/Alpha is now robust and
				includes most of the capabilities provided by the Linux/Intel
				system.</para>

			<para>The BLADE distribution was the first available distribution for
				Linux/Alpha. For the project, we retrieved the November 95 BLADE_0.3
				release, based on the Linux 1.3 development kernel, at the following
				site:</para>

			<para><ulink url="ftp://ftp.digital.com/pub/DEC/Linux-Alpha">ftp.digital.com:/pub/DEC/Linux-Alpha</ulink></para>

			<para>This release consists of more than thirty 3.5'' floppy images (not
				including X-Window). The source code for the commands is not a part of
				this distribution. Since then, several new versions for the boot firmware,
				kernel, compiler and libraries have been released, but, as we encountered
				minor problems only with BLADE_0.3, we did not upgrade our system.</para>

			<para>Since December 95, another distribution of Linux for Dec/Alpha is also
				available from the RedHat company; the current version is:</para>

			<para><ulink url="ftp://ftp.redhat.com/pub/redhat/redhat-2.1/axp">ftp.redhat.com:/pub/redhat/redhat-2.1/axp</ulink></para>

			<para>This distribution includes all the source packages for the components
				it is made from, along with some fixes and additions, in both binary and
				source forms. It is possible to unpack a RedHat Linux/Alpha 2.1 set while
				not running the RedHat Linux, but, as a proprietary packaging format is
				used, one should install the packaging tools (&rpm;) first.</para>

			<para>At the time we setup the machine, Linux/Alpha was operational only on
				a few variants of Digital Alpha-based systems. So, we selected an entry
				level and rather inexpensive board, the Digital AXPpci 33
				Alpha PC motherboard, around which we built a machine. Our Linux/Alpha system
				currently comprises the following:</para>

			<itemizedlist>
				<listitem>
					<para>an 8-slot enclosure with 200W power supply and fan</para>
				</listitem>

				<listitem>
					<para>Digital AXPpci 33 motherboard, Windows NT (ARC) firmware, PS/2
						style keyboard interface, 233 Mhz Alpha processor</para>
				</listitem>

				<listitem>
					<para>2x16MB, 36-bit, 70ns SIMMs</para>
				</listitem>

				<listitem>
					<para>256 KB, 20ns cache [optional part]</para>
				</listitem>

				<listitem>
					<para>a Number 9 GXE VGA display adapter (ISA)</para>
				</listitem>

				<listitem>
					<para>a dumb VGA display</para>
				</listitem>

				<listitem>
					<para>a PS/2 style keyboard</para>
				</listitem>

				<listitem>
					<para>a 3.5''/1440K floppy disk drive</para>
				</listitem>

				<listitem>
					<para>a SCSI-2 hard disk (a DECpc 2.0GB disk from Digital)</para>
				</listitem>

				<listitem>
					<para>a 3COM Ethernet Link-II (aka 3c503) controller (ISA).</para>
				</listitem>
			</itemizedlist>

			<para>We installed the BLADE_0.3 distribution on our machine, including the
				C compilation chain and libraries. In order to use the 3COM Ethernet
				board, we had to rebuild the kernel. We used almost all of the default
				kernel build parameters, except for the Ethernet adapter, for the settings
				for the TGA graphics support (switched to &ldquo;no&rdquo;) and for the NFS-client
				feature (selected). Note that a kernel rebuild takes more than half an
				hour on our system.</para>

			<para>A very interesting feature of the current releases of
				Linux/Alpha is that they provide an almost perfect binary compatibility
				with Digital Unix. This was of great help to us, as will be described
				later.</para>

			<para>Among the various updates to the Linux/Alpha boot
				loader, kernel, C compiler and libraries, commands, ..., which have been
				made by the Linux-Alpha development teams, we have used only a
				few:</para>

			<itemizedlist>
				<listitem>
					<para>upgrade of the <command>sed</command> command: some sed scripts
						used for modifying the system headers when building the APIs with TenDRA
						caused the original <command>sed</command> command to abort.</para>
				</listitem>

				<listitem>
					<para>upgrade of a few system headers, extracted from the azstarnet
						<filename>inc-and-libs-0.38.tar.gz</filename> file.</para>
				</listitem>
			</itemizedlist>

			<para>These two updates were downloaded from the site</para>

			<para><ulink url="ftp://ftp.azstartnet.com/pub/linux/axp">ftp.azstartnet.com:/pub/linux/axp</ulink></para>

			<para>We encountered a few problems with the BLADE_0.3
				release on the AXPpci Alpha board:</para>

			<itemizedlist>
				<listitem>
					<para>The floppy disk driver sometimes entered a time-out, as
						indicated by a console message.</para>
				</listitem>

				<listitem>
					<para>Some shell scripts failed until a #!/bin/sh line, or equivalent,
						was inserted. According to a member of the Linux/Alpha development team,
						it is caused by the kernel command loader, and was fixed in new kernel
						releases. We worked-around this problem by patching a number of shell
						script files included with various source packages we were building on
						Linux/Alpha: we realized too late that it would have been preferable to
						upgrade the kernel.</para>
				</listitem>

				<listitem>
					<para>Linux/Alpha failed to mount an NFS file system served by a HP-UX
						release 8 machine. Fortunately, this problem disappeared when using a
						server running Solaris or HP-UX release 9: we had to move our
						development tree to such a host.</para>
				</listitem>

				<listitem>
					<para>As mentioned above, the sets of source files were shared through
						NFS between a Linux/Intel, a Digital Unix and a Linux/Alpha platform.
						Occasionally, Linux/Alpha lost access to a file that had been updated
						recently by another NFS client: the error message &ldquo;Stale NFS file
						handle&rdquo; was displayed.  Unmounting/remounting the NFS file system
						usually cured such problems.</para>
				</listitem>

				<listitem>
					<para>During kernel rebuilds, the compilation of at least one file
						failed because of lack of memory: in the makefiles for kernel rebuild,
						the gcc compiler is called with the <code>-pipe</code> option, which speeds up the
						build but is not safe when compiling large source files. We wrote a
						small shell script which redoes a compilation without the <code>-pipe</code>
						option. (This problem was fixed by a subsequent kernel release:
						<filename>tcpip.c</filename> was split into several parts...)</para>
				</listitem>
			</itemizedlist>
		</section>
	</section>

	<section>
		<title>TenDRA installation</title>

		<para>We first installed the TenDRA technology on the Linux/i386
			platform, from the April 1995 snapshot. Later, we installed the November 1995
			release, the first to include support for the Dec/Alpha machine, in order to
			start work on the Linux/Alpha platform. However, because this snapshot was not
			upward compatible with the previous TenDRA release, we also had to install it on
			the Linux/i386 platform. We did not upgrade to the February 1996 snapshot,
			though it is compatible with the previous one. We only used it in a few cases
			when we had a bug in a command and wanted to make sure that it was not due to a
			problem already fixed in TenDRA.</para>

		<section>
			<title>TenDRA installation on Intel/i386</title>

			<para>The TenDRA snapshot from April 1995, based on TDF 3.1,
				included support for the Linux/i386 platform. So, the installation on our
				machine was straightforward. We only had to recompile the tcc driver, and to
				modify some environment and startup files to fine tune the level of checking.</para>
				<para>When we started to work on the second platform, we had to
				install the November 1995 snapshot of the TenDRA technology (see below). This
				was DRA's first snapshot based on TDF 4.0, and it included significant changes
				to the installation procedure. We had some difficulties to install this
				snapshot, due to a few bugs in the new installation procedures, but once
				installed the technology appeared to work well.</para>
		</section>

		<section id="installonalpha">
			<title>TenDRA installation on DEC/Alpha</title>

			<para>The TenDRA snapshot from November 1995 was the first
				snapshot with support for the Dec/Alpha platform, but was not upward compatible
				with the one installed on the Intel platform (TenDRA 4.0 versus TenDRA 3.1). So,
				the TenDRA snapshot from November 1995 was installed on both the Intel/i386 and
				the Dec/Alpha platforms.</para>

			<para>DRA provide support for the DigitalUnix/Alpha platform, not
				for the Linux/Alpha one. However, we benefited from the compatibility between
				Digital Unix and Linux to solve this problem. We made three different
				installations of the TenDRA technology for Alpha, among which the 2nd was fully
				operational for Linux/Alpha:</para>

			<itemizedlist>
				<listitem>
					<para>First installation on native Digital Unix/alpha.</para>
				</listitem>

				<listitem>
					<para>Second installation, still on Digital Unix, but for cross-development for
						Linux/Alpha (termed &ldquo;lin_alpha_cross&rdquo;).</para>
				</listitem>

				<listitem>
					<para>Third installation on Linux/Alpha (termed &ldquo;lin_alpha&rdquo;).</para>
				</listitem>
			</itemizedlist>

			<para>The first installation was straightforward and worked very
				well. The main purpose was to ensure that the TenDRA technology worked correctly
				on Dec/Alpha.</para>

			<para>For the second installation, we created a new target
				platform termed &ldquo;lin_alpha_cross&rdquo;. Most of the &ldquo;lin_alpha_cross&rdquo; files are
				shared with Digital Unix, using symbolic links to directories or files, since
				only a few files differ between the two targets. The main purpose of these
				changes was to use Linux/Alpha system header files when compiling, instead of
				the Digital Unix system header files, and Linux/Alpha libraries and startup
				files when link-editing. For example, we changed three files inside the <code>&lt;target_platform&gt;/private/env</code>
				directory named <filename>default</filename>, <filename>system</filename> and <filename>tcc_diag</filename>. For the
				same reason, we created a specific &ldquo;lin_alpha_cross&rdquo; subdirectory in lib/system
				to hold some replacement system header files when cross-compiling with the <code>-Ysystem</code>
				option (i.e. in DRA-NAT mode). The target dependent directories and files used
				when (cross-)building APIs for Linux/Alpha, e.g. located under the <filename>src/apis/libs</filename>
				directory, were also made specific.</para>

			<para>Using this installation, we could cross-compile and
				cross-link on Digital Unix for Linux, without any problem. The binary
				compatibility between Linux/Alpha and Digital Unix was thus a key factor of
				success.</para>

			<para>The third TenDRA installation for Linux/Alpha was readily
				derived from the previous one. We benefited again from the binary compatibility
				with Digital Unix: we ran the TenDRA compilation chain, built for Digital Unix,
				on top of Linux/Alpha, without the necessity to port it or recompile it.
				However, to do so, we had to copy and install the shared library tools of
				Digital Unix on Linux/Alpha because TenDRA uses shared libraries, for which
				there is currently no support in Linux/Alpha. The Digital Unix shared libraries
				mechanism works fine under Linux! This trick could have be avoided if we had
				re-linked the TenDRA tools under Digital Unix using its statically-linked
				libraries.</para>

			<para>In order to use the Linux/Alpha native assembler and
				link-editor instead of those from Digital Unix, we wrote a front-end shell
				script to the TenDRA installer (trans). This shell script calls the actual trans
				tool with an option to output a source assembly file instead of the &ldquo;binary
				assembly&rdquo; files used by the Digital Unix as1 tool. Similarly, we wrote a
				front-end shell script which emulates the call made by tcc to as1 by a call to
				the Linux as tool. We give below the changes to the settings in &lt;lin_alpha&gt;/private/env/default
				for the third installation:</para>

			<programlisting language="env">+TRANS "/..../linux/1.3.45/alpha/private/bin/trans.sh"
+AS1   "/..../linux/1.3.45/alpha/private/bin/as1.sh"
+AS    "/usr/bin/as -nocpp" # seems unused
+LD    "/usr/bin/ld -G8 -O1"</programlisting>

			<para>However, despite these modifications, the port of the TenDRA
				installer to Linux/Alpha could not be completed. In some cases, the TenDRA
				installer appeared to generate assembly instructions that are not recognized by
				the Linux/Alpha assembler. For example, the following lines could not be
				assembled properly by Linux/Alpha:</para>

			<screen>.extern __ctype_ 8
	Error: Rest of line ignored. First ignored character is '8'

stq $fp, 8($sp)
	Warning: Illegal operands

bis $17,$17,$fp
	Warning: Illegal operands

.frame $fp, 360, $26, 0
	Error: bad absolute expression; zero assumed</screen>

			<para>We now understand it is not surprising that we were unable
				to use the TenDRA installer for Digital Unix/Alpha on Linux/Alpha. ANDF
				installer output needs to be tailored for different target operating systems
				according to the assembler and/or link editor interfaces supported by the target
				operating system. In our case we attempted to use the assembler interface, and
				the errors and warnings above are examples where this interface differs between
				Digital Unix/Alpha and Linux/Alpha. Debugger support and even some details of
				the procedure calling conventions may also need to be taken into account when
				tailoring an ANDF installer to a different operating system.</para>

			<para>Since we had already set up a cross-development TenDRA
				environment for Linux/Alpha, hosted by Digital Unix, we continued to use it and
				discontinued use of the &ldquo;lin_alpha&rdquo; installation. We actually installed TenDRA
				on an NFS file server (used by the Linux/ i386, the Digital Unix and the
				Linux/Alpha platforms).</para>
		</section>
	</section>

	<section>
		<title>Build environment with TenDRA</title>

		<section>
			<title>Definition of the set of Linux commands</title>

			<para>The definition of the set of commands has not been done once
				for all. It has been done on the Intel/i386 platform, during the first part of
				the project, in two steps, level1 and level2, as described in <xref linkend="phases"/>.
				Each step has been performed as an incremental process.
				Each time new commands were selected, a
				whole cycle of API definition (<xref linkend="apidef"/>),
				command ANDFization (<xref linkend="andfization"/>), API
				installation (<xref linkend="apiinstallation"/>) and command
				installation and validation (<xref linkend="installandvalid"/>) was
				performed.</para>

			<para>During the first phase of the project, a number of commands
				have been compiled in DRA-DRA mode on the Unixware platform (see &unix-validation.doc;).
				We started by locating these commands in the
				packages from the Slackware Linux source distribution for Intel/ix86. Since
				these commands were among the simplest ones to ANDFize on Unixware, they were
				good candidates to start with. Provided that a full binary installation was made
				on our Linux/i386 platform, a command could be located in a package by searching
				for its name in the list of packages under the <filename>/var/adm/packages</filename>
				directory. This directory contains one text file per installed package, which
				records the names of the commands it contains (actually the relative
				installation path from / is provided for each command). When the name of the
				package which holds a command has been found, we just had to connect to the ftp
				site, find the directory of the same name in the Slackware source distribution,
				and download the files under this directory.</para>

			<para>Among the 103 Unixware commands ANDfized during the previous
				phase of this project, we found 59 commands with similar name in Linux,
				scattered among 11 packages: <code>bc</code>, <code>bin</code>,
				<code>bsdgames</code>, <code>diff</code>, <code>find</code>, <code>grep</code>, <code>gzip</code>,
				<code>sh_utils</code>, <code>txtutils</code> and <code>util</code>.
				Moreover, these packages also contained
				some additional commands which appeared to be good candidates for easy
				ANDFization. However, we excluded a few of them which were compiled but not
				delivered in the binary package, or which seemed too dependent on the target
				platform (e.g. the
				<code>fdformat</code> command which formats floppy disks). We also selected four
				additional packages, <code>tar, cpio, xlock</code> and <code>xgames</code>, in order to
				complete the <code>level 1</code> set of commands.</para>

			<para>The definition of the <code>level 2</code> set of commands was
				more difficult than for <code>level 1</code>, because we had to reject a number of
				commands, for various reasons discussed below.</para>

			<para>First, we tried to include in the <code>level 2</code> set of
				commands more commands from X11, as we successfully experimented the ANDFization
				of a few of them for<code> level 1</code>. However it appeared that this was not so
				easy: the sources for these commands had not been packaged by Slackware, but
				were provided inside a huge collection of sources named <code>Xfree86</code> (from
				the Xfree86 Project, Inc.), itself derived from the X Consortium X11R6 code. An
				attempt to perform the first step of the build of Xfree86 on Linux/i386, which
				consisted in producing Makefiles from Imakefiles, failed. With some rewriting,
				we managed to produce a Makefile for a simple Xfree86 command, <code>xclock</code>,
				and successfully compiled it. However, we did not spend much time on
				understanding the installation procedures of Xfree86, and, since it would have
				taken us too much time per command to rewrite every Makefile, we set aside
				Xfree86.</para>

			<para>Then we excluded one package, <code>groff</code>, because it was
				mostly coded in C++. We found also that some native Linux header files, used in
				several packages, offer BSD compatibility but in a way that could not be
				straightforwardly adapted to TenDRA. This issue is discussed in <xref linkend="apidef"/>.</para>

			<para>We have included in the <code>level 2 </code>set of commands some
				commands which represent quite large amounts of source code: <code>m4, elvis</code>
				(a <code>vi</code> clone), <code>joe</code> (another editor), <code>less</code>, <code>perl</code>
				and <code>elm</code>. The ultimate step of this experiment would have been to build
				&ldquo;monsters&rdquo; such as <code>bash</code> and <code>emacs</code>.</para>

			<para>Finally, we evaluated the number of commands distributed
				with a Linux system, and we found about 700 executable binary files in the
				/usr/bin, /bin, /usr/X11/bin, /usr/openwin/bin, /usr/games, /sbin and /usr/sbin
				directories. We examined some of these commands in the Slackware packages, and
				concluded that there could be candidates for ANDFization. But we were limited by
				time constraints to include such commands. Also, we did not port to the 2nd
				platform, nor validate, all the commands operational on the 1st platform. Here
				again, time is the main reason why we did not complete the port. We estimate
				that an additional 1.5 engineer-month would have been sufficient to complete the
				task, apart from some commands which may have been difficult to port.</para>

			<para>The <code>level1 </code>and <code>level2</code> set of commands
				include 236 commands: these commands were installed and validated on Linux/i386
				(cf. section 4.7 on this point).</para>

			<para>In the list below, the commands in <emphasis>bold</emphasis> (149) have
				been installed and validated on both Linux/i386 and Linux/Alpha, as opposed to
				the commands listed in plain characters, which are available on the first
				platform only.</para>

			<para>The few (13) commands listed in <replaceable>italic</replaceable> were ported
				to both platforms, but their validation failed, or was not completed, on the
				second platform.</para>

			<para>Finally, in the &ldquo;p/m&rdquo; statements, p is the
				best-case number of commands we ported, while m is the maximum number of them
				with respect to a given Slackware Linux package.</para>

			<table>
				<col align="center"/>
				<col align="center"/>
				<col align="left"/>

				<thead>
					<tr>
						<th>Package</th>
						<th>Total</th>
						<th>Commands ported</th>
					</tr>
				</thead>

				<tbody>
					<tr>
						<td>aaa_base</td>
						<td>9/9</td>
						<td>fromdos, funzip, mtools, todos,
							unzip, unzipsfx, zip, zipnote, zipsplit.</td>
					</tr>

					<tr>
						<td>ash</td>
						<td>1/1</td>
						<td>ash.</td>
					</tr>

					<tr>
						<td>bc</td>
						<td>1/1</td>
						<td><emphasis>bc</emphasis>.</td>
					</tr>

					<tr>
						<td>bin</td>
						<td>48/56</td>
						<td>at, <emphasis>bban, bpe, chgrp, chmod, chown</emphasis>,
							compress, <emphasis>cp</emphasis>, crond, crontab, <emphasis>ctags, dd, df,</emphasis> dircolors, <emphasis>du</emphasis>,
							ed, <emphasis>elvis, elvprsv, elvrec</emphasis>, file, fiz, <emphasis>fmt</emphasis>,
							<replaceable>gawk</replaceable>, <emphasis>ginstall</emphasis>,
							indent, <emphasis>ln, ls, man, mkdir, mkfifo, mknod, mv, patch, ref, rm, rmdir</emphasis>,
							sed, <emphasis>shar, sysvbanner, time, touch, tput</emphasis>, unarj, <emphasis>unshar, uudecode,
							uuencode, which</emphasis>, zoo.</td>
					</tr>

					<tr>
						<td>bsdgames</td>
						<td>13/36</td>
						<td>bcd, caesar, factor, fish, monop,
							morse, number, paranoia, ppt, primes, rain, worm, worms.</td>
					</tr>

					<tr>
						<td>byacc</td>
						<td>1/1</td>
						<td><emphasis>byacc</emphasis>.</td>
					</tr>

					<tr>
						<td>cpio</td>
						<td>2/2</td>
						<td><replaceable>cpio, mt-GNU</replaceable>.</td>
					</tr>

					<tr>
						<td>diff</td>
						<td>4/4</td>
						<td><emphasis>cmp, diff, diff3, sdiff</emphasis>.</td>
					</tr>

					<tr>
						<td>elm</td>
						<td>9/9</td>
						<td><replaceable>answer</replaceable>, <emphasis>elm</emphasis>, <replaceable>elmalias</replaceable>,
							<emphasis>fastmail, filter, frm,</emphasis><replaceable> newalias, newmail</replaceable>, <emphasis>readmsg</emphasis>.</td>
					</tr>

					<tr>
						<td>find</td>
						<td>6/6</td>
						<td><emphasis>bigram, code, find, frcode, locate, xargs</emphasis>.</td>
					</tr>

					<tr>
						<td>flex</td>
						<td>1/1</td>
						<td><emphasis>flex</emphasis>.</td>
					</tr>

					<tr>
						<td>getty</td>
						<td>2/2</td>
						<td>getty, uugetty.</td>
					</tr>

					<tr>
						<td>grep</td>
						<td>1/1</td>
						<td><emphasis>grep</emphasis>.</td>
					</tr>

					<tr>
						<td>gzip</td>
						<td>1/1</td>
						<td><emphasis>gzip</emphasis>.</td>
					</tr>

					<tr>
						<td>ispell</td>
						<td>6/6</td>
						<td><emphasis>buildash, icombine, ijoin, ispell, sq, unsq</emphasis>. 
						</td>
					</tr>

					<tr>
						<td>joe</td>
						<td>2/2</td>
						<td>joe, termidx.</td>
					</tr>

					<tr>
						<td>less</td>
						<td>2/2</td>
						<td><emphasis>less, lesskey</emphasis>.</td>
					</tr>

					<tr>
						<td>m4</td>
						<td>2/2</td>
						<td><emphasis> ansi2knr, m4</emphasis>.</td>
					</tr>

					<tr>
						<td>perl</td>
						<td>4/4</td>
						<td><replaceable> a2p, perl4.036, sperl4.036, tperl4.036</replaceable>.</td>
					</tr>

					<tr>
						<td>ps</td>
						<td>11/12</td>
						<td>free, fuser, killall, ps, pstree,
						psupdate, tload, uptime, vmstat, w.procps, w.bassman.</td>
					</tr>

					<tr>
						<td>rcs</td>
						<td>8/8</td>
						<td><emphasis>ci, co, ident, merge, rcs, rcsdiff, rcsmerge, rlog</emphasis>. 
						</td>
					</tr>

					<tr>
						<td>sh_utils</td>
						<td>24/24</td>
						<td><emphasis> basename, date, dirname,
						echo, env, expr, id, logname, nice, pathchk, printenv, printf, pwd, sleep, stty,
						su, tee, test, tty, uname, users, who, whoami, yes</emphasis>.</td>
					</tr>

					<tr>
						<td>sudo</td>
						<td>2/2</td>
						<td>sudo.bin, visudo.</td>
					</tr>

					<tr>
						<td>tar</td>
						<td>3/3</td>
						<td><emphasis>tar</emphasis>, <replaceable>rmt</replaceable>, testpad.</td>
					</tr>

					<tr>
						<td>tcpip</td>
						<td>7/31 (from the net-tools subset)</td>
						<td>arp,
						ifconfig, plipconfig, rarp, route, netstat, slattach. 
						</td>
					</tr>

					<tr>
						<td>txtutils</td>
						<td>22/22</td>
						<td><emphasis>cat, cksum, comm, csplit,
						cut, expand, fold, head, join, nl, od, paste, pr, sort, split, sum, tac, tail,
						tr, unexpand, uniq, wc</emphasis>.</td>
					</tr>

					<tr>
						<td>util</td>
						<td>35/57</td>
						<td>agetty, <emphasis>arch, banner, chfn,
						chroot, chsh, col, colcrt, colrm, column, ddate, frag, hexdump, hostname, ipcrm,
						ipcs, last, login, mesg, more, newgrp, passwd, rdev</emphasis>, readprofile, <emphasis>renice,
						rev, setsid, sln</emphasis>, strings, swapon, <emphasis>ul, vipw, wall</emphasis>, <replaceable>zdump</replaceable>,
						<emphasis>zic</emphasis>.</td>
					</tr>

					<tr>
						<td>xgames</td>
						<td>8/13</td>
						<td>maze, xcolormap, spider, xtetris,
						xlander, xminesweep, xroach, xvier.</td>
					</tr>

					<tr>
						<td>xlock</td>
						<td>1/1</td>
						<td>xlock.</td>
					</tr>
				</tbody>
			</table>
		</section>

		<section>
			<title>Setting up the build environment</title>

			<para>The environments for the NAT-NAT, DRA-NAT and DRA-DRA builds
				have been setup using similar to those used during the Unixware port.</para>

			<itemizedlist>
				<listitem>
					<para>One single reference source tree, then a dedicated work tree per (build,
						target platform). For the 1st target (Linux/i386), each work tree holds symbolic
						links to the <code>source</code> tree, while binaries are built inside a <code>work</code>
						tree as plain files. In addition, a procedure is used to replace a link to the
						source tree by a link to a <code>patch</code> tree when a source file has to be
						modified during the port to TenDRA. This is very similar to the environment we
						had on Unixware. The major difference is that each package has its own set of
						<code>source/work/patch</code> file trees. This is more modular but requires more
						manipulations.</para>
				</listitem>

				<listitem>
					<para>For the 2nd target (Linux/Alpha): we usually created only a work tree for
						the DRA-DRA build. It initially contained source files only, which are
						symbolic links to their equivalent in the DRA-DRA/i386 work tree. By &ldquo;source
						files&rdquo; we mean here the Makefiles and the &andf; - <filename>.j</filename> - files
						having been generated from the original .c files by the TenDRA producer, during
						the DRA-DRA build for Linux/i386.</para>
				</listitem>

				<listitem>
					<para>A shell script used as a pseudo cc (e.g. pseudo gcc) during the DRA-NAT and
						DRA-DRA builds. This avoids the necessity to modify most of the original
						makefiles when building the commands. The pseudo <code>cc</code> used during the
						build for the 2nd platform substitutes the (usually unique) <replaceable>input_file</replaceable><filename>.c</filename>
						by <replaceable>input_file</replaceable><filename>.j</filename>.</para>
				</listitem>
			</itemizedlist>

			<para>One specific feature of the sources and build procedures of
				the Linux commands is that they have often been designed to support a variety of
				target platforms and UNIX variants at source level. Thus, when building a
				command for the first time, there is usually a preliminary self-configuration
				step which examines the system header files, and produces a local header file
				(or a customized Makefile) which summarizes the target system peculiarities by
				means of #define (or -D) statements. We ran such self-configuration scripts
				before creating the NAT-NAT, DRA-NAT and DRA-DRA work trees: this assumes that
				our second platform for porting (Linux/Alpha) is to provide similar APIs to the
				1st one (Linux/i386). Eventually, we had to revise the settings chose by the
				self-configuration.</para>
		</section>

		<section>
			<title>NAT-NAT/i386 and DRA-NAT/i386 build problems</title>

			<para>These two builds of the commands were only performed on the
				Linux/i386 platform, as a sanity check and cleanup of the source code.</para>
				<para>We faced only one problem during the NAT-NAT/i386 build of a
				few commands.</para>

			<itemizedlist>
				<listitem>
					<para>Some header files (e.g. <code>linux/autoconf.h</code>) were not found when
						attempting to compile some administrative commands. To gain access to such
						headers, the preliminary step of a kernel rebuild can be done; alternatively,
						one could manually establish the proper symbolic links for <code>/usr/include/linux</code>
						and <code>/usr/include/asm</code>: they should point to their equivalent inside the
						<code>/usr/src/linux/include</code>directory.</para>
				</listitem>
			</itemizedlist>

			<para>We faced a limited number of problems during the
				DRA-NAT/i386 builds of the commands. We list these problems below:</para>

			<itemizedlist>
				<listitem>
					<para>The link-edit of some commands failed because one symbol was undefined:
						<code>_alloca</code>. In the native compiler (gcc), <code>_alloca</code> is implemented as
						a built-in function. In the TenDRA compiler, this can also be the case, provided
						that the header file <code>alloca.h</code> is explicitly included. So we modified the
						relevant source files to include this header file.</para>
				</listitem>

				<listitem>
					<para>The source code for some commands appeared to use, through the inclusion of
						a system header file or under <code>#ifdef i386</code> conditional instruction, some
						assembly code. The related commands were thus excluded from our set of commands,
						except for a few of them for which we found a C variant to the assembly code.</para>
				</listitem>

				<listitem>
					<para>Re-declaration of an array, for which the dimension was computed using
						<code>sizeof</code>. The following code sums-up the problem:</para>

					<programlisting language="c">extern int lnum[sizeof(short)];
int lnum[sizeof(short)]; /* bis */</programlisting>   
				</listitem>
			</itemizedlist>

			<para>We sent a Change Request, <code>array_sizeof(262)</code>,
				concerning this problem, which applied to the apr-95 and nov-95 TenDRA releases.
				It has now been fixed.</para>
  
			<itemizedlist>
				<listitem>
					<para>Name conflict between a function and its arguments. The following code
						sums-up the problem:</para>

					<programlisting language="c">char *fields(fields)
char *fields;
{ return fields; }</programlisting> 
				</listitem>
			</itemizedlist>

			<para>We sent a Change Request, <code>func_var(262)</code>, concerning
				this problem, which applies to the apr-95 and nov-95 TenDRA releases. It has now
				been fixed.</para>

			<itemizedlist>
				<listitem>
					<para>Use of custom options of the native compiler (gcc), e.g.
						<code>-fpcc_struct_return</code></para>

					<para>This option was used in the Makefile for the
						getty package. The gcc man page says that this option provides intercallability
						with modules (e.g. library modules) compiled with a pcc compiler. We concluded
						that this was not relevant when compiling for a Linux target platform, since gcc
						is used to compile the libraries, and we ignored it. Similarly, we ignored, i.e.
						filtered out in our pseudo-gcc for DRA-NAT/DRA-DRA builds, many other gcc
						options such as <code>-fomit-frame-pointer, -pipe, -g</code>
						while we adapted to TenDRA style some others, such as <code>-static</code>
						(for gcc) to <code>-Wl,-static</code> (for tcc).</para>
				</listitem>
			</itemizedlist>
		</section>
	</section>

	<section id="apidef">
		<title>Definition of the API for the commands</title>

		<para>We started the experiment with an xpg3 API, and decided to
			put all other symbols we needed in an extension API. However, after a few
			compilations of Linux commands, it became clear that most of the symbols we were
			adding to the extension API were in fact part of some other standard APIs, such
			as svid3.</para>

		<para>So, we redefined our base API to be a merge between the
			xpg3, svid3, gcc and bsd_extn APIs delivered with TenDRA, limiting the extension
			API to symbols specific to the Linux commands interface. In fact, some of the
			symbols in the extension API are defined in the standard cose API, but since
			this API is very partially supported by Linux, and sometimes conflicts with
			definitions provided in other APIs, it was not worth including it in the base
			API.</para>

		<para>For the<code> level 2</code> set of commands, we downloaded some
			packages using a BSD-like interface, and we tried to include the symbol
			definitions for these commands in our extension API. However, this appeared to
			be very difficult, since we found that the Linux implementation of some BSD
			interfaces redefines symbols from the POSIX API, in an incompatible way. This is
			reflected in the Linux header files by conditional definitions, selected with
			the _BSD_SOURCE macro for example, or by replacement header files, such as
			bsd/signal.h instead of signal.h. The incompatible definitions we found were for
			the <code>jmp_buf</code> type, the <code>setjmp()</code>, <code>getpgrp()</code>, <code>wait()</code>,
			<code>waitpid()</code>, <code>wait3()</code> and
			<code>wait4()</code> functions, and finally the<code> signal()</code> function redefined
			as <code>bsd_signal()</code>.</para>

		<para>This problem could have been resolved by removing from our
			base API the conflicting symbols, and creating a <code>conflict_posix</code> and a
			<code>conflict_bsd</code> extension APIs with these symbols. The compilation of the
			commands based on a BSD-like API would have used the <code>conflict_bsd</code> API,
			in addition to the base and regular extension APIs, and would have been
			link-edited with the
			<code>libbsd</code> library provided by Linux. Since this would have taken a lot of
			time, we preferred not to modify our API and we set aside these commands, unless
			we found a simple work-around: selecting at build-time, or recoding to, a POSIX
			adherence for them (refer to next section).</para>

		<para>Finally, in order to compile some X11 commands, a separate
			API including the <code>x5_lib</code>, <code>x5_t</code>, <code>x5_mu</code>,<code> x5_aw</code> and<code>x5_mit</code>
			standard APIs, has been created. Since Linux is based on X11R6, an extension API
			has also been created, which includes the few symbols we had to define for the
			X11 commands we built.</para>

		<para>We found one inconsistency between the Linux header files
			and the standard API provided with TenDRA for the &lt;sys/socket.h&gt; header
			file, defined in the bsd_ext API: we had to change almost every use of <code>caddr_t</code>
			to <code>struct sockaddr *</code>. We also found a few inconsistencies between the
			Linux/i386 and Linux/Alpha header files, which have been resolved by some
			corrections to the Linux native header files, in the API definition, and in the
			source code for one command (<code>more</code>).</para>
	</section>

	<section id="andfization">
		<title>ANDFization of the commands</title>

		<para>We encountered different kinds of problems when compiling
			with TenDRA the set of commands on the Linux/i386 platform. Among these
			problems, only one was related to a bug in the TenDRA technology, the others
			were either related to ANDF constraints, or to more general portability issues.</para>

		<section>
			<title>Dealing with ANDF constraints</title>

			<para>We list below problems we encountered while ANDFizing Linux
				commands, which are related to the use of the TenDRA technology as a 
				replacement to a classic compiler. We start with the only bug found in TenDRA during 
				this process, then we roughly follow the order in which the various issues were
				encountered.</para>

			<itemizedlist>
				<listitem>
					<para>Redefinition of an API token as a macro</para>

					<para>In the code below, <code>alarm</code> is defined as a macro, but it is 
						also a token in our API:</para>

					<programlisting language="c">#include &lt;unistd.h&gt; /* for alarm() */
extern int debug() ;
#define D_RUN 1
#define alarm(d) alarm(d); debug(D_RUN, "alarm set: %s:%u",\
    __FILE__, __LINE__)
long xx() { return alarm((long)5); }</programlisting>

					<para>This code is indeed illegal, but tdfc entered an infinite loop.
						The problem was reported to DRA as <code>loop_tdfc_alarm(276)</code>, and
						has now been fixed.</para>
				</listitem>

				<listitem>
					<para>Added missing startup macros</para>

					<para>When the TenDRA
						compiler (tcc) was used, a number of startup flags, defined with the
						native compiler (gcc), were missing.  The <code>linux</code>,
						<code>__linux__</code>, <code>unix</code> and _<code>_X11_P_HEADERS</code> flags, plus a
						number of flags defined in the native <code>features.h</code> header file,
						such as <code>_POSIX_SOURCE</code>, were added in a startup file for tcc.</para>
				</listitem>

				<listitem>
					<para>Added missing function prototypes and fixed type
						mismatches</para><para>We used a tcc option to warn about missing function
						prototypes, and we fixed them by either including the appropriate header
						files or adding their prototype for locally defined functions. We added
						casting on some calls to library functions.  Then, every remaining
						undeclared symbol was added to the extension API. <emphasis>Note than more
						than half of the changes we made in the source code for Linux commands
						consisted in adding such prototypes.</emphasis></para>
				</listitem>

				<listitem>
					<para>Resolved one conflict with an API symbol</para>

					<para>The function <code>mkdir()</code>, local to the file <code>mtools</code>, has been
						renamed to avoid a conflict with the API symbol defined in
						&lt;sys/stat.h&gt;.</para>
				</listitem>

				<listitem>
					<para>Illegal use of target-dependent condition</para>

					<para>In the code below, INT_MAX is a target dependent token, which cannot
						be used to conditionally define a preprocessor macro:</para>

					<programlisting language="c">	#if (INT_MAX &lt;= 65535)
  	#define longdiff(a, b) /* (definition 1 for the macro) */
  	#else
  	#define longdiff(a, b) /* (definition 2 for the macro) */
  	#endif</programlisting> 

					<para>We fixed it by replacing the macro definition by a static functions:</para>

					<programlisting language="c">static int longdiff(time_t a, time_t b) {
#if (INT_MAX &lt;= 65535)
  	/* ... (definition 1 for the function) */
#else
  	/* ... (definition 2 for the function) */
#endif
}</programlisting>

					<para>This constraint arises from the way ANDF is used to achieve
						portability between targets which may have different values for
						INT_MAX. The constraint is that a target-dependent #if is permitted
						only where a statement is permissible, and both alternatives must be
						legal statement lists.</para>

					<para>This constraint unfortunately prevents target-dependent macro
						definitions in the style shown above. DRA is currently considering
						whether the constraint may be eased in a subsequent version of TenDRA
						to permit certain well-formed cases such as this.</para>
				</listitem>

				<listitem>
					<para>POSIX.1 or SVID interfaces versus BSD interfaces</para>

					<para>Three functions of the <code>bin</code> package, <command>time</command>
						and <command>crontab</command>, and <command>ash</command> (a simple
						shell), were configured to use some BSD interfaces which had not been
						included into our API, as discussed in <xref linkend="apidef"/>.</para>

					<para>For the <command>time</command> command, we found that the support
						for POSIX interfaces was provided in the source code, so we used it.</para>

					<para>Similarly, prior to building <command>ash</command>, we modified
						the related configuration file and Makefile, in order to elect
						svid3-like interfaces instead of the default bsd ones.</para>

					<para>For the <command>crontab</command> command, we fixed the problem by
						removing in the source code some (simple) calls to the BSD
						<function>wait4()</function> function, and by using the XPG3
						<function>waitpid()</function> function instead.</para>
				</listitem>

				<listitem>
					<para>For a few commands which use the <code>curses</code> interface, e.g.
						<code>bpe</code>, we chose the svid3 variant instead of the BSD one (they are
						both supported by Linux). Makefiles for building these commands with
						TenDRA have been changed to use the <code>libncurses</code> library instead of
						the <code>libcurses</code> library at link-edit time. Note that the sources for
						the <code>elvis</code> editor (from the <code>bin</code> package) embed a small custom
						version of the <code>curses</code> interface.</para>
				</listitem>

				<listitem>
					<para>For some commands, the initial self-configuration step performed
						prior to entering the actual build defines the path for another command,
						because the latter is called by the first one by means of
						<function>exec()</function> or <function>system()</function>.  While Linux
						provides the &lt;paths.h&gt; header file for this purpose, we found some
						files which do not include this header file, and others which need to call
						a command for which there is no path definition in the regular header. An
						example of such a situation is <command>elm</command>, which calls an
						editor (e.g. <command>vi</command>).  When we detected such situations, we
						either modified the source code to include and use &lt;paths.h&gt;, or we
						added a definition inside the alternate &lt;paths.h&gt; specified in our
						extension API.</para>
				</listitem>

				<listitem>
					<para>Pointer/Integer conversion</para>

					<para>The TenDRA compiler can be
						configured to issue a warning on every pointer/integer conversion. This is
						done with the pragma instruction:</para>

					<para><code>#pragma TenDRA conversion
						analysis (int-pointer) warning</code></para>

					<para>However, due to the very large
						number of occurrences of these warnings, we had to cancel this mode, and
						decided to postpone their analysis until after the validation
						step.</para>

					<para>For example, we encountered uses of -1 (minus one) to give a
						special meaning to a pointer value, while only 0 (NULL) is accepted for
						this purpose. (Note: 64-bit issues are discussed later in this section.)</para>
				</listitem>

				<listitem>
					<para>Underspecified type in svid3 API</para>

					<para>We found one command which
						makes the assumption that the daddr_t type, defined in the svid3 API, is an
						arithmetic type. The source code casts a daddr_t value into an int, while
						daddr_t is defined in the API as:</para>

					<programlisting language="tspec">+TYPE daddr_t;</programlisting>

					<para>We fixed this problem by stating that daddr_t is indeed an arithmetic type,
						which is correct for both Linux/i386 and Linux/Alpha. We initially modified
						the reference svid3 API, but later we did it more cleanly, moving the
						daddr_t definition to our extension API prior to changing it to:</para>

					<programlisting language="tspec">+TYPE (int) daddr_t;</programlisting>

					<para>Also, prior to fixing this in the API, we found that casting an integer
						value to a daddr_t type was not rejected by the TenDRA compiler, while it is
						obviously illegal. A bug report has been sent to DRA, and this has now been
						fixed.</para>
				</listitem>

				<listitem>
					<para>Recoding of a source file dealing with target platform byte ordering
						issues.</para>

					<para>A source file used a local BYTEORDER macro, set-up during the
						initial self-configuration step of the build of the command, to support
						different byte ordering. However, Linux already provides for this purpose a
						__BYTE_ODER macro, defined in the &lt;bytesex.h&gt; header file. So, we added
						the __BYTE_ORDER symbol to our API, and replaced all the occurrences of the
						BYTEORDER macro by references to the __BYTE_ODER API macro. We also had to
						rewrite some code, because with TenDRA some instructions are illegal after a
						target dependent condition.</para>
				</listitem>

				<listitem>
					<para>The termio and termios interfaces are both provided with Linux,
						and share the same set of macros to define indexes in the<code> c_cc </code>array
						from either the termio or termios structures. On Linux/i386, these indexes
						are the same for the two structures, while on Linux/Alpha they differ.
						TenDRA provides a way to support different variants of a same object, using
						version numbers, and this should have solved our problem. However, since we
						never used this feature before, we did not spend time to see how we could
						use it in our API. Instead, we made a temporary fix, consisting in renaming
						the constants in the termio interface. For two of the commands we ported,
						<code>more</code> and <code>ispell</code>, which use the termio interface, we changed
						their sources to reference the new macros.</para>
				</listitem>
			</itemizedlist>
		</section>

		<section>
			<title>Undocumented dependencies to the OS / the underlying hardware</title>

			<para>Some commands are platform dependent, and are not
				easily (sometimes: not at all) portable from one platform to another.
				However, the Linux/i386 and Linux/Alpha OS's are very similar;
				furthermore, some hardware architectures built around the DEC Alpha chip
				are not much different from the Intel-based PC: for example, our
				Linux/Alpha platform includes ISA adapters for graphics and Ethernet. In
				such a favorable situation, the Linux/i386 <code>ifconfig</code> command (from
				the<code> tcpip/net-tools</code> subset), which displays hardware information on
				the network interfaces such as their (ISA) &ldquo;Base address&rdquo;, could
				probably have been easily ported to Linux/Alpha (/AXP pci). Also, the perl
				command, which includes optional support for undocumented system calls,
				may or may not be portable between two Linux platforms, depending on the
				system calls they implement.</para>

			<para>On the other hand, changing the format for binary
				files, e.g. switching from a classic Linux <code>a.out</code> format to the
				Digital Unix &ldquo;Extended COFF&rdquo;, may require changes in some common commands
				such as <code>strings</code> or <code>file</code>. When using a classic compiler, some
				(or even all in a favorable case) of these changes may be hidden inside the
				system header files, e.g. &lt;a.out.h&gt;, but the TenDRA compilation chain,
				when used in DRA-DRA mode, is often more rigid.</para>
		</section>

		<section>
			<title>Upgrade to TenDRA 4.0</title>

			<para>When we had ANDFized the whole set of commands, we
				upgraded to TenDRA 4.0 in order to work on the Linux/Alpha platform (see
				<xref linkend="installonalpha"/>).
				However, we had to ANDFize again the set of commands with the new TenDRA
				version, since it was not upward compatible with the previous one. In
				fact, we only re-ANDFized the commands we tried to install on the
				Dec/Alpha platform, at the time we needed them. We did not encounter any
				problem when doing this.</para>
		</section>

		<section>
			<title>Holes in source code portability (64-bit vs 32-bit issues)</title>

			<para>During the installation and validation of these
				commands on the second platform, we found a number of bugs related to
				portability problems, which are out of the scope of TenDRA. All these bugs
				were due to code assuming 32-bit platforms, which break on 64-bit
				platforms. Some of the bugs we found were already fixed in early
				Linux/Alpha releases, such as the Blade release, others were still there.
				We fixed the source of the commands, re-andfized them, and installed and
				validated these commands again on the two platforms. We give below the
				portability issues we encountered:</para>

			<itemizedlist>
				<listitem>
					<para>Wrong <code>int &lt;-&gt; pointer</code> conversion</para>

					<para>On Linux/Alpha
						(and Digital Unix/Alpha), a pointer type is 8-bytes wide, so it cannot
						fit in an <code>int</code> type, which is only 4-bytes wide. Fortunately, the
						<code>long</code> type on Linux/Alpha is, as usual, as large as a pointer, and
						thus can be used as a replacement for an <code>int</code>, each time an
						explicit pointer&lt;-&gt;integer is used. This is a common type of the
						portability fixes we had to make in the source code for Linux commands,
						subsequent to encountering a Linux/Alpha-only problem at validation
						time.</para>
				</listitem>

				<listitem>
					<para>Incorrect assumptions on sizes of <code>int</code>, <code>long</code> and
						<code>size_t</code></para>

					<para>Although in many cases int and long types are equivalent,
						we give below three examples of code we found where it makes a difference:</para>

					<programlisting language="c">/* #1 */ { int i; printf("i value is: %ld\n", i); }
/* #2 */ extern char *malloc(int);
/* #3 */ { long l ; printf("%08lx", l); }</programlisting>

					<para>All three work perfectly on Linux/i386, while they cause, or could
						cause, damage under Linux/Alpha.</para>

					<para>In the first two lines the
						function, printf or malloc, will read respectively a long on the stack,
						which are 8 bytes wide, while only 4 bytes for an int would have been
						pushed. Note that the correct prototype for malloc is char
						*malloc(size_t), and that size_t is equivalent to long on Linux/Alpha. We
						fixed the error on such printf statements with a cast to long for an
						argument, and the error on malloc by replacing its local-and-wrong
						declaration by the inclusion of the &lt;stdlib.h&gt; header
						file.</para>

					<para>In the third case, the instruction was used to print a
						fixed number of digits.  However, a long, 8-bytes on an Alpha platform,
						may hold a value that prints up to 16 digits, thus putting unexpected
						digits in the output. In the code where we found the problem, the fix
						was to truncate the value to a 4-byte value.</para>
				</listitem>
			</itemizedlist>
		</section>
 	 </section>

	<section id="apiinstallation">
		<title>Installation of the API for the commands</title>

		<section>
			<title>Installation of the API on Linux/i386</title>

			<para>The API is made of two parts, a base API, which is a
				merge between xpg3, svid3, gcc and bsd_extn APIs, and an extension API,
				which completes the interface required for the commands (see <xref linkend="apidef"/>).</para>

			<para>The base API was installed on the Linux/i386 platform,
				without any problem. However, we left some tokens undefined when some parts of
				the API were not part of the actual Linux API. Then, the extension API was
				installed, as we extended it to cover more and more commands. These
				installations required a few patches to the system header files, some of which
				were already provided with the TenDRA snapshot. These installations went very
				well, with only a few problems, listed in a following paragraph. Then, when we
				moved to a new TenDRA snapshot to the Linux/Alpha platform, we re-installed the
				API, without any problem.</para>

			<para>We made a small number of modifications to the API during
				the port of the commands on the Linux/Alpha platform. However, each modification
				we made required re-installation of some parts of the API.</para>
		</section>

		<section>
			<title>Installation of the API on Linux/Alpha</title>

			<para>As for the Linux/i386 platform, we had to apply some patches
				to the system header files in order to install the API. A number of these
				patches were actually identical to the patches we made on the Linux/i386 header
				files. So, instead of copying and editing, by hand, these files again, we chose
				to implement these patches by means of <code>sed</code> scripts, which could be
				applied to both Linux/i386 and Linux/Alpha header files. Most of these scripts
				are now common to the two platforms, although a few of them are specific to one.
				These
				<code>sed</code> scripts not only facilitate corrections to the system header files,
				but would also be useful if we need to upgrade from one Linux version to
				another.</para>

			<para>The Linux/Alpha system header files do not differ much from
				the Linux/i386 ones. However, since the Linux/Alpha port was derived from a more
				recent Linux/i386 version (Linux 1.3) than the one we used (Linux 1.1), we could
				not clearly distinguish between the changes which come from standard Linux
				evolutions and those which have been introduced during the port of Linux to
				Digital Alpha. One important modification was that some definitions found on
				Linux/i386 in some &lt;linux/*&gt; or &lt;sys/*&gt; header files have now been
				moved into &lt;asm/*&gt; header files. We had to take such changes into account
				when adapting the Linux/i386 modifications to Linux/Alpha.</para>

			<para>Finally, we did not port to Linux/Alpha the extension API to
				the TenDRA x5/* APIs. This would have required installation of X11 on our
				Linux/Alpha box, which consists of 28 additional floppy images! This part of the
				API was only required for 9 commands from our set of commands, which we did not
				install on Linux/Alpha.</para>
		</section>

		<section>
			<title>API installation problems</title>

			<para>We list below the problems we found when building the API on
				the Linux/i386 or the Linux/Alpha platforms, and the solution we adopted.</para>

			<itemizedlist>
				<listitem>
					<para>A macro, <code>makedev</code>, added to our extension API, was defined in the
						Linux/i386<code>sys/sysmacros.h </code>header file. This file contains the lines:</para>

					<programlisting language="c">#define major(dev) ...
#define minor(dev) ...
#define makedev(major,minor) ...</programlisting>

					<para>The identifiers <code>major</code> and <code>minor</code> used to name the formal
						parameters of the <code>makedev</code> macro are also the name of two macros defined
						in this header file, which we included in our API. The clash on the names is
						reported as an error by tdfc when building the API. We did not check whether
						this was a TenDRA bug or not, but we bypassed the problem by using an alternate
						version of <code>sys/sysmacros.h</code>, in which the formal parameters of the <code>makedev</code>
						macro have been renamed. </para>
				</listitem>

				<listitem>
					<para>The &lt;bytesex.h&gt; header file contained the following lines:</para>

					<programlisting language="c">#undef __BYTE_ORDER
#define __BYTE_ORDER 1234</programlisting>

					<para>The<code> #undef</code> line prevents tcc from finding the definition of the
						__BYTE_ORDER constant. This is a constraint that applies only when building API
						token libraries. It is a necessary consequence of using C macro definitions to
						obtain ANDF token definitions. We bypassed this behaviour by commenting out the
						#undef line in a replacement header file.</para>
				</listitem>

				<listitem>
					<para>The Linux/Alpha header files do not follow the standard APIs in some cases.
						For example, the Linux/Alpha &lt;sys/stat.h&gt; header file defines the field
						<code>st_dev</code> from the <code>stat</code> structure as <code>unsigned int</code> instead of
						<code>dev_t</code> as defined in XPG/3. Since <code>dev_t</code> is equivalent to <code>unsigned int</code> on
						Linux/Alpha, we were able to modify the system header file to use the correct
						type.</para>
				</listitem>

				<listitem>
					<para>The Linux/Alpha header files sometimes use an <code>int</code> type, in places where a
						<code>long</code> type is used on Linux/i386. In such cases, we decided to patch the
						Linux/i386 header files to use an <code>int</code> type, since <code>long</code> and <code>int</code> are
						equivalent on a 32-bit platform.</para>
				</listitem>

				<listitem>
					<para>The reverse situation, where Linux/i386 uses an <code>int</code> and Linux/Alpha uses
						a <code>long</code>, has also been found. In this case, we preferred to modify the API to
						accept both types, using the tspec <code>+TYPE (int) ...</code> notation.</para>
				</listitem>

				<listitem>
					<para>On the Linux/i386 platform, we extended the API with some symbols from the &lt;termio.h&gt;
						header file. The &lt;termio.h&gt; system header file has changed between
						Linux/i386 and Linux/Alpha, and some definition were incompatible with the
						extension API. We eventually found a solution, which involved a fix to the Linux
						header files.</para>
				</listitem>

				<listitem>
					<para>The Linux system supports two variants of the <code>curses</code> library, one
						defined by the &lt;curses.h&gt; header file for a BSD API, and the other defined
						by the &lt;ncurses.h&gt; header file for a svid3 API. We used the latter to
						build the API, since we do not support the BSD API.</para>
				</listitem>

				<listitem>
					<para>The TenDRA svid3 API defines the constant RLIM_INFINITY, from the
						sys/resource.h header file, as follow:</para>

					<programlisting language="tspec">+CONST int RLIM_INFINITY;</programlisting>

					<para>However, this constant is used to assign variables of type <code>rlimit_t</code>,
						which is, on Dec/Alpha, defined as a long, thus 8-bytes wide. So the problem
						was: while this constant was defined with the value 0x7fffffffffffffffL, it was
						actually truncated to fit within a (32-bit) int. We fixed this bug by replacing
						the definition of RLIM_INFINITY by:</para>

					<programlisting language="tspec">+CONST rlimit_t RLIM_INFINITY;</programlisting> 
				</listitem>
			</itemizedlist>
		</section>
	</section>

	<section id="installandvalid">
		<title>Installation and validation of the commands</title>

		<para>On the Linux/i386 platform, we used the TenDRA compiler to
			produce the ANDF files, and then translate them into binary executable files, in
			the same invocation of the compiler. A tcc option was used to preserve the
			intermediate ANDF files.</para>

		<para>On the Linux/Alpha platform, we used the ANDF files produced
			on the Linux/i386 platform, and translated them into binary executable files.
			For this platform, we ran the TenDRA compiler on a Dec/Alpha platform as a
			cross-compiler for the Linux/Alpha platform (see <xref linkend="installonalpha"/>).</para>

		<para>In order to validate the commands we built, we used several
			different methods, depending on the commands.</para>

		<para>We found that a very limited number of commands were
			packaged with some rather extensive self-validation tests, that we used to
			validate such commands.</para>

		<para>We tested some other commands interactively (e.g. <code>elvis</code>,
			<code>bpe</code>, <code>ispell</code>, <code>elm</code>, ...). However, for most commands we
			had to write small tests. Even a basic test requires several shell script lines:
			it took us several weeks to write tests for &gt;200 commands then to run them.</para>

		<para>Finally, a small number of commands, actually 10, was not
			tested: <code>getty/uugetty</code>, <code>sudo.bin/visudo</code>, <code>readprofile</code>,
			<code>swapon</code>, <code>mt-GNU</code>, <code>rmt</code>,
			<code>plipconfig</code> and <code>slattach</code>. As none of these commands were actually
			installed on the 2nd platform, there is no real penalty.</para>

		<para>On the Linux/i386 platform, 236 commands were installed,
			then validated. Conversely, on Linux/Alpha, we installed and validated only a
			subset of these commands: about 150, as previously mentioned. While we found
			only a few problems during the validation on Linux/i386, we faced a number of
			validation failures on Linux/Alpha, thus requiring much more investigation. Some
			of these problems were due to bugs in the TenDRA technology, and have all been
			fixed by now. Most of the others have already been discussed in previous
			sections.</para>

		<para>We list below miscellaneous problems, encountered at
			validation time on either the 1st or the 2nd platforms, which are not really
			related to TenDRA, nor do they depend on portability issues in the original
			source code.</para>

		<section>
			<title>Miscellaneous problems encountered at validation</title>
  
			<itemizedlist>
				<listitem>
					<para>For two commands, <code>sln</code> and <code>stty</code>, we found different
						behaviour due to an undetected missing symbol in our API. For example, the <code>sln</code>
						command is written such that, depending on weather the S_ISLINK symbol is
						defined or not, it generates a symbolic link or a hard link. The missing symbol
						was defined in our API to fix the problem.</para>
				</listitem>

				<listitem>
					<para>The <code>more</code> command on Linux/Alpha, of which the source code uses the
						non-POSIX <code>termio</code> interface, waits for 4 input characters before
						processing them. The reason is that in Linux/Alpha (as in Digital Unix) some of
						the <code>termio.c_cc[]</code> control characters overlap with some others, depending
						on the input mode being used (i.e. either the &ldquo;canonical&rdquo; mode or the
						&ldquo;half-cooked&rdquo; mode). So such control characters, which are the ones at VMIN and
						VTIME indexes, must always be updated when switching from one input mode to the
						other: we changed the source code for the <code>more</code> command accordingly.</para>
				</listitem>

				<listitem>
					<para>We found two bugs in the Linux/Alpha libc library, in the <code>getegid</code>
						and <code>times</code> functions. The 1st one was already known and fixed in a later
						release, while the 2nd one was not (we received a fix for it a few days later,
						from a member of the Linux/Alpha project).</para>
				</listitem>

				<listitem>
					<para>The <code>csplit</code> command, from the txtutils package, defines the <code>memchr()
						</code>function, also defined in the libc library. The validation of this command
						failed on Alpha, until we removed this local recoding for <code>memchr()</code> and
						used the regular library entry point instead.</para>
				</listitem>

				<listitem>
					<para>The environment on Linux/Alpha for using the <code>zic</code> command was not
						correct, since that command is not available in the Linux/Alpha BLADE_0.3
						distribution.</para>
				</listitem>

				<listitem>
					<para>The environment on Linux/Alpha for running the <code>bpe</code> command was not
						correct, since we had used the (available) <code>ncurses</code> library when
						link-editing this command: at run-time the related <code>terminfo</code> data base
						was lacking. We simply had to replicate on Linux/Alpha the Linux/i386 terminfo
						files to cure this problem.</para>
				</listitem>
			</itemizedlist>
		</section>

		<section>
			<title>Recent upgrades of our original source code for Linux commands</title>

			<para>We initially found on the net a limited number of patches
				for the commands in source form; such patches had been made during the port of
				Linux to Digital Alpha. For example, the following patch for the source code for
				the col command was found on <code>ftp.azstarnet.com</code>, but it is not a example
				of interest since we had preventively fixed it, i.e. during the initial
				ANDFization of the col command: </para>

			<para>util-linux-2.5/text-utils/col.c:</para>

			<programlisting language="diff">+ #include &lt;malloc.h&gt;</programlisting>

			<para>Conversely, neither the BLADE_0.3 nor the BLADE_0.2
				distributions include source code for commands; we discovered very
				recently that such code was available (on <code>ftp.digital.com</code>)
				for the very first, 32-bit Linux/Alpha distribution. Nevertheless,
				for three commands we used source code from the RedHat 2.1/beta
				and 2.1 Linux/Alpha distributions. This allowed us to fix
				incorrect behavior of the <code>zic</code> command; we also experimented
				without success (due to lack of time) some partial upgrades of the
				source code for <code>zdump</code> and <code>cpio</code>.</para>
		</section>
	</section>
</chapter>

