<!-- Published by Quadralay WebWorks HTML Lite 1.5 -->
<html>
<head>


<script type="text/javascript" src="/static/js/analytics.js"></script>
<script type="text/javascript">archive_analytics.values.server_name="wwwb-app14.us.archive.org";archive_analytics.values.server_ms=146;</script>
<link type="text/css" rel="stylesheet" href="/static/css/banner-styles.css"/>


<title></title>
</head>

<body>


<!-- BEGIN WAYBACK TOOLBAR INSERT -->
<script type="text/javascript" src="/static/js/disclaim-element.js" ></script>
<script type="text/javascript" src="/static/js/graph-calc.js" ></script>
<script type="text/javascript">//<![CDATA[
var __wm = (function(imgWidth,imgHeight,yearImgWidth,monthImgWidth){
var wbPrefix = "/web/";
var wbCurrentUrl = "http://www.gr.osf.org/projects/andf/java-and.htm";

var firstYear = 1996;
var displayDay = "28";
var displayMonth = "Jan";
var displayYear = "1998";
var prettyMonths = ["Jan","Feb","Mar","Apr","May","Jun","Jul","Aug","Sep","Oct","Nov","Dec"];
var $D=document,$=function(n){return document.getElementById(n)};
var trackerVal,curYear = -1,curMonth = -1;
var yearTracker,monthTracker;
function showTrackers(val) {
  if (val===trackerVal) return;
  var $ipp=$("wm-ipp");
  var $y=$("displayYearEl"),$m=$("displayMonthEl"),$d=$("displayDayEl");
  if (val) {
    $ipp.className="hi";
  } else {
    $ipp.className="";
    $y.innerHTML=displayYear;$m.innerHTML=displayMonth;$d.innerHTML=displayDay;
  }
  yearTracker.style.display=val?"inline":"none";
  monthTracker.style.display=val?"inline":"none";
  trackerVal = val;
}
function trackMouseMove(event,element) {
  var eventX = getEventX(event);
  var elementX = getElementX(element);
  var xOff = Math.min(Math.max(0, eventX - elementX),imgWidth);
  var monthOff = xOff % yearImgWidth;

  var year = Math.floor(xOff / yearImgWidth);
  var monthOfYear = Math.min(11,Math.floor(monthOff / monthImgWidth));
  // 1 extra border pixel at the left edge of the year:
  var month = (year * 12) + monthOfYear;
  var day = monthOff % 2==1?15:1;
  var dateString = zeroPad(year + firstYear) + zeroPad(monthOfYear+1,2) +
    zeroPad(day,2) + "000000";

  $("displayYearEl").innerHTML=year+firstYear;
  $("displayMonthEl").innerHTML=prettyMonths[monthOfYear];
  // looks too jarring when it changes..
  //$("displayDayEl").innerHTML=zeroPad(day,2);
  var url = wbPrefix + dateString + '/' +  wbCurrentUrl;
  $("wm-graph-anchor").href=url;

  if(curYear != year) {
    var yrOff = year * yearImgWidth;
    yearTracker.style.left = yrOff + "px";
    curYear = year;
  }
  if(curMonth != month) {
    var mtOff = year + (month * monthImgWidth) + 1;
    monthTracker.style.left = mtOff + "px";
    curMonth = month;
  }
}
function hideToolbar() {
  $("wm-ipp").style.display="none";
}
function bootstrap() {
  var $spk=$("wm-ipp-sparkline");
  yearTracker=$D.createElement('div');
  yearTracker.className='yt';
  with(yearTracker.style){
    display='none';width=yearImgWidth+"px";height=imgHeight+"px";
  }
  monthTracker=$D.createElement('div');
  monthTracker.className='mt';
  with(monthTracker.style){
    display='none';width=monthImgWidth+"px";height=imgHeight+"px";
  }
  $spk.appendChild(yearTracker);
  $spk.appendChild(monthTracker);

  var $ipp=$("wm-ipp");
  $ipp&&disclaimElement($ipp);
}
return{st:showTrackers,mv:trackMouseMove,h:hideToolbar,bt:bootstrap};
})(500, 27, 25, 2);//]]>
</script>
<style type="text/css">
body {
  margin-top:0 !important;
  padding-top:0 !important;
  min-width:800px !important;
}
</style>
<div id="wm-ipp" lang="en" style="display:none;">

<div style="position:fixed;left:0;top:0;width:100%!important">
<div id="wm-ipp-inside">
   <table style="width:100%;"><tbody><tr>
   <td id="wm-logo">
       <a href="/web/" title="Wayback Machine home page"><img src="/static/images/toolbar/wayback-toolbar-logo.png" alt="Wayback Machine" width="110" height="39" border="0" /></a>
   </td>
   <td class="c">
       <table style="margin:0 auto;"><tbody><tr>
       <td class="u" colspan="2">
       <form target="_top" method="get" action="/web/form-submit.jsp" name="wmtb" id="wmtb"><input type="text" name="url" id="wmtbURL" value="http://www.gr.osf.org/projects/andf/java-and.htm" style="width:400px;" onfocus="this.focus();this.select();" /><input type="hidden" name="type" value="replay" /><input type="hidden" name="date" value="19980128074102" /><input type="submit" value="Go" /><span id="wm_tb_options" style="display:block;"></span></form>
       </td>
       <td class="n" rowspan="2">
           <table><tbody>
           <!-- NEXT/PREV MONTH NAV AND MONTH INDICATOR -->
           <tr class="m">
           	<td class="b" nowrap="nowrap">
		
		    <a href="/web/19971016043911/http://www.gr.osf.org/projects/andf/java-and.htm" title="16 Oct 1997">OCT</a>
		
		</td>
		<td class="c" id="displayMonthEl" title="You are here: 7:41:02 Jan 28, 1998">JAN</td>
		<td class="f" nowrap="nowrap">
		
		    <a href="/web/19990427175454/http://www.gr.osf.org/projects/andf/java-and.htm" title="27 Apr 1999"><strong>APR</strong></a>
		
                </td>
	    </tr>
           <!-- NEXT/PREV CAPTURE NAV AND DAY OF MONTH INDICATOR -->
           <tr class="d">
               <td class="b" nowrap="nowrap">
               
                   <a href="/web/19980115054305/http://gr.osf.org/projects/andf/java-and.htm" title="5:43:05 Jan 15, 1998"><img src="/static/images/toolbar/wm_tb_prv_on.png" alt="Previous capture" width="14" height="16" border="0" /></a>
               
               </td>
               <td class="c" id="displayDayEl" style="width:34px;font-size:24px;" title="You are here: 7:41:02 Jan 28, 1998">28</td>
	       <td class="f" nowrap="nowrap">
               
		   <a href="/web/19990427175454/http://www.gr.osf.org/projects/andf/java-and.htm" title="17:54:54 Apr 27, 1999"><img src="/static/images/toolbar/wm_tb_nxt_on.png" alt="Next capture" width="14" height="16" border="0" /></a>
	       
	       </td>
           </tr>
           <!-- NEXT/PREV YEAR NAV AND YEAR INDICATOR -->
           <tr class="y">
	       <td class="b" nowrap="nowrap">
               
                   1997
               
               </td>
               <td class="c" id="displayYearEl" title="You are here: 7:41:02 Jan 28, 1998">1998</td>
	       <td class="f" nowrap="nowrap">
               
	           <a href="/web/19990427175454/http://www.gr.osf.org/projects/andf/java-and.htm" title="27 Apr 1999"><strong>1999</strong></a>
	       
	       </td>
           </tr>
           </tbody></table>
       </td>
       </tr>
       <tr>
       <td class="s">
           <a class="t" href="/web/19980128074102*/http://www.gr.osf.org/projects/andf/java-and.htm" title="See a list of every capture for this URL">6 captures</a>
           <div class="r" title="Timespan for captures of this URL">27 Apr 97 - 27 Apr 99</div>
       </td>
       <td class="k">
       <a href="" id="wm-graph-anchor">
       <div id="wm-ipp-sparkline" title="Explore captures for this URL">
	 <img id="sparklineImgId" alt="sparklines"
		 onmouseover="__wm.st(1)" onmouseout="__wm.st(0)"
		 onmousemove="__wm.mv(event,this)"
		 width="500"
		 height="27"
		 border="0"
		 src="/web/jsp/graph.jsp?graphdata=500_27_1996:-1:000000000000_1997:-1:000101000100_1998:0:200000000000_1999:-1:000100000000_2000:-1:000000000000_2001:-1:000000000000_2002:-1:000000000000_2003:-1:000000000000_2004:-1:000000000000_2005:-1:000000000000_2006:-1:000000000000_2007:-1:000000000000_2008:-1:000000000000_2009:-1:000000000000_2010:-1:000000000000_2011:-1:000000000000_2012:-1:000000000000_2013:-1:000000000000_2014:-1:000000000000_2015:-1:000000000000" />
       </div>
       </a>
       </td>
       </tr></tbody></table>
   </td>
   <td class="r">
       <a href="#close" onclick="__wm.h();return false;" style="background-image:url(/static/images/toolbar/wm_tb_close.png);top:5px;" title="Close the toolbar">Close</a>
       <a href="http://faq.web.archive.org/" style="background-image:url(/static/images/toolbar/wm_tb_help.png);bottom:5px;" title="Get some help using the Wayback Machine">Help</a>
   </td>
   </tr></tbody></table>
</div>
</div>
</div>
<script type="text/javascript">__wm.bt();</script>
<!-- END WAYBACK TOOLBAR INSERT -->
<h1></h1>

<a name="4710">
<h1 align="center">Java-ANDF Feasibility Study</h1>
</a>
<a name="4711">
<h1 align="center">June 1996</h1>
</pre>
</a>
<a name="3163">
<p align="center">Christian Fabre, Fran&ccedil;ois de Ferri&egrave;re<br>
Open Software Foundation<br>
Research Institute
<hr>
</a>
<a name="107">
<h1>1. Objectives and Description</h1>
</a>
<a name="3972">
This study is part of the CSM/165 contract with DRA, Academic Research Co-ordination for TDF Software <a href="java-and.htm#354">[1]</a>.<p>
</a>
<a name="3973">
<h2>1.1 Objectives</h2>
</a>
<a name="3974">
Java is an emerging language for distributing and executing applications over the Internet <a href="java-and.htm#3010">[2]</a>.<p>
</a>
<a name="3977">
ANDF was designed a few years ago, to achieve the goal of distributing, to many platforms, applications written in many languages.<p>
</a>
<a name="3978">
While these two intermediate languages share a same objective, executing applications on multiple platforms, the way they handle this challenge is very different.<p>
</a>
<a name="3980">
Java was designed for the purpose of executing applications in the Internet World. It shares many features with C++, but is simpler, and has strong requirements on security. Java source code is compiled into bytecode, which is the instruction set of an abstract machine <a href="java-and.htm#6086">[3]</a>. The Java bytecode is then distributed over the Internet, and executed, through an interpreter, on the abstract machine. The Java abstract machine has already been ported to several different hardware platforms.<p>
</a>
<a name="7634">
ANDF, on the other hand, is an intermediate language for applications written in a High Level Language (HLL), including C, C++, Ada, Fortran. It has been designed to encompass the semantics of most HLL, with abstraction of the platform dependencies, and uses a byte-stream to distribute an application. This byte-stream can be installed on a large number of different platforms, currently Dec/Alpha, Sun/Sparc, HP-PA, PowerPC, MIPS, Intels and executed as native binary code on the machine.<p>
</a>
<a name="4008">
In this study we will establish a parallel between the two technologies, and explain where and how ANDF can be useful to Java.<p>
</a>
<a name="4003">
<h2>1.2 Description</h2>
</a>
<a name="3988">
In the proposal of the contract with DRA, we described five points where ANDF could be useful to Java. We reproduce below these points from the proposal:<p>
</a>

<ol>
<a name="4027">
<li>Distribute native Java libraries in ANDF format for Unixes. Since the Java Virtual Machine has fixed data formats, we do not have to worry about the tokenisation of types, which (a) greatly simplifies the translation, and (b) means that the same Token Definition Libraries for the Java APIs work on all platforms. Extending the capabilities of Java, however, requires that a set of classes be declared, which have methods tagged as native and implemented directly in C. This is already how the Java Developer's Kit (JDK) provides access to X11/Motif, networking and audio. If a relevant Unix API is standardized, then we are able to distribute these native methods in ANDF form, and the interface classes as bytecode.
</a>
<a name="4028">
<li>A Java runtime in ANDF. The current runtime is more mutable than portable. But with new standards such as COSE (and latter on Posix Pthreads), it might be possible to have a generic runtime that could be distributed in ANDF.
</a>
<a name="3991">
<li>A Java-byte code to ANDF translator. Assume the Java-byte code has already gone through a filter that has rendered it ``security-safe''. The idea is to use the ANDF installers to generate native code afterwards. This could be done in two phases:
</a>
<ul>
<a name="3992">
<li>An initial version to demonstrate the principle, where the translation is limited to an expansion of the virtual machine within each method. This could gain a factor 4 over interpretation.
</a>
<a name="3993">
<li>A more sophisticated version could analyse more thoroughly the code of each method and translate it into more efficient ANDF. This would allow installers to generate more efficient code. (Consider a tight loop with floating point in it).
</a>
</ul>
<a name="3994">
<li>Application optimiser. This is for full scale Java applications, not applets.
</a>
<a name="3995">
<br>All the Java classes of an application are in bytecode. Now one can generate ANDF 
with additional profiling information. The results can be fed back to a tool that takes 
advantage of this information to inline code in critical sections. This may outperform any native code generator.
</a>
<a name="3996">
<br>We might go as far as always generating profiled ANDF. The actual installation of 
profiling could then depend on the value of a token provided at installation time.
</a>
<a name="4012">
<li>A native Java to ANDF producer. This may not seem necessary if we have tools such as (3) for backends, coupled with Sun's compiler as front end. On the other hand, Java might take off as a general purpose programming language and, if we get a good mapping of Java to ANDF, it might be interesting to build a plain Java producer.
</a>

</ol>
<a name="4017">
These five points can be classified into two different possible uses of the ANDF Technology for Java.<p>
</a>
<a name="4023">
First, ANDF can be used as a portability and distribution tool for Java, which is seen as an application which can be ported to multiple platforms. OSF has already done a number of ports for standard applications, the most recent one being a port of the Linux commands on two different platforms. This includes points (1) and (2) above.<p>
</a>
<a name="4029">
Second, ANDF can be used as a compiler in order to translate the interpreted Java bytecode into native executable code. This could greatly enhance the performance of Java applications, since they could now be executed as native code, instead of being interpreted on the Java abstract machine. This could also be an added-value to ANDF since applications written in Java, of which there is a rapidly increasing number, could now be compiled and installed on a large number of platforms, using the ANDF technology. This includes points (3) to (5) above.<p>
</a>
<a name="4050">
We will now study in detail the possible difficulties and benefits of each of the above mentioned points.<p>
</a>
<a name="4041">
<h1>2. ANDF as a portability tool for Java</h1>
</a>
<a name="4055">
The Java technology was first developed by Sun on a Solaris platform. OSF has ported it to many other platforms. The list of platforms on which Java as been ported by OSF includes the following:<p>
</a>
<TABLE ALIGN="CENTER", BORDER="BORDER">
<TR>
<TD>
<H3>Hardware Platform</H3></TD>
<TD>
<H3>Operating System</H3></TD>
<TR>
<TD>Sparc</TD>
<TD>Solaris</TD>
<TR>
<TD>Intel</TD>
<TD>Unixware</TD><TR>
<TD>Intel</TD>
<TD>NCR/ATT Sys V R4</TD><TR>
<TD>Intel</TD>
<TD>Dascom OSF/1</TD><TR>
<TD>PA RISC</TD>
<TD>HP-UX</TD><TR>
<TD>DEC AXP</TD>
<TD>Digital Unix</TD><TR>
<TD>Mips R4000</TD>
<TD>Sony/NEWS</TD><TR>
<TD>PowerPC</TD>
<TD>Bul/AIX</TD></TR>
</table>
<a name="4061">
<p>
The Java technology contains two main components:<p>
</a>

<ol>
<a name="4062">
<li>A Java runtime, which emulates the Java Virtual machine on a particular platform. This code is written in C, with a few exceptions. It may be possible to use ANDF to port it to multiple platforms, with a few caveats:
</a>

<ul>
<a name="6479">
<li>Multi-threaded libraries and API trapping.<br>The runtime implements its own variation of threads. This raises a number of issues.
</a>
<ul>
<a name="6484">
<li>Implementing user-level multi-threading in a rather portable way on top of mono-threaded Unixes requires some tricks. The issue is to build thread contexts on top of classical Unix data structures. A classical solution is to use a jmp_buf as a thread context, and to use sigsetjmp() &amp; siglongjmp() to switch between threads. In this case, only one unavoidable issue remains: we have to figure out which part of the jmp_buf we need to modify to give the new thread a stack. The only solution here, is to browse through the system include files to find out where the stack pointer lives within the jmp_buf structure.<br>A similar solution can be based on the &lt;ucontext.h&gt; API rather than on &lt;setjmp.h&gt;. It uses the data structure ucontext_t, and the functions setcontext(), getcontext(), makecontext(). This solution is cleaner in some aspects, but the &lt;ucontex.h&gt; API is not yet widely available on the various flavors of Unixes, despite the fact that it is part of XPG/4.2.
</a>
<a name="7655">
<li>The runtime needs to trap a number of I/O calls to interface them with the thread scheduler. The issue is that, if a thread performs an I/O that would block, the scheduler blocks this thread only, and schedules another one. The former one will not be allowed to perform its call until it is certain that the I/O call will be non-blocking (Heavy use of select()).<br>From an API point of view, this means that the runtime provides its own implementation of I/O entry points (to interface with the scheduler), AND at the same time uses the actual entry point in the libc (to do the actual work when it is time to do so).<br>Note also that these new entry points have to be used by the external system libs as well (e.g. libX11 &amp; libXm).<br>This can lead to name conflicts, and each platform provides an ad-hoc workaround for this issue.
</a>
<a name="7668">
<li>A user-level thread package relies heavily on Unix's signals, if only to implement some form of time sharing by means of SIGALRM.<br>As signals is the area where many of the differences between various flavors of Unixes remains, the part of the thread package that deals with them will probably be more mutable than portable in the ANDF sense.
</a>
<a name="6502">
<li>In any case, a reentrant version of the libc is required.
</a>
</ul>
<a name="6737">
<li>On Sun/Sparc, a couple of assembly lines are necessary to ensure that the registers are actually flushed in the memory when context is switched between threads.
</a>
</ul>

<dl>
<a name="6738">
<dt>	 Most of the problems we have experienced do not come from the use of non standard APIs, but rather from the use that is made of those APIs. The threading kernel is based on use of known, but unspecified, API side effects: getcontext(), setcontext(), makecontext(). This is not a problem for ANDF though, which only performs static checks.
</dt>
</dl>
</a>
<a name="4063">
<li>Java classes, which implement tools and libraries for the Java language. Java classes are written in Java itself, with a limited number of methods implemented in C (called ``native methods''). No porting is required for Java code, since it is directly interpreted on the Java abstract machine. The native methods use either entry points from the runtime, or standardized APIs. In the latter case, as for the runtime, they might use the API in unspecified ways.
</a>

</ol>
<a name="4088">
<h2>2.1 Port of the Java Abstract Machine</h2>
</a>
<a name="4092">
Two features on which JAVA is strongly based are ``Shared Libraries'' and ``Dynamic Loading''. However, hardware platforms usually have different ways to handle these features. Solaris, for example, is based on the ELF format, which comes with a set of functions to manipulate the shared libraries. Conversely, HPUX for example, does not support ELF and manipulates shared libraries with a different API. However, these two different implementations provide more or less the same functionalities. This means that it is possible to define an API, based on the ELF one for example, and implement it on a number of platforms by means of ANDF tokens.<p>
</a>
<a name="6362">
<h2>2.2 Port of the Java native library code</h2>
</a>
<a name="6363">
Java libraries are for a large part built with Java code. Some methods in the Java libraries, which compose the Java native library code, are written in C. This code relies heavily on the underlying platform libraries, for graphic display or audio devices.<p>
</a>
<a name="6378">
While in the Unix world, X11 and Motif APIs are well standardized and implemented on all platforms, the graphical interface on Windows NT is completely different. This means that only the external Java API (named AWT) is common to both, but most of the underlying Java classes, and the native code that provide access to the system, is completely different for X11 &amp; Windows NT. ANDF will not be useful in this case.<p>
</a>
<a name="6386">
Interfaces with audio devices are being standardized, but currently, each platform has its own API. In some cases, few modifications are required to port from one platform to another, but in other cases, completely different code has to be developed to interface the Java audio API with the audio device.<p>
</a>
<a name="1966">
<h1>3. ANDF as a compiler for Java</h1>
</a>
<a name="4153">
Java is currently run by means of interpretation of its bytecode. The ANDF compiler, based on the ANDF intermediate language, already supports many platforms, including most of the platforms on which Java has been ported. So, it may be very interesting to try to integrate the two technologies.<p>
</a>
<a name="4283">
<h2>3.1 A compiler for Java</h2>
</a>
<a name="4286">
An interpreted language has usually poor performance, 10 to 100 times slower than compiled code. Interpretation allows wide dissemination since, once the interpreter is ported, a platform can run Java code. The downside is that this comes at the expense of performance, which can only be improved by means of compilation.<p>
</a>
<a name="4322">
Translation of the Java bytecode to ANDF is a solution. Another solution would be to directly translate Java source code into ANDF, using an ANDF Java producer. Such a producer could be derived from a C++ producer, since Java and C++ are quite close.<p>
</a>
<a name="4654">
There are different possibilities for integrating Java and ANDF together. It may be possible to compile with the ANDF compiler parts of the Java runtime libraries. Also, applications written in Java code could be, partially or totally, compiled into executable code with the ANDF compiler. In any case, this means that interpreted Java bytecode and compiled code will have to work together. Compilation of Java bytecode will thus have to solve the two following problems:<p>
</a>

<ul>
<a name="4684">
<li>How can the interpreter and the compiled code work together?
</a>
<a name="5729">
<li>How can Java semantics be expressed in ANDF?
</a>

</ul>
<a name="4323">
<h2>3.2 Main features of the Java language</h2>
</a>
<a name="4355">
<i>Security</i>
</a>
<a name="4358">
<p>
Java has been designed with security as a key feature, since executing code in the user environment must not give access to, nor damage, unrelated user data.<p>
</a>
<a name="4365">
Before interpreting Java bytecode, the interpreter runs a Java bytecode verifier, which is a static bytecode analyzer. First, it checks that the bytecode is well formed, that it only contains valid references to objects, fields and methods, and that variables are all initialized. In addition, the Java bytecode contains all the information for strong type checking. Stack operations are also analyzed in order to check that the stack will not underflow or overflow.<p>
</a>
<a name="4390">
During execution of the code, the interpreter also checks for array out of bounds accesses, and detects memory or stack exceptions. As a way to improve security of the code, pointers have been removed from the language. In this way, pointer forging, unlike other languages, is impossible.<p>
</a>
<a name="4403">
<i>Garbage collector</i>
</a>
<a name="4406">
<p>
Memory leaks or access to dangling references are a frequent source of bugs in applications, and may result in catastrophic behaviour. To free the programmer from memory deallocation, Java uses a garbage collector which is responsible for memory operations on allocation and deallocation. A `new' operation is used to allocate memory for an object, while cycles of the garbage collector will reclaim memory when all references have gone. A garbage collector mechanism imposes some constraints on memory access.<p>
</a>
<a name="4745">
<i>Stack based</i>
</a>
<a name="5730">
<p>
Each Java thread has its own stack which is used as a usual execution stack: to push frame invocations, locals, etc. When the stack overflows, an exception is raised.<p>
</a>
<a name="4455">
<i>Exceptions</i>
</a>
<a name="4474">
<p>
The Java language supports an exception mechanism. Java exceptions are objects which can be raised by the runtime, or by the user with a `throw' instruction. When an exception is raised, the execution of the method stops, and resumes at the first catch statement, going up in the calling stack, that matches the exception class or a parent of the exception class.<p>
</a>
<a name="4489">
<i>Concurrency</i>
</a>
<a name="4498">
<p>
Methods or blocks can be synchronized, which consists in acquiring a monitor, on an object or a class, for the time of the execution.<p>
</a>
<a name="4509">
User threads are also provided, by a Thread class, to express concurrent programming.<p>
</a>
<a name="4515">
<i>Dynamic loading</i>
</a>
<a name="4353">
<p>
Java bytecode, either from local libraries or a distant network application, is dynamically linked.<p>
</a>
<a name="4553">
<h2>3.3 Java compiler and Java interpreter interactions</h2>
</a>
<a name="4709">
Before analysing the mapping between Java bytecode and ANDF constructs, we studied the relationship between the Java runtime and compilation of bytecode. The following paragraphs describe the most critical issues.<p>
</a>
<a name="4555">
<i>The Java runtime &amp; compiled bytecode</i>
</a>
<a name="4750">
<p>
The bare concepts of Java (stack based, threads &amp; synchronisation, exception, GC, dynamic loading) could be implemented by a runtime in a number of ways. The incarnation of these concepts in a particular implementation are specific to the runtime e.g. how do exceptions traverse the stack? Other software modules have attendant constraints, e.g. X11/Motif on Unixes imposes a certain style of application coding.<p>
</a>
<a name="4335">
Thus, compiling Java bytecode requires knowledge about the internal data structures of the runtime in which the object code will be executed. It also requires knowledge of how these structures are expected to be used. If nothing else, the compiled code must have some idea about the layout of an object, how to call its methods, and how to get a new one from the GC.<p>
</a>
<a name="4812">
<i>Sharing data between the interpreter and compiled code.</i>
</a>
<a name="6837">
<p>
Accessing a field, data or method, in an object requires some precise knowledge of the runtime. Actually, it may be possible to access a field from its position in the class declaration, or it may be necessary to access it by its name only, which allows for field reordering.<p>
</a>
<a name="7332">
Java bytecode downloaded from a Java class file or through the net accesses a field with opcodes that refer to its name. When the interpreter runs into these opcodes for the first time, it does a lookup in the symbol table, downloads the target class if needed, and computes a definitive offset from that. In Sun's Java runtime, an optimization is done at this point, which modifies the bytecode to use special opcodes that will now refer to fields by their offsets instead of their names. This means that the compiler will have to act somewhat differently depending on when the compilation occurs.<p>
</a>
<a name="5128">
We also need to have access to the information on the object class and class hierarchy. This information is used by some Java bytecode instructions, such as checkcast, instanceof, and by the interpreter when it resolves dynamic binding when calling abstract methods. Also, in case of abstract methods, the compiled code must obey the same dispatch protocol as the interpreter. This requires the compiler to have an extensive knowledge of the method tables used by the interpreter.<p>
</a>
<a name="4983">
In Java, objects are managed by a Garbage Collector. This means that compiled code must be aware of some of the characteristics of the GC:<p>
</a>
<ul>
<a name="4989">
<li>What is an object reference?<br>Depending on the GC, it may be directly a pointer to the object, or a handle.
</a>
<a name="4994">
<li>How do we ask the GC for a new Object?<br>Some GCs may only need the size of the object, but others may require the type to do some internal bookkeeping.
</a>
<a name="4995">
<li>How do we ask the GC for a new Table of Objects?
</a>
<a name="4996">
<li>Integration of finalization with the GC - how should this be done?
</a>
<a name="4997">
<li>What is considered to be a root pointer by the GC?
</a>
<a name="4999">
<li>Does the GC move objects to compact memory?<br>If a GC does so, short-cuts to access an object are no longer valid after a cycle of the GC.
</a>
<a name="5108">
<li>Does the GC run asynchronously?
</a>
</ul>
<a name="5022">
If our objective is to compile code compatible with Sun's runtime, then many of the points raised above can already be answered precisely, but this require knowledge of the internals of Sun's implementation of the Java runtime.<p>
</a>
<a name="4855">
The careful use of ANDF tokens in the definition of this API can provide a convenient solution to this issue. However, the resulting token library may be somewhat different from those we are used to: the resulting set of tokens, will probably be at a much higher level than those obtained from a C API abstraction.<p>
</a>
<a name="7730">
To illustrate what is involved, we can list a set of tokens which are required by the compiler for the runtime to interface the GC and the compiled code.<p>
</a>
<ul>
<ul>
<a name="4851">
<li>A SHAPE token named ``handle'' which is the type of variables used to identify an object.
</a>
<a name="7739">
<li>A SHAPE token named ``method'' which is the type for description of a method.
</a>
<a name="7741">
<li>An EXP token named ``ishandle'' which takes a pointer as parameter, and returns a value to say whether or not the pointer is a valid reference to an object.
</a>
<a name="7743">
<li>An EXP token named ``unhand'' which takes a handle value as parameter, and returns the actual memory location of the object.
</a>
<a name="7745">
<li>An EXP token named ``objmethods'' which takes a handle value as parameter, and returns the method table of the object.
</a>
<a name="7747">
<li>An EXP token named ``callmethod'', which takes an object, a method table, and a method index as parameters, and calls the method on the object.
</a>
<a name="7876">
<li>An EXP token named ``allocobject'' which takes a size as parameter and allocates a new object and returns a handle value to it.
</a>
</ul>
</ul>
<a name="7878">
<i>Managing the Java stacks.</i>
</a>
<a name="7877">
<p>
The compiled code needs to have a handle on the Java stack: it needs to push/pop data on it, increment/decrement its stack pointer, etc. If nothing else, it needs to know the alignment constraints (16, 32 or 64 bits?), its granularity (word, double word?), and its direction of growth (upwards, downwards?).<p>
</a>
<a name="4823">
<i>Calling methods between compiled code and the interpreter.</i>
</a>
<a name="4813">
<p>
Integration of the Java interpreter with compiled Java code requires that methods can be called between interpreted and compiled code. But we need also to be able to access the code of the method, which in case of abstract methods, may not be obvious. Before any function can be called, we must be able to choose which function must be actually called.<p>
</a>
<a name="4871">
First, let's see how compiled code could be called from interpreted code.<p>
</a>
<a name="4877">
The current runtime from Sun already supports a special sort of native code: native methods. These methods are qualified with the keyword native in the Java source file, as for this example from the class java.lang.Thread:<p>
</a>
<a name="4872">
<pre>public static native Thread currentThread();
</pre>
</a>
<a name="4873">
These methods will not have any bytecode attached to them, and the interpreter expects to find in the runtime (in this case) or in a shared library (as for the AWT library) a C function named<p>
</a>
<a name="4874">
<pre>java_lang_Thread_currentThread().
</pre>
</a>
<a name="4875">
So it may be a good idea to try to implement compilation of methods by pretending that they are in fact native methods. This may be the scenario that would require the minimum modifications in the runtime to support code compilation.<p>
</a>
<a name="4878">
The current Sun implementation uses a stub to interface between Java bytecode and native methods. This stub is automatically generated by a tool `javah', from a specification of the interface. In this stub, data from the Java stack is passed to the native method, and when the method returns, its result, if any, is pushed onto the Java stack. We could make this stub part of the calling convention between java bytecode and native method, or another way to say it is to inline the native method code into the stub.<p>
</a>
<a name="4892">
Compiled code must also be able to call interpreted Java bytecode.<p>
</a>
<a name="4876">
Sun's Java runtime also supports calls to the Java interpreter from a native method. This mechanism is typically used by X11/Motif callbacks, which are written in Java bytecode and called by the X11/Motif libraries. In this case, a recursive call to the Java interpreter is performed.<p>
</a>
<a name="4897">
A special entry point in the interpreter is used, which pushes onto the Java stack the arguments it is called with, and starts interpreting the Java bytecode. When the interpretation ends, controls return to the calling procedure, passing the result of the method if needed.<p>
</a>
<a name="4900">
<i>Exceptions</i>
</a>
<a name="4898">
<p>
In Java, some exceptions may be raised, as a result of an exceptional behavior detected by the runtime, as a result of calling a Java library which raises an exception, or by the application itself. An exception can be caught in the method where it has been raised, or it will be passed up through the stack of method calls, until a catch statement for it is found.<p>
</a>
<a name="4917">
Currently, in Sun' runtime, exceptions can not pass between interpreted and compiled code, in either direction. Exception handling is usually handled through non local gotos, which is not the case for Sun's runtime. So we need to accommodate this to be able to compile code that uses try/catch/raise.<p>
</a>
<a name="4814">
<i>Security</i>
</a>
<a name="4755">
<p>
Compilation of Java bytecode must result in an executable code as safe as the interpreted bytecode.<p>
</a>
<a name="4783">
When loading Java bytecode, and before executing it, the interpreter performs many static checks on the bytecode, such as type checking or variable initialization. In case of compilation of this bytecode, we must ensure that these checks are run before any treatment starts. This will respect the Java semantics, and will also facilitate the compilation of the code, since the code will be guaranteed to be correct.<p>
</a>
<a name="4788">
During the interpretation of the bytecode, other checks, such as array access out of bounds, stack or memory exceptions, are performed. All of these checks must also be performed by the compiled code. In fact, the API needed for data access can be used here, with some extensions for points such as memory allocation.<p>
</a>
<a name="5173">
<i>Compilable code</i>
</a>
<a name="5171">
<p>
Not any random bytecode is actually compilable. One of the rules to compile code, is that the size of the stack used by the compiled code (the frame size) should be predictable from the text of the source code (here the bytecode). In other words, the SP should point to the same address just after a method call as it did just before. This is not true in general for random bytecode, but is true for code that has passed the bytecode verifier.<p>
</a>
<a name="7244">
<i>When to compile the bytecode?</i>
</a>
<a name="7242">
<p>
When the bytecode is downloaded, it goes through a number of checks and modifications, including some at execution time. With regard to this, and as the compiled code has to behave as if it was interpreted, when is it actually possible to compile it?<p>
</a>
<a name="7250">
	- When we download the class?<br>	- When we have checked it?<br>	- Before any execution?<br>	- At any time?<p>
</a>
<a name="7273">
In Sun Java runtime, the code is self-modified at run time during its first execution. At that point, logical references to methods and attribute names are resolved into actual offsets by a lookup into the runtime symbol table. If the referenced class is not currently available in the symbol table, it is fetched, possibly over the network.<p>
</a>
<a name="7276">
This means that, when we compile code, we need to be sure that the information that we get from the symbol table is the same as that which would have been obtained at first execution time.<p>
</a>
<a name="7278">
This might turn out to be difficult to achieve, and we will have to make a trade-off between compilation and 100% emulation of the interpreter.<p>
</a>
<a name="7274">
<h2>3.4 Java bytecode to ANDF mapping</h2>
</a>
<a name="7275">
The Java bytecode is an intermediate language for the Java language, which takes many features from C++. C++ is just one of the HLL language for which a producer to ANDF exists, others are C, Fortran and ADA. Thus, ANDF should have all, or nearly all, the capabilities to encompass the semantics of the Java language. Moreover, in case the semantics can not be exactly described in ANDF, a powerful token mechanism can be used to extend the language.<p>
</a>
<a name="5349">
<i>Data types</i>
</a>
<a name="5184">
<p>
Java has several fixed data types. Their representation does not depend on the underlying hardware. Data types are:<p>
</a>
<ul>
<a name="5185">
<li>byte	// 1-byte signed 2's complement integer
</a>
<a name="5188">
<li>short	// 2-byte signed 2's complement integer
</a>
<a name="5190">
<li>int	// 4-byte signed 2's complement integer
</a>
<a name="5191">
<li>long	// 8-byte signed 2's complement integer
</a>
<a name="5203">
<li>float	// 4-byte IEEE 754 single-precision float
</a>
<a name="5204">
<li>double	// 8-byte IEEE 754 double-precision float
</a>
<a name="5205">
<li>char	// 2-byte unsigned Unicode character
</a>
<a name="5222">
<li>object	// 4-byte reference to a Java object
</a>
<a name="5223">
<li>returnAddress	// 4-bytes, used for return instructions
</a>
</ul>
<a name="5187">
There is no boolean type. Integer operations are used to operate on boolean values, and byte arrays are used for arrays of boolean.<p>
</a>
<a name="5186">
There is no problem representing these types in ANDF. However, an ANDF installer can allocate more space than is required for a data type, i.e. a 4-byte space for a 1-byte type. We must be careful about this and examine the problems this may cause.<p>
</a>
<a name="5355">
<i>Java execution spaces</i>
</a>
<a name="5179">
<p>
When executing the bytecode for a method, the following spaces are allocated:<p>
</a>
<ul>
<a name="5230">
<li>a set of local variables
</a>
<a name="5231">
<li>an operand stack
</a>
<a name="5232">
<li>an execution environment structure
</a>
</ul>
<a name="4180">
local variables are all 32 bits wide, long integers and double precision floats take up two local variables.<p>
</a>
<a name="5245">
The Java bytecode instructions all take operands from an operand stack, operate on them, and return results to the stack. The operand stack is 32 bits wide, each operand requires a single location, except for long and double, which require two locations. Each primitive data type has specialized instructions that know how to operate on operands of that type.<p>
</a>
<a name="5260">
The execution environment structure is used to do dynamic linking, normal method returns and exception propagation.<p>
</a>
<a name="5264">
<i>The Java Instruction Set</i>
</a>
<a name="5267">
<p>
An instruction of the Java Instruction Set consists of a one-byte opcode specifying the operation to be performed, and zero or more operands supplying parameters or data that will be used by the operation.<p>
</a>
<a name="5308">
The Java Instruction Set comprises the following subsets of instructions:<p>
</a>
<ul>
<a name="5309">
<li>Constant, Load and Store Instructions
</a>
<a name="5310">
<li>Wider index for Loading, Storing and Incrementing
</a>
<a name="5275">
<li>Managing Arrays
</a>
<a name="5276">
<li>Stack Instructions
</a>
<a name="5277">
<li>Arithmetic and Logical Instructions
</a>
<a name="5279">
<li>Basic Type Conversions
</a>
<a name="5280">
<li>Control Transfer Instructions
</a>
<a name="5281">
<li>Function Return
</a>
<a name="5282">
<li>Table Jumping
</a>
<a name="5283">
<li>Manipulating Object Fields
</a>
<a name="5284">
<li>Method Invocation
</a>
<a name="5285">
<li>Exception Handling
</a>
<a name="5286">
<li>Miscellaneous Object Operations
</a>
<a name="5287">
<li>Monitors
</a>
</ul>
<a name="5704">
Before going through this list of subsets to examine the mapping with ANDF, we will give a quick description of the information which comes with the bytecode in a Java class file.<p>
</a>
<a name="5385">
<i>Java class file</i>
</a>
<a name="5386">
<p>
A Java class file contains a description of the class, fields and methods it represents.<p>
</a>
<a name="5392">
One important item in this description is the constant pool, a table of values, which contains the various string constants, class names, field names, and others that are referred to by the class description or by the bytecode.<p>
</a>
<a name="5393">
The bytecode for the methods is embedded with the description of the methods of the class.<p>
</a>
<a name="6876">
<i>Java stack to ANDF tree</i>
</a>
<a name="6874">
<p>
Java bytecode is a stack based language, while ANDF is a tree based language, so we can translate from Java bytecode form to ANDF by a simple walk over (or pseudo interpretation of) the Java bytecode.<p>
</a>
<a name="6879">
The general scheme for translating Java bytecode to ANDF is to split the bytecode into sections that correspond to the computation of a single expression. Then the corresponding ANDF can be built by a simple pseudo interpretation of each such sections. The temporary storage of sub expressions within the stack simply disappear in the ANDF tree. E.g. the following piece of bytecode:<p>
</a>
<pre>
		iload a
		iconst_2
		iadd	// Yield a+2
		iconst_3
		imul	// Yield (a+2)*3
</pre>
<a name="7072">
is translated in ANDF to:<p>
</a>
<a name="7105">
<pre>( mult
	( plus
		( contents ( obtain_tag a ) )
		( make_int 2 ) )
	( make_int 3 ) )
</pre>
</a>
<a name="7136">
<pre>
</pre>
</a>
<a name="7135">
This example shows that in many cases, translation from Java bytecode to ANDF will be straightforward. We will now analyze all of the Java bytecode instructions and see how they translate into ANDF.<p>
</a>
<a name="7074">
<i>Constant, Load and Store Instructions</i>
</a>
<a name="6891">
<p>
These instructions consist in pushing constant values or local variables onto the stack and storing stack values into local variables. Each instruction operates on a specific data type.<p>
</a>
<a name="5454">
<pre><b>    bipush, sipush, ldc1, ldc2, ldc2w, aconst_null, iconst_m1,
<br>    iconst_&lt;n&gt;, lconst_&lt;l&gt;, fconst_&lt;f&gt;, dconst_&lt;d&gt;
</b></pre>
</a>
<a name="5342">
Pushing a constant value onto the stack will translate into ANDF to a make_int or make_floating construct. There are also instructions to push values from the constant pool, and in particular string constants, which will translate in this case into ANDF to a make_string construct.<p>
</a>
<a name="5455">
<pre><b>    iload, iload_&lt;n&gt;, lload, lload_&lt;n&gt;, fload, fload_&lt;n&gt;, dload,
<br>    dload_&lt;n&gt;, aload, aload_&lt;n&gt;, istore, istore_&lt;n&gt;, lstore, lstore_&lt;n&gt;, 
<br>    fstore, fstore_&lt;n&gt;, dstore, dstore_&lt;n&gt;, astore, astore_&lt;n&gt;
</b></pre>
</a>
<a name="5402">
Pushing a local variable onto the stack will translate into ANDF to a contents construct. Storing a stack value into a local variable will translate into ANDF to a assign construct<p>
</a>
<a name="5406">
When loading or storing an object reference, it may be useful to use the transfer_mode volatile, to prevent any optimization, in case the Garbage Collector has moved the object.<p>
</a>
<a name="5456">
<pre><b>    iinc
</b></pre>
</a>
<a name="5343">
This operation increments an integer local variable by a constant. This instruction will translate into ANDF to:<p>
</a>
<a name="5411">
<pre>( identify T_LV
	( contents ( integer VR ) ( obtain_tag LV) )
	( assign
		( obtain_tag LV )
		( plus
			( obtain_tag T_LV )
			( make_int VR Const ) ) ) )
</pre>
</a>
<a name="5446">
<i>Wider index for Loading, Storing and Incrementing</i>
</a>
<a name="5449">
<pre><b>    wide
</b></pre>
</a>
<a name="5296">
This instruction must precede one of the above constructs operating on local variables. Its purpose is to extend the index of the local variable given with the following bytecode. This instruction will translate to nothing in ANDF.<p>
</a>
<a name="5462">
<i>Managing Arrays</i>
</a>
<a name="5463">
<pre><b>   newarray, anewarray, multianewarray
</b></pre>
</a>
<a name="5478">
Java supports single dimension arrays of basic types, objects, and arrays, for which space is allocated at exec time using these bytecodes. Since memory allocation must be managed through the Garbage Collector, a special entry point in the Java runtime must be called to perform these operations.<p>
</a>
<a name="5494">
<pre><b>    arraylength
</b></pre>
</a>
<a name="5503">
Arrays are dynamically allocated at execution time, so arraylength cannot be computed at compile time, unless we do complex optimization to detect constant sizes. An array object contains a field giving its actual length. Compilation of this bytecode will require knowledge about the runtime representation of an array since the length of an array is stored within the array object.<p>
</a>
<a name="5504">
<pre><b>    iaload, laload, faload, daload, aaload, baload, caload, saload, 
<br>    iastore, lastore, fastore, dastore, aastore, bastore, castore, sastore
</b></pre>
</a>
<a name="5466">
These instructions load or store an array element. They will translate into ANDF to contents or assign constructs, and using offset_mult to compute the address of the element to access.<p>
</a>
<a name="5524">
The transfer_mode trap_on_nil may be required on the assign and contents ANDF constructs, or specific code should be added, since an exception must be thrown if the array address is null. Exceptions must also be thrown if the index is out of the bounds of the array, so, requiring some code to check this.<p>
</a>
<a name="5522">
<i>Stack Instructions</i>
</a>
<a name="5526">
<pre><b>    nop
</b></pre>
</a>
<a name="5528">
This instruction will translate to nothing into ANDF.<p>
</a>
<a name="5527">
<pre><b>    pop, pop2
</b></pre>
</a>
<a name="5529">
These instructions will usually have the effect of discarding the result of the previous operation. So, no ANDF code will be required for these instructions.<p>
</a>
<a name="5530">
<pre><b>    dup, dup2, dup_x1, dup2_x1, dup_x2, dup2_x2
</b></pre>
</a>
<a name="5534">
These instructions duplicate some item onto the stack. They will in most cases result in ANDF in a identify construct, to keep a value and use it later. Consider the code below:<p>
</a>
<a name="7094">
<pre>		iload a
		ldc 2
		iadd
		dup
		ldc 3
		imult
		istore b	// Store 3(a+2) in b
		istore c	// Store a+2 in c
</pre>
</a>
<a name="7102">
This code will translate into ANDF to:<p>
</a>
<a name="7141">
<pre>( identify temp
	( plus
		( contents ( obtain_tag a ) )
		( make_int 2 ) )
	( sequence
		( assign
			( obtain_tag b )
			( mult
				( obtain_tag temp )
				( make_int 3 ) ) )
		( assign
			( obtain_tag c )
			( obtain_tag temp ) ) ) )
</pre>
</a>
<a name="7184">
<p>
</a>
<a name="7202">
With the opcode dup2, the issue is more tricky:<br>	(1) Are we duplicating a 64 bit entity that takes two stack slots?<br>or<br>	(2) Are we duplicating two separate entities in a single shot?<p>
</a>
<a name="7162">
For the first case, we can use the same scheme as above with sequence and identify, with the modification that the identify will denote a 64 bits entity. For the second case, this can also be translated in a sequence and a number of identify to reorder the expressions.<p>
</a>
<a name="7219">
The issue here is, how do we decide that we are in either (1) or (2)?. Actually we will need help from the bytecode verifier, that knows to which kind of data the dup2 applies (a single 64 bit entity or a pair of 32 bit entities).<p>
</a>
<a name="5535">
<pre><b>    swap
</b></pre>
</a>
<a name="5551">
This instruction swaps the top two elements on the stack. It will result in ANDF in reordering some expression evaluation, and may require the use of an identify construct in some cases.<p>
</a>
<a name="5554">
<i>Arithmetic and Logical Instructions</i>
</a>
<a name="5558">
<pre><b>    iadd, ladd, fadd, dadd, isub, lsub, fsub, dsub, imul, lmul, fmul, dmul, 
<br>    idiv, ldiv, fdiv, ddiv, irem, lrem, frem, drem, ineg, lneg, fneg, dneg,
<br>    ishl, ishr, iushr, lshl, lshr, lushr, iand, land, ior, lor, ixor, lxor
</b></pre>
</a>
<a name="5562">
These instructions will translate into ANDF to plus, minus, mult, div, rem, negate, shift_left, shift_right, and, or and xor constructs.<p>
</a>
<a name="5563">
The result of the integer div operation in Java is truncated towards zero. The integer division provided in ANDF does not behave this way, so some code will have to be added to perform the correct division. The rem operation in Java, either on integers or floatings, is not, as far as we know, clearly specified.<p>
</a>
<a name="5567">
The shr Java operation will translate into the ANDF shift_right construct, working on signed integers. The ushr Java operation will translate into the ANDF shift_right construct, after a change_variety to an unsigned integer variety has been applied to its operand.<p>
</a>
<a name="5610">
<i>Basic Type Conversions</i>
</a>
<a name="5613">
<pre><b>    i2l, i2f, i2d, l2i, l2f, l2d, f2i, f2l, f2d, d2i, d2l, d2f, int2byte, int2char, 
<br>    int2short
</b></pre>
</a>
<a name="5614">
These instructions will translate into ANDF to change_integer_variety, change_floating_variety, float_int and round_with_mode.<p>
</a>
<a name="5618">
<i>Control Transfer Instructions</i>
</a>
<a name="5625">
<pre><b>    ifeq, ifnull, iflt, ifle, ifne, ifnonnull, ifgt, ifge, if_icmpeq, if_icmpne, 
<br>    if_icmplt, if_icmpgt, if_icmple, if_icmpge, lcmp, fcmpl, fcmpg, 
<br>    dcmpl, dcmpg, if_acmpeg, if_acmpne
</b></pre>
</a>
<a name="5629">
These instructions will translate into ANDF to the integer_test and floating_test constructs, in combination with the various NTEST constructs. A labelled or conditional will be used to introduce the branch label.<p>
</a>
<a name="5627">
<pre><b>    goto, goto_w
</b></pre>
</a>
<a name="5638">
These instructions will translate into ANDF to the goto construct. A label will have to be associated with the destination of the jump, using a labelled construct. This will most likely require some reordering of the code.<p>
</a>
<a name="5636">
<pre><b>    jsr, jsr_w, ret, ret_w
</b></pre>
</a>
<a name="5626">
These instructions will translate into ANDF to the apply_proc and return constructs. However, since no parameter is passed on the call, and no return value is available at the end of the call, a simplified implementation may be possible.<p>
</a>
<a name="5641">
<i>Function Return</i>
</a>
<a name="5644">
<pre><b>    ireturn, lreturn, freturn, dreturn, areturn, return
</b></pre>
</a>
<a name="5647">
These instructions will translate into ANDF to the return construct. No particular problem is expected with these instructions.<p>
</a>
<a name="5654">
<pre><b>    breakpoint
</b></pre>
</a>
<a name="5665">
Our understanding of the Java interpreter is that this construct is rejected by the bytecode verifier. So, this bytecode should not appear in code subject to translation into ANDF. A deeper analysis of the interpreter will be needed to solve completely this issue.<p>
</a>
<a name="5669">
<i>Table Jumping</i>
</a>
<a name="5671">
<pre><b>    tableswitch, lookupswitch
</b></pre>
</a>
<a name="5672">
These instructions will translate into ANDF to a case construct within a labelled construct.<p>
</a>
<a name="5675">
<i>Manipulating Object Fields</i>
</a>
<a name="5676">
<pre><b>    putfield, getfield, putstatic, getstatic
</b></pre>
</a>
<a name="5679">
These instructions set or get values from an object or a class field. The argument to these operators is the name of the field to access, which must be resolved to an offset into the object or the class. A special entry point in the Java runtime will be required to compute this offset. <p>
</a>
<a name="5682">
<i>Method Invocation</i>
</a>
<a name="5685">
<pre><b>    invokevirtual, invokenonvirtual, invokestatic, invokeinterface
</b></pre>
</a>
<a name="5686">
When invoking a method, we first have to know which method to call. The resolution, except for invokenonvirtual, will require some knowledge of the current object. Once the method has been found, the way to call it will depend on whether the method has to be interpreted or has been compiled into native executable code. This could be done by adding one more parameters (the method descriptor) to each method call.<p>
</a>
<a name="5692">
<i>Exception Handling</i>
</a>
<a name="5695">
<pre><b>    athrow
</b></pre>
</a>
<a name="5696">
This instruction has no equivalent in ANDF. A mechanism based on long_jump to search a handler for an exception will have to be designed. However, the interface between compiled and interpreted bytecode must be carefully handled.<p>
</a>
<a name="5693">
<i>Miscellaneous Object Operations</i>
</a>
<a name="5697">
<pre><b>    new, checkcast, instanceof
</b></pre>
</a>
<a name="5698">
Special entry points in the Java runtime will be required to implement these functions.<p>
</a>
<a name="5694">
<i>Monitors</i>
</a>
<a name="5690">
<pre><b>    monitorenter, monitorexit
</b></pre>
</a>
<a name="5703">
Special entry points in the Java runtime will be required to implement these functions.<p>
</a>
<a name="5771">
<h2>3.5 Java to ANDF producer</h2>
</a>
<a name="5773">
A Java to ANDF producer is not much different from a java bytecode to ANDF translator. In fact, if we know how to translate Java bytecode to ANDF, we are not far from being able to produce ANDF directly from Java source code. Since Java and C++ are very similar, a Java producer could be derived from a C++ producer, which DRA is currently working on.<p>
</a>
<a name="5772">
<h2>3.6 ANDF-ANDF optimiser, based on profiling information</h2>
</a>
<a name="5782">
Such a tool is not specially related to Java/ANDF work. Of course, it would be very interesting, when we have a Java compiler based on ANDF, to optimize the code using profiling information, in order to run faster applications over the internet. However, current performance obtain with the Java interpreter is already acceptable in most cases, and compiled code will already improve it significantly. So, we think that such a tool is not a priority for now.<p>
</a>
<a name="5721">
<h1>4. Conclusion</h1>
</a>
<a name="7421">
In this paper, we have studied the possible use of ANDF with Java, which we classified into two different approaches.<p>
</a>
<a name="7422">
First, ANDF can be used as a portability tool for Java. The analysis of the Sun implementation shows that the Java runtime and Java native library code have strong dependencies on the underlying hardware. This will require a careful design and implementation of tokens to provide a common API on every platform. In addition, there are large differences between platforms, such as Unix and Windows NT, for which ANDF offers no solution.<p>
</a>
<a name="5745">
Second, ANDF can be used as a compiler, in order to produce executable code from Java bytecode. Java bytecode and ANDF are very similar, and a precise mapping of most of Java bytecode to ANDF is given in this study. We also analyzed the difficulties of running compiled code with interpreted bytecode. This will require that an API to access some Java runtime services be defined, and ensuring that generated code does not break rules imposed by the interpreter. Designing a Java to ANDF producer should also be possible, based on the fact that Java and C++ are closely related. On the other hand, an ANDF to ANDF optimiser based on profiling information does not seem a priority now for the Java technology.<p>
</a>
<a name="6469">
As a result of this study, it seems that a Java bytecode to ANDF translator is the most interesting use of ANDF with Java. The mapping between Java bytecode and ANDF is in most cases straightforward. However, the issues relative to integration of compiled code with interpreted bytecode will probably not be so easy.<p>
</a>
<a name="362">
<pre>
</pre>
<h1>Bibliography</h1>
</a>
<dl compact>
<a name="354">
<dt>[1]
<dd>James Loveluck, Christian Fabre, <i>Proposal for an Extension
to DRA Contract MAL1a/0541: Distribution and Support Service for the DRA TDF/ANDF Technology</i>, December 1995
</p>
</a>
<a name="3010">
<dt>[2]
<dd>SunSoft <i>The Java Language Specification</i>, version 1.0 Beta. October 30, 1995.
</p>
</a>
<a name="6086">
<dt>[3]
<dd>SunSoft <i>The Java Virtual Machine Specification</i> release 1.0 Beta. August 21, 1995.
</p>
</a>

<p><hr>

<h5>Last Modified: 10:13pm , January 01, 1997</h5>
</body>
</html>





<!--
     FILE ARCHIVED ON 7:41:02 Jan 28, 1998 AND RETRIEVED FROM THE
     INTERNET ARCHIVE ON 11:42:12 Nov 9, 2015.
     JAVASCRIPT APPENDED BY WAYBACK MACHINE, COPYRIGHT INTERNET ARCHIVE.

     ALL OTHER CONTENT MAY ALSO BE PROTECTED BY COPYRIGHT (17 U.S.C.
     SECTION 108(a)(3)).
-->
