<?xml version="1.0"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
	"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">

<chapter>
	<title id="wbS115">Symbol Table Dump</title>

	<para>Tchk produces an extra output file, called a dump output file, for
		each translation unit processed. This file is in the form given by the
		symbol table output specification in Annex E, and contains information
		about the objects declared, defined or used within an application. Each
		object encountered during processing is assigned a unique reference
		number allowing uses of the object to be traced back to the declaration
		and definition of the object.</para>

	<para>In the default mode only external declaration and definition
		information is written to each dump file. The amount of information
		output may be increased by passing the <code>-sym[cehklsu]</code>
		command line option to tchk. Any combination of the optional flags
		enclosed by <code>[]</code> may be used and the effect of each flag is
		described below:</para>

	<itemizedlist>
		<listitem>
			<para><code>no</code> flags external declarations, definitions only;</para>
		</listitem>
		<listitem>
			<para><code>c</code> string and character literals output;</para>
		</listitem>
		<listitem>
			<para><code>e</code> errors incorporated into dump output;</para>
		</listitem>
		<listitem>
			<para><code>e_only</code> only errors output;</para>
		</listitem>
		<listitem>
			<para><code>h</code> included headers output;</para>
		</listitem>
		<listitem>
			<para><code>k</code> keywords output;</para>
		</listitem>
		<listitem>
			<para><code>l</code> local variables output;</para>
		</listitem>
		<listitem>
			<para><code>s</code> scopes output;</para>
		</listitem>
		<listitem>
			<para><code>u</code> variable usage output.</para>
		</listitem>
	</itemizedlist>

	<para>The dump information is currently used for four main purposes:
		detecting included header files from which nothing is used within the
		translation unit; production of lint-like error output; API usage
		analysis and type checking between translation units.</para>

	<section>
		<title id="wbS115">Unused headers</title>

		<para>Header files which are included but from which nothing is used
			within the other source files comprising the translation unit,
			might just as well not have been included. Tchk can detect top
			level include files which are unnecessary, by analysing the dump
			output for the file. This check is enabled by passing the
			<code>-Wd,-H</code> command line flag to tchk. Errors are written
			to stderr in a simple ascii form by default, or to the unified
			dump file in dump format if the <code>-D</code> command line
			option is used.</para>
	</section>

	<section>
		<title id="wbS115">Error processing</title>

		<para>By default the error messages generated by the checker are
			written in a simple ascii form to stderr. If instead, the errors
			are written to the dump file using the <code>-sym:e</code> option
			mentioned above, an alternative lint-like error output may be
			generated by processing the dump files. The lint-like errors are
			enabled by passing the <code>-Ycompact</code> flag to tchk.</para>
	</section>

	<section>
		<title id="wbS115">API usage analysis</title>

		<para>Analysis performed on the set of dump files produced for an
			entire application can detect the objects, types, etc. from
			external APIs which are used by the application. The API usage
			analysis is enabled by passing one or more
			<code>-api_check<emphasis>API</emphasis></code> flags to tchk
			where <emphasis>API</emphasis> may be any of the standard APIs
			listed in section 2.1.
			The <code>-api_check_out<emphasis>FILE</emphasis></code> flag
			may be used to direct the API analysis information to the file
			<emphasis>FILE</emphasis> (by default it is written to stdout).
			The APIs used to perform API usage analysis may be different
			from those used to process the application. Annex G.8 contains
			details of the methods used to perform the API usage analysis.</para>
	</section>

	<section>
		<title id="wbS115">Intermodular checks</title>

		<para>All the checks discussed in earlier chapters have been concerned
			with a single source file. However, tchk also contains a linking
			phase in which it is able to perform intermodular checks (i.e.
			checks between source files). In the linking phase, the dumps file
			generated from each translation unit processed are combined into a
			single dump file containing information on all external objects
			within the application, and type consistency checks are applied to
			ensure that the definitions and declarations of each object are
			consistent and external objects and functions have at most one
			definition.</para>

		<para>The amount of information about an object stored in a dump file
			depends on the compilation mode used to produce that file. For
			example, if extra prototype checks are enabled (see section 3.3),
			the dump file contains any information inferred about a function
			from its traditional style definition or from applications of that
			function. For example, if one file contains:</para>

		<programlisting language="C">
extern void f () ;
void g ()
{
	f ( "hello" ) ;
}</programlisting>

		<para>and another contained:</para>

		<programlisting language="C">
void f ( n )
int n ;
{
	return ;
}</programlisting>

		<para>then the inferred prototype:</para>

		<programlisting language="C">void f WEAK ( char * ) ;</programlisting>

		<para>from the call of <code>f</code> would be included in the first
			dump file, whereas the weak prototype deduced from the definition
			of <code>f</code>:</para>

		<programlisting language="C">void f WEAK ( int ) ;</programlisting>

		<para>would be included in the second. When these two dump files are
			linked, the inconsistency is discovered and an error is
			reported.</para>
	</section>
</chapter>

