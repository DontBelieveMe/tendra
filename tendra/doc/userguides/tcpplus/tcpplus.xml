<?xml version="1.0" standalone="no"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
  "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">

<!--
  $Id$
-->

<book xmlns:dt="http://xml.water-powered.com/docs">
  <bookinfo>
    <title>C++ Producer User Guide</title>

    <othercredit class="copyeditor">
      <firstname>Katherine</firstname>
      <surname>Flavel</surname>
      <affiliation><orgname>The TenDRA Project</orgname></affiliation>
    </othercredit>
    <othercredit class="copyeditor">
      <firstname>Jeroen</firstname>
      <surname>Ruigrok van der Werven</surname>
      <affiliation><orgname>The TenDRA Project</orgname></affiliation>
    </othercredit>
    <corpauthor>DERA</corpauthor>

    <pubdate>2004</pubdate>

    <copyright>
      <year>2004</year>
      <year>2005</year>
      <year>2007</year>

      <holder>The TenDRA Project</holder>
    </copyright>

    <copyright>
      <year>1998</year>

      <holder>DERA</holder>
    </copyright>

	<revhistory>
		<revision>
			<date>01 10 2007</date>
			<revremark>Split off various non-user documentation to
				<dt:doc name="developer/components/tcpplus"/>,
				<dt:doc name="papers/cppporting"/> and
				<dt:doc name="developer/guides/style"/>.</revremark>
			<author><firstname>kate</firstname></author>
		</revision>
	</revhistory>
  </bookinfo>

  <chapter id="intro">
    <title>Introduction</title>

    <para>This document is designed as a technical overview of the TenDRA C++
      to TDF/ANDF producer.  It is divided into two broad areas; descriptions
      of the <link linkend="interface">public interfaces</link> of the producer, and
      an overview of the producer <link linkend="program">source code</link>.</para>

    <para>Whereas the interface description contains most of the information
      which would be required in a users' guide, it is not necessarily in a
      readily digestible form.  The C++ producer is designed to complement the
      existing TenDRA C to TDF producer; although they are completely distinct
      programs, the same design philosophy underlies both and they share a
      number of common interfaces.  There are no radical differences between
      the two producers, besides the fact that the C++ producer covers a
      vastly larger and more complex language.  This means that much of the
      <link linkend="tdfc">existing documentation on the C producer</link> can be
      taken as also applying to the C++ producer.  This document tries to make
      clear where the C++ producer extends the C producer's interfaces, and
      those portions of these interfaces which are not directly applicable to
      C++.</para>

    <para>
    A familiarity with both C++ and TDF is assumed. The version of C++
    implemented is that given by the <link linkend="cplusplus">draft ISO C++
    standard</link>.  All references to &quot;ISO C++&quot; within the document
    should strictly be qualified using the word &quot;draft&quot;, but
    for convenience this has been left implicit.  The C++ producer has
    a number of switches which allow it to be configured for older dialects
    of C++.  In particular, the version of C++ described in the <link linkend="arm">ARM
    (Annotated Reference Manual)</link> is fully supported.
    </para>

    <para>The <dt:doc name="reference/specification"/> (version 4.0) may be consulted
    for a description of the compiler intermediate language used.  The
    paper
    <dt:doc name="papers/porting"/> provides a useful (if
    slightly old) introduction to some of the ideas relating to static
    program analysis and interface checking which underlie the whole TenDRA
    compilation system.
    </para>

    <para>
    The warning sign:

	<warning/>

    is used within the document to indicate areas where the implementation
    is currently incomplete or incorrect.
    </para>

    <section id="update">
      <title>Updated introduction</title>

      <para>Since this document was originally written, the old C producer,
        <emphasis>tdfc</emphasis>, has been replaced by a new C producer, <emphasis>tdfc2</emphasis>,
        which is just a modified version of the C++ producer, <emphasis>tcpplus</emphasis>.
        All C producer documentation continues to apply to the new C producer,
        but the new C producer also has many of the features described in this
        document as only applying to the C++ producer.</para>
    </section>
  </chapter>

  <chapter id="interface">
    <title>Interface descriptions</title>
  <para>
  The most important public interfaces of the C++ producer are the ISO
  C++ standard and the TDF 4.0 specification; however there are other
  interfaces, mostly common to both the C and C++ producers, which are
  described in this section.
  </para>
  <para>
  An important design criterion of the C++ producer was that it should
  be strictly ISO conformant by default, but have a method whereby dialect
  features and extra static program analysis can be enabled. This compiler
  configuration is controlled by the
  <A HREF="pragma.html"><code>#pragma TenDRA</code> directives</A>
  described in the first section.
  </para>
  <para>
  The requirement that the C and C++ producers should be able to translate
  portable C or C++ programs into target independent TDF requires a
  mechanism whereby the target dependent implementations of APIs can
  be represented.  This mechanism, the <A HREF="token.html"><code>#pragma
  token</code> syntax</A>, is described in the following section.  Note
  that at present this mechanism only contains support for C APIs; it
  is considered that the C++ language itself contains sufficient interface
  mechanisms for C++ APIs to be described.
  </para>
  <para>
  The C and C++ producers provide two mechanisms whereby type and declaration
  information derived from a translation unit can be stored to a file
  for post-processing by other tools.  The first is the
  <A HREF="dump.html">symbol table dump</A>, which is a public interface
  designed for use by third party tools.  The second is the
  <A HREF="link.html">C/C++ spec file</A>, which is designed for ease
  of reading and writing by the producers themselves, and is used for
  intermodule analysis.
  </para>
  <para>
  The mapping from C++ to TDF implemented by the C++ producer is largely
  straightforward.  There are however target dependencies arising within
  the language itself which require special handling.  These are represented
  by certain <A HREF="lib.html">standard tokens</A> which the producer
  requires to be defined on the target machine.  These tokens are also
  used to describe the interface between the producer and the run-time
  system.  Note that the C++ producer is primarily concerned with the
  C++ language, not with the standard C++ library. An example implementation
  of those library components which are required as an integral part
  of the language (memory allocation, exception handling, run-time type
  information etc.) is provided. Otherwise, libraries should be obtained
  from third parties.  A number of hints on <A HREF="std.html">integrating
  such libraries</A> with the C++ producer are given.
  </para>
  </chapter>

  <chapter id="invocation">
  <title>Invocation</title>

  <section>
    <title>Overview</title>
  <para>
  In this section it is described how the C++ to TDF producer,
  <code>tcpplus</code>, fits into the overall compilation scheme controlled
  by the TenDRA compiler front-end, <code>tcc</code>, or the TenDRA
  checker front-end, <code>tchk</code>.  While it is possible to use
  <code>tcpplus</code> as a stand-alone program, it is recommended that
  it should be invoked via <code>tcc</code> or <code>tchk</code>. The
  <code>tcc</code> users' guide should be consulted for more details.
  </para>
  <para>
  <code>tcc</code> and <code>tchk</code> require the <code>-Yc++</code>
  command-line option in order to enable their C++ capabilities.  Files
  with a <code>.C</code> suffix are recognised as C++ source files and
  passed to <code>tcpplus</code> for processing (see
  <link linkend="compile">below</link>).  It is possible to change the suffix
  used for C++ source files; for example <code>-sC:cc</code> causes
  <code>.cc</code> files to be recognised as C++ source files.  An interesting
  variation is <code>-sC:c</code> which causes C source files to be
  processed by the C++ producer.  Similarly <code>.I</code> files are
  recognised as preprocessed C++ source files and <code>.K</code>
  files are recognised as C++ spec files.
  </para>
  <para>
  Most of the command-line option handling for <code>tcpplus</code>
  is done by <code>tcc</code> and <code>tchk</code>, however it is possible
  to pass the option <emphasis>opt</emphasis> directly to <code>tcpplus</code> using
  the option <code>-Wx,</code><emphasis>opt</emphasis> to <code>tcc</code> or <code>tchk</code>.
  Similarly <code>-Wg,</code><emphasis>opt</emphasis> and <code>-WS,</code><emphasis>opt</emphasis>
  can be used to pass options to the C++ preprocessor and the C++ spec
  linker (both of which are actually <code>tcpplus</code> invoked with
  different options) respectively.
  </para>


  <section id="compile">
    <title>Compilation scheme</title>
  <para>
  The overall compilation scheme controlled by <code>tcc</code>, as
  it relates to the C++ producer, can be represented as follows:

	<figure>
		<title>Compilation Scheme</title>

		<graphic fileref="compile.png"/>
	</figure>

  Each C++ source file, <code>a.C</code> say, is processed using
  <code>tcpplus</code> to give an output TDF capsule, <code>a.j</code>,
  which is passed to the installer phase of <code>tcc</code>.  The capsule
  is linked with any target dependent token definition libraries, translated
  to assembler and assembled to give a binary object file,
  <code>a.o</code>.  The various object files comprising the program
  are then linked with the system libraries to give a final executable,
  <code>a.out</code>.
  </para>
  <para>
  In addition to this main compilation scheme, <code>tcpplus</code>
  can additionally be made to output a <A HREF="link.html">C++ spec
  file</A>
  for each C++ source file, <code>a.K</code> say.  These C++ spec files
  can be linked, using <code>tcpplus</code> in its spec linker mode,
  to give an additional TDF capsule, <code>x.j</code> say, and a combined
  C++ spec file, <code>x.K</code>.  The main purpose of this C++ spec
  linking is to perform intermodule checks on the program, however in
  the course of this checking exported templates which are defined in
  one module and used in another are instantiated.  This extra code
  is output to <code>x.j</code>, which is then installed and linked
  in the normal way.
  </para>
  <para>
  Note that intermodule checks, and hence intermodule template instantiations,
  are only performed if the <code>-im</code> option is passed to <code>tcc</code>.
  </para>
  <para>
  The TenDRA checker, <code>tchk</code>, is similar to <code>tcc</code>
  except that it disables TDF output and has intermodule analysis enabled
  by default.
  </para>
  </section>

  <section id="option">
    <title>Producer options</title>
  <para>
  The general form for the invocation of <code>tcpplus</code> is as
  follows:
  <programlisting>
tcpplus [ <emphasis>options</emphasis> ] [ <emphasis>input-file</emphasis> ] .... [ <emphasis>output-file</emphasis> ]</programlisting>
  The output file can alternatively be specified using the
  <link linkend="output"><code>-o</code> option</link>.  If no output file is
  given, or the output file is <code>-</code>, the standard output is
  used.  In general there can be any number of input files.  If no input
  file is given, or the input file is <code>-</code>, the standard input
  is used.
  </para>
  <para>
  <code>tcpplus</code> has three modes which determine the form of its
  input and output files.  The default mode is compilation, in which
  a single input C++ source file is translated into an output TDF capsule.
  In preprocessing mode, specified using the
  <link linkend="preproc"><code>-E</code> option</link>, a single input C++
  source file is preprocessed into an output C++ source file.  Note
  that the preprocessor is built into <code>tcpplus</code>, rather than,
  as with most other compilers, being a separate program.  The final
  mode is
  <A HREF="link.html">C++ spec linking</A>, specified using the
  <link linkend="linker"><code>-S</code> option</link>.  Any number of C++ spec
  input files are linked and any code generated as a result (for example,
  template instantiations) is written to the output TDF capsule.
  </para>
  <para>
  In either compilation or spec linking mode, a C++ spec output file
  can be generated, in addition to the TDF capsule, using the
  <link linkend="spec"><code>-s</code> option</link>.  In any mode a symbol
  table dump output file can generated using the <link linkend="dump"><code>-d</code>
  option</link>.
  </para>
  <para>
  Command-line options can appear in any order and can be interspersed
  with the input and output files, except following a <code>--</code>
  option.  All the multi-part options can be given either as one or
  two command-line arguments, so that <code>-I</code><emphasis>directory</emphasis>
  and
  <code>-I</code> <emphasis>directory</emphasis> are equivalent.  The recognised options
  are as follows:

  <itemizedlist>

  <listitem><code>-A<emphasis>predicate</emphasis>(<emphasis>tokens</emphasis>)</code>
  Asserts that the given predicate is true, that is to say:
  <programlisting language="C++">
#assert <emphasis>predicate</emphasis> ( <emphasis>tokens</emphasis> )</programlisting>
  The special case <code>-A-</code> undefines all the built-in predicates
  (of which there are none).  Use of this option automatically enables
  support for the <A HREF="pragma.html#ppdir"><code>#assert</code> and
  <code>#unassert</code> directives</A>.
  </listitem>

  <listitem><code>-D<emphasis>macro</emphasis></code>
  <code>-D<emphasis>macro</emphasis>=<emphasis>tokens</emphasis></code>
  Defines the given macro to be 1 in the first case, or the given sequence
  of preprocessing tokens in the second case, that is to say:
  <programlisting language="C++">
#define <emphasis>macro</emphasis> 1
#define <emphasis>macro tokens</emphasis></programlisting>
  respectively.  In fact <code>-D</code> and <code>-U</code> options
  to
  <code>tcc</code> are not passed as <code>-D</code> and <code>-U</code>
  options to <code>tcpplus</code>.  Instead a
  <link linkend="start-up">start-up</link> file containing the equivalent
  <code>#define</code> and <code>#undef</code> directives is used.
  </listitem>

  <listitem><A id="preproc"><code>-E</code></A>
  Enables preprocessing mode in which the input C++ source file is preprocessed
  into the output file.
  </listitem>

  <listitem><code>-F<emphasis>file</emphasis></code>
  Causes a list of command-line options to be read from <emphasis>file</emphasis>.
  Other than empty lines and lines beginning with <code>#</code>, each
  line in the file is treated as if it had been specified as a separate
  command-line option.
  </listitem>

  <listitem><code>-H</code>
  Enables verbose inclusion mode in which warnings are printed at the
  start and end of each included source file.
  </listitem>

  <listitem><code>-I<emphasis>directory</emphasis></code>
  Adds the given directory to the list searched for included source
  files. No such directories are built into the producer by default.
  </listitem>

  <listitem><A id="directory"><code>-N<emphasis>name</emphasis>:<emphasis>directory</emphasis></code></A>
  This is identical to <code>-I</code><emphasis>directory</emphasis> except that it
  also associates the given identifier with the directory.  The directory
  name can be used to specify a <A HREF="pragma.html#scope">compilation
  profile</A> to be used on files included from this directory.
  </listitem>

  <listitem><A id="linker"><code>-S</code></A>
  Enables C++ spec linker mode, in which any number of C++ spec input
  files are linked together.
  </listitem>

  <listitem><code>-U<emphasis>macro</emphasis></code>
  Undefines the given macro, that is to say:
  <programlisting language="C++">
#undef <emphasis>macro</emphasis></programlisting>
  The special case <code>-U-</code> undefines all the built-in macros.
  These may be described as follows:
  <programlisting language="C++">
#define __FILE__		<emphasis>(current file)</emphasis>
#define __LINE__		<emphasis>(current line)</emphasis>
#define __TIME__		<emphasis>(current time)</emphasis>
#define __DATE__		<emphasis>(current date)</emphasis>
#define __STDC__		1
#define __STDC_VERSION__	199409L
#define __cplusplus		199711L</programlisting>
  The actual value of <code>__cplusplus</code> gives the date of the
  draft ISO C++ standard on which the current version of the producer
  is based. The value given above gives the expected date of the final
  C++ standard.
  </listitem>

  <listitem><code>-V</code>
  Causes the name of each function to be printed to the standard output
  as it is compiled.
  </listitem>

  <listitem><code>-W<emphasis>option</emphasis></code>
  Sets the given <A HREF="pragma.html#low">compiler option</A> to give
  a warning, that is to say:
  <programlisting language="C++">
#pragma TenDRA option &quot;<emphasis>option</emphasis>&quot; warning</programlisting>
  The special case <code>-Wall</code> enables a wide range of warnings.
  </listitem>

  <listitem><code>-X</code>
  Disables exception handling.  The <A HREF="lib.html#except">current
  implementation</A> can be a large run-time overhead if not required.
  The effect of linking any module compiled with this option with a
  module which throws an exception is undefined.  This is equivalent
  to <link linkend="output"><code>-j-e</code></link>.
  </listitem>

  <listitem><code>-a</code>
  Causes complete program analysis to be applied.  That is to say it
  is assumed that no other translation units need to be linked in order
  for the program to execute.
  </listitem>

  <listitem><code>-c</code>
  Disables TDF output.  The output file will still be a valid TDF capsule,
  but it will contain no information.  This is equivalent to
  <link linkend="output"><code>-j-c</code></link>.
  </listitem>

  <listitem><para><A id="dump"><code>-d<emphasis>opt</emphasis>=<emphasis>dump-file</emphasis></code></A>
  Specifies the given file as a <A HREF="dump.html">symbol table dump</A>
  output file.  <emphasis>opt</emphasis> will be a series of characters describing
  the information to be dumped, as follows:

  <table>
  <tr><th>Key</th>
  <th>Description</th>
  </tr>
  <tr><td><code>a</code></td>
  <td>equivalent to <code>ehlmu</code></td>
  </tr>
  <tr><td><code>c</code></td>
  <td>dump string literals</td>
  </tr>
  <tr><td><code>e</code></td>
  <td>dump error messages</td>
  </tr>
  <tr><td><code>h</code></td>
  <td>dump header information</td>
  </tr>
  <tr><td><code>k</code></td>
  <td>dump keyword identifiers</td>
  </tr>
  <tr><td><code>l</code></td>
  <td>dump local variables</td>
  </tr>
  <tr><td><code>m</code></td>
  <td>dump macro identifiers</td>
  </tr>
  <tr><td><code>s</code></td>
  <td>dump scope information</td>
  </tr>
  <tr><td><code>u</code></td>
  <td>dump identifier usage information</td>
  </tr>
  </table>

  </para>
  <para>
  Note that these correspond to the <code>tcc -sym</code> options.
  </para>
  </listitem>

  <listitem><A id="end-up"><code>-e<emphasis>file</emphasis></code></A>
  Specifies the given file as an end-up file.  This is equivalent to
  adding:
  <programlisting language="C++">
#include &quot;<emphasis>file</emphasis>&quot;</programlisting>
  at the end of the input source file.  More than one end-up file may
  be given; they are processed in the order given.
  </listitem>

  <listitem><A id="start-up"><code>-f<emphasis>file</emphasis></code></A>
  Specifies the given file as a start-up file.  This is equivalent to
  adding:
  <programlisting  language="C++">
#include &quot;<emphasis>file</emphasis>&quot;</programlisting>
  at the start of the input source file.  More than one start-up file
  may be given; they are processed in the order given.
  </listitem>

  <listitem><code>-g</code>
  Specifies that the output TDF capsule should also contain information
  to allow for the generation of run-time debugging directives.  This
  is equivalent to <link linkend="output"><code>-jg</code></link>.
  </listitem>

  <listitem><code>-h</code>
  Causes a full list of command-line options to be printed.  This includes
  a number not documented here which are unlikely to prove useful to
  the normal user.
  </listitem>

  <listitem><A id="output"><code>-j<emphasis>opt</emphasis></code></A>
  Sets the TDF output options given by <emphasis>opt</emphasis>.  This consists of
  a sequence of characters describing the options to be enabled or disabled.
  By default, or following a <code>+</code>, the options are enabled;
  following a <code>-</code> they are disabled.  The available options
  are as follows:
  </listitem>

  <table>
  <tr><th>Key</th>
  <th>Default</th>
  <th>Description</th>
  </tr>
  <tr><td><code>a</code></td>
  <td>off</td>
  <td>output external names for local objects</td>
  </tr>
  <tr><td><code>b</code></td>
  <td>off</td>
  <td>work round old installer bugs</td>
  </tr>
  <tr><td><code>c</code></td>
  <td>on</td>
  <td>output TDF capsule</td>
  </tr>
  <tr><td><code>d</code></td>
  <td>off</td>
  <td>output termination function</td>
  </tr>
  <tr><td><code>e</code></td>
  <td>on</td>
  <td>output exceptions</td>
  </tr>
  <tr><td><code>f</code></td>
  <td>on</td>
  <td>mangle template function signatures</td>
  </tr>
  <tr><td><code>g</code></td>
  <td>off</td>
  <td>output debugging information</td>
  </tr>
  <tr><td><code>i</code></td>
  <td>off</td>
  <td>output dynamic initialisers as a function</td>
  </tr>
  <tr><td><code>n</code></td>
  <td>on</td>
  <td>mangle object names</td>
  </tr>
  <tr><td><code>o</code></td>
  <td>off</td>
  <td>order class data members by access</td>
  </tr>
  <tr><td><code>p</code></td>
  <td>on</td>
  <td>output partial destructors</td>
  </tr>
  <tr><td><code>r</code></td>
  <td>on</td>
  <td>output run-time type information</td>
  </tr>
  <tr><td><code>s</code></td>
  <td>on</td>
  <td>output shared string literals</td>
  </tr>
  <tr><td><code>t</code></td>
  <td>off</td>
  <td>output token declarations</td>
  </tr>
  <tr><td><code>u</code></td>
  <td>on</td>
  <td>output unused static variables</td>
  </tr>
  <tr><td><code>v</code></td>
  <td>off</td>
  <td>output local virtual function tables</td>
  </tr>
  </table>

  <listitem><A id="error"><code>-m<emphasis>opt</emphasis></code></A>
  Sets the error formatting options given by <emphasis>opt</emphasis>.  This consists
  of a sequence of characters describing the options to be enabled or
  disabled. By default, or following a <code>+</code>, the options are
  enabled; following a <code>-</code> they are disabled.  The available
  options are as follows:

  <table>
  <tr><th>Key</th>
  <th>Default</th>
  <th>Description</th>
  </tr>
  <tr><td><code>c</code></td>
  <td>off</td>
  <td>show source code with error</td>
  </tr>
  <tr><td><code>e</code></td>
  <td>off</td>
  <td>show error name</td>
  </tr>
  <tr><td><code>f</code></td>
  <td>on</td>
  <td>reliable <code>fseek</code> function</td>
  </tr>
  <tr><td><code>g</code></td>
  <td>off</td>
  <td>record statement locations</td>
  </tr>
  <tr><td><code>i</code></td>
  <td>on</td>
  <td>reliable <code>stat</code> function</td>
  </tr>
  <tr><td><code>k</code></td>
  <td>off</td>
  <td>enable C++ spec output</td>
  </tr>
  <tr><td><code>l</code></td>
  <td>off</td>
  <td>output full error location</td>
  </tr>
  <tr><td><code>s</code></td>
  <td>on</td>
  <td>output ISO section number</td>
  </tr>
  <tr><td><code>t</code></td>
  <td>off</td>
  <td>use <code>typedef</code> names in errors</td>
  </tr>
  <tr><td><code>w</code></td>
  <td>off</td>
  <td>disable warnings</td>
  </tr>
  <tr><td><code>z</code></td>
  <td>off</td>
  <td>continue after error</td>
  </tr>
  </table>

  </listitem>

  <listitem><A id="table"><code>-n<emphasis>port-table</emphasis></code></A>
  Specifies that the given <A HREF="pragma.html#table">portability table</A>
  should be used to specify the basic configuration parameters.
  </listitem>

  <listitem><A id="output"><code>-o<emphasis>output-file</emphasis></code></A>
  Gives an alternative method of specifying the output file.
  </listitem>

  <listitem><code>-q</code>
  Causes the program to quit immediately without processing its input
  files. This is useful primarily in version and command-line option
  queries.
  </listitem>

  <listitem><A id="spec"><code>-s<emphasis>spec-file</emphasis></code></A>
  Specifies the given file as a C++ spec output file.
  </listitem>

  <listitem><code>-t</code>
  Specifies that token declarations should be included in the output
  TDF capsule.  While these are strictly unnecessary, they help when
  pretty-printing the output.  This is equivalent to
  <link linkend="output"><code>-jt</code></link>.
  </listitem>

  <listitem><A id="unmangle"><code>-u</code></A>
  The form:
  <programlisting>
tcpplus -u <emphasis>name</emphasis> .... <emphasis>name</emphasis></programlisting>
  can be used to print the unmangled forms of a list of
  <A HREF="lib.html#mangle">mangled identifier names</A> to the standard
  output.
  </listitem>

  <listitem><code>-v</code>
  Causes the C++ producer version number, plus information on the versions
  of C++ and TDF supported, to be printed to the standard error.
  </listitem>

  <listitem><code>-w</code>
  Disables all warning messages.  This is equivalent to
  <link linkend="error"><code>-mw</code></link>.
  </listitem>

  <listitem><code>-z</code>
  Forces an output file to be created even if compilation errors occur.
  The effect of installing a TDF capsule produced using this option
  is undefined.  This is equivalent to <link linkend="error"><code>-mz</code></link>.
  </listitem>

  <listitem><code>--</code>
  Marks the last option.  Any subsequent arguments are interpreted as
  input and output files even if they resemble command-line options.
  </listitem>

  </itemizedlist>
  </para>
  </section>
  </section>

  <section>
    <title>Compiler configuration</title>
  <para>
  This section describes how the C++ producer can be configured to apply
  extra static checks or to support various dialects of C++.  In all
  cases the default behaviour is precisely that specified in the ISO
  C++ standard with no extra checks.
  </para>
  <para>
  Certain very basic configuration information is specified using a
  <link linkend="table">portability table</link>, however the primary method
  of configuration is by means of <code>#pragma</code> directives.
  These directives may be placed within the program itself, however
  it is generally more convenient to group them into a
  <A HREF="man.html#start-up">start-up file</A> in order to create a
  <A id="usr">user-defined compilation profile</A>.  The
  <code>#pragma</code> directives recognised by the C++ producer have
  one of the equivalent forms:
  <programlisting language="C++">
#pragma TenDRA ....
#pragma TenDRA++ ....</programlisting>
  Some of these are common to the C and C++ producers (although often
  with differing default behaviour).  The C producer will ignore any
  <code>TenDRA++</code> directives, so these may be used in compilation
  profiles which are to be used by both producers.  In the descriptions
  below, the presence of a <code>++</code> is used to indicate a directive
  which is C++ specific; the other directives are common to both producers.
  </para>
  <para>
  Within the description of the <code>#pragma</code> syntax, <emphasis>on</emphasis>
  stands for <code>on</code>, <code>off</code> or <code>warning</code>,
  <emphasis>allow</emphasis> stands for <code>allow</code>, <code>disallow</code>
  or
  <code>warning</code>, <emphasis>string-literal</emphasis> is any string literal,
  <emphasis>integer-literal</emphasis> is any integer literal, <emphasis>identifier</emphasis> is
  any simple, unqualified identifier name, and <emphasis>type-id</emphasis> is any
  type identifier.  Other syntactic items are described in the text.
  A
  <A HREF="pragma1.html">complete grammar</A> for the <code>#pragma</code>
  directives accepted by the C++ producer is given as an annex.
  </para>


  <section id="table">
    <title>Portability tables</title>
  <para>
  Certain very basic configuration information is read from a file called
  a portability table, which may be specified to the producer using
  a
  <A HREF="man.html#table"><code>-n</code> option</A>.  This information
  includes the minimum sizes of the basic integral types, the
  <link linkend="char">sign of plain <code>char</code></link>, and whether signed
  types can be assumed to be symmetric (for example, [-127,127]) or
  maximum (for example, [-128,127]).
  </para>
  <para>
  The default portability table values, which are built into the producer,
  can be expressed in the form:
  <programlisting>
char_bits			8
short_bits			16
int_bits			16
long_bits			32
signed_range			symmetric
char_type			either
ptr_int				none
ptr_fn				no
non_prototype_checks		yes
multibyte			1</programlisting>
  This illustrates the syntax for the portability table; note that all
  ten entries are required, even though the last four are ignored.
  </para>
  </section>

  <section id="low">
    <title>Low level configuration</title>
  <para>
  The simplest level of configuration is to reset the severity level
  of a particular error message using:
  <programlisting language="C++">
#pragma TenDRA++ error <emphasis>string-literal on</emphasis>
#pragma TenDRA++ error <emphasis>string-literal allow</emphasis></programlisting>
  The given <emphasis>string-literal</emphasis> should name an error from the
  <A HREF="error.html">error catalogue</A>.  A severity of <code>on</code>
  or <code>disallow</code> indicates that the associated diagnostic
  message should be an error, which causes the compilation to fail.
  A severity of
  <code>warning</code> indicates that the associated diagnostic message
  should be a warning, which is printed but allows the compilation to
  continue.  A severity of <code>off</code> or <code>allow</code>
  indicates that the associated error should be ignored.  Reducing the
  severity of any error from its default value, other than via one of
  the dialect directives described in this section, results in undefined
  behaviour.
  </para>
  <para>
  The next level of configuration is to reset the severity level of
  a particular compiler option using:
  <programlisting language="C++">
#pragma TenDRA++ option <emphasis>string-literal on</emphasis>
#pragma TenDRA++ option <emphasis>string-literal allow</emphasis></programlisting>
  The given <emphasis>string-literal</emphasis> should name an option from the option
  catalogue.  The simplest form of compiler option just sets the severity
  level of one or more error messages.  Some of these options may require
  additional processing to be applied.</para>
  <para>
  It is possible to link a particular error message to a particular
  compiler option using:
  <programlisting language="C++">
#pragma TenDRA++ error <emphasis>string-literal</emphasis> as option <emphasis>string-literal</emphasis></programlisting>
  </para>
  <para>
  Note that the directive:
  <programlisting language="C++">
#pragma TenDRA++ use error <emphasis>string-literal</emphasis></programlisting>
  can be used to raise a given error at any point in a translation unit
  in a similar fashion to the <code>#error</code> directive.  The values
  of any parameters for this error are unspecified.
  </para>
  <para>
  The directives just described give the primitive operations on error
  messages and compiler options.  Many of the remaining directives in
  this section are merely higher level ways of expressing these primitives.
  </para>
  </section>

  <section id="scope">
    <title>Checking scopes</title>
  <para>
  Most compiler options are scoped.  A checking scope may be defined
  by enclosing a list of declarations within:
  <programlisting language="C++">
#pragma TenDRA begin
....
#pragma TenDRA end</programlisting>
  If the final <code>end</code> directive is omitted then the scope
  ends at the end of the translation unit.  Checking scopes may be nested
  in the obvious way.  A checking scope inherits its initial set of
  checks from its enclosing scope (this includes the implicit main checking
  scope consisting of the entire input file).  Any checks switched on
  or off within a scope apply only to the remainder of that scope and
  any scope it contains.  A particular check can only be set once in
  a given scope. The set of applied checks reverts to its previous state
  at the end of the scope.</para>
  <para>
  A checking scope can be named using the directives:
  <programlisting language="C++">
#pragma TenDRA begin name environment <emphasis>identifier</emphasis>
....
#pragma TenDRA end</programlisting>
  Checking scope names occupy a namespace distinct from any other namespace
  within the translation unit.  A named scope defines a set of modifications
  to the current checking scope.  These modifications may be reapplied
  within a different scope using:
  <programlisting language="C++">
#pragma TenDRA use environment <emphasis>identifier</emphasis></programlisting>
  The default behaviour is not to allow checks set in the named checking
  scope to be reset in the current scope.  This can however be modified
  using:
  <programlisting language="C++">
#pragma TenDRA use environment <emphasis>identifier</emphasis> reset <emphasis>allow</emphasis></programlisting>
  </para>
  <para>
  Another use of a named checking scope is to associate a checking scope
  with a named include file directory.  This is done using:
  <programlisting language="C++">
#pragma TenDRA directory <emphasis>identifier</emphasis> use environment <emphasis>identifier</emphasis></programlisting>
  where the directory name is one introduced via a
  <A HREF="man.html#directory"><code>-N</code> command-line option</A>.
  The effect of this directive, if a <code>#include</code> directive
  is found to resolve to a file from the given directory, is as if the
  file was enclosed in directives of the form:
  <programlisting language="C++">
#pragma TenDRA begin
#pragma TenDRA use environment <emphasis>identifier</emphasis> reset allow
....
#pragma TenDRA end</programlisting>
  </para>
  <para>
  The checks applied to the expansion of a macro definition are those
  from the scope in which the macro was defined, not that in which it
  was expanded. The macro arguments are checked in the scope in which
  they are specified, that is to say, the scope in which the macro is
  expanded.  This enables macro definitions to remain localised with
  respect to checking scopes.
  </para>
  </section>

  <section id="limits">
    <title>Implementation limits</title>
  <para>
  This table gives the default implementation limits imposed by the
  C++ producer for the various implementation quantities listed in Annex
  B of the ISO C++ standard, together with the minimum limits allowed
  in ISO C and C++.  A default limit of <emphasis>none</emphasis> means that the quantity
  is limited only by the size of the host machine (either <code>ULONG_MAX</code>
  or until it runs out of memory).  A limit of <emphasis>target</emphasis> means that
  while no limits is imposed by the C++ front-end, particular target
  machines may impose such limits.
  </para>

  <table>
  <tr><th>Quantity identifier</th>
  <th>Min C limit</th>  <th>Min C++ limit</th>
  <th>Default limit</th>
  </tr>
  <tr><td>statement_depth</td>
  <td>15</td>  <td>256</td>
  <td>none</td>
  </tr>
  <tr><td>hash_if_depth</td>
  <td>8</td>  <td>256</td>
  <td>none</td>
  </tr>
  <tr><td>declarator_max</td>
  <td>12</td>  <td>256</td>
  <td>none</td>
  </tr>
  <tr><td>paren_depth</td>
  <td>32</td>  <td>256</td>
  <td>none</td>
  </tr>
  <tr><td>name_limit</td>
  <td>31</td>  <td>1024</td>
  <td>none</td>
  </tr>
  <tr><td>extern_name_limit</td>
  <td>6</td>  <td>1024</td>
  <td>target</td>
  </tr>
  <tr><td>external_ids</td>
  <td>511</td>  <td>65536</td>
  <td>target</td>
  </tr>
  <tr><td>block_ids</td>
  <td>127</td>  <td>1024</td>
  <td>none</td>
  </tr>
  <tr><td>macro_ids</td>
  <td>1024</td>  <td>65536</td>
  <td>none</td>
  </tr>
  <tr><td>func_pars</td>
  <td>31</td>  <td>256</td>
  <td>none</td>
  </tr>
  <tr><td>func_args</td>
  <td>31</td>  <td>256</td>
  <td>none</td>
  </tr>
  <tr><td>macro_pars</td>
  <td>31</td>  <td>256</td>
  <td>none</td>
  </tr>
  <tr><td>macro_args</td>
  <td>31</td>  <td>256</td>
  <td>none</td>
  </tr>
  <tr><td>line_length</td>
  <td>509</td>  <td>65536</td>
  <td>none</td>
  </tr>
  <tr><td>string_length</td>
  <td>509</td>  <td>65536</td>
  <td>none</td>
  </tr>
  <tr><td>sizeof_object</td>
  <td>32767</td>  <td>262144</td>
  <td>target</td>
  </tr>
  <tr><td>include_depth</td>
  <td>8</td>  <td>256</td>
  <td>256</td>
  </tr>
  <tr><td>switch_cases</td>
  <td>257</td>  <td>16384</td>
  <td>none</td>
  </tr>
  <tr><td>data_members</td>
  <td>127</td>  <td>16384</td>
  <td>none</td>
  </tr>
  <tr><td>enum_consts</td>
  <td>127</td>  <td>4096</td>
  <td>none</td>
  </tr>
  <tr><td>nested_class</td>
  <td>15</td>  <td>256</td>
  <td>none</td>
  </tr>
  <tr><td>atexit_funcs</td>
  <td>32</td>  <td>32</td>
  <td>target</td>
  </tr>
  <tr><td>base_classes</td>
  <td>N/A</td>  <td>16384</td>
  <td>none</td>
  </tr>
  <tr><td>direct_bases</td>
  <td>N/A</td>  <td>1024</td>
  <td>none</td>
  </tr>
  <tr><td>class_members</td>
  <td>N/A</td>  <td>4096</td>
  <td>none</td>
  </tr>
  <tr><td>virtual_funcs</td>
  <td>N/A</td>  <td>16384</td>
  <td>none</td>
  </tr>
  <tr><td>virtual_bases</td>
  <td>N/A</td>  <td>1024</td>
  <td>none</td>
  </tr>
  <tr><td>static_members</td>
  <td>N/A</td>  <td>1024</td>
  <td>none</td>
  </tr>
  <tr><td>friends</td>
  <td>N/A</td>  <td>4096</td>
  <td>none</td>
  </tr>
  <tr><td>access_declarations</td>
  <td>N/A</td>  <td>4096</td>
  <td>none</td>
  </tr>
  <tr><td>ctor_initializers</td>
  <td>N/A</td>  <td>6144</td>
  <td>none</td>
  </tr>
  <tr><td>scope_qualifiers</td>
  <td>N/A</td>  <td>256</td>
  <td>none</td>
  </tr>
  <tr><td>external_specs</td>
  <td>N/A</td>  <td>1024</td>
  <td>none</td>
  </tr>
  <tr><td>template_pars</td>
  <td>N/A</td>  <td>1024</td>
  <td>none</td>
  </tr>
  <tr><td>instance_depth</td>
  <td>N/A</td>  <td>17</td>
  <td>17</td>
  </tr>
  <tr><td>exception_handlers</td>
  <td>N/A</td>  <td>256</td>
  <td>none</td>
  </tr>
  <tr><td>exception_specs</td>
  <td>N/A</td>  <td>256</td>
  <td>none</td>
  </tr>
  </table>

  <para>
  It is possible to impose lower limits on most of the quantities listed
  above by means of the directive:
  <programlisting language="C++">
#pragma TenDRA++ option value <emphasis>string-literal integer-literal</emphasis></programlisting>
  where <emphasis>string-literal</emphasis> gives one of the quantity identifiers
  listed above and <emphasis>integer-literal</emphasis> gives the limit to be imposed.
  An error is reported if the quantity exceeds this limit (note however
  that checks have not yet been implemented for all of the quantities
  listed).  Note that the <link linkend="identifier"><code>name_limit</code></link>
  and
  <link linkend="include"><code>include_depth</code></link> implementation limits
  can be set using dedicated directives.
  </para>
  <para>
  The maximum number of errors allowed before the producer bails out
  can be set using the directive:
  <programlisting language="C++">
#pragma TenDRA++ set error limit <emphasis>integer-literal</emphasis></programlisting>
  The default value is 32.
  </para>
  </section>

  <section id="lex">
    <title>Lexical analysis</title>
  <para>
  During lexical analysis, a source file which is not empty should end
  in a newline character.  It is possible to relax this constraint using
  the directive:
  <programlisting language="C++">
#pragma TenDRA no nline after file end <emphasis>allow</emphasis></programlisting>
  </para>
  </section>

  <section id="keyword">
    <title>Keywords</title>
  <para>
  In several places in this section it is described how to introduce
  keywords for TenDRA language extensions.  By default, no such extra
  keywords are defined.  There are also low-level directives for defining
  and undefining keywords.  The directive:
  <programlisting language="C++">
#pragma TenDRA++ keyword <emphasis>identifier</emphasis> for keyword <emphasis>identifier</emphasis></programlisting>
  can be used to introduce a keyword (the first identifier) standing
  for the standard C++ keyword given by the second identifier.  The
  directive:
  <programlisting language="C++">
#pragma TenDRA++ keyword <emphasis>identifier</emphasis> for operator <emphasis>operator</emphasis></programlisting>
  can similarly be used to introduce a keyword giving an alternative
  representation for the given operator or punctuator, as, for example,
  in:
  <programlisting language="C++">
#pragma TenDRA++ keyword and for operator &amp;&amp;</programlisting>
  Finally the directive:
  <programlisting language="C++">
#pragma TenDRA++ undef keyword <emphasis>identifier</emphasis></programlisting>
  can be used to undefine a keyword.
  </para>
  </section>

  <section id="comment">
    <title>Comments</title>
  <para>
  C-style comments do not nest.  The directive:
  <programlisting language="C++">
#pragma TenDRA nested comment analysis <emphasis>on</emphasis></programlisting>
  enables a check for the characters <code>/*</code> within C-style
  comments.
  </para>
  </section>

  <section id="lex-identifier-names">
    <title>Identifier names</title>
  <para>
  During lexical analysis, each character in the source file has an
  associated look-up value which is used to determine whether the character
  can be used in an identifier name, is a white space character etc.
  These values are stored in a simple look-up table.  It is possible
  to set the look-up value using:
  <programlisting language="C++">
#pragma TenDRA++ character <emphasis>character-literal</emphasis> as <emphasis>character-literal</emphasis> allow</programlisting>
  which sets the look-up for the first character to be the default look-up
  for the second character.  The form:
  <programlisting language="C++">
#pragma TenDRA++ character <emphasis>character-literal</emphasis> disallow</programlisting>
  sets the look-up of the character to be that of an invalid character.
  The forms:
  <programlisting language="C++">
#pragma TenDRA++ character <emphasis>string-literal</emphasis> as <emphasis>character-literal</emphasis> allow
#pragma TenDRA++ character <emphasis>string-literal</emphasis> disallow</programlisting>
  can be used to modify the look-up values for the set of characters
  given by the string literal.  For example:
  <programlisting language="C++">
#pragma TenDRA character '$' as 'a' allow
#pragma TenDRA character '\r' as ' ' allow</programlisting>
  allows <code>$</code> to be used in identifier names (like <code>a</code>)
  and carriage return to be a white space character.  The former is
  a common dialect feature and can also be controlled by the directive:
  <programlisting language="C++">
#pragma TenDRA dollar as ident <emphasis>allow</emphasis></programlisting>
  </para>
  <para>
  The maximum number of characters allowed in an identifier name can
  be set using the directives:
  <programlisting language="C++">
#pragma TenDRA set name limit <emphasis>integer-literal</emphasis>
#pragma TenDRA++ set name limit <emphasis>integer-literal</emphasis> warning</programlisting>
  This length is given by the <code>name_limit</code> implementation
  quantity
  <link linkend="limits">mentioned above</link>.  Identifiers which exceed this
  length raise an error or a warning, but are not truncated.
  </para>
  </section>

  <section id="int">
    <title>Integer literals</title>
  <para>
  The rules for finding the type of an integer literal can be described
  using directives of the form:
  <programlisting language="C++">
#pragma TenDRA integer literal <emphasis>literal-spec</emphasis></programlisting>
  where:
  <programlisting language="BNF">
<emphasis>literal-spec</emphasis> :
	<emphasis>literal-base literal-suffix<subscript>opt</subscript> literal-type-list</emphasis>

<emphasis>literal-base</emphasis> :
	octal
	decimal
	hexadecimal

<emphasis>literal-suffix</emphasis> :
	unsigned
	long
	unsigned long
	long long
	unsigned long long

<emphasis>literal-type-list</emphasis> :
	* <emphasis>literal-type-spec</emphasis>
	<emphasis>integer-literal literal-type-spec</emphasis> | <emphasis>literal-type-list</emphasis>
	? <emphasis>literal-type-spec</emphasis> | <emphasis>literal-type-list</emphasis>

<emphasis>literal-type-spec</emphasis> :
	: <emphasis>type-id</emphasis>
	* <emphasis>allow<subscript>opt</subscript></emphasis> : <emphasis>identifier</emphasis>
	* * <emphasis>allow<subscript>opt</subscript></emphasis> :</programlisting>
  Each directive gives a literal base and suffix, describing the form
  of an integer literal, and a list of possible types for literals of
  this form. This list gives a mapping from the value of the literal
  to the type to be used to represent the literal.  There are three
  cases for the literal type; it may be a given integral type, it may
  be calculated using a given <A HREF="lib.html#literal">literal type
  token</A>, or it may cause an error to be raised.  There are also
  three cases for describing a literal range; it may be given by values
  less than or equal to a given integer literal, it may be given by
  values which are guaranteed to fit into a given integral type, or
  it may be match any value.  For example:
  <programlisting language="C++">
#pragma token PROC ( VARIETY c ) VARIETY l_i # ~lit_int
#pragma TenDRA integer literal decimal 32767 : int | ** : l_i</programlisting>
  describes how to find the type of a decimal literal with no suffix.
  Values less that or equal to 32767 have type <code>int</code>; larger
  values have target dependent type calculated using the token
  <code>~lit_int</code>.  Introducing a <code>warning</code> into the
  directive will cause a warning to be printed if the token is used
  to calculate the value.
  </para>
  <para>
  Note that this scheme extends that implemented by the C producer,
  because of the need for more accurate information in the C++ producer.
  For example, the specification above does not fully express the ISO
  rule that the type of a decimal integer is the first of the types
  <code>int</code>, <code>long</code> and <code>unsigned long</code>
  which it fits into (it only expresses the first step).  However with
  the C++ extensions it is possible to write:
  <programlisting language="C++">
#pragma token PROC ( VARIETY c ) VARIETY l_i # ~lit_int
#pragma TenDRA integer literal decimal ? : int | ? : long |\
    ? : unsigned long | ** : l_i</programlisting>
  </para>
  </section>

  <section id="char">
    <title>Character literals and built-in types</title>
  <para>
  By default, a simple character literal has type <code>int</code> in
  C and type <code>char</code> in C++.  The type of such literals can
  be controlled using the directive:
  <programlisting language="C++">
#pragma TenDRA++ set character literal : <emphasis>type-id</emphasis></programlisting>
  The type of a wide character literal is given by the implementation
  defined type <code>wchar_t</code>.  By default, the definition of
  this type is taken from the target machine's <code>&lt;stddef.h&gt;</code>
  C header (note that in ISO C++, <code>wchar_t</code> is actually a
  keyword, but its underlying representation must be the same as in
  C). This definition can be overridden in the producer by means of
  the directive:
  <programlisting languae="C++">
#pragma TenDRA set wchar_t : <emphasis>type-id</emphasis></programlisting>
  for an integral type <emphasis>type-id</emphasis>.  Similarly, the definitions of
  the other implementation dependent integral types which arise naturally
  within the language - the type of the difference of two pointers,
  <code>ptrdiff_t</code>, and the type of the <code>sizeof</code>
  operator, <code>size_t</code> - given in the <code>&lt;stddef.h&gt;</code>
  header can be overridden using the directives:
  <programlisting language="C++">
#pragma TenDRA set ptrdiff_t : <emphasis>type-id</emphasis>
#pragma TenDRA set size_t : <emphasis>type-id</emphasis></programlisting>
  These directives are useful when targeting a specific machine on which
  the definitions of these types are known; while they may not affect
  the code generated they can cut down on spurious conversion warnings.
  Note that although these types are built into the producer they are
  not visible to the user unless an appropriate header is included (with
  the exception of the keyword <code>wchar_t</code> in ISO C++), however
  the directives:
  <programlisting language="C++">
#pragma TenDRA++ type <emphasis>identifier</emphasis> for <emphasis>type-name</emphasis></programlisting>
  can be used to make these types visible.  They are equivalent to a
  <code>typedef</code> declaration of <emphasis>identifier</emphasis> as the given
  built-in type, <code>ptrdiff_t</code>, <code>size_t</code> or
  <code>wchar_t</code>.
  </para>
  <para>
  Whether plain <code>char</code> is signed or unsigned is implementation
  dependent.  By default the implementation is determined by the definition
  of the <A HREF="lib.html#arith"><code>~char</code> token</A>, however
  this can be overridden in the producer either by means of the
  <link linkend="table">portability table</link> or by the directive:
  <programlisting language="C++">
#pragma TenDRA character <emphasis>character-sign</emphasis></programlisting>
  where <emphasis>character-sign</emphasis> can be <code>signed</code>,
  <code>unsigned</code> or <code>either</code> (the default).  Again
  this directive is useful primarily when targeting a specific machine
  on which the signedness of <code>char</code> is known.
  </para>
  </section>

  <section id="string">
    <title>String literals</title>
  <para>
  By default, character string literals have type <code>char [n]</code>
  in C and older dialects of C++, but type <code>const char [n]</code>
  in ISO C++.  Similarly wide string literals have type <code>wchar_t
  [n]</code>
  or <code>const wchar_t [n]</code>.  Whether string literals are
  <code>const</code> or not can be controlled using the two directives:
  <programlisting language="C++">
#pragma TenDRA++ set string literal : const
#pragma TenDRA++ set string literal : no const</programlisting>
  In the case where literals are <code>const</code>, the array-to-pointer
  conversion is allowed to cast away the <code>const</code> to allow
  for a degree of backwards compatibility.  The status of this deprecated
  conversion can be controlled using the directive:
  <programlisting language="C++">
#pragma TenDRA writeable string literal <emphasis>allow</emphasis></programlisting>
  (yes, I know that that should be <code>writable</code>).  Note that
  this directive has a slightly different meaning in the C producer.
  </para>
  <para>
  Adjacent string literals tokens of similar types (either both character
  string literals or both wide string literals) are concatenated at
  an early stage in parser, however it is unspecified what happens if
  a character string literal token is adjacent to a wide string literal
  token.  By default this gives an error, but the directive:
  <programlisting language="C++">
#pragma TenDRA unify incompatible string literal <emphasis>allow</emphasis></programlisting>
  can be used to enable the strings to be concatenated to give a wide
  string literal.
  </para>
  <para>
  If a <code>'</code> or <code>&quot;</code> character does not have
  a matching closing quote on the same line then it is undefined whether
  an implementation should report an unterminated string or treat the
  quote as a single unknown character.  By default, the C++ producer
  treats this as an unterminated string, but this behaviour can be controlled
  using the directive:
  <programlisting language="C++">
#pragma TenDRA unmatched quote <emphasis>allow</emphasis></programlisting>
  </para>
  </section>

  <section id="escape">
    <title>Escape sequences</title>
  <para>
  By default, if the character following the <code>\</code> in an escape
  sequence is not one of those listed in the ISO C or C++ standards
  then an error is given.  This behaviour, which is left unspecified
  by the standards, can be controlled by the directive:
  <programlisting language="C++">
#pragma TenDRA unknown escape <emphasis>allow</emphasis></programlisting>
  The result is that the <code>\</code> in unknown escape sequences
  is ignored, so that <code>\z</code> is interpreted as <code>z</code>,
  for example.  Individual escape sequences can be enabled or disabled
  using the directives:
  <programlisting language="C++">
#pragma TenDRA++ escape <emphasis>character-literal</emphasis> as <emphasis>character-literal</emphasis> allow
#pragma TenDRA++ escape <emphasis>character-literal</emphasis> disallow</programlisting>
  so that, for example:
  <programlisting language="C++">
#pragma TenDRA++ escape 'e' as '\033' allow
#pragma TenDRA++ escape 'a' disallow</programlisting>
  sets <code>\e</code> to be the ASCII escape character and disables
  the alert character <code>\a</code>.
  </para>
  <para>
  By default, if the value of a character, given for example by a
  <code>\x</code> escape sequence, does not fit into its type then an
  error is given.  This implementation dependent behaviour can however
  be controlled by the directive:
  <programlisting language="C++">
#pragma TenDRA character escape overflow <emphasis>allow</emphasis></programlisting>
  the value being converted to its type in the normal way.
  </para>
  </section>

  <section id="ppdir">
    <title>Preprocessing directives</title>
  <para>
  Non-standard preprocessing directives can be controlled using the
  directives:
  <programlisting language="C++">
#pragma TenDRA directive <emphasis>ppdir allow</emphasis>
#pragma TenDRA directive <emphasis>ppdir</emphasis> (ignore) <emphasis>allow</emphasis></programlisting>
  where <emphasis>ppdir</emphasis> can be <code>assert</code>, <code>file</code>,
  <code>ident</code>, <code>import</code> (C++ only),
  <code>include_next</code> (C++ only), <code>unassert</code>,
  <code>warning</code> (C++ only) or <code>weak</code>.  The second form
  causes the directive to be processed but ignored (note that there is no
  <code>(ignore) disallow</code> form).  The treatment of other unknown
  preprocessing directives can be controlled using:
  <programlisting language="C++">
#pragma TenDRA unknown directive <emphasis>allow</emphasis></programlisting>
  Cases where the token following the <code>#</code> in a preprocessing
  directive is not an identifier can be controlled using:
  <programlisting language="C++">
#pragma TenDRA no directive/nline after ident <emphasis>allow</emphasis></programlisting>
  When permitted, unknown preprocessing directives are ignored.
  </para>
  <para>
  By default, unknown <code>#pragma</code> directives are ignored without
  comment, however this behaviour can be modified using the directive:
  <programlisting language="C++">
#pragma TenDRA unknown pragma <emphasis>allow</emphasis></programlisting>
  Note that any unknown <code>#pragma TenDRA</code> directives always
  give an error.
  </para>
  <para>
  Older preprocessors allowed text after <code>#else</code> and
  <code>#endif</code> directives.  The following directive can be used
  to enable such behaviour:
  <programlisting language="C++">
#pragma TenDRA text after directive <emphasis>allow</emphasis></programlisting>
  Such text after a directive is ignored.
  </para>
  <para>
  Some older preprocessors have problems with white space in preprocessing
  directives - whether at the start of the line, before the initial
  <code>#</code>, or between the <code>#</code> and the directive identifier.
  Such white space can be detected using the directives:
  <programlisting language="C++">
#pragma TenDRA indented # directive <emphasis>allow</emphasis>
#pragma TenDRA indented directive after # <emphasis>allow</emphasis></programlisting>
  respectively.
  </para>
  </section>

  <section id="target-if">
    <title>Target dependent conditional inclusion</title>
  <para>
  One of the effects of trying to compile code in a target independent
  manner is that it is not always possible to completely evaluate the
  condition in a <code>#if</code> directive.  Thus the conditional inclusion
  needs to be preserved until the installer phase.  This can only be
  done if the target dependent <code>#if</code> is more structured than
  is normally required for preprocessing directives. There are two cases;
  in the first, where the <code>#if</code> appears in a statement, it
  is treated as if it were a <code>if</code> statement with braces including
  its branches; that is:
  <programlisting language="C++">
#if cond
    true_statements
#else
    false_statements
#endif</programlisting>
  maps to:
  <programlisting>
if ( cond ) {
    true_statements
} else {
    false_statements
}</programlisting>
  In the second case, where the <code>#if</code> appears in a list of
  declarations, normally gives an error.  The can however be overridden
  by the directive:
  <programlisting language="C++">
#pragma TenDRA++ conditional declaration <emphasis>allow</emphasis></programlisting>
  which causes both branches of the <code>#if</code> to be analysed.
  </para>
  </section>

  <section id="include">
    <title>File inclusion directives</title>
  <para>
  There is a maximum depth of nested <code>#include</code>
  directives allowed by the C++ producer. This depth is given by the
  <code>include_depth</code> implementation quantity
  <link linkend="limits">mentioned above</link>.  Its value is fairly small
  in order to detect recursive inclusions.  The maximum depth can be
  set using:
  <programlisting language="C++">
#pragma TenDRA includes depth <emphasis>integer-literal</emphasis></programlisting>
  </para>
  <para>
  A further check, for full pathnames in <code>#include</code> directives
  (which may not be portable), can be enabled using the directive:
  <programlisting language="C++">
#pragma TenDRA++ complete file includes <emphasis>allow</emphasis></programlisting>
  </para>
  </section>

  <section id="macro">
    <title>Macro definitions</title>
  <para>
  By default, multiple consistent definitions of a macro are allowed.
  This behaviour can be controlled using the directive:
  <programlisting language="C++">
#pragma TenDRA extra macro definition <emphasis>allow</emphasis></programlisting>
  The ISO C/C++ rules for determining whether two macro definitions
  are consistent are fairly restrictive.  A more relaxed rule allowing
  for consistent renaming of macro parameters can be enabled using:
  <programlisting language="C++">
#pragma TenDRA weak macro equality <emphasis>allow</emphasis></programlisting>
  </para>
  <para>
  In the definition of macros with parameters, a <code>#</code> in the
  replacement list must be followed by a parameter name, indicating
  the stringising operation.  This behaviour can be controlled by the
  directive:
  <programlisting language="C++">
#pragma TenDRA no ident after # <emphasis>allow</emphasis></programlisting>
  which allows a <code>#</code> which is not followed by a parameter
  name to be treated as a normal preprocessing token.
  </para>
  <para>
  In a list of macro arguments, the effect of a sequence of preprocessing
  tokens which otherwise resembles a preprocessing directive is undefined.
  The C++ producer treats such directives as normal sequences of preprocessing
  tokens, but can be made to report such behaviour using:
  <programlisting language="C++">
#pragma TenDRA directive as macro argument <emphasis>allow</emphasis></programlisting>
  </para>
  </section>

  <section id="empty">
    <title>Empty source files</title>
  <para>
  ISO C requires that a translation unit should contain at least one
  declaration.  C++ and older dialects of C allow translation units
  which contain no declarations.  This behaviour can be controlled using
  the directive:
  <programlisting language="C++">
#pragma TenDRA no external declaration <emphasis>allow</emphasis></programlisting>
  </para>
  </section>

  <section id="std">
    <title>The <code>std</code> namespace</title>
  <para>
  Several classes declared in the <code>std</code> namespace arise naturally
  as part of the C++ language specification.  These are as follows:
	<!-- TODO table? -->
  <programlisting>
std::type_info		// type of typeid construct
std::bad_cast		// thrown by dynamic_cast construct
std::bad_typeid		// thrown by typeid construct
std::bad_alloc		// thrown by new construct
std::bad_exception	// used in exception specifications</programlisting>
  The definitions of these classes are found, when needed, by looking
  up the appropriate class name in the <code>std</code> namespace.
  Depending on the context, an error may be reported if the class is
  not found. It is possible to modify the namespace which is searched
  for these classes using the directive:
  <programlisting language="C++">
#pragma TenDRA++ set std namespace : <emphasis>scope-name</emphasis></programlisting>
  where <emphasis>scope-name</emphasis> can be an identifier giving a namespace name
  or <code>::</code>, indicating the global namespace.
  </para>
  </section>

  <section id="linkage">
    <title>Object linkage</title>
  <para>
  If an object is declared with both external and internal linkage in
  the same translation unit then, by default, an error is given.  This
  behaviour can be changed using the directive:
  <programlisting language="C++">
#pragma TenDRA incompatible linkage <emphasis>allow</emphasis></programlisting>
  When incompatible linkages are allowed, whether the resultant identifier
  has external or internal linkage can be set using one of the directives:
  <programlisting language="C++">
#pragma TenDRA linkage resolution : off
#pragma TenDRA linkage resolution : (external) <emphasis>on</emphasis>
#pragma TenDRA linkage resolution : (internal) <emphasis>on</emphasis></programlisting>
  </para>
  <para>
  It is possible to declare objects with external linkage in a block.
  C leaves it undefined whether declarations of the same object in different
  blocks, such as:
  <programlisting language="C">
void f ()
{
    extern int a ;
    ....
}

void g ()
{
    extern double a ;
    ....
}</programlisting>
  are checked for compatibility.  However in C++ the one definition
  rule implies that such declarations are indeed checked for compatibility.
  The status of this check can be set using the directive:
  <programlisting language="C++">
#pragma TenDRA unify external linkage <emphasis>on</emphasis></programlisting>
  Note that it is not possible in ISO C or C++ to declare objects or
  functions with internal linkage in a block.  While <code>static</code>
  object definitions in a block have a specific meaning, there is no
  real reason why <code>static</code> functions should not be declared
  in a block.  This behaviour can be enabled using the directive:
  <programlisting language="C++">
#pragma TenDRA block function static <emphasis>allow</emphasis></programlisting>
  </para>
  <para>
  Inline functions have external linkage by default in ISO C++, but
  internal linkage in older dialects.  The default linkage can be set
  using the directive:
  <programlisting language="C++">
#pragma TenDRA++ inline linkage <emphasis>linkage-spec</emphasis></programlisting>
  where <emphasis>linkage-spec</emphasis> can be <code>external</code> or
  <code>internal</code>.  Similarly <code>const</code> objects have
  internal linkage by default in C++, but external linkage in C.  The
  default linkage can be set using the directive:
  <programlisting language="C++">
#pragma TenDRA++ const linkage <emphasis>linkage-spec</emphasis></programlisting>
  </para>
  <para>
  Older dialects of C treated all identifiers with external linkage
  as if they had been declared <code>volatile</code> (i.e. by being
  conservative in optimising such values).  This behaviour can be enabled
  using the directive:
  <programlisting language="C++">
#pragma TenDRA external volatile_t</programlisting>
  </para>
  <para>
  It is possible to set the default language linkage using the directive:
  <programlisting language="C++">
#pragma TenDRA++ external linkage <emphasis>string-literal</emphasis></programlisting>
  This is equivalent to enclosing the rest of the current checking scope
  in:
  <programlisting language="C++">
extern <emphasis>string-literal</emphasis> {
    ....
}</programlisting>
  It is unspecified what happens if such a directive is used within
  an explicit linkage specification and does not nest correctly.  This
  directive is particularly useful when used in a <link linkend="scope">named
  environment</link> associated with an include directory.  For example,
  it can be used to express the fact that all the objects declared in
  headers included from that directory have C linkage.
  </para>
  <para>
  A change in ISO C++ relative to older dialects is that the language
  linkage of a function now forms part of the function type.  For example:
  <programlisting language="C++">
extern &quot;C&quot; int f ( int ) ;
int ( *pf ) ( int ) = f ;		// error</programlisting>
  The directive:
  <programlisting language="C++">
#pragma TenDRA++ external function linkage <emphasis>on</emphasis></programlisting>
  can be used to control whether function types with differing language
  linkages, but which are otherwise compatible, are considered compatible
  or not.
  </para>
  </section>

  <section id="static">
    <title>Static identifiers</title>
  <para>
  By default, objects and functions with internal linkage are mapped
  to tags without external names in the output TDF capsule.  Thus such
  names are not available to the installer and it needs to make up internal
  names to represent such objects in its output.  This is not desirable
  in such operations as profiling, where a meaningful internal name
  is needed to make sense of the output.  The directive:
  <programlisting language="C++">
#pragma TenDRA preserve <emphasis>identifier-list</emphasis></programlisting>
  can be used to preserve the names of the given list of identifiers
  with internal linkage.  This is done using the <code>static_name_def</code>
  TDF construct.  The form:
  <programlisting language="C++">
#pragma TenDRA preserve *</programlisting>
  will preserve the names of all identifiers with internal linkage in
  this way.
  </para>
  </section>

  <section id="decl_none">
    <title>Empty declarations</title>
  <para>
  ISO C++ requires every declaration or member declaration to introduce
  one or more names into the program.  The directive:
  <programlisting language="C++">
#pragma TenDRA unknown struct/union <emphasis>allow</emphasis></programlisting>
  can be used to relax one particular instance of this rule, by allowing
  anonymous class definitions (recall that anonymous unions are objects,
  not types, in C++ and so are not covered by this rule).  The C++ grammar
  also allows a solitary semicolon as a declaration or member declaration;
  however such a declaration does not introduce a name and so contravenes
  the rule above.  The rule can be relaxed in this case using the directive:
  <programlisting language="C++">
#pragma TenDRA extra ; <emphasis>allow</emphasis></programlisting>
  Note that the C++ grammar explicitly allows for an extra semicolon
  following an inline member function definition, but that semicolons
  following other function definitions are actually empty declarations
  of the form above.  A solitary semicolon in a statement is interpreted
  as an empty expression statement rather than an empty declaration
  statement.
  </para>
  </section>

  <section id="implicit">
    <title>Implicit <code>int</code></title>
  <para>
  The C &quot;implicit <code>int</code>&quot; rule, whereby a type of
  <code>int</code>
  is inferred in a list of type or declaration specifiers which does
  not contain a type name, has been removed in ISO C++, although it
  was supported in older dialects of C++.  This check is controlled
  by the directive:
  <programlisting language="C++">
#pragma TenDRA++ implicit int type <emphasis>allow</emphasis></programlisting>
  Partial relaxations of this rules are allowed.  The directive:
  <programlisting language="C++">
#pragma TenDRA++ implicit int type for const/volatile <emphasis>allow</emphasis></programlisting>
  will allow for implicit <code>int</code> when the list of type specifiers
  contains a cv-qualifier.  Similarly the directive:
  <programlisting language="C++">
#pragma TenDRA implicit int type for function return <emphasis>allow</emphasis></programlisting>
  will allow for implicit <code>int</code> in the return type of a function
  definition (this excludes constructors, destructors and conversion
  functions, where special rules apply).  A function definition is the
  only kind of declaration in ISO C where a declaration specifier is
  not required. Older dialects of C allowed declaration specifiers to
  be omitted in other cases.  Support for this behaviour can be enabled
  using:
  <programlisting language="C++">
#pragma TenDRA implicit int type for external declaration <emphasis>allow</emphasis></programlisting>
  The four cases can be demonstrated in the following example:
  <programlisting language="C">
extern a ;		// implicit int
const b = 1 ;		// implicit const int

f ()			// implicit function return
{
    return 2 ;
}

c = 3 ;			// error: not allowed in C++</programlisting>
  </para>
  </section>

  <section id="longlong">
    <title>Extended integral types</title>
  <para>
  The <code>long long</code> integral types are not part of ISO C or
  C++ by default, however support for them can be enabled using the
  directive:
  <programlisting language="C++">
#pragma TenDRA longlong type <emphasis>allow</emphasis></programlisting>
  This support includes allowing <code>long long</code> in type specifiers
  and allowing <code>LL</code> and <code>ll</code> as integer literal
  suffixes.
  </para>
  <para>
  There is a further directive given by the two cases:
  <programlisting language="C++">
#pragma TenDRA set longlong type : long long
#pragma TenDRA set longlong type : long</programlisting>
  which can be used to control the implementation of the <code>long
  long</code> types.  Either they can be mapped to the
  <A HREF="lib.html#arith">default representation</A>, which is guaranteed
  to contain at least 64 bits, or they can be mapped to the corresponding
  <code>long</code> types.
  </para>
  <para>
  Because these <code>long long</code> types are not an intrinsic part
  of C++ the implementation does not integrate them into the language
  as fully as is possible.  This is to prevent the presence or otherwise
  of
  <code>long long</code> types affecting the semantics of code which
  does not use them.  For example, it would be possible to extend the
  rules for the types of integer literals, integer promotion types and
  arithmetic types to say that if the given value does not fit into
  the standard integral types then the extended types are tried.  This
  has not been done, although these rules could be implemented by changing
  the definitions of the <A HREF="lib.html#arith">standard tokens</A>
  used to determine these types.  By default, only the rules for arithmetic
  types involving a <code>long long</code> operand and for <code>LL</code>
  integer literals mention <code>long long</code> types.
  </para>
  </section>

  <section id="bitfield-types">
    <title>Bitfield types</title>
  <para>
  The C++ rules on bitfield types differ slightly from the C rules.
  Firstly any integral or enumeration type is allowed in a bitfield,
  and secondly the bitfield width may exceed the underlying type size
  (the extra bits being treated as padding).  These properties can be
  controlled using the directives:
  <programlisting language="C++">
#pragma TenDRA extra bitfield int type <emphasis>allow</emphasis>
#pragma TenDRA bitfield overflow <emphasis>allow</emphasis></programlisting>
  respectively.
  </para>
  </section>

  <section id="elab">
    <title>Elaborated type specifiers</title>
  <para>
  In elaborated type specifiers, the class key (<code>class</code>,
  <code>struct</code>, <code>union</code> or <code>enum</code>) should
  agree with any previous declaration of the type (except that <code>class</code>
  and <code>struct</code> are interchangeable).  This requirement can
  be relaxed using the directive:
  <programlisting language="C++">
#pragma TenDRA ignore struct/union/enum tag <emphasis>on</emphasis></programlisting>
  </para>
  <para>
  In ISO C and C++ it is not possible to give a forward declaration
  of an enumeration type.  This constraint can be relaxed using the
  directive:
  <programlisting language="C++">
#pragma TenDRA forward enum declaration <emphasis>allow</emphasis></programlisting>
  Until the end of its definition, an enumeration type is treated as
  an incomplete type (as with class types).  In enumeration definitions,
  and a couple of other contexts where comma-separated lists are required,
  the directive:
  <programlisting language="C++">
#pragma TenDRA extra , <emphasis>allow</emphasis></programlisting>
  can be used to allow a trailing comma at the end of the list.
  </para>
  <para>
  The directive:
  <programlisting language="C++">
#pragma TenDRA complete struct/union analysis <emphasis>on</emphasis></programlisting>
  can be used to enable a check that every class or union has been completed
  within each translation unit in which it is declared.
  </para>
  </section>

  <section id="impl_func">
    <title>Implicit function declarations</title>
  <para>
  C, but not C++, allows calls to undeclared functions, the function
  being declared implicitly.  It is possible to enable support for implicit
  function declarations using the directive:
  <programlisting language="C++">
#pragma TenDRA implicit function declaration <emphasis>on</emphasis></programlisting>
  Such implicitly declared functions have C linkage and type
  <code>int ( ... )</code>.
  </para>
  </section>

  <section id="weak">
    <title>Weak function prototypes</title>
  <para>
  The C producer supports a concept, weak prototypes, whereby type checking
  can be applied to the arguments of a non-prototype function.  This
  checking can be enabled using the directive:
  <programlisting language="C++">
#pragma TenDRA weak prototype analysis <emphasis>on</emphasis></programlisting>
  The concept of weak prototypes is not applicable to C++, where all
  functions are prototyped.  The C++ producer does allow the syntax
  for explicit weak prototype declarations, but treats them as if they
  were normal prototypes.  These declarations are denoted by means of
  a keyword,
  <code>WEAK</code> say, introduced by the directive:
  <programlisting language="C++">
#pragma TenDRA keyword <emphasis>identifier</emphasis> for weak</programlisting>
  preceding the <code>(</code> of the function declarator.  The directives:
  <programlisting language="C++">
#pragma TenDRA prototype <emphasis>allow</emphasis>
#pragma TenDRA prototype (weak) <emphasis>allow</emphasis></programlisting>
  which can be used in the C producer to warn of prototype or weak prototype
  declarations, are similarly ignored by the C++ producer.
  </para>
  <para>
  The C producer also allows the directives:
  <programlisting language="C++">
#pragma TenDRA argument <emphasis>type-id</emphasis> as <emphasis>type-id</emphasis>
#pragma TenDRA argument <emphasis>type-id</emphasis> as ...
#pragma TenDRA extra ... <emphasis>allow</emphasis>
#pragma TenDRA incompatible promoted function argument <emphasis>allow</emphasis></programlisting>
  which control the compatibility of function types.  These directives
  are ignored by the C++ producer (some of them would make sense in
  the context of C++ but would over-complicate function overloading).
  </para>
  </section>

  <section id="printf">
    <title><code>printf</code> and <code>scanf</code>
  argument checking</title>
  <para>
  The C producer includes a number of checks that the arguments in a
  call to a function in the <code>printf</code> or <code>scanf</code>
  families match the given format string.  The check is implemented
  by using the directives:
  <programlisting language="C++">
#pragma TenDRA type <emphasis>identifier</emphasis> for ... printf
#pragma TenDRA type <emphasis>identifier</emphasis> for ... scanf</programlisting>
  to introduce a type representing a <code>printf</code> or <code>scanf</code>
  format string.  For most purposes this type is treated as <code>const
  char *</code>, but when it appears in a function declaration it alerts
  the producer that any extra arguments passed to that function should
  match the format string passed as the corresponding argument.  The
  TenDRA API headers conditionally declare <code>printf</code>,
  <code>scanf</code> and similar functions in something like the form:
  <programlisting language="C++">
#ifdef __NO_PRINTF_CHECKS
typedef const char *__printf_string ;
#else
#pragma TenDRA type __printf_string for ... printf
#endif

int printf ( __printf_string, ... ) ;
int fprintf ( FILE *, __printf_string, ... ) ;
int sprintf ( char *, __printf_string, ... ) ;</programlisting>
  These declarations can be skipped, effectively disabling this check,
  by defining the <code>__NO_PRINTF_CHECKS</code> macro.
  </para>
	<warning>
  <para>
  These <code>printf</code> and <code>scanf</code> format string checks
  have not yet been implemented in the C++ producer due to presence
  of an alternative, type checked, I/O package - namely
  <code>&lt;iostream&gt;</code>.  The format string types are simply
  treated as <code>const char *</code>.
  </para>
	</warning>
  </section>

  <section id="typedef">
    <title>Type declarations</title>
  <para>
  C does not allow multiple definitions of a <code>typedef</code> name,
  whereas C++ allows multiple consistent definitions.  This behaviour
  can be controlled using the directive:
  <programlisting language="C++">
#pragma TenDRA extra type definition <emphasis>allow</emphasis></programlisting>
  </para>
  </section>

  <section id="compatible">
    <title>Type compatibility</title>
  <para>
  The directive:
  <programlisting language="C++">
#pragma TenDRA incompatible type qualifier <emphasis>allow</emphasis></programlisting>
  allows objects to be redeclared with different cv-qualifiers (normally
  such redeclarations would be incompatible).  The composite type is
  qualified using the join of the cv-qualifiers in the various redeclarations.
  </para>
  <para>
  The directive:
  <programlisting language="C++">
#pragma TenDRA compatible type : <emphasis>type-id</emphasis> == <emphasis>type-id</emphasis> : <emphasis>allow</emphasis></programlisting>
  asserts that the given two types are compatible.  Currently the only
  implemented version is <code>char * == void *</code> which enables
  <code>char *</code> to be used as a generic pointer as it was in older
  dialects of C.
  </para>
  </section>

  <section id="complete">
    <title>Incomplete types</title>
  <para>
  Some dialects of C allow incomplete arrays as member types.  These
  are generally used as a place-holder at the end of a structure to
  allow for the allocation of an arbitrarily sized array.  Support for
  this feature can be enabled using the directive:
  <programlisting language="C++">
#pragma TenDRA incomplete type as object type <emphasis>allow</emphasis></programlisting>
  </para>
  </section>

  <section id="type-conversions">
    <title>Type conversions</title>
  <para>
  There are a number of directives which allow various classes of type
  conversion to be checked.  The directives:
  <programlisting language="C++">
#pragma TenDRA conversion analysis (int-int explicit) <emphasis>on</emphasis>
#pragma TenDRA conversion analysis (int-int implicit) <emphasis>on</emphasis></programlisting>
  will check for unsafe explicit or implicit conversions between arithmetic
  types.  Similarly conversions between pointers and arithmetic types
  can be checked using:
  <programlisting language="C++">
#pragma TenDRA conversion analysis (int-pointer explicit) <emphasis>on</emphasis>
#pragma TenDRA conversion analysis (int-pointer implicit) <emphasis>on</emphasis></programlisting>
  or equivalently:
  <programlisting language="C++">
#pragma TenDRA conversion analysis (pointer-int explicit) <emphasis>on</emphasis>
#pragma TenDRA conversion analysis (pointer-int implicit) <emphasis>on</emphasis></programlisting>
  Conversions between pointer types can be checked using:
  <programlisting language="C++">
#pragma TenDRA conversion analysis (pointer-pointer explicit) <emphasis>on</emphasis>
#pragma TenDRA conversion analysis (pointer-pointer implicit) <emphasis>on</emphasis></programlisting>
  </para>
  <para>
  There are some further variants which can be used to enable useful
  sets of conversion checks.  For example:
  <programlisting language="C++">
#pragma TenDRA conversion analysis (int-int) <emphasis>on</emphasis></programlisting>
  enables both implicit and explicit arithmetic conversion checks.
  The directives:
  <programlisting language="C++">
#pragma TenDRA conversion analysis (int-pointer) <emphasis>on</emphasis>
#pragma TenDRA conversion analysis (pointer-int) <emphasis>on</emphasis>
#pragma TenDRA conversion analysis (pointer-pointer) <emphasis>on</emphasis></programlisting>
  are equivalent to their corresponding explicit forms (because the
  implicit forms are illegal by default).  The directive:
  <programlisting language="C++">
#pragma TenDRA conversion analysis <emphasis>on</emphasis></programlisting>
  is equivalent to the four directives just given.  It enables checks
  on implicit and explicit arithmetic conversions, explicit arithmetic
  to pointer conversions and explicit pointer conversions.
  </para>
  <para>
  The default settings for these checks are determined by the implicit
  and explicit conversions allowed in C++.  Note that there are differences
  between the conversions allowed in C and C++.  For example, an arithmetic
  type can be converted implicitly to an enumeration type in C, but
  not in C++.  The directive:
  <programlisting language="C++">
#pragma TenDRA conversion analysis (int-enum implicit) <emphasis>on</emphasis></programlisting>
  can be used to control the status of this conversion.  The level of
  severity for an error message arising from such a conversion is the
  maximum of the severity set by this directive and that set by the
  <code>int-int implicit</code> directive above.
  </para>
  <para>
  The implicit pointer conversions described above do not include conversions
  to and from the generic pointer <code>void *</code>, which have their
  own controlling directives.  A pointer of type <code>void *</code>
  can be converted implicitly to another pointer type in C but not in
  C++; this is controlled by the directive:
  <programlisting language="C++">
#pragma TenDRA++ conversion analysis (void*-pointer implicit) <emphasis>on</emphasis></programlisting>
  The reverse conversion, from a pointer type to <code>void *</code>
  is allowed in both C and C++, and has a controlling directive:
  <programlisting language="C++">
#pragma TenDRA++ conversion analysis (pointer-void* implicit) <emphasis>on</emphasis></programlisting>
  </para>
  <para>
  In ISO C and C++, a function pointer can only be cast to other function
  pointers, not to object pointers or <code>void *</code>.  Many dialects
  however allow function pointers to be cast to and from other pointers.
  This behaviour can be controlled using the directive:
  <programlisting language="C++">
#pragma TenDRA function pointer as pointer <emphasis>allow</emphasis></programlisting>
  which causes function pointers to be treated in the same way as all
  other pointers.
  </para>
  <para>
  The integer conversion checks described above only apply to unsafe
  conversions.  A simple-minded check for shortening conversions is
  not adequate, as is shown by the following example:
  <programlisting language="C++">
char a = 1, b = 2 ;
char c = a + b ;</programlisting>
  the sum <code>a + b</code> is evaluated as an <code>int</code> which
  is then shortened to a <code>char</code>.  Any check which does not
  distinguish this sort of &quot;safe&quot; shortening conversion from
  unsafe shortening conversions such as:
  <programlisting language="C++">
int a = 1, b = 2 ;
char c = a + b ;</programlisting>
  is not likely to be very useful.  The producer therefore associates
  two types with each integral expression; the first is the normal,
  representation type and the second is the underlying, semantic type.
  Thus in the first example, the representation type of <code>a + b</code>
  is <code>int</code>, but semantically it is still a <code>char</code>.
  The conversion analysis is based on the semantic types.
  </para>
	<warning>
  <para>The C producer supports a directive:
  <programlisting language="C++">
#pragma TenDRA keyword <emphasis>identifier</emphasis> for type representation</programlisting>
  whereby a keyword can be introduced which can be used to explicitly
  declare a type with given representation and semantic components.
  Unfortunately this makes the <A HREF="parse.html">C++ grammar</A>
  ambiguous, so it has not yet been implemented in the C++ producer.
  </para>
	</warning>
  <para>
  It is possible to allow individual conversions by means of conversion
  tokens.  A <A HREF="token.html">procedure token</A> which takes one
  rvalue expression program parameter and returns an rvalue expression,
  such as:
  <programlisting language="C++">
#pragma token PROC ( EXP : t : ) EXP : s : conv #</programlisting>
  can be regarded as mapping expressions of type <code>t</code> to expressions
  of type <code>s</code>.  The directive:
  <programlisting language="C++">
#pragma TenDRA conversion <emphasis>identifier-list</emphasis> allow</programlisting>
  can be used to nominate such a token as a conversion token.  That
  is to say, if the conversion, whether explicit or implicit, from <code>t</code>
  to <code>s</code> cannot be done by other means, it is done by applying
  the token <code>conv</code>, so:
  <programlisting language="C++">
t a ;
s b = a ;		// maps to conv ( a )</programlisting>
  Note that, unlike conversion functions, conversion tokens can be applied
  to any types.
  </para>
  </section>

  <section id="cast">
    <title>Cast expressions</title>
  <para>
  ISO C++ introduces the constructs <code>static_cast</code>,
  <code>const_cast</code> and <code>reinterpret_cast</code>, which can
  be used in various contexts where an old style explicit cast would
  previously have been used.  By default, an explicit cast can perform
  any combination of the conversions performed by these three constructs.
  To aid migration to the new style casts the directives:
  <programlisting language="C++">
#pragma TenDRA++ explicit cast as <emphasis>cast-state allow</emphasis>
#pragma TenDRA++ explicit cast <emphasis>allow</emphasis></programlisting>
  where <emphasis>cast-state</emphasis> is defined as follows:
  <programlisting language="BNF">
<emphasis>cast-state</emphasis> :
	static_cast
	const_cast
	reinterpret_cast
	static_cast | <emphasis>cast-state</emphasis>
	const_cast | <emphasis>cast-state</emphasis>
	reinterpret_cast | <emphasis>cast-state</emphasis></programlisting>
  can be used to restrict the conversions which can be performed using
  explicit casts.  The first form sets the interpretation of explicit
  cast to be combinations of the given constructs; the second resets
  the interpretation to the default.  For example:
  <programlisting language="C++">
#pragma TenDRA++ explicit cast as static_cast | const_cast allow</programlisting>
  means that conversions requiring <code>reinterpret_cast</code> (the
  most unportable conversions) will not be allowed to be performed using
  explicit casts, but will have to be given as a <code>reinterpret_cast</code>
  construct.  Changing <code>allow</code> to <code>warning</code> will
  also cause a warning to be issued for every explicit cast expression.
  </para>
  </section>

  <section id="ellipsis">
    <title>Ellipsis functions</title>
  <para>
  The directive:
  <programlisting language="C++">
#pragma TenDRA ident ... <emphasis>allow</emphasis></programlisting>
  may be used to enable or disable the use of <code>...</code> as a
  primary expression in a function defined with ellipsis.  The type
  of such an expression is implementation defined.  This expression
  is used in the definition of the <A HREF="lib.html#ellipsis"><code>va_start
  </code>
  macro</A> in the <code>&lt;stdarg.h&gt;</code> header.  This header
  automatically enables this switch.
  </para>
  </section>

  <section id="overload">
    <title>Overloaded functions</title>
  <para>
  Older dialects of C++ did not report ambiguous overloaded function
  resolutions, but instead resolved the call to the first of the most
  viable candidates to be declared.  This behaviour can be controlled
  using the directive:
  <programlisting language="C++">
#pragma TenDRA++ ambiguous overload resolution <emphasis>allow</emphasis></programlisting>
  There are occasions when the resolution of an overloaded function
  call is not clear.  The directive:
  <programlisting language="C++">
#pragma TenDRA++ overload resolution <emphasis>allow</emphasis></programlisting>
  can be used to report the resolution of any such call (whether explicit
  or implicit) where there is more than one viable candidate.
  </para>
  <para>
  An interesting consequence of compiling C++ in a target independent
  manner is that certain overload resolutions can only be determined
  at install-time. For example, in:
  <programlisting language="C++">
int f ( int ) ;
int f ( unsigned int ) ;
int f ( long ) ;
int f ( unsigned long ) ;

int a = f ( sizeof ( int ) ) ;	// which f?</programlisting>
  the type of the <code>sizeof</code> operator, <code>size_t</code>,
  is target dependent, but its promotion must be one of the types
  <code>int</code>, <code>unsigned int</code>, <code>long</code> or
  <code>unsigned long</code>.  Thus the call to <code>f</code> always
  has a unique resolution, but what it is is target dependent.  The
  equivalent directives:
  <programlisting language="C++">
#pragma TenDRA++ conditional overload resolution <emphasis>allow</emphasis>
#pragma TenDRA++ conditional overload resolution (complete) <emphasis>allow</emphasis></programlisting>
  can be used to warn about such target dependent overload resolutions.
  By default, such resolutions are only allowed if there is a unique
  resolution for each possible implementation of the argument types
  (note that, for simplicity, the possibility of <code>long long</code>
  implementation types is ignored).  The directive:
  <programlisting language="C++">
#pragma TenDRA++ conditional overload resolution (incomplete) <emphasis>allow</emphasis></programlisting>
  can be used to allow target dependent overload resolutions which only
  have resolutions for some of the possible implementation types (if
  one of the <code>f</code> declarations above was removed, for example).
  If the implementation does not match one of these types then an install-time
  error is given.
  </para>
  <para>
  There are restrictions on the set of candidate functions involved
  in a target dependent overload resolution.  Most importantly, it should
  be possible to bring their return types to a common type, as if by
  a series of <code>?:</code> operations.  This common type is the type
  of the target dependent call.  By this means, target dependent types
  are prevented from propagating further out into the program.  Note
  that since sets of overloaded functions usually have the same semantics,
  this does not usually present a problem.
  </para>
  </section>

  <section id="expressions">
    <title>Expressions</title>
  <para>
  The directive:
  <programlisting language="C++">
#pragma TenDRA operator precedence analysis <emphasis>on</emphasis></programlisting>
  can be used to enable a check for expressions where the operator precedence
  is not necessarily what might be expected.  The intended precedence
  can be clarified by means of explicit parentheses.  The precedence
  levels checked are as follows:
  <itemizedlist>
  <listitem><code>&amp;&amp;</code> versus <code>||</code>.
  </listitem>
  <listitem><code>&lt;&lt;</code> and <code>&gt;&gt;</code> versus binary
  <code>+</code> and <code>-</code>.
  </listitem>
  <listitem>Binary <code>&amp;</code> versus binary <code>+</code>,     <code>-</code>,
  <code>==</code>, <code>!=</code>, <code>&gt;</code>,     <code>&gt;=</code>,
  <code>&lt;</code> and <code>&lt;=</code>.
  </listitem>
  <listitem><code>^</code> versus binary <code>&amp;</code>, <code>+</code>,
  <code>-</code>, <code>==</code>, <code>!=</code>, <code>&gt;</code>,
  <code>&gt;=</code>, <code>&lt;</code> and <code>&lt;=</code>.
  </listitem>
  <listitem><code>|</code> versus binary <code>^</code>, <code>&amp;</code>,
  <code>+</code>, <code>-</code>, <code>==</code>, <code>!=</code>,
  <code>&gt;</code>, <code>&gt;=</code>, <code>&lt;</code> and     <code>&lt;=
  </code>.
  </listitem>
  </itemizedlist>
  Also checked are expressions such as <code>a &lt; b &lt; c</code>
  which do not have their normal mathematical meaning.  For example,
  in:
  <programlisting language="C++">
d = a &lt;&lt; b + c ;	// precedence is a &lt;&lt; ( b + c )</programlisting>
  the precedence is counter-intuitive, although strangely enough, it
  isn't in:
  <programlisting language="C++">
cout &lt;&lt; b + c ;		// precedence is cout &lt;&lt; ( b + c )</programlisting>
  </para>
  <para>
  Other dubious arithmetic operations can be checked for using the directive:
  <programlisting language="C++">
#pragma TenDRA integer operator analysis <emphasis>on</emphasis></programlisting>
  This includes checks for operations, such as division by a negative
  value, which are implementation dependent, and those such as testing
  whether an unsigned value is less than zero, which serve no purpose.
  Similarly the directive:
  <programlisting language="C++">
#pragma TenDRA++ pointer operator analysis <emphasis>on</emphasis></programlisting>
  checks for dubious pointer operations.  This includes very simple
  bounds checking for arrays and checking that only the simple literal
  <code>0</code>
  is used in null pointer constants:
  <programlisting language="C++">
char *p = 1 - 1 ;	// valid, but weird</programlisting>
  </para>
  <para>
  The directive:
  <programlisting language="C++">
#pragma TenDRA integer overflow analysis <emphasis>on</emphasis></programlisting>
  is used to control the treatment of overflows in the evaluation of
  integer constant expressions.  This includes the detection of division
  by zero.
  </para>
  </section>

  <section id="initialiser-expressions">
    <title>Initialiser expressions</title>
  <para>
  C, but not C++, only allows constant expressions in static initialisers.
  The directive:
  <programlisting language="C++">
#pragma TenDRA variable initialization <emphasis>allow</emphasis></programlisting>
  can be enable support for C++-style dynamic initialisers.  Conversely,
  it can be used in C++ to detect such dynamic initialisers.
  </para>
  <para>
  In older dialects of C it was not possible to initialise an automatic
  variable of structure or union type.  This can be checked for using
  the directive:
  <programlisting language="C++">
#pragma TenDRA initialization of struct/union (auto) <emphasis>allow</emphasis></programlisting>
  </para>
  <para>
  The directive:
  <programlisting language="C++">
#pragma TenDRA++ complete initialization analysis <emphasis>on</emphasis></programlisting>
  can be used to check aggregate initialisers.  The initialiser should
  be fully bracketed (i.e. with no elision of braces), and should have
  an entry for each member of the structure or array.
  </para>
  </section>

  <section id="lvalue">
    <title>Lvalue expressions</title>
  <para>
  C++ defines the results of several operations to be lvalues, whereas
  they are rvalues in C.  The directive:
  <programlisting language="C++">
#pragma TenDRA conditional lvalue <emphasis>allow</emphasis></programlisting>
  is used to apply the C++ rules for lvalues in conditional (<code>?:</code>)
  expressions.
  </para>
  <para>
  Older dialects of C++ allowed <code>this</code> to be treated as an
  lvalue. It is possible to enable support for this dialect feature
  using the directive:
  <programlisting language="C++">
#pragma TenDRA++ this lvalue <emphasis>allow</emphasis></programlisting>
  however it is recommended that programs using this feature should
  be modified.
  </para>
  </section>

  <section id="discard">
    <title>Discarded expressions</title>
  <para>
  The directive:
  <programlisting language="C++">
#pragma TenDRA discard analysis <emphasis>on</emphasis></programlisting>
  can be used to enable a check for values which are calculated but
  not used.  There are three checks controlled by this directive, each
  of which can be controlled independently.  The directive:
  <programlisting language="C++">
#pragma TenDRA discard analysis (function return) <emphasis>on</emphasis></programlisting>
  checks for functions which return a value which is not used.  The
  check needs to be enabled for both the declaration and the call of
  the function in order for a discarded function return to be reported.
  Discarded returns for overloaded operator functions are never reported.
  The directive:
  <programlisting language="C++">
#pragma TenDRA discard analysis (value) <emphasis>on</emphasis></programlisting>
  checks for other expressions which are not used.  Finally, the directive:
  <programlisting language="C++">
#pragma TenDRA discard analysis (static) <emphasis>on</emphasis></programlisting>
  checks for variables with internal linkage which are defined but not
  used.
  </para>
  <para>
  An unused function return or other expression can be asserted to be
  deliberately discarded by explicitly casting it to <code>void</code>
  or, equivalently, preceding it by a keyword introduced using the directive:
  <programlisting language="C++">
#pragma TenDRA keyword <emphasis>identifier</emphasis> for discard value</programlisting>
  A static variable can be asserted to be deliberately unused by including
  it in list of identifiers in a directive of the form:
  <programlisting language="C++">
#pragma TenDRA suspend static <emphasis>identifier-list</emphasis></programlisting>
  </para>
  </section>

  <section id="if">
    <title>Conditional and iteration statements</title>
  <para>
  The directive:
  <programlisting language="C++">
#pragma TenDRA const conditional <emphasis>allow</emphasis></programlisting>
  can be used to enable a check for constant expressions used in conditional
  contexts.  A literal constant is allowed in the condition of a <code>while
  </code>, <code>for</code> or <code>do</code> statement to allow for
  such common constructs as:
  <programlisting language="C++">
while ( true ) {
    // while statement body
}</programlisting>
  and target dependent constant expressions are allowed in the condition
  of an <code>if</code> statement, but otherwise constant conditions
  are reported according to the status of this check.
  </para>
  <para>
  The common error of writing <code>=</code> rather than <code>==</code>
  in conditions can be detected using the directive:
  <programlisting language="C++">
#pragma TenDRA assignment as bool <emphasis>allow</emphasis></programlisting>
  which can be used to disallow such assignment expressions in contexts
  where a boolean is expected.  The error message can be suppressed
  by enclosing the assignment within parentheses.
  </para>
  <para>
  Another common error associated with iteration statements, particularly
  with certain <A HREF="style.html">heretical</A> brace styles, is the
  accidental insertion of an extra semicolon as in:
  <programlisting language="C++">
for ( init ; cond ; step ) ;
{
    // for statement body
}</programlisting>
  The directive:
  <programlisting language="C++">
#pragma TenDRA extra ; after conditional <emphasis>allow</emphasis></programlisting>
  can be used to enable a check for such suspicious empty iteration
  statement bodies (it actually checks for <code>;{</code>).
  </para>
  </section>

  <section id="switch">
    <title>Switch statements</title>
  <para>
  A <code>switch</code> statement is said to be exhaustive if its control
  statement is guaranteed to take one of the values of its
  <code>case</code> labels, or if it has a <code>default</code> label.
  The TenDRA C and C++ producers allow a <code>switch</code> statement
  to be asserted to be exhaustive using the syntax:
  <programlisting language="C++">
switch ( cond ) EXHAUSTIVE {
    // switch statement body
}</programlisting>
  where <code>EXHAUSTIVE</code> is either the directive:
  <programlisting language="C++">
#pragma TenDRA exhaustive</programlisting>
  or a keyword introduced using:
  <programlisting language="C++">
#pragma TenDRA keyword <emphasis>identifier</emphasis> for exhaustive</programlisting>
  Knowing whether a <code>switch</code> statement is exhaustive or not
  means that checks relying on flow analysis (including variable usage
  checks) can be applied more precisely.
  </para>
  <para>
  In certain circumstances it is possible to deduce whether a
  <code>switch</code> statement is exhaustive or not.  For example,
  the directive:
  <programlisting language="C++">
#pragma TenDRA enum switch analysis <emphasis>on</emphasis></programlisting>
  enables a check on <code>switch</code> statements on values of enumeration
  type.  Such statements should be exhaustive, either explicitly by
  using the <code>EXHAUSTIVE</code> keyword or declaring a
  <code>default</code> label, or implicitly by having a <code>case</code>
  label for each enumerator.  Conversely, the value of each <code>case</code>
  label should equal the value of an enumerator.  For the purposes of
  this check, boolean values are treated as if they were declared using
  an enumeration type of the form:
  <programlisting language="C++">
enum bool { false = 0, true = 1 } ;</programlisting>
  </para>
  <para>
  A common source of errors in <code>switch</code> statements is the
  fall-through from one <code>case</code> or <code>default</code>
  statement to the next.  A check for this can be enabled using:
  <programlisting language="C++">
#pragma TenDRA fall into case <emphasis>allow</emphasis></programlisting>
  <code>case</code> or <code>default</code> labels where fall-through
  from the previous statement is intentional can be marked by preceding
  them by a keyword, <code>FALL_THRU</code> say, introduced using the
  directive:
  <programlisting language="C++">
#pragma TenDRA keyword <emphasis>identifier</emphasis> for fall into case</programlisting>
  </para>
  </section>

  <section id="for">
    <title>For statements</title>
  <para>
  In ISO C++ the scope of a variable declared in a for-init-statement
  is the body of the <code>for</code> statement; in older dialects it
  extended to the end of the enclosing block.  So:
  <programlisting language="C++">
for ( int i = 0 ; i &lt; 10 ; i++ ) {
    // for statement body
}
return i ;	// OK in older dialects, error in ISO C++</programlisting>
  This behaviour is controlled by the directive:
  <programlisting language="C++">
#pragma TenDRA++ for initialization block <emphasis>on</emphasis></programlisting>
  a state of <code>on</code> corresponding to the ISO rules and
  <code>off</code> to the older rules.  Perhaps most useful is the
  <code>warning</code> state which implements the old rules but gives
  a warning if a variable declared in a for-init-statement is used outside
  the corresponding <code>for</code> statement body.  A program which
  does not give such warnings should compile correctly under either
  set of rules.
  </para>
  </section>

  <section id="return">
    <title>Return statements</title>
  <para>
  In C, but not in C++, it is possible to have a <code>return</code>
  statement without an expression in a function which does not return
  <code>void</code>.  It is possible to enable this behaviour using
  the directive:
  <programlisting language="C++">
#pragma TenDRA incompatible void return <emphasis>allow</emphasis></programlisting>
  Note that this check includes the implicit <code>return</code> caused
  by falling off the end of a function.  The effect of such a
  <code>return</code> statement is undefined.  The C++ rule that falling
  off the end of <code>main</code> is equivalent to returning a value
  of 0 overrides this check.
  </para>
  </section>

  <section id="reach">
    <title>Unreached code analysis</title>
  <para>
  The directive:
  <programlisting language="C++">
#pragma TenDRA unreachable code <emphasis>allow</emphasis></programlisting>
  enables a flow analysis check to detect unreachable code.  It is possible
  to assert that a statement is reached or not reached by preceding
  it by a keyword introduced by one of the directives:
  <programlisting language="C++">
#pragma TenDRA keyword <emphasis>identifier</emphasis> for set reachable
#pragma TenDRA keyword <emphasis>identifier</emphasis> for set unreachable</programlisting>
  </para>
  <para>
  The fact that certain functions, such as <code>exit</code>, do not
  return a value can be exploited in the flow analysis routines.  The
  equivalent directives:
  <programlisting language="C++">
#pragma TenDRA bottom <emphasis>identifier</emphasis>
#pragma TenDRA++ type <emphasis>identifier</emphasis> for bottom</programlisting>
  can be used to introduce a <code>typedef</code> declaration for the
  type, bottom, returned by such functions.  The TenDRA API headers
  declare
  <code>exit</code> and similar functions in this way, for example:
  <programlisting language="C++">
#pragma TenDRA bottom __bottom
__bottom exit ( int ) ;
__bottom abort ( void ) ;</programlisting>
  The bottom type is compatible with <code>void</code> in function declarations
  to allow such functions to be redeclared in their conventional form.
  </para>
  </section>

  <section id="variable">
    <title>Variable flow analysis</title>
  <para>
  The directive:
  <programlisting language="C++">
#pragma TenDRA variable analysis <emphasis>on</emphasis></programlisting>
  enables checks on the uses of automatic variables and function parameters.
  These checks detect:
  <itemizedlist>
  <listitem>If a variable is not used in its scope.
  </listitem>
  <listitem>If the value of a variable is used before it has been assigned
  to.
  </listitem>
  <listitem>If a variable is assigned to twice without an intervening use.
  </listitem>
  <listitem>If a variable is assigned to twice without an intervening sequence
  point.
  </listitem>
  </itemizedlist>
  as illustrated by the variables <code>a</code>, <code>b</code>,
  <code>c</code> and <code>d</code> respectively in:
  <programlisting language="C++">
void f ()
{
    int a ;			// a never used
    int b ;
    int c = b ;			// b not initialised
    c = 0 ;			// c assigned to twice
    int d = 0 ;
    d = ++d ;			// d assigned to twice
}</programlisting>
  The second, and more particularly the third, of these checks requires
  some fairly sophisticated flow analysis, so any hints which can be
  picked up from <link linkend="switch">exhaustive <code>switch</code>
  statements</link> etc. is likely to increase the accuracy of the errors
  detected.
  </para>
  <para>
  In a non-static member function the various non-static data members
  are analysed as if they were automatic variables.  It is checked that
  each member is initialised in a constructor.  A common source of initialisation
  problems in a constructor is that the base classes and members are
  initialised in the canonical order of virtual bases, non-virtual direct
  bases and members in the order of their declaration, rather than in
  the order in which their initialisers appear in the constructor definition.
  Therefore a check that the initialisers appear in the canonical order
  is also applied.
  </para>
  <para>
  It is possible to change the state of a variable during the variable
  analysis using the directives:
  <programlisting language="C++">
#pragma TenDRA set <emphasis>expression</emphasis>
#pragma TenDRA discard <emphasis>expression</emphasis></programlisting>
  The first asserts that the variable given by the <emphasis>expression</emphasis>
  has been assigned to; the second asserts that the variable is not
  used.  An alternative way of expressing this is by means of keywords:
  <programlisting language="C++">
SET ( <emphasis>expression</emphasis> )
DISCARD ( <emphasis>expression</emphasis> )</programlisting>
  introduced using the directives.
  <programlisting language="C++">
#pragma TenDRA keyword <emphasis>identifier</emphasis> for set
#pragma TenDRA keyword <emphasis>identifier</emphasis> for discard variable</programlisting>
  respectively.  These expressions can appear in expression statements
  and as the first argument of a comma expression.
  </para>
	<warning>
  <para>The variable flow analysis checks have not yet been completely implemented.
  They may not detect errors in certain circumstances and for extremely
  convoluted code may occasionally give incorrect errors.</para>
	</warning>
  </section>

  <section id="hide">
    <title>Variable hiding</title>
  <para>
  The directive:
  <programlisting language="C++">
#pragma TenDRA variable hiding analysis <emphasis>on</emphasis></programlisting>
  can be used to enable a check for hiding of other variables and, in
  member functions, data members, by local variable declarations.
  </para>
  </section>

  <section id="exception">
    <title>Exception analysis</title>
  <para>
  The ISO C++ rules do not require exception specifications to be checked
  statically.  This is to facilitate the integration of large systems
  where a single change in an exception specification could have ramifications
  throughout the system.  However it is often useful to apply such checks,
  which can be enabled using the directive:
  <programlisting language="C++">
#pragma TenDRA++ throw analysis <emphasis>on</emphasis></programlisting>
  This detects any potentially uncaught exceptions and other exception
  problems.  In the error messages arising from this check, an uncaught
  exception of type <code>...</code> means that an uncaught exception
  of an unknown type (arising, for example, from a function without
  an exception specification) may be thrown.  For example:
  <programlisting language="C++">
void f ( int ) throw ( int ) ;
void g ( int ) throw ( long ) ;
void h ( int ) ;

void e () throw ( int )
{
    f ( 1 ) ;			// OK
    g ( 2 ) ;			// uncaught 'long' exception
    h ( 3 ) ;			// uncaught '...' exception
}</programlisting>
  </para>
  </section>

  <section id="template">
    <title>Template compilation</title>
  <para>
  The C++ producer makes the distinction between exported templates,
  which may be used in one module and defined in another, and non-exported
  templates, which must be defined in every module in which they are
  used. As in the ISO C++ standard, the <code>export</code> keyword
  is used to distinguish between the two cases.  In the past, different
  compilers have had different template compilation models; either all
  templates were exported or no templates were exported.  The latter
  is easily emulated - if the <code>export</code> keyword is not used
  then no templates will be exported.  To emulate the former behaviour
  the directive:
  <programlisting language="C++">
#pragma TenDRA++ implicit export template <emphasis>on</emphasis></programlisting>
  can be used to treat all templates as if they had been declared using
  the <code>export</code> keyword.
  </para>
	<warning>
  <para>The automatic instantiation of exported templates has not yet been
  implemented correctly.  It is intended that such instantiations will
  be generated during <A HREF="link.html">intermodule analysis</A>
  (where they conceptually belong).  At present it is necessary to work
  round this using explicit instantiations.</para>
	</warning>
  </section>

  <section id="catch_all">
    <title>Other checks</title>
  <para>
  Several checks of varying utility have been implemented in the C++
  producer but do not as yet have individual directives controlling
  their use.  These can be enabled <emphasis>en masse</emphasis> using the directive:
  <programlisting language="C++">
#pragma TenDRA++ catch all <emphasis>allow</emphasis></programlisting>
  It is intended that this directive will be phased out as these checks
  are assigned controlling directives.  It is possible to achieve finer
  control over these checks by enabling their individual error messages
  <link linkend="low">as described above</link>.
  </para>
  </section>
  </section>

  <section id="token">
    <title>Token syntax</title>
  <para>
  The C and C++ producers allow place-holders for various categories
  of syntactic classes to be expressed using directives of the form:
  <programlisting language="C++">
#pragma TenDRA token <emphasis>token-spec</emphasis></programlisting>
  or simply:
  <programlisting language="C++">
#pragma token <emphasis>token-spec</emphasis></programlisting>
  These place-holders are represented as TDF tokens and hence are called
  tokens.  These tokens stand for a certain type, expression or whatever
  which is to be represented by a certain named TDF token in the producer
  output.  This mechanism is used, for example, to allow C API specifications
  to be represented target independently.  The types, functions and
  expressions comprising the API can be described using <code>#pragma
  token</code> directives and the target dependent definitions of these
  tokens, representing the implementation of the API on a particular
  machine, can be linked in later.  This mechanism is described in detail
  elsewhere.
  </para>
  <para>
  A <A HREF="pragma1.html#token">summary of the grammar</A> for the
  <code>#pragma token</code> directives accepted by the C++ producer
  is given as an annex.
  </para>


  <section id="spec">
    <title>Token specifications</title>
  <para>
  A token specification is divided into two components, a
  <emphasis>token-introduction</emphasis> giving the token sort, and a
  <emphasis>token-identification</emphasis> giving the internal and external token
  names:
  <programlisting language="BNF">
<emphasis>token-spec</emphasis> :
	<emphasis>token-introduction token-identification</emphasis>

<emphasis>token-introduction</emphasis> :
	<emphasis>exp-token</emphasis>
	<emphasis>statement-token</emphasis>
	<emphasis>type-token</emphasis>
	<emphasis>member-token</emphasis>
	<emphasis>procedure-token</emphasis>

<emphasis>token-identification</emphasis> :
	<emphasis>token-namespace<subscript>opt</subscript> identifier</emphasis> # <emphasis>external-identifier<subscript>opt</subscript></emphasis>

<emphasis>token-namespace</emphasis> :
	TAG

<emphasis>external-identifier</emphasis> :
	-
	<emphasis>preproc-token-list</emphasis></programlisting>
  The <code>TAG</code> qualifier is used to indicate that the internal
  name lies in the C tag namespace.  This only makes sense for structure
  and union types.  The external token name can be given by any sequence
  of preprocessing tokens.  These tokens are not macro expanded.  If
  no external name is given then the internal name is used.  The special
  external name <code>-</code> is used to indicate that the token does
  not have an associated external name, and hence is local to the current
  translation unit.  Such a local token must be defined.  White space
  in the external name (other than at the start or end) is used to indicate
  that a TDF unique name should be used.  The white space serves as
  a separator for the unique name components.
  </para>

<section id="expression-tokens">
	<title>Expression tokens</title>

  <para>
  Expression tokens are specified as follows:
  <programlisting language="BNF">
<emphasis>exp-token</emphasis> :
	EXP <emphasis>exp-storage<subscript>opt</subscript></emphasis> : <emphasis>type-id</emphasis> :
	NAT
	INTEGER</programlisting>
  representing a expression of the given type, a non-negative integer
  constant and general integer constant, respectively.  Each expression
  has an associated storage class:
  <programlisting language="BNF">
<emphasis>exp-storage</emphasis> :
	lvalue
	rvalue
	const</programlisting>
  indicating whether it is an lvalue, an rvalue or a compile-time constant
  expression.  An absent <emphasis>exp-storage</emphasis> is equivalent to
  <code>rvalue</code>.  All expression tokens lie in the macro namespace;
  that is, they may potentially be defined as macros.
  </para>
  <para>
  For backwards compatibility with the C producer, the directive:
  <programlisting language="C++">
#pragma TenDRA++ rvalue token as const <emphasis>allow</emphasis></programlisting>
  causes <code>rvalue</code> tokens to be treated as <code>const</code>
  tokens.</para>
</section>

<section>
	<title>Statement tokens</title>
  <para>
  Statement tokens are specified as follows:
  <programlisting language="BNF">
<emphasis>statement-token</emphasis> :
	STATEMENT</programlisting>
  All statement tokens lie in the macro namespace.
  </para>
</section>

<section>
	<title>Type tokens</title>
  <para>
  Type tokens are specified as follows:
  <programlisting language="BNF">
<emphasis>type-token</emphasis> :
	TYPE
	VARIETY
	VARIETY signed
	VARIETY unsigned
	FLOAT
	ARITHMETIC
	SCALAR
	CLASS
	STRUCT
	UNION</programlisting>
  representing a generic type, an integral type, a signed integral type,
  an unsigned integral type, a floating point type, an arithmetic (integral
  or floating point) type, a scalar (arithmetic or pointer) type, a
  class type, a structure type and a union type respectively.
  </para>
	<warning>
  <para>Floating-point, arithmetic and scalar token types have not yet been
  implemented correctly in either the C or C++ producers.</para>
	</warning>
</section>

<section id="member-tokens">
	<title>Member tokens</title>
  <para>
  Member tokens are specified as follows:
  <programlisting language="BNF">
<emphasis>member-token</emphasis> :
	MEMBER <emphasis>access-specifier<subscript>opt</subscript> member-type-id</emphasis> : <emphasis>type-id</emphasis> :</programlisting>
  where an <emphasis>access-specifier</emphasis> of <code>public</code> is assumed
  if none is given.  The member type is given by:
  <programlisting language="BNF">
<emphasis>member-type-id</emphasis> :
	<emphasis>type-id</emphasis>
	<emphasis>type-id</emphasis> % <emphasis>constant-expression</emphasis></programlisting>
  where <code>%</code> is used to denote bitfield members (since
  <code>:</code> is used as a separator).  The second type denotes the
  structure or union the given member belongs to.  Different types can
  have members with the same internal name, but the external token name
  must be unique.  Note that only non-static data members can be represented
  in this form.
  </para>
  <para>
  Two declarations for the same <code>MEMBER</code> token (including token
  definitions) should have the same type, however the directive:
  <programlisting language="C++">
#pragma TenDRA++ incompatible member declaration <emphasis>allow</emphasis></programlisting>
  allows declarations with different types, provided these types have the
  same size and alignment requirements.
  </para>
</section>

<section>
	<title>Procedure tokens</title>
  <para>
  Procedure, or high-level, tokens are specified in one of three ways:
  <programlisting language="BNF">
<emphasis>procedure-token</emphasis> :
	<emphasis>general-procedure</emphasis>
	<emphasis>simple-procedure</emphasis>
	<emphasis>function-procedure</emphasis></programlisting>
  All procedure tokens (except ellipsis functions - see below) lie in
  the macro namespace.  The most general form of procedure token specifies
  two sets of parameters.  The bound parameters are those which are
  used in encoding the actual TDF output, and the program parameters
  are those which are <link linkend="args">specified in the program</link>.
  The program parameters are expressed in terms of the bound parameters.
  A program parameter can be an expression token parameter, a statement
  token parameter, a member token parameter, a procedure token parameter
  or any type.  The bound parameters are deduced from the program parameters
  by a similar process to that used in template argument deduction.
  <programlisting language="BNF">
<emphasis>general-procedure</emphasis> :
	PROC { <emphasis>bound-toks<subscript>opt</subscript></emphasis> | <emphasis>prog-pars<subscript>opt</subscript></emphasis> } <emphasis>token-introduction
  </emphasis>

<emphasis>bound-toks</emphasis> :
	<emphasis>bound-token</emphasis>
	<emphasis>bound-token</emphasis> , <emphasis>bound-toks</emphasis>

<emphasis>bound-token</emphasis> :
	<emphasis>token-introduction token-namespace<subscript>opt</subscript> identifier</emphasis>

<emphasis>prog-pars</emphasis> :
	<emphasis>program-parameter</emphasis>
	<emphasis>program-parameter</emphasis> , <emphasis>prog-pars</emphasis>

<emphasis>program-parameter</emphasis> :
	EXP <emphasis>identifier</emphasis>
	STATEMENT <emphasis>identifier</emphasis>
	TYPE <emphasis>type-id</emphasis>
	MEMBER <emphasis>type-id</emphasis> : <emphasis>identifier</emphasis>
	PROC <emphasis>identifier</emphasis></programlisting>
  </para>
  <para>
  The simplest form of a <emphasis>general-procedure</emphasis> is one in which the
  <emphasis>prog-pars</emphasis> correspond precisely to the <emphasis>bound-toks</emphasis>.  In
  this case the syntax:
  <programlisting language="BNF">
<emphasis>simple-procedure</emphasis> :
	PROC ( <emphasis>simple-toks<subscript>opt</subscript></emphasis> ) <emphasis>token-introduction</emphasis>

<emphasis>simple-toks</emphasis> :
	<emphasis>simple-token</emphasis>
	<emphasis>simple-token</emphasis> , <emphasis>simple-toks</emphasis>

<emphasis>simple-token</emphasis> :
	<emphasis>token-introduction token-namespace<subscript>opt</subscript> identifier<subscript>opt</subscript></emphasis></programlisting>
  may be used.  Note that the parameter names are optional.
  </para>
  <para>
  A function token is specified as follows:
  <programlisting language="TDF">
<emphasis>function-procedure</emphasis> :
	FUNC <emphasis>type-id</emphasis> :</programlisting>
  where the given type is a function type.  This has two effects: firstly
  a function with the given type is declared; secondly, if the function
  type has the form:
  <programlisting language="C++">
r ( p1, ...., pn )</programlisting>
  a procedure token with sort:
  <programlisting language="TDF">
PROC ( EXP rvalue : p1 :, ...., EXP rvalue : pn : ) EXP rvalue : r :</programlisting>
  is declared.  For ellipsis function types only the function, not the
  token, is declared.  Note that the token behaves like a macro definition
  of the corresponding function.  Unless explicitly enclosed in a linkage
  specification, a function declared using a <code>FUNC</code>
  token has C linkage.  Note that it is possible for two <code>FUNC</code>
  tokens to have the same internal name, because of function overloading,
  however external names must be unique.
  </para>
  <para>
  The directive:
  <programlisting language="C++">
#pragma TenDRA incompatible interface declaration <emphasis>allow</emphasis></programlisting>
  can be used to allow incompatible redeclarations of functions declared
  using <code>FUNC</code> tokens.  The token declaration takes precedence.
  </para>
	<warning>
  <para>Certain of the more complex examples of <code>PROC</code> tokens such
  as, for example, tokens with <code>PROC</code> parameters, have not
  been implemented in either the C or C++ producers.</para>
	</warning>
</section>
  </section>

  <section id="token-arguments">
    <title>Token arguments</title>
  <para>
  As mentioned above, the program parameters for a <code>PROC</code>
  token are those specified in the program itself.  These arguments
  are expressed as a comma-separated list enclosed in brackets, the
  form of each argument being determined by the corresponding program
  parameter.
  </para>
  <para>
  An <code>EXP</code> argument is an assignment expression.  This must
  be an lvalue for <code>lvalue</code> tokens and a constant expression
  for
  <code>const</code> tokens.  The argument is converted to the token
  type (for <code>lvalue</code> tokens this is essentially a conversion
  between the corresponding reference types).  A <code>NAT</code> or
  <code>INTEGER</code> argument is an integer constant expression.
  In the former case this must be non-negative.
  </para>
  <para>
  A <code>STATEMENT</code> argument is a statement.  This statement
  should not contain any labels or any <code>goto</code> or <code>return</code>
  statements.
  </para>
  <para>
  A type argument is a type identifier.  This must name a type of the
  correct category for the corresponding token.  For example, a
  <code>VARIETY</code> token requires an integral type.
  </para>
  <para>
  <A id="offset">A member argument must describe the offset of a member
  or nested member of the given structure or union type</A>.  The type
  of the member should agree with that of the <code>MEMBER</code> token.
  The general form of a member offset can be described in terms of member
  selectors and array indexes as follows:
  <programlisting language="BNF">
<emphasis>member-offset</emphasis> :
	::<emphasis><subscript>opt</subscript> id-expression</emphasis>
	<emphasis>member-offset</emphasis> . ::<emphasis><subscript>opt</subscript> id-expression</emphasis>
	<emphasis>member-offset</emphasis> [ <emphasis>constant-expression</emphasis> ]</programlisting>
  </para>
  <para>
  A <code>PROC</code> argument is an identifier.  This identifier must
  name a <code>PROC</code> token of the appropriate sort.
  </para>
  </section>

  <section id="tokdef">
    <title>Defining tokens</title>
  <para>
  Given a token specification of a syntactic object and a normal language
  definition of the same object (including macro definitions if the
  token lies in the macro namespace), the producers attempt to unify
  the two by defining the TDF token in terms of the given definition.
  Whether the token specification occurs before or after the language
  definition is immaterial.  Unification also takes place in situations
  where, for example, two types are known to be compatible.  Multiple
  consistent explicit token definitions are allowed by default when
  allowed by the language; this is controlled by the directive:
  <programlisting language="C++">
#pragma TenDRA compatible token <emphasis>allow</emphasis></programlisting>
  The default unification behaviour may be modified using the directives:
  <programlisting language="C++">
#pragma TenDRA no_def <emphasis>token-list</emphasis>
#pragma TenDRA define <emphasis>token-list</emphasis>
#pragma TenDRA reject <emphasis>token-list</emphasis></programlisting>
  or equivalently:
  <programlisting language="C++">
#pragma no_def <emphasis>token-list</emphasis>
#pragma define <emphasis>token-list</emphasis>
#pragma ignore <emphasis>token-list</emphasis></programlisting>
  which set the state of the tokens given in <emphasis>token-list</emphasis>.  A state
  of <code>no_def</code> means that no unification is attempted and
  that any attempt to explicitly define the token results in an error.
  A state of <code>define</code> means that unification takes place
  and that the token must be defined somewhere in the translation unit.
  A state of <code>reject</code> means that unification takes place as
  normal, but any resulting token definition is discarded and not output
  to the TDF capsule.
  </para>
  <para>
  If a token with the state <code>define</code> is not defined, then the
  behaviour depends on the sort of the token.  A <code>FUNC</code> token
  is implicitly defined in terms of its underlying function, such as:
  <programlisting language="C++">
#define f( a1, ...., an )	( f ) ( a1, ...., an )</programlisting>
  Other undefined tokens cause an error.  This behaviour can be modified
  using the directives:
  <programlisting language="C++">
#pragma TenDRA++ implicit token definition <emphasis>allow</emphasis>
#pragma TenDRA++ no token definition <emphasis>allow</emphasis></programlisting>
  respectively.</para>
  <para>
  The primitive operations, <code>no_def</code>, <code>define</code> and
  <code>reject</code>, can also be expressed using the context sensitive
  directive:
  <programlisting language="C++">
#pragma TenDRA interface <emphasis>token-list</emphasis></programlisting>
  or equivalently:
  <programlisting language="C++">
#pragma interface <emphasis>token-list</emphasis></programlisting>
  By default this is equivalent to <code>no_def</code>, but may be modified
  by inclusion using one of the directives:
  <programlisting language="C++">
#pragma TenDRA extend <emphasis>header-name</emphasis>
#pragma TenDRA implement <emphasis>header-name</emphasis></programlisting>
  or equivalently:
  <programlisting language="C++">
#pragma extend interface <emphasis>header-name</emphasis>
#pragma implement interface <emphasis>header-name</emphasis></programlisting>
  These are equivalent to:
  <programlisting language="C++">
#include <emphasis>header-name</emphasis></programlisting>
  except that the form <code>[....]</code> is allowed as a header name.
  This is equivalent to <code>&lt;....&gt;</code> except that it starts
  the directory search after the point at which the including file was
  found, rather than at the start of the path (i.e. it is equivalent
  to the
  <code>#include_next</code> directive found in some preprocessors).
  The effect of the <code>extend</code> directive on the state of the
  <code>interface</code> directive is as follows:
  <programlisting>
no_def -&gt; no_def
define -&gt; reject
reject -&gt; reject</programlisting>
  The effect of the <code>implement</code> directive is as follows:
  <programlisting>
no_def -&gt; define
define -&gt; define
reject -&gt; reject</programlisting>
  That is to say, a <code>implement</code> directive will cause all
  the tokens in the given header to be defined and their definitions
  output. Any tokens included in this header by <code>extend</code>
  may be defined, but their definitions will not be output.  This is
  precisely the behaviour which is required to ensure that each token
  is defined exactly once in an API library build.
  </para>
  <para>
  The lists of tokens in the directives above are expressed in the form:
  <programlisting language="BNF">
<emphasis>token-list</emphasis> :
	<emphasis>token-id token-list<subscript>opt</subscript></emphasis>
	# <emphasis>preproc-token-list</emphasis></programlisting>
  where a <emphasis>token-id</emphasis> represents an internal token name:
  <programlisting language="BNF">
<emphasis>token-id</emphasis> :
	<emphasis>token-namespace<subscript>opt</subscript> identifier</emphasis>
	<emphasis>type-id</emphasis> . <emphasis>identifier</emphasis></programlisting>
  Note that member tokens are specified by means of both the member
  name and its parent type.  In this type specifier, <code>TAG</code>,
  rather than
  <code>class</code>, <code>struct</code> or <code>union</code>, may
  be used in elaborated type specifiers for structure and union tokens.
  If the
  <emphasis>token-id</emphasis> names an overloaded function then the directive is
  applied to all <code>FUNC</code> tokens of that name.  It is possible
  to  be more selective using the <code>#</code> form which allows the
  external token name to be specified.  Such an entry must be the last
  in a <emphasis>token-list</emphasis>.
  </para>
  <para>
  A related directive has the form:
  <programlisting language="C++">
#pragma TenDRA++ undef token <emphasis>token-list</emphasis></programlisting>
  which undefines all the given tokens so that they are no longer visible.
  </para>
  <para>
  As noted above, a macro is only considered as a token definition if
  the token lies in the macro namespace.  Tokens which are not in the
  macro namespace, such as types and members, cannot be defined using
  macros. Occasionally API implementations do define member selector
  as macros in terms of other member selectors.  Such a token needs
  to be explicitly defined using a directive of the form:
  <programlisting language="C++">
#pragma TenDRA member definition <emphasis>type-id</emphasis> : <emphasis>identifier member-offset
  </emphasis></programlisting>
  where <emphasis>member-offset</emphasis> is <link linkend="offset">as above</link>.
  </para>
  </section>
  </section>

  <section>
    <title>Symbol table dump</title>
  <para>
  The symbol table dump provides a method whereby third party tools
  can interface with the C and C++ producers.  The producer outputs
  information on the identifiers declared within a source file, their
  uses etc. into a file which can then be post-processed by a separate
  tool. Any error messages and warnings can also be included in this
  file, allowing more sophisticated error presentation tools to be written.
  </para>
  <para>
  The file to be used as the symbol table output file, plus details
  of what information is to be included in the dump file can be specified
  using the <A HREF="man.html#dump"><code>-d</code> command-line option</A>.
  The format of the dump file is described below; a
  <A HREF="dump1.html">summary of the syntax</A> is given as an annex.
  </para>


  <section id="lexical-elements">
    <title>Lexical elements</title>
  <para>
  A symbol table dump file consists of a sequence of characters giving
  information on identifiers, errors etc. arising from a translation
  unit. The fundamental lexical tokens are a <emphasis>number</emphasis>, consisting
  of a sequence of decimal digits, and a <emphasis>string</emphasis>, consisting of
  a sequence of characters enclosed in angle braces.  A <emphasis>string</emphasis>
  can have one of two forms:
  <programlisting language="BNF">
<emphasis>string</emphasis> :
	&lt;<emphasis>characters</emphasis>&gt;
	&amp;<emphasis>number</emphasis>&lt;<emphasis>characters</emphasis>&gt;</programlisting>
  In the first form, the <emphasis>characters</emphasis> are terminated by the first
  <code>&gt;</code> character encountered.  In the second form, the
  number of characters is given by the preceding <emphasis>number</emphasis>.  No
  white space is allowed either before or after the <emphasis>number</emphasis>.
  To aid parsers, the C++ producer always uses the second form for strings
  containing more than 100 characters.  There are no escape characters
  in strings; the
  <emphasis>characters</emphasis> can contain any characters, including newlines and
  <code>#</code>, except that the first form cannot contain a
  <code>&gt;</code> character.
  </para>
  <para>
  Space, tab and newline characters are white space.  Comments begin
  with
  <code>#</code> and run to the end of the line.  Comments are treated
  as white space.  All other characters are treated as distinct lexical
  tokens.
  </para>
  </section>

  <section id="main">
    <title>Overall syntax</title>
  <para>
  A symbol table dump file takes the form of a list of commands of various
  kinds conveying information on the analysed file.  This can be represented
  as follows:
  <programlisting language="BNF">
<emphasis>dump-file</emphasis> :
	<emphasis>command-list<subscript>opt</subscript></emphasis>

<emphasis>command-list</emphasis> :
	<emphasis>command command-list<subscript>opt</subscript></emphasis>

<emphasis>command</emphasis> :
	<emphasis>version-command</emphasis>
	<emphasis>identifier-command</emphasis>
	<emphasis>scope-command</emphasis>
	<emphasis>override-command</emphasis>
	<emphasis>base-command</emphasis>
	<emphasis>api-command</emphasis>
	<emphasis>template-command</emphasis>
	<emphasis>promotion-command</emphasis>
	<emphasis>error-command</emphasis>
	<emphasis>path-command</emphasis>
	<emphasis>file-command</emphasis>
	<emphasis>include-command</emphasis>
	<emphasis>string-command</emphasis></programlisting>
  The various kinds of command are discussed below.  The first command
  in the dump file should be of the form:
  <programlisting language="BNF">
<emphasis>version-command</emphasis> :
	V <emphasis>number number string</emphasis></programlisting>
  where the two numbers give the version of the dump file format (the
  version described here is 1.1 so both numbers should be 1) and the
  string gives the language being represented, for example,
  <code>&lt;C++&gt;</code>.
  </para>
  </section>

  <section id="file-locations">
    <title>File locations</title>
  <para>
  A location within a source file can be specified using three
  <emphasis>number</emphasis>s and two <emphasis>string</emphasis>s.  These give respectively, the
  column number, the line number taking <code>#line</code> directives
  into account, the line number not taking <code>#line</code> directives
  into account, the file name taking <code>#line</code> directives into
  account, and the file name not taking <code>#line</code> directives
  into account.  Any or all of the trailing elements can be replaced
  by
  <code>*</code> to indicate that they have not changed relative to
  the last <emphasis>location</emphasis> given.  Note that for the two line numbers,
  unchanged means that the difference of the line numbers, taking
  <code>#line</code> directives into account or not, is unchanged.
  Thus:
  <programlisting language="BNF">
<emphasis>location</emphasis> :
	<emphasis>number number number string string</emphasis>
	<emphasis>number number number string</emphasis> *
	<emphasis>number number number</emphasis> *
	<emphasis>number number</emphasis> *
	<emphasis>number</emphasis> *
	*</programlisting>
  Note that there is a concept of the <A id="crt_loc">current file
  location</A>, relative to which other locations are given.  The initial
  value of the current file location is undefined.  Unless otherwise
  stated, all <emphasis>location</emphasis> elements update the current file location.
  </para>
  </section>

  <section id="identifiers">
    <title>Identifiers</title>
  <para>
  Each identifier is represented in the symbol table dump by a unique
  number.  The same number always represents the same identifier.
  </para>

  <section id="identifier-names">
<title>Identifier names</title>
  <para>
  The number representing an identifier is introduced in the first declaration
  or use of that identifier and thereafter the number alone is used
  to denote the identifier:
  <programlisting language="BNF">
<emphasis>identifier</emphasis> :
	<emphasis>number</emphasis> = <emphasis>identifier-name access<subscript>opt</subscript> scope-identifier</emphasis>
	<emphasis>number</emphasis></programlisting>
  </para>
  <para>
  The identifier name is given by:
  <programlisting language="BNF">
<emphasis>identifier-name</emphasis> :
	<emphasis>string</emphasis>
	C <emphasis>type</emphasis>
	D <emphasis>type</emphasis>
	O <emphasis>string</emphasis>
	T <emphasis>type</emphasis></programlisting>
  denoting respectively, a simple identifier name, a constructor for
  a type, a destructor for a type, an overloaded operator function name,
  and a conversion function name.  The empty string is used for anonymous
  identifiers.
  </para>
  <para>
  The optional identifier access is given by:
  <programlisting language="BNF">
<emphasis>access</emphasis> :
	N
	B
	P</programlisting>
  denoting <code>public</code>, <code>protected</code> and
  <code>private</code> respectively.  An absent <emphasis>access</emphasis> is equivalent
  to <code>public</code>.  Note that all identifiers, not just class
  members, can have access specifiers; however the access of a non-member
  is always <code>public</code>.
  </para>
  <para>
  The <link linkend="scope">scope</link> (i.e. class, namespace, block etc.)
  in which an identifier is declared is given by:
  <programlisting language="BNF">
<emphasis>scope-identifier</emphasis> :
	<emphasis>identifier</emphasis>
	*</programlisting>
  denoting either a named or an unnamed scope.
  </para>
</section>

<section id="use">
	<title>Identifier uses</title>
  <para>
  Each declaration or use of an identifier is represented by a command
  of the form:
  <programlisting language="BNF">
<emphasis>identifier-command</emphasis> :
	D <emphasis>identifier-info type-info</emphasis>
	M <emphasis>identifier-info type-info</emphasis>
	T <emphasis>identifier-info type-info</emphasis>
	Q <emphasis>identifier-info</emphasis>
	U <emphasis>identifier-info</emphasis>
	L <emphasis>identifier-info</emphasis>
	C <emphasis>identifier-info</emphasis>
	W <emphasis>identifier-info type-info</emphasis></programlisting>
  where:
  <programlisting language="BNF">
<emphasis>identifier-info</emphasis> :
	<emphasis>identifier-key location identifier</emphasis></programlisting>
  gives the kind of identifier being declared or used, the location
  of the declaration or use, and the number associated with the identifier.
  Each declaration may, depending on the <emphasis>identifier-key</emphasis>, associate
  various <emphasis>type-info</emphasis> with the identifier, giving its type etc.
  </para>
  <para>
  The various kinds of <emphasis>identifier-command</emphasis> are described below.
  Any can be preceded by <code>I</code> to indicate an implicit declaration
  or use.  <code>D</code> denotes a definition.  <code>M</code> (make)
  denotes a declaration.  <code>T</code> denotes a tentative definition
  (C only).  <code>Q</code> denotes the end of a definition, for those
  identifiers such as classes and functions whose definitions may be
  spread over several lines.  <code>U</code> denotes an undefine operation
  (such as <code>#undef</code> for macro identifiers).  <code>C</code>
  denotes a call to a function identifier; <code>L</code> (load) denotes
  other identifier uses.  Finally <code>W</code> denotes implicit type
  information such as the C producer gleans from its
  <A HREF="pragma.html#weak">weak prototype analysis</A>.
  </para>
  <para>
  The various <emphasis>identifier-key</emphasis>s are their associated <emphasis>type-info</emphasis>
  fields are given by the following table:
  </para>

  <table>
  <tr><th>Key</th>
  <th>Type information</th>
  <th>Description</th>
  </tr>
  <tr><td><code>K</code></td>
  <td><code>*</code></td>
  <td>keyword</td>
  </tr>
  <tr><td><code>MO</code></td>
  <td><emphasis>sort</emphasis></td>
  <td>object macro</td>
  </tr>
  <tr><td><code>MF</code></td>
  <td><emphasis>sort</emphasis></td>
  <td>function macro</td>
  </tr>
  <tr><td><code>MB</code></td>
  <td><emphasis>sort</emphasis></td>
  <td>built-in macro</td>
  </tr>
  <tr><td><code>TC</code></td>
  <td><emphasis>type</emphasis></td>
  <td>class tag</td>
  </tr>
  <tr><td><code>TS</code></td>
  <td><emphasis>type</emphasis></td>
  <td>structure tag</td>
  </tr>
  <tr><td><code>TU</code></td>
  <td><emphasis>type</emphasis></td>
  <td>union tag</td>
  </tr>
  <tr><td><code>TE</code></td>
  <td><emphasis>type</emphasis></td>
  <td>enumeration tag</td>
  </tr>
  <tr><td><code>TA</code></td>
  <td><emphasis>type</emphasis></td>
  <td><code>typedef</code> name</td>
  </tr>
  <tr><td><code>NN</code></td>
  <td><code>*</code></td>
  <td>namespace name</td>
  </tr>
  <tr><td><code>NA</code></td>
  <td><emphasis>scope-identifier</emphasis></td>
  <td>namespace alias</td>
  </tr>
  <tr><td><code>VA</code></td>
  <td><emphasis>type</emphasis></td>
  <td>automatic variable</td>
  </tr>
  <tr><td><code>VP</code></td>
  <td><emphasis>type</emphasis></td>
  <td>function parameter</td>
  </tr>
  <tr><td><code>VE</code></td>
  <td><emphasis>type</emphasis></td>
  <td><code>extern</code> variable</td>
  </tr>
  <tr><td><code>VS</code></td>
  <td><emphasis>type</emphasis></td>
  <td><code>static</code> variable</td>
  </tr>
  <tr><td><code>FE</code></td>
  <td><emphasis>type identifier<subscript>opt</subscript></emphasis></td>
  <td><code>extern</code> function</td>
  </tr>
  <tr><td><code>FS</code></td>
  <td><emphasis>type identifier<subscript>opt</subscript></emphasis></td>
  <td><code>static</code> function</td>
  </tr>
  <tr><td><code>FB</code></td>
  <td><emphasis>type identifier<subscript>opt</subscript></emphasis></td>
  <td>built-in operator function</td>
  </tr>
  <tr><td><code>CF</code></td>
  <td><emphasis>type identifier<subscript>opt</subscript></emphasis></td>
  <td>member function</td>
  </tr>
  <tr><td><code>CS</code></td>
  <td><emphasis>type identifier<subscript>opt</subscript></emphasis></td>
  <td><code>static</code> member function</td>
  </tr>
  <tr><td><code>CV</code></td>
  <td><emphasis>type identifier<subscript>opt</subscript></emphasis></td>
  <td>virtual member function</td>
  </tr>
  <tr><td><code>CM</code></td>
  <td><emphasis>type</emphasis></td>
  <td>data member</td>
  </tr>
  <tr><td><code>CD</code></td>
  <td><emphasis>type</emphasis></td>
  <td><code>static</code> data member</td>
  </tr>
  <tr><td><code>E</code></td>
  <td><emphasis>type</emphasis></td>
  <td>enumerator</td>
  </tr>
  <tr><td><code>L</code></td>
  <td><code>*</code></td>
  <td>label</td>
  </tr>
  <tr><td><code>XO</code></td>
  <td><emphasis>sort</emphasis></td>
  <td>object token</td>
  </tr>
  <tr><td><code>XF</code></td>
  <td><emphasis>sort</emphasis></td>
  <td>procedure token</td>
  </tr>
  <tr><td><code>XP</code></td>
  <td><emphasis>sort</emphasis></td>
  <td>token parameter</td>
  </tr>
  <tr><td><code>XT</code></td>
  <td><emphasis>sort</emphasis></td>
  <td>template parameter</td>
  </tr>
  </table>

  <para>
  The function identifier keys can optionally be followed by
  <code>C</code> indicating that the function has C linkage, and
  <code>I</code> indicating that the function is inline.  By default,
  functions declared in a C++ dump file have C++ linkage and functions
  declared in a C dump file have C linkage.  The optional
  <emphasis>identifier</emphasis> which forms part of the <emphasis>type-info</emphasis> of these
  functions is used to form linked lists of overloaded functions.
  </para>
</section>

<section id="ident-scope">
	<title>Identifier scopes</title>
  <para>
  Each identifier belongs to a scope, called its parent scope, in which
  it is declared.  For example, the parent of a member of a class is
  the class itself.  This information is expressed in an identifier
  declaration using a <emphasis>scope-identifier</emphasis>.  In addition to the obvious
  scopes such as classes and namespaces, there are other scopes such
  as blocks in function definitions.  It is possible to introduce dummy
  identifiers to name such scopes.  The parent of such a dummy identifier
  will be the enclosing scope identifier, so these dummy identifiers
  naturally represent the block structure.  The parent of the top-level
  block in a function definition can be considered to be the function
  itself.
  </para>
  <para>
  Information on the start and end of such scopes is given by:
  <programlisting language="BNF">
<emphasis>scope-command</emphasis> :
	SS <emphasis>scope-key location identifier</emphasis>
	SE <emphasis>scope-key location identifier</emphasis></programlisting>
  where:
  <programlisting language="BNF">
<emphasis>scope-key</emphasis> :
	N
	S
	B
	D
	H
	CT
	CF
	CC</programlisting>
  gives the kind of scope involved: a namespace, a class, a block, some
  other declarative scope, a declaration block (see below), a true conditional
  scope, a false conditional scope or a target dependent conditional
  scope.
  </para>
  <para>
  A declaration block is a sequence of declarations enclosed in directives
  of the form:
  <programlisting language="C++">
#pragma TenDRA declaration block <emphasis>identifier</emphasis> begin
....
#pragma TenDRA declaration block end</programlisting>
  This allows the sequence of declarations to be associated with the
  given
  <emphasis>identifier</emphasis> in the symbol dump file.  This technique is used
  in the API description files to aid analysis tools in determining
  which declarations are part of the API.
  </para>
</section>

<section id="other-ident-info">
	<title>Other identifier information</title>
  <para>
  Other information associated with an identifier may be expressed using
  other dump commands.  For example:
  <programlisting language="BNF">
<emphasis>override-command</emphasis> :
	O <emphasis>identifier identifier</emphasis></programlisting>
  is used to express the fact that the two <emphasis>identifier</emphasis>s are virtual
  member functions, the first of which overrides the second.
  </para>
  <para>
  The command:
  <programlisting language="BNF">
<emphasis>base-command</emphasis> :
	B <emphasis>identifier-key identifier base-graph</emphasis>

<emphasis>base-graph</emphasis> :
	<emphasis>base-class</emphasis>
	<emphasis>base-class</emphasis> ( <emphasis>base-list</emphasis> )

<emphasis>base-class</emphasis> :
	<emphasis>number</emphasis> = V<emphasis><subscript>opt</subscript> access<subscript>opt</subscript> type-name</emphasis>
	<emphasis>number</emphasis> :

<emphasis>base-list</emphasis> :
	<emphasis>base-graph base-list<subscript>opt</subscript></emphasis>
</programlisting>
  associates a base class graph with a class identifier.  Any class
  which does not have an associated <emphasis>base-command</emphasis> can be assumed
  to have no base classes.  Each node in the graph is a <emphasis>type-name</emphasis>
  with an associated list of base classes.  A <code>V</code> is used
  to indicate a virtual base class.  Each node is numbered; duplicate
  numbers are used to indicate bases identified via the virtual base
  class structure.  Any base class can then be referred to as:
  <programlisting language="BNF">
<emphasis>base-number</emphasis> :
	<emphasis>number</emphasis> : <emphasis>type-name</emphasis></programlisting>
  indicating the base class with the given number in the given class.
  </para>
  <para>
  The command:
  <programlisting language="BNF">
<emphasis>api-command</emphasis> :
	X <emphasis>identifier-key identifier string</emphasis></programlisting>
  associates the external token name given by the <emphasis>string</emphasis> with
  the given tokenised identifier.
  </para>
  <para>
  The command:
  <programlisting language="BNF">
<emphasis>template-command</emphasis> :
	Z <emphasis>identifier-key identifier token-application specialise-info</emphasis></programlisting>
  is used to introduce an identifier corresponding to an instance of
  a template, <emphasis>token-application</emphasis>.  This instance may correspond
  to a specialisation of the primary template; this information is represented
  by:
  <programlisting language="BNF">
<emphasis>specialise-info</emphasis> :
	<emphasis>identifier</emphasis>
	<emphasis>token-application</emphasis>
	*</programlisting>
  where <code>*</code> indicates a non-specialised instance.
  </para>
</section>
  </section>

  <section id="types">
    <title>Types</title>
  <para>
  The <A id="built-in">built-in types</A> are represented in the symbol
  table dump as follows:
  </para>

  <table>
  <tr><th>Type</th>
  <th>Encoding</th>
  <th>Type</th>
  <th>Encoding</th>
  </tr>
  <tr><td>char</td>
  <td><code>c</code></td>
  <td>float</td>
  <td><code>f</code></td>
  </tr>
  <tr><td>signed char</td>
  <td><code>Sc</code></td>
  <td>double</td>
  <td><code>d</code></td>
  </tr>
  <tr><td>unsigned char</td>
  <td><code>Uc</code></td>
  <td>long double</td>
  <td><code>r</code></td>
  </tr>
  <tr><td>signed short</td>
  <td><code>s</code></td>
  <td>void</td>
  <td><code>v</code></td>
  </tr>
  <tr><td>unsigned short</td>
  <td><code>Us</code></td>
  <td>(bottom)</td>
  <td><code>u</code></td>
  </tr>
  <tr><td>signed int</td>
  <td><code>i</code></td>
  <td>bool</td>
  <td><code>b</code></td>
  </tr>
  <tr><td>unsigned int</td>
  <td><code>Ui</code></td>
  <td>ptrdiff_t</td>
  <td><code>y</code></td>
  </tr>
  <tr><td>signed long</td>
  <td><code>l</code></td>
  <td>size_t</td>
  <td><code>z</code></td>
  </tr>
  <tr><td>unsigned long</td>
  <td><code>Ul</code></td>
  <td>wchar_t</td>
  <td><code>w</code></td>
  </tr>
  <tr><td>signed long long</td>
  <td><code>x</code></td>
  <td>-</td>
  <td>-</td>
  </tr>
  <tr><td>unsigned long long</td>
  <td><code>Ux</code></td>
  <td>-</td>
  <td>-</td>
  </tr>
  </table>

  <para>
  Named types (classes, enumeration types etc.) can be represented by
  the corresponding identifier or token application:
  <programlisting language="BNF">
<emphasis>type-name</emphasis> :
	<emphasis>identifier</emphasis>
	<emphasis>token-application</emphasis></programlisting>
  <A id="composite">Composite and qualified types</A> are represented
  in terms of their subtypes as follows:
  </para>

  <table>
  <tr><th>Type</th>
  <th>Encoding</th>
  </tr>
  <tr><td><code>const</code> type</td>
  <td><code>C</code> <emphasis>type</emphasis></td>
  </tr>
  <tr><td><code>volatile</code> type</td>
  <td><code>V</code> <emphasis>type</emphasis></td>
  </tr>
  <tr><td>pointer type</td>
  <td><code>P</code> <emphasis>type</emphasis></td>
  </tr>
  <tr><td>reference type</td>
  <td><code>R</code> <emphasis>type</emphasis></td>
  </tr>
  <tr><td>pointer to member type</td>
  <td><code>M</code> <emphasis>type-name</emphasis> <code>:</code> <emphasis>type</emphasis></td>
  </tr>
  <tr><td>function type</td>
  <td><code>F</code> <emphasis>type parameter-types</emphasis></td>
  </tr>
  <tr><td>array type</td>
  <td><code>A</code> <emphasis>nat<subscript>opt</subscript></emphasis> <code>:</code> <emphasis>type</emphasis></td>
  </tr>
  <tr><td>bitfield type</td>
  <td><code>B</code> <emphasis>nat</emphasis> <code>:</code> <emphasis>type</emphasis></td>
  </tr>
  <tr><td>template type</td>
  <td><code>t</code> <emphasis>parameter-list<subscript>opt</subscript></emphasis> <code>:</code> <emphasis>type</emphasis></td>
  </tr>
  <tr><td>promotion type</td>
  <td><code>p</code> <emphasis>type</emphasis></td>
  </tr>
  <tr><td>arithmetic type</td>
  <td><code>a</code> <emphasis>type</emphasis> <code>:</code> <emphasis>type</emphasis></td>
  </tr>
  <tr><td>integer literal type</td>
  <td><code>n</code> <emphasis>lit-base<subscript>opt</subscript> lit-suffix<subscript>opt</subscript></emphasis></td>
  </tr>
  <tr><td>weak function prototype (C only)</td>
  <td><code>W</code> <emphasis>type parameter-types</emphasis></td>
  </tr>
  <tr><td>weak parameter type (C only)</td>
  <td><code>q</code> <emphasis>type</emphasis></td>
  </tr>
  </table>

  <para>
  Other types can be represented by their textual representation using
  the form <code>Q</code> <emphasis>string</emphasis>, or by <code>*</code>, indicating
  an unknown type.
  </para>
  <para>
  The parameter types for a function type are represented as follows:
  <programlisting language="BNF">
<emphasis>parameter-types</emphasis> :
	: <emphasis>exception-spec<subscript>opt</subscript> func-qualifier<subscript>opt</subscript></emphasis> :
	. <emphasis>exception-spec<subscript>opt</subscript> func-qualifier<subscript>opt</subscript></emphasis> :
	. <emphasis>exception-spec<subscript>opt</subscript> func-qualifier<subscript>opt</subscript></emphasis> .
	, <emphasis>type parameter-types</emphasis></programlisting>
  where the <code>::</code> form indicates that there are no further
  parameters, the <code>.:</code> form indicates that the parameters
  are terminated by an ellipsis, and the <code>..</code> form indicates
  that no information is available on the further parameters (this can
  only happen with non-prototyped functions in C).  The function qualifiers
  are given by:
  <programlisting language="BNF">
<emphasis>func-qualifier</emphasis> :
	C <emphasis>func-qualifier<subscript>opt</subscript></emphasis>
	V <emphasis>func-qualifier<subscript>opt</subscript></emphasis></programlisting>
  representing <code>const</code> and <code>volatile</code> member functions.
  The function exception specifier is given by:
  <programlisting language="BNF">
<emphasis>exception-spec</emphasis> :
	( <emphasis>exception-list<subscript>opt</subscript></emphasis> )

<emphasis>exception-list</emphasis> :
	<emphasis>type</emphasis>
	<emphasis>type</emphasis> , <emphasis>exception-list</emphasis></programlisting>
  with an absent exception specifier, as in C++, indicating that any
  exception may be thrown.
  </para>
  <para>
  Array and bitfield sizes are represented as follows:
  <programlisting language="BNF">
<emphasis>nat</emphasis> :
	+ <emphasis>number</emphasis>
	- <emphasis>number</emphasis>
	<emphasis>identifier</emphasis>
	<emphasis>token-application</emphasis>
	<emphasis>string</emphasis></programlisting>
  where a <emphasis>string</emphasis> is used to hold a textual representation of
  complex values.
  </para>
  <para>
  Template types are represented by a list of template parameters, which
  will have previously been declared using the <code>XT</code> identifier
  key, followed by the underlying type expressed in terms of these parameters.
  The parameters are represented as follows:
  <programlisting language="BNF">
<emphasis>parameter-list</emphasis> :
	<emphasis>identifier</emphasis>
	<emphasis>identifier</emphasis> , <emphasis>parameter-list</emphasis></programlisting>
  </para>
  <para>
  Integer literal types are represented by the value of the literal
  followed by a representation of the literal base and suffix.  These
  are given by:
  <programlisting language="BNF">
<emphasis>lit-base</emphasis> :
	O
	X</programlisting>
  representing octal and hexadecimal literals respectively (decimal
  is the default), and:
  <programlisting language="BNF">
<emphasis>lit-suffix</emphasis> :
	U
	l
	Ul
	x
	Ux</programlisting>
  representing the <code>U</code>, <code>L</code>, <code>UL</code>,
  <code>LL</code> and <code>ULL</code> suffixes respectively.
  </para>
  <para>
  Target dependent integral promotion types are represented using
  <code>p</code>, so for example the promotion of <code>unsigned short</code>
  is represented as <code>pUs</code>.  Information on the other cases,
  where the promotion type is known, can be given in a command of the
  form:
  <programlisting language="BNF">
<emphasis>promotion-command</emphasis> :
	P <emphasis>type</emphasis> : <emphasis>type</emphasis></programlisting>
  Thus the fact that the promotion of <code>short</code> is <code>int</code>
  would be expressed by the command <code>Ps:i</code>.
  </para>
  </section>

  <section id="sort">
    <title>Sorts</title>
  <para>
  A <emphasis>sort</emphasis> in the symbol table dump corresponds to the sort of
  a token declared in the <A HREF="token.html#spec"><code>#pragma token</code>
  syntax</A>.  Expression tokens are represented as follows:
  <programlisting language="BNF">
<emphasis>expression-sort</emphasis> :
	ZEL <emphasis>type</emphasis>
	ZER <emphasis>type</emphasis>
	ZEC <emphasis>type</emphasis>
	ZN</programlisting>
  corresponding to <code>lvalue</code>, <code>rvalue</code> and
  <code>const</code> <code>EXP</code> tokens of the given type, and
  <code>NAT</code> or <code>INTEGER</code> tokens, respectively. Statement
  tokens are represent by:
  <programlisting language="BNF">
<emphasis>statement-sort</emphasis> :
	ZS</programlisting>
  </para>
  <para>
  Type tokens are represented as follows:
  <programlisting language="BNF">
<emphasis>type-sort</emphasis> :
	ZTO
	ZTI
	ZTF
	ZTA
	ZTP
	ZTS
	ZTU</programlisting>
  corresponding to <code>TYPE</code>, <code>VARIETY</code>, <code>FLOAT</code>,
  <code>ARITHMETIC</code>, <code>SCALAR</code>, <code>STRUCT</code>
  or
  <code>CLASS</code>, and <code>UNION</code> token respectively.  There
  are corresponding <code>TAG</code> forms:
  <programlisting language="BNF">
<emphasis>tag-type-sort</emphasis> :
	ZTTS
	ZTTU</programlisting>
  </para>
  <para>
  Member tokens are represented using:
  <programlisting language="BNF">
<emphasis>member-sort</emphasis> :
	ZM <emphasis>type</emphasis> : <emphasis>type-name</emphasis></programlisting>
  where the first type gives the member type and the second gives the
  parent structure or union type.
  </para>
  <para>
  Procedure tokens can be represented using:
  <programlisting language="BNF">
<emphasis>proc-sort</emphasis> :
	ZPG <emphasis>parameter-list<subscript>opt</subscript></emphasis> ; <emphasis>parameter-list<subscript>opt</subscript></emphasis> : <emphasis>sort</emphasis>
	ZPS <emphasis>parameter-list<subscript>opt</subscript></emphasis> : <emphasis>sort</emphasis></programlisting>
  The first form corresponds to the more general form of <code>PROC</code>
  token, that expressed using <code>{ .... | .... }</code>, which has
  separate lists of bound and program parameters.  These token parameters
  will have previously been declared using the <code>XP</code> identifier
  key.  The second form corresponds to the case where the bound and
  program parameter lists are equal, that expressed as a <code>PROC</code>
  token using <code>( .... )</code>.  A more specialised version of
  this second form is a <code>FUNC</code> token, which is represented
  as:
  <programlisting language="BNF">
<emphasis>func-sort</emphasis> :
	ZF <emphasis>type</emphasis></programlisting>
  </para>
  <para>
  As noted above, template parameters are represented by a <emphasis>sort</emphasis>.
  Template type parameters are represented by <code>ZTO</code>, while
  template expression parameters are represent by <code>ZEC</code>
  (recall that such parameters are always constant expressions).  The
  remaining case, template template parameters, can be represented as:
  <programlisting language="BNF">
<emphasis>template-sort</emphasis> :
	ZTt <emphasis>parameter-list<subscript>opt</subscript></emphasis> :</programlisting>
  </para>
  <para>
  Finally, the number of parameters in a macro definition is represented
  by a <emphasis>sort</emphasis> of the form:
  <programlisting language="BNF">
<emphasis>macro-sort</emphasis> :
	ZUO
	ZUF <emphasis>number</emphasis></programlisting>
  corresponding to a object-like macro and a function-like macro with
  the given number of parameters, respectively.
  </para>
  </section>

  <section id="token-applications">
    <title>Token applications</title>
  <para>
  Given an identifier representing a <code>PROC</code> token or a template,
  an application of that token or an instance of that template can be
  represented using:
  <programlisting language="BNF">
<emphasis>token-application</emphasis> :
	T <emphasis>identifier</emphasis> , <emphasis>token-argument-list</emphasis> :</programlisting>
  where the token or template arguments are given by:
  <programlisting language="BNF">
<emphasis>token-argument-list</emphasis> :
	<emphasis>token-argument</emphasis>
	<emphasis>token-argument</emphasis> , <emphasis>token-argument-list</emphasis></programlisting>
  Note that the case where there are no arguments is generally just
  represented by <emphasis>identifier</emphasis>; this case is specified separately
  in the rest of the grammar.
  </para>
  <para>
  A <emphasis>token-argument</emphasis> can represent a value of any of the sorts
  listed above: expressions, integer constants, statements, types, members,
  functions and templates.  These are given respectively by:
  <programlisting language="BNF">
<emphasis>token-argument</emphasis> :
	E <emphasis>expression</emphasis>
	N <emphasis>nat</emphasis>
	S <emphasis>statement</emphasis>
	T <emphasis>type</emphasis>
	M <emphasis>member</emphasis>
	F <emphasis>identifier</emphasis>
	C <emphasis>identifier</emphasis></programlisting>
  where:
  <programlisting language="BNF">
<emphasis>expression</emphasis> :
	<emphasis>nat</emphasis>

<emphasis>statement</emphasis> :
	<emphasis>expression</emphasis>

<emphasis>member</emphasis> :
	<emphasis>identifier</emphasis>
	<emphasis>string</emphasis></programlisting>
  </para>
  </section>

  <section id="error">
    <title>Errors</title>
  <para>
  Each error in the C++ <A HREF="error.html">error catalogue</A> is
  represented by a number.  These numbers happen to correspond to the
  position of the error within the catalogue, but in general this need
  not be the case.  The first use of each error introduces the error
  number by associating it with a <emphasis>string</emphasis> giving the error name.
  This has the form <code>cpp.</code><emphasis>error</emphasis> where <emphasis>error</emphasis>
  gives an error name from the C++ (<code>cpp</code>) error catalogue.
  Thus:
  <programlisting language="BNF">
<emphasis>error-name</emphasis> :
	<emphasis>number</emphasis> = <emphasis>string</emphasis>
	<emphasis>number</emphasis></programlisting>
  </para>
  <para>
  Each error message written to the symbol table dump has the form:
  <programlisting language="BNF">
<emphasis>error-command</emphasis> :
	ES <emphasis>location error-info</emphasis>
	EW <emphasis>location error-info</emphasis>
	EI <emphasis>location error-info</emphasis>
	EF <emphasis>location error-info</emphasis>
	EC <emphasis>error-info</emphasis>
	EA <emphasis>error-argument</emphasis></programlisting>
  denoting constraint errors, warnings, internal errors, fatal errors,
  continuation errors and error arguments respectively.  Note that an
  error message may consist of several components; the initial error
  plus a number of continuation errors.  Each error message may also
  have a number of error argument associated with it.  This error information
  is given by:
  <programlisting language="BNF">
<emphasis>error-info</emphasis> :
	<emphasis>error-name number number</emphasis></programlisting>
  where the first <emphasis>number</emphasis> gives the number of error arguments
  which should be read, and the second is nonzero to indicate that a
  continuation error should be read.
  </para>
  <para>
  Each error argument has one of the forms:
  <programlisting language="BNF">
<emphasis>error-argument</emphasis> :
	B <emphasis>base-number</emphasis>
	C <emphasis>scope-identifier</emphasis>
	E <emphasis>expression</emphasis>
	H <emphasis>identifier-name</emphasis>
	I <emphasis>identifier</emphasis>
	L <emphasis>location</emphasis>
	N <emphasis>nat</emphasis>
	S <emphasis>string</emphasis>
	T <emphasis>type</emphasis>
	V <emphasis>number</emphasis>
	V - <emphasis>number</emphasis></programlisting>
  corresponding to the various syntactic categories described above.
  Note that a <emphasis>location</emphasis> error argument, while expressed relative
  to the
  <link linkend="crt_loc">current file location</link>, does not change this
  location.
  </para>
  </section>

  <section id="file">
    <title>File inclusions</title>
  <para>
  It is possible to include information on header files within the symbol
  table dump.  Firstly a number is associated with each directory on
  the <code>#include</code> search path:
  <programlisting language="BNF">
<emphasis>path-command</emphasis> :
	FD <emphasis>number</emphasis> = <emphasis>string string<subscript>opt</subscript></emphasis></programlisting>
  The first <emphasis>string</emphasis> gives the directory pathname; the second,
  if present, gives the associated directory name as specified in the
  <A HREF="man.html#directory"><code>-N</code> command-line option</A>.
  </para>
  <para>
  Now the start and end of each file are marked using:
  <programlisting language="BNF">
<emphasis>file-command</emphasis> :
	FS <emphasis>location directory</emphasis>
	FE <emphasis>location</emphasis></programlisting>
  where <emphasis>directory</emphasis> gives the number of the directory in the search
  path where the file was found, or <code>*</code> if the file was found
  by other means.  It is worth noting that if, for example, a function
  definition is the last item in a file, the <code>FE</code> command
  will appear in the symbol table dump before the <code>QFE</code> command
  for the end of the function definition.  This is because lexical analysis,
  where the end of file is detected, takes place before parsing, where
  the end of function is detected.
  </para>
  <para>
  A <code>#include</code> directive, whether explicit or implicit, can
  be represented using:
  <programlisting language="BNF">
<emphasis>include-command</emphasis> :
	FIA <emphasis>location string</emphasis>
	FIQ <emphasis>location string</emphasis>
	FIN <emphasis>location string</emphasis>
	FIS <emphasis>location string</emphasis>
	FIE <emphasis>location string</emphasis>
	FIR <emphasis>location</emphasis></programlisting>
  the first three corresponding to header names of the forms
  <code>&lt;....&gt;</code>, <code>&quot;....&quot;</code> and <code>[....]</code>
  respectively, the next two corresponding to <A HREF="man.html#start-up">start-up
  </A>
  and <A HREF="man.html#end-up">end-up</A> files, and the final form
  being used to resume the original file after the <code>#include</code>
  directive has been processed.
  </para>
  </section>

  <section id="string-literals">
    <title>String literals</title>
  <para>
  It is possible to dump information on string literals to the symbol
  table dump file using the commands:
  <programlisting language="BNF">
<emphasis>string-command</emphasis> :
	A <emphasis>location string</emphasis>
	AC <emphasis>location string</emphasis>
	AL <emphasis>location string</emphasis>
	ACL <emphasis>location string</emphasis></programlisting>
  representing string literals, character literals, wide string literals
  and wide character literals respectively.  The given <emphasis>string</emphasis>
  gives the string text.
  </para>
  </section>
  </section>

  <section>
    <title>Standard library</title>
  <para>
  At present the default implementation contains only a very small fraction
  of the ISO C++ library, namely those headers -
  <code>&lt;exception&gt;</code>, <code>&lt;new&gt;</code> and
  <code>&lt;typeinfo&gt;</code> - which are an integral part of the
  language specification.  These headers are also those which require
  the most cooperation between the producer and the library implementation,
  as described in the <A HREF="lib.html">previous section</A>.
  </para>
  <para>
  It is suggested that if further library components are required then
  they be acquired from third parties.  It should be noted however that
  such libraries may require <link linkend="porting">some effort</link> to be
  ported to an ISO compliant compiler; for example, some information
  on porting the <code>libio</code> component of <code>libg++</code>,
  which contains some very compiler-dependent code, are
  <link linkend="libio">given below</link>.  Libraries compiled with other C++
  compilers may not link correctly with modules compiled using <code>tcc</code>.
  </para>
  </section>
  </chapter>

  <appendix>
    <title><code>#pragma</code> directive syntax</title>
  <para>
  The following gives a summary of the syntax for the <code>#pragma</code>
  directives used for <A HREF="pragma.html">compiler configuration</A>
  and <A HREF="token.html">token specification</A>:
  <programlisting language="BNF">
<emphasis>pragma-directive</emphasis> :
	<link linkend="tendra"># pragma TenDRA ++<emphasis><subscript>opt</subscript> tendra-directive</emphasis></link>
	<link linkend="token"># pragma <emphasis>token-directive</emphasis></link>

<A id="tendra"><emphasis>tendra-directive</emphasis></A> :
	<link linkend="scope"><emphasis>scope-directive</emphasis></link>
	<link linkend="low"><emphasis>low-level-directive</emphasis></link>
	<link linkend="analysis"><emphasis>analysis-directive on</emphasis></link>
	<link linkend="check"><emphasis>check-directive allow</emphasis></link>
	<link linkend="keyword"><emphasis>keyword-directive</emphasis></link>
	<link linkend="type"><emphasis>type-directive</emphasis></link>
	<link linkend="linkage"><emphasis>linkage-directive</emphasis></link>
	<link linkend="misc"><emphasis>misc-directive</emphasis></link>
	<link linkend="token1"><emphasis>tendra-token-directive</emphasis></link>

<emphasis>on</emphasis> :
	on
	warning
	off

<emphasis>allow</emphasis> :
	allow
	warning
	disallow


<A id="scope"><emphasis>scope-directive</emphasis></A> :
	<A HREF="pragma.html#scope">begin</A>
	<A HREF="pragma.html#scope">begin name environment <emphasis>identifier</emphasis></A>
	<A HREF="pragma.html#scope">end</A>
	<A HREF="pragma.html#scope">directory <emphasis>identifier</emphasis> use environment <emphasis>identifier</emphasis></A>
	<A HREF="pragma.html#scope">use environment <emphasis>identifier</emphasis></A>
	<A HREF="pragma.html#scope">use environment <emphasis>identifier</emphasis> reset <emphasis>allow</emphasis></A>


<A id="low"><emphasis>low-level-directive</emphasis></A> :
	<A HREF="pragma.html#low">error <emphasis>string-literal allow</emphasis></A>
	<A HREF="pragma.html#low">error <emphasis>string-literal on</emphasis></A>
	<A HREF="pragma.html#low">error <emphasis>string-literal</emphasis> as option <emphasis>string-literal</emphasis></A>
	<A HREF="pragma.html#low">option <emphasis>string-literal allow</emphasis></A>
	<A HREF="pragma.html#low">option <emphasis>string-literal on</emphasis></A>
	<A HREF="pragma.html#limits">option value <emphasis>string-literal integer-literal</emphasis></A>
	<A HREF="pragma.html#low">use error <emphasis>string-literal</emphasis></A>


<A id="analysis"><emphasis>analysis-directive</emphasis></A> :
	<A HREF="pragma.html#init">complete initialization analysis</A>
	<A HREF="pragma.html#elab">complete struct / union analysis</A>
	<A HREF="pragma.html#conv">conversion analysis <emphasis>conversion-spec<subscript>opt</subscript></emphasis></A>
	<A HREF="pragma.html#discard">discard analysis <emphasis>discard-spec<subscript>opt</subscript></emphasis></A>
	<A HREF="pragma.html#switch">enum switch analysis</A>
	<A HREF="pragma.html#linkage">external function linkage</A>
	<A HREF="pragma.html#for">for initialization block</A>
	<A HREF="pragma.html#elab">ignore struct / union / enum tag</A>
	<A HREF="pragma.html#template">implicit export template</A>
	<A HREF="pragma.html#impl_func">implicit function declaration</A>
	<A HREF="pragma.html#exp">integer operator analysis</A>
	<A HREF="pragma.html#exp">integer overflow analysis</A>
	<A HREF="pragma.html#comment">nested comment analysis</A>
	<A HREF="pragma.html#exp">operator precedence analysis</A>
	<A HREF="pragma.html#exp">pointer operator analysis</A>
	<A HREF="pragma.html#throw">throw analysis</A>
	<A HREF="pragma.html#linkage">unify external linkage</A>
	<A HREF="pragma.html#variable">variable analysis</A>
	<A HREF="pragma.html#hide">variable hiding analysis</A>
	<A HREF="pragma.html#weak">weak prototype analysis</A>

<emphasis>conversion-spec</emphasis> :
	( int - int <emphasis>implicit-spec<subscript>opt</subscript></emphasis> )
	( int - pointer <emphasis>implicit-spec<subscript>opt</subscript></emphasis> )
	( pointer - int <emphasis>implicit-spec<subscript>opt</subscript></emphasis> )
	( pointer - pointer <emphasis>implicit-spec<subscript>opt</subscript></emphasis> )
	( int - enum implicit )
	( pointer - void * implicit )
	( void * - pointer implicit )

<emphasis>implicit-spec</emphasis> :
	implicit
	explicit

<emphasis>discard-spec</emphasis> :
	( function return )
	( static )
	( value )


<A id="check"><emphasis>check-directive</emphasis></A> :
	<A HREF="pragma.html#overload">ambiguous overload resolution</A>
	<A HREF="pragma.html#if">assignment as bool</A>
	<A HREF="pragma.html#bitfield">bitfield overflow</A>
	<A HREF="pragma.html#linkage">block function static</A>
	<A HREF="pragma.html#catch_all">catch all</A>
	<A HREF="pragma.html#escape">character escape overflow</A>
	<A HREF="token.html#tokdef">compatible token</A>
	<A HREF="pragma.html#include">complete file includes</A>
	<A HREF="pragma.html#target-if">conditional declaration</A>
	<A HREF="pragma.html#lvalue">conditional lvalue</A>
	<A HREF="pragma.html#overload">conditional overload resolution <emphasis>overload-spec<subscript>opt</subscript></emphasis></A>
	<A HREF="pragma.html#if">const conditional</A>
	<A HREF="pragma.html#macro">directive as macro argument</A>
	<A HREF="pragma.html#identifier">dollar as ident</A>
	<A HREF="pragma.html#elab">extra ,</A>
	<A HREF="pragma.html#decl_none">extra ;</A>
	<A HREF="pragma.html#if">extra ; after conditional</A>
	<A HREF="pragma.html#weak">extra ...</A>
	<A HREF="pragma.html#bitfield">extra bitfield int type</A>
	<A HREF="pragma.html#macro">extra macro definition</A>
	<A HREF="pragma.html#typedef">extra type definition</A>
	<A HREF="pragma.html#switch">fall into case</A>
	<A HREF="pragma.html#elab">forward enum declaration</A>
	<A HREF="pragma.html#conv">function pointer as pointer</A>
	<A HREF="pragma.html#ellipsis">ident ...</A>
	<A HREF="pragma.html#implicit">implicit int type <emphasis>inttype-spec<subscript>opt</subscript></emphasis></A>
	<A HREF="token.html#tokdef">implicit token definition</A>
	<A HREF="token.html#spec">incompatible interface declaration</A>
	<A HREF="token.html#member">incompatible member declaration</A>
	<A HREF="pragma.html#linkage">incompatible linkage</A>
	<A HREF="pragma.html#weak">incompatible promoted function argument</A>
	<A HREF="pragma.html#compatible">incompatible type qualifier</A>
	<A HREF="pragma.html#return">incompatible void return</A>
	<A HREF="pragma.html#complete">incomplete type as object type</A>
	<A HREF="pragma.html#ppdir">indented # directive</A>
	<A HREF="pragma.html#ppdir">indented directive after #</A>
	<A HREF="pragma.html#init">initialization of struct / union ( auto )</A>
	<A HREF="pragma.html#longlong">longlong type</A>
	<A HREF="pragma.html#ppdir">no directive / nline after ident</A>
	<A HREF="pragma.html#empty">no external declaration</A>
	<A HREF="pragma.html#macro">no ident after #</A>
	<A HREF="pragma.html#lex">no nline after file end</A>
	<A HREF="token.html#tokdef">no token definition</A>
	<A HREF="pragma.html#overload">overload resolution</A>
	<A HREF="pragma.html#weak">prototype</A>
	<A HREF="pragma.html#weak">prototype ( weak )</A>
	<A HREF="token.html#exp">rvalue token as const</A>
	<A HREF="pragma.html#ppdir">text after directive</A>
	<A HREF="pragma.html#lvalue">this lvalue</A>
	<A HREF="pragma.html#string">unify incompatible string literal</A>
	<A HREF="pragma.html#ppdir">unknown directive</A>
	<A HREF="pragma.html#escape">unknown escape</A>
	<A HREF="pragma.html#ppdir">unknown pragma</A>
	<A HREF="pragma.html#decl_none">unknown struct / union</A>
	<A HREF="pragma.html#string">unmatched quote</A>
	<A HREF="pragma.html#reach">unreachable code</A>
	<A HREF="pragma.html#init">variable initialization</A>
	<A HREF="pragma.html#macro">weak macro equality</A>
	<A HREF="pragma.html#string">writeable string literal</A>

<emphasis>inttype-spec</emphasis> :
	for const / volatile
	for external declaration
	for function return

<emphasis>overload-spec</emphasis> :
	( complete )
	( incomplete )


<A id="keyword"><emphasis>keyword-directive</emphasis></A> :
	<link linkend="keyword">keyword <emphasis>identifier</emphasis> for <emphasis>keyword-spec</emphasis></link>
	<A HREF="pragma.html#keyword-spec">undef keyword <emphasis>identifier</emphasis></A>

<A id="keyword-spec"><emphasis>keyword-spec</emphasis></A> :
	<A HREF="pragma.html#discard">discard value</A>
	<A HREF="pragma.html#variable">discard variable</A>
	<A HREF="pragma.html#switch">exhaustive</A>
	<A HREF="pragma.html#switch">fall into case</A>
	<A HREF="pragma.html#keyword">keyword <emphasis>identifier</emphasis></A>
	<A HREF="pragma.html#keyword">operator <emphasis>operator</emphasis></A>
	<A HREF="pragma.html#variable">set</A>
	<A HREF="pragma.html#reach">set reachable</A>
	<A HREF="pragma.html#reach">set unreachable</A>
	<A HREF="pragma.html#conv">type representation</A>
	<A HREF="pragma.html#weak">weak</A>


<A id="type-directive"><emphasis>type-directive</emphasis></A> :
	<A HREF="pragma.html#reach">bottom <emphasis>identifier</emphasis></A>
	<A HREF="pragma.html#char">character <emphasis>character-sign</emphasis></A>
	<A HREF="pragma.html#identifier">character <emphasis>character-literal character-mapping</emphasis></A>
	<A HREF="pragma.html#identifier">character <emphasis>string-literal character-mapping</emphasis></A>
	<A HREF="lib.html#arith">compute promote <emphasis>identifier</emphasis></A>
	<A HREF="pragma.html#escape">escape <emphasis>character-literal character-mapping</emphasis></A>
	<A HREF="pragma.html#int">integer literal <emphasis>literal-spec</emphasis></A>
	<A HREF="lib.html#arith">promoted <emphasis>type-id</emphasis> : <emphasis>type-id</emphasis></A>
	<A HREF="pragma.html#char">set character literal : <emphasis>type-id</emphasis></A>
	<A HREF="pragma.html#longlong">set longlong type : <emphasis>longlong-spec</emphasis></A>
	<A HREF="pragma.html#char">set ptrdiff_t : <emphasis>type-id</emphasis></A>
	<A HREF="pragma.html#char">set size_t : <emphasis>type-id</emphasis></A>
	<A HREF="pragma.html#char">set wchar_t : <emphasis>type-id</emphasis></A>
	<A HREF="pragma.html#string">set string literal : <emphasis>string-const</emphasis></A>
	<A HREF="pragma.html#std">set std namespace : <emphasis>scope-name</emphasis></A>
	<link linkend="type-spec">type <emphasis>identifier</emphasis> for <emphasis>type-spec</emphasis></link>

<emphasis>character-sign</emphasis> :
	signed
	unsigned
	either

<emphasis>character-mapping</emphasis> :
	as <emphasis>character-literal</emphasis> allow
	disallow

<emphasis>literal-spec</emphasis> :
	<emphasis>literal-base literal-suffix<subscript>opt</subscript> literal-type-list</emphasis>

<emphasis>literal-base</emphasis> :
	decimal
	octal
	hexadecimal

<emphasis>literal-suffix</emphasis> :
	unsigned
	long
	unsigned long
	long long
	unsigned long long

<emphasis>literal-type-list</emphasis> :
	* <emphasis>literal-type-spec</emphasis>
	<emphasis>integer-literal literal-type-spec</emphasis> | <emphasis>literal-type-list</emphasis>
	? <emphasis>literal-type-spec</emphasis> | <emphasis>literal-type-list</emphasis>

<emphasis>literal-type-spec</emphasis> :
	: <emphasis>type-id</emphasis>
	* <emphasis>allow<subscript>opt</subscript></emphasis> : <emphasis>identifier</emphasis>
	* * <emphasis>allow<subscript>opt</subscript></emphasis> :

<emphasis>longlong-spec</emphasis> :
	long
	long long

<emphasis>string-const</emphasis> :
	const
	no const

<emphasis>scope-name</emphasis> :
	<emphasis>identifier</emphasis>
	::

<A id="type-spec"><emphasis>type-spec</emphasis></A> :
	<A HREF="pragma.html#reach">bottom</A>
	<A HREF="pragma.html#char">ptrdiff_t</A>
	<A HREF="pragma.html#char">size_t</A>
	<A HREF="pragma.html#char">wchar_t</A>
	<A HREF="pragma.html#printf">... printf</A>
	<A HREF="pragma.html#printf">... scanf</A>


<A id="linkage"><emphasis>linkage-directive</emphasis></A> :
	<A HREF="pragma.html#linkage">const linkage <emphasis>linkage</emphasis></A>
	<A HREF="pragma.html#linkage">external linkage <emphasis>string-literal</emphasis></A>
	<A HREF="pragma.html#linkage">external volatile_t</A>
	<A HREF="pragma.html#linkage">inline linkage <emphasis>linkage</emphasis></A>
	<A HREF="pragma.html#linkage">linkage resolution : <emphasis>linkage-spec</emphasis></A>

<emphasis>linkage</emphasis> :
	external
	internal

<emphasis>linkage-spec</emphasis> :
	( <emphasis>linkage</emphasis> ) on
	( <emphasis>linkage</emphasis> ) warning
	off


<A id="misc"><emphasis>misc-directive</emphasis></A> :
	<A HREF="pragma.html#weak">argument <emphasis>type-id</emphasis> as ...</A>
	<A HREF="pragma.html#weak">argument <emphasis>type-id</emphasis> as <emphasis>type-id</emphasis></A>
	<A HREF="pragma.html#compatible">compatible type : <emphasis>type-id</emphasis> == <emphasis>type-id</emphasis> : <emphasis>allow</emphasis></A>
	<A HREF="pragma.html#conv">conversion <emphasis>identifier-list</emphasis> allow</A>
	<A HREF="dump.html#scope">declaration block <emphasis>identifier</emphasis> begin</A>
	<A HREF="dump.html#scope">declaration block end</A>
	<A HREF="pragma.html#ppdir">directive <emphasis>directive-spec directive-state</emphasis></A>
	<A HREF="pragma.html#variable">discard <emphasis>expression</emphasis></A>
	<A HREF="pragma.html#switch">exhaustive</A>
	<A HREF="pragma.html#cast">explicit cast <emphasis>cast-spec<subscript>opt</subscript> allow</emphasis></A>
	<A HREF="pragma.html#include">includes depth <emphasis>integer-literal</emphasis></A>
	<A HREF="pragma.html#static">preserve <emphasis>preserve-list</emphasis></A>
	<A HREF="pragma.html#variable">set <emphasis>expression</emphasis></A>
	<A HREF="pragma.html#limits">set error limit <emphasis>integer-literal</emphasis></A>
	<A HREF="pragma.html#identifier">set name limit <emphasis>integer-literal</emphasis> warning<emphasis><subscript>opt</subscript></emphasis></A>
	<A HREF="pragma.html#discard">suspend static <emphasis>identifier-list</emphasis></A>

<emphasis>directive-spec</emphasis> :
	assert
	file
	ident
	import
	include_next
	unassert
	warning
	weak

<emphasis>directive-state</emphasis> :
	allow
	warning
	disallow
	( ignore ) allow
	( ignore ) warning

<emphasis>cast-operator</emphasis> :
	static_cast
	const_cast
	reinterpret_cast

<emphasis>cast-spec</emphasis> :
	as <emphasis>cast-operator</emphasis>
	<emphasis>cast-spec</emphasis> | <emphasis>cast-operator</emphasis>

<emphasis>preserve-list</emphasis> :
	<emphasis>identifier-list</emphasis>
	*

<emphasis>identifier-list</emphasis> :
	<emphasis>identifier identifier-list<subscript>opt</subscript></emphasis>


<A id="token"><emphasis>token-directive</emphasis></A> :
	<A HREF="token.html#spec">token <emphasis>token-spec</emphasis></A>
	<A HREF="token.html#tokdef">no_def <emphasis>token-list</emphasis></A>
	<A HREF="token.html#tokdef">define <emphasis>token-list</emphasis></A>
	<A HREF="token.html#tokdef">ignore <emphasis>token-list</emphasis></A>
	<A HREF="token.html#tokdef">interface <emphasis>token-list</emphasis></A>
	<A HREF="token.html#tokdef">undef token <emphasis>token-list</emphasis></A>
	<A HREF="token.html#tokdef">extend interface <emphasis>header-name</emphasis></A>
	<A HREF="token.html#tokdef">implement interface <emphasis>header-name</emphasis></A>

<A id="token1"><emphasis>tendra-token-directive</emphasis></A> :
	<A HREF="token.html#spec">token <emphasis>token-spec</emphasis></A>
	<A HREF="token.html#tokdef">no_def <emphasis>token-list</emphasis></A>
	<A HREF="token.html#tokdef">define <emphasis>token-list</emphasis></A>
	<A HREF="token.html#tokdef">reject <emphasis>token-list</emphasis></A>
	<A HREF="token.html#tokdef">interface <emphasis>token-list</emphasis></A>
	<A HREF="token.html#tokdef">undef token <emphasis>token-list</emphasis></A>
	<A HREF="token.html#tokdef">extend <emphasis>header-name</emphasis></A>
	<A HREF="token.html#tokdef">implement <emphasis>header-name</emphasis></A>
	<A HREF="token.html#tokdef">member definition <emphasis>type-id</emphasis> : <emphasis>identifier member-offset</emphasis></A>

<emphasis>member-offset</emphasis> :
	::<emphasis><subscript>opt</subscript> id-expression</emphasis>
	<emphasis>member-offset</emphasis> . ::<emphasis><subscript>opt</subscript> id-expression</emphasis>
	<emphasis>member-offset</emphasis> [ <emphasis>constant-expression</emphasis> ]

<emphasis>token-list</emphasis> :
	<emphasis>token-id token-list<subscript>opt</subscript></emphasis>
	# <emphasis>preproc-token-list</emphasis>

<emphasis>token-id</emphasis> :
	<emphasis>token-namespace<subscript>opt</subscript> identifier</emphasis>
	<emphasis>type-id</emphasis> . <emphasis>identifier</emphasis>


<emphasis>token-spec</emphasis> :
	<emphasis>token-introduction token-identification</emphasis>

<emphasis>token-introduction</emphasis> :
	<emphasis>exp-token</emphasis>
	<emphasis>statement-token</emphasis>
	<emphasis>type-token</emphasis>
	<emphasis>member-token</emphasis>
	<emphasis>procedure-token</emphasis>

<emphasis>token-identification</emphasis> :
	<emphasis>token-namespace<subscript>opt</subscript> identifier</emphasis> # <emphasis>external-identifier<subscript>opt</subscript></emphasis>

<emphasis>token-namespace</emphasis> :
	TAG

<emphasis>external-identifier</emphasis> :
	-
	<emphasis>preproc-token-list</emphasis>

<emphasis>exp-token</emphasis> :
	EXP <emphasis>exp-storage<subscript>opt</subscript></emphasis> : <emphasis>type-id</emphasis> :
	NAT
	INTEGER

<emphasis>exp-storage</emphasis> :
	lvalue
	rvalue
	const

<emphasis>statement-token</emphasis> :
	STATEMENT

<emphasis>type-token</emphasis> :
	TYPE
	VARIETY
	VARIETY signed
	VARIETY unsigned
	FLOAT
	ARITHMETIC
	SCALAR
	CLASS
	STRUCT
	UNION

<emphasis>member-token</emphasis> :
	MEMBER <emphasis>access-specifier<subscript>opt</subscript> member-type-id</emphasis> : <emphasis>type-id</emphasis> :

<emphasis>member-type-id</emphasis> :
	<emphasis>type-id</emphasis>
	<emphasis>type-id</emphasis> % <emphasis>constant-expression</emphasis>

<emphasis>access-specifier</emphasis> :
	public
	protected
	private

<emphasis>procedure-token</emphasis> :
	<emphasis>general-procedure</emphasis>
	<emphasis>simple-procedure</emphasis>
	<emphasis>function-procedure</emphasis>

<emphasis>general-procedure</emphasis> :
	PROC { <emphasis>bound-toks<subscript>opt</subscript></emphasis> | <emphasis>prog-pars<subscript>opt</subscript></emphasis> } <emphasis>token-introduction</emphasis>

<emphasis>bound-toks</emphasis> :
	<emphasis>bound-token</emphasis>
	<emphasis>bound-token</emphasis> , <emphasis>bound-toks</emphasis>

<emphasis>bound-token</emphasis> :
	<emphasis>token-introduction token-namespace<subscript>opt</subscript> identifier</emphasis>

<emphasis>prog-pars</emphasis> :
	<emphasis>program-parameter</emphasis>
	<emphasis>program-parameter</emphasis> , <emphasis>prog-pars</emphasis>

<emphasis>program-parameter</emphasis> :
	EXP <emphasis>identifier</emphasis>
	STATEMENT <emphasis>identifier</emphasis>
	TYPE <emphasis>type-id</emphasis>
	MEMBER <emphasis>type-id</emphasis> : <emphasis>identifier</emphasis>
	PROC <emphasis>identifier</emphasis>

<emphasis>simple-procedure</emphasis> :
	PROC ( <emphasis>simple-toks<subscript>opt</subscript></emphasis> ) <emphasis>token-introduction</emphasis>

<emphasis>simple-toks</emphasis> :
	<emphasis>simple-token</emphasis>
	<emphasis>simple-token</emphasis> , <emphasis>simple-toks</emphasis>

<emphasis>simple-token</emphasis> :
	<emphasis>token-introduction token-namespace<subscript>opt</subscript> identifier<subscript>opt</subscript></emphasis>

<emphasis>function-procedure</emphasis> :
	FUNC <emphasis>type-id</emphasis> :</programlisting>
  </para>
  </appendix>

  <appendix>
    <title>Symbol table dump syntax</title>
  <para>
  The following gives a summary of the syntax for the
  <A HREF="dump.html">symbol table dump file</A> (version 1.1):
  <programlisting language="BNF">
<emphasis>dump-file</emphasis> :
	<emphasis>command-list<subscript>opt</subscript></emphasis>

<emphasis>command-list</emphasis> :
	<emphasis>command command-list<subscript>opt</subscript></emphasis>

<emphasis>command</emphasis> :
	<emphasis>version-command</emphasis>
	<emphasis>identifier-command</emphasis>
	<emphasis>scope-command</emphasis>
	<emphasis>override-command</emphasis>
	<emphasis>base-command</emphasis>
	<emphasis>api-command</emphasis>
	<emphasis>template-command</emphasis>
	<emphasis>promotion-command</emphasis>
	<emphasis>error-command</emphasis>
	<emphasis>path-command</emphasis>
	<emphasis>file-command</emphasis>
	<emphasis>include-command</emphasis>
	<emphasis>string-command</emphasis>

<emphasis>version-command</emphasis> :
	V <emphasis>number number string</emphasis>


<emphasis>location</emphasis> :
	<emphasis>number number number string string</emphasis>
	<emphasis>number number number string</emphasis> *
	<emphasis>number number number</emphasis> *
	<emphasis>number number</emphasis> *
	<emphasis>number</emphasis> *
	*


<emphasis>identifier</emphasis> :
	<emphasis>number</emphasis> = <emphasis>identifier-name access<subscript>opt</subscript> scope-identifier</emphasis>
	<emphasis>number</emphasis>

<emphasis>identifier-name</emphasis> :
	<emphasis>string</emphasis>
	C <emphasis>type</emphasis>
	D <emphasis>type</emphasis>
	O <emphasis>string</emphasis>
	T <emphasis>type</emphasis>

<emphasis>access</emphasis> :
	N
	B
	P

<emphasis>scope-identifier</emphasis> :
	<emphasis>identifier</emphasis>
	*

<emphasis>identifier-command</emphasis> :
	D <emphasis>identifier-info type-info</emphasis>
	M <emphasis>identifier-info type-info</emphasis>
	T <emphasis>identifier-info type-info</emphasis>
	Q <emphasis>identifier-info</emphasis>
	U <emphasis>identifier-info</emphasis>
	L <emphasis>identifier-info</emphasis>
	C <emphasis>identifier-info</emphasis>
	W <emphasis>identifier-info type-info</emphasis>
	I <emphasis>identifier-command</emphasis>

<emphasis>identifier-info</emphasis> :
	<emphasis>identifier-key location identifier</emphasis>

<emphasis>identifier-key</emphasis> :
	K
	MO
	MF
	MB
	TC
	TS
	TU
	TE
	TA
	NN
	NA
	VA
	VP
	VE
	VS
	FE <emphasis>function-key<subscript>opt</subscript></emphasis>
	FS <emphasis>function-key<subscript>opt</subscript></emphasis>
	FB <emphasis>function-key<subscript>opt</subscript></emphasis>
	CF <emphasis>function-key<subscript>opt</subscript></emphasis>
	CS <emphasis>function-key<subscript>opt</subscript></emphasis>
	CV <emphasis>function-key<subscript>opt</subscript></emphasis>
	CM
	CD
	E
	L
	XO
	XF
	XP
	XT

<emphasis>function-key</emphasis> :
	C <emphasis>function-key<subscript>opt</subscript></emphasis>
	I <emphasis>function-key<subscript>opt</subscript></emphasis>

<emphasis>type-info</emphasis> :
	<emphasis>type identifier<subscript>opt</subscript></emphasis>
	<emphasis>sort</emphasis>
	<emphasis>scope-identifier</emphasis>
	*


<emphasis>scope-command</emphasis> :
	SS <emphasis>scope-key location identifier</emphasis>
	SE <emphasis>scope-key location identifier</emphasis>

<emphasis>scope-key</emphasis> :
	N
	S
	B
	D
	H
	CT
	CF
	CC


<emphasis>override-command</emphasis> :
	O <emphasis>identifier identifier</emphasis>


<emphasis>base-command</emphasis> :
	B <emphasis>identifier-key identifier base-graph</emphasis>

<emphasis>base-graph</emphasis> :
	<emphasis>base-class</emphasis>
	<emphasis>base-class</emphasis> ( <emphasis>base-list</emphasis> )

<emphasis>base-class</emphasis> :
	<emphasis>number</emphasis> = V<emphasis><subscript>opt</subscript> access<subscript>opt</subscript> type-name</emphasis>
	<emphasis>number</emphasis> :

<emphasis>base-list</emphasis> :
	<emphasis>base-graph base-list<subscript>opt</subscript></emphasis>

<emphasis>base-number</emphasis> :
	<emphasis>number</emphasis> : <emphasis>type-name</emphasis>


<emphasis>api-command</emphasis> :
	X <emphasis>identifier-key identifier string</emphasis>


<emphasis>template-command</emphasis> :
	Z <emphasis>identifier-key identifier token-application specialise-info</emphasis>

<emphasis>specialise-info</emphasis> :
	<emphasis>identifier</emphasis>
	<emphasis>token-application</emphasis>
	*


<emphasis>type</emphasis> :
	<emphasis>type-name</emphasis>
	c
	s
	i
	l
	x
	b
	w
	y
	z
	f
	d
	r
	v
	u
	Sc
	Uc
	Us
	Ui
	Ul
	Ux
	C <emphasis>type</emphasis>
	V <emphasis>type</emphasis>
	P <emphasis>type</emphasis>
	R <emphasis>type</emphasis>
	M <emphasis>type-name</emphasis> : <emphasis>type</emphasis>
	F <emphasis>type parameter-types</emphasis>
	A <emphasis>nat<subscript>opt</subscript></emphasis> : <emphasis>type</emphasis>
	B <emphasis>nat</emphasis> : <emphasis>type</emphasis>
	t <emphasis>parameter-list<subscript>opt</subscript></emphasis> : <emphasis>type</emphasis>
	p <emphasis>type</emphasis>
	a <emphasis>type</emphasis> : <emphasis>type</emphasis>
	n <emphasis>lit-base<subscript>opt</subscript> lit-suffix<subscript>opt</subscript></emphasis>
	W <emphasis>type parameter-types</emphasis>
	q <emphasis>type</emphasis>
	Q <emphasis>string</emphasis>
	*

<emphasis>type-name</emphasis> :
	<emphasis>identifier</emphasis>
	<emphasis>token-application</emphasis>

<emphasis>parameter-types</emphasis> :
	: <emphasis>exception-spec<subscript>opt</subscript> func-qualifier<subscript>opt</subscript></emphasis> :
	. <emphasis>exception-spec<subscript>opt</subscript> func-qualifier<subscript>opt</subscript></emphasis> :
	. <emphasis>exception-spec<subscript>opt</subscript> func-qualifier<subscript>opt</subscript></emphasis> .
	, <emphasis>type parameter-types</emphasis>

<emphasis>func-qualifier</emphasis> :
	C <emphasis>func-qualifier<subscript>opt</subscript></emphasis>
	V <emphasis>func-qualifier<subscript>opt</subscript></emphasis>

<emphasis>exception-spec</emphasis> :
	( <emphasis>exception-list<subscript>opt</subscript></emphasis> )

<emphasis>exception-list</emphasis> :
	<emphasis>type</emphasis>
	<emphasis>type</emphasis> , <emphasis>exception-list</emphasis>

<emphasis>nat</emphasis> :
	+ <emphasis>number</emphasis>
	- <emphasis>number</emphasis>
	<emphasis>identifier</emphasis>
	<emphasis>token-application</emphasis>
	<emphasis>string</emphasis>

<emphasis>parameter-list</emphasis> :
	<emphasis>identifier</emphasis>
	<emphasis>identifier</emphasis> , <emphasis>parameter-list</emphasis>

<emphasis>lit-base</emphasis> :
	O
	X

<emphasis>lit-suffix</emphasis> :
	U
	l
	Ul
	x
	Ux


<emphasis>promotion-command</emphasis> :
	P <emphasis>type</emphasis> : <emphasis>type</emphasis>


<emphasis>sort</emphasis> :
	<emphasis>expression-sort</emphasis>
	<emphasis>statement-sort</emphasis>
	<emphasis>type-sort</emphasis>
	<emphasis>tag-type-sort</emphasis>
	<emphasis>member-sort</emphasis>
	<emphasis>proc-sort</emphasis>
	<emphasis>func-sort</emphasis>
	<emphasis>template-sort</emphasis>
	<emphasis>macro-sort</emphasis>

<emphasis>expression-sort</emphasis> :
	ZEL <emphasis>type</emphasis>
	ZER <emphasis>type</emphasis>
	ZEC <emphasis>type</emphasis>
	ZN

<emphasis>statement-sort</emphasis> :
	ZS

<emphasis>type-sort</emphasis> :
	ZTO
	ZTI
	ZTF
	ZTA
	ZTP
	ZTS
	ZTU

<emphasis>tag-type-sort</emphasis> :
	ZTTS
	ZTTU

<emphasis>member-sort</emphasis> :
	ZM <emphasis>type</emphasis> : <emphasis>type-name</emphasis>

<emphasis>proc-sort</emphasis> :
	ZPG <emphasis>parameter-list<subscript>opt</subscript></emphasis> ; <emphasis>parameter-list<subscript>opt</subscript></emphasis> : <emphasis>sort</emphasis>
	ZPS <emphasis>parameter-list<subscript>opt</subscript></emphasis> : <emphasis>sort</emphasis>

<emphasis>func-sort</emphasis> :
	ZF <emphasis>type</emphasis>

<emphasis>template-sort</emphasis> :
	ZTt <emphasis>parameter-list<subscript>opt</subscript></emphasis> :

<emphasis>macro-sort</emphasis> :
	ZUO
	ZUF <emphasis>number</emphasis>

<emphasis>token-application</emphasis> :
	T <emphasis>identifier</emphasis> , <emphasis>token-argument-list</emphasis> :

<emphasis>token-argument-list</emphasis> :
	<emphasis>token-argument</emphasis>
	<emphasis>token-argument</emphasis> , <emphasis>token-argument-list</emphasis>

<emphasis>token-argument</emphasis> :
	E <emphasis>expression</emphasis>
	N <emphasis>nat</emphasis>
	S <emphasis>statement</emphasis>
	T <emphasis>type</emphasis>
	M <emphasis>member</emphasis>
	F <emphasis>identifier</emphasis>
	C <emphasis>identifier</emphasis>

<emphasis>expression</emphasis> :
	<emphasis>nat</emphasis>

<emphasis>statement</emphasis> :
	<emphasis>expression</emphasis>

<emphasis>member</emphasis> :
	<emphasis>identifier</emphasis>
	<emphasis>string</emphasis>


<emphasis>error-name</emphasis> :
	<emphasis>number</emphasis> = <emphasis>string</emphasis>
	<emphasis>number</emphasis>

<emphasis>error-command</emphasis> :
	ES <emphasis>location error-info</emphasis>
	EW <emphasis>location error-info</emphasis>
	EI <emphasis>location error-info</emphasis>
	EF <emphasis>location error-info</emphasis>
	EC <emphasis>error-info</emphasis>
	EA <emphasis>error-argument</emphasis>

<emphasis>error-info</emphasis> :
	<emphasis>error-name number number</emphasis>

<emphasis>error-argument</emphasis> :
	B <emphasis>base-number</emphasis>
	C <emphasis>scope-identifier</emphasis>
	E <emphasis>expression</emphasis>
	H <emphasis>identifier-name</emphasis>
	I <emphasis>identifier</emphasis>
	L <emphasis>location</emphasis>
	N <emphasis>nat</emphasis>
	S <emphasis>string</emphasis>
	T <emphasis>type</emphasis>
	V <emphasis>number</emphasis>
	V - <emphasis>number</emphasis>


<emphasis>path-command</emphasis> :
	FD <emphasis>number</emphasis> = <emphasis>string string<subscript>opt</subscript></emphasis>

<emphasis>directory</emphasis> :
	<emphasis>number</emphasis>
	*

<emphasis>file-command</emphasis> :
	FS <emphasis>location directory</emphasis>
	FE <emphasis>location</emphasis>

<emphasis>include-command</emphasis> :
	FIA <emphasis>location string</emphasis>
	FIQ <emphasis>location string</emphasis>
	FIN <emphasis>location string</emphasis>
	FIS <emphasis>location string</emphasis>
	FIE <emphasis>location string</emphasis>
	FIR <emphasis>location</emphasis>


<emphasis>string-command</emphasis> :
	A <emphasis>location string</emphasis>
	AC <emphasis>location string</emphasis>
	AL <emphasis>location string</emphasis>
	ACL <emphasis>location string</emphasis></programlisting>
  </para>
  </appendix>

<!-- TODO bibliography -->
  <chapter id="reference">
    <title>References</title>
    <itemizedlist>
      <listitem><A id="cplusplus"><code>Working paper for Draft Proposed
      Internation Standard for Information Systems - Programming Language
      C++</code></A>, X3J16/96-0225, December 1996:
      <ulink url="http://www.cygnus.com/misc/wp/dec96pub/"/> or
      <ulink url="http://www.maths.warwick.ac.uk/c++/pub/wp/html/cd2/"/>.
      </listitem>
      <listitem><A id="arm"><code>The Annotated C++ Reference Manual</code></A>,
      Margaret Ellis and Bjarne Stroustrup, ISBN 0-201-51459-1,
      Addison-Wesley, 1990:
      <ulink url="http://heg-school.aw.com/cseng/authors/ellis/annocpp/annocpp.html"/>
      </listitem>
      <listitem><dt:doc name="user/guides/tdfc"/>:
      <A HREF="../tdfc/tdfc1.html">attached</A>.
      </listitem>
    </itemizedlist>
  </chapter>
</book>

