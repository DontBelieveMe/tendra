<?xml version="1.0" standalone="no"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
  "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">

<chapter>
    <title>Symbol table dump</title>
  <para>
  The symbol table dump provides a method whereby third party tools
  can interface with the C and C++ producers.  The producer outputs
  information on the identifiers declared within a source file, their
  uses etc. into a file which can then be post-processed by a separate
  tool. Any error messages and warnings can also be included in this
  file, allowing more sophisticated error presentation tools to be written.
  </para>
  <para>
  The file to be used as the symbol table output file, plus details
  of what information is to be included in the dump file can be specified
  using the <A HREF="man.html#dump"><code>-d</code> command-line option</A>.
  The format of the dump file is described below; a
  <A HREF="dump1.html">summary of the syntax</A> is given as an annex.
  </para>


  <section id="lexical-elements">
    <title>Lexical elements</title>
  <para>
  A symbol table dump file consists of a sequence of characters giving
  information on identifiers, errors etc. arising from a translation
  unit. The fundamental lexical tokens are a <emphasis>number</emphasis>, consisting
  of a sequence of decimal digits, and a <emphasis>string</emphasis>, consisting of
  a sequence of characters enclosed in angle braces.  A <emphasis>string</emphasis>
  can have one of two forms:
  <programlisting language="BNF">
<emphasis>string</emphasis> :
	&lt;<emphasis>characters</emphasis>&gt;
	&amp;<emphasis>number</emphasis>&lt;<emphasis>characters</emphasis>&gt;</programlisting>
  In the first form, the <emphasis>characters</emphasis> are terminated by the first
  <code>&gt;</code> character encountered.  In the second form, the
  number of characters is given by the preceding <emphasis>number</emphasis>.  No
  white space is allowed either before or after the <emphasis>number</emphasis>.
  To aid parsers, the C++ producer always uses the second form for strings
  containing more than 100 characters.  There are no escape characters
  in strings; the
  <emphasis>characters</emphasis> can contain any characters, including newlines and
  <code>#</code>, except that the first form cannot contain a
  <code>&gt;</code> character.
  </para>
  <para>
  Space, tab and newline characters are white space.  Comments begin
  with
  <code>#</code> and run to the end of the line.  Comments are treated
  as white space.  All other characters are treated as distinct lexical
  tokens.
  </para>
  </section>

  <section id="main">
    <title>Overall syntax</title>
  <para>
  A symbol table dump file takes the form of a list of commands of various
  kinds conveying information on the analysed file.  This can be represented
  as follows:
  <programlisting language="BNF">
<emphasis>dump-file</emphasis> :
	<emphasis>command-list<subscript>opt</subscript></emphasis>

<emphasis>command-list</emphasis> :
	<emphasis>command command-list<subscript>opt</subscript></emphasis>

<emphasis>command</emphasis> :
	<emphasis>version-command</emphasis>
	<emphasis>identifier-command</emphasis>
	<emphasis>scope-command</emphasis>
	<emphasis>override-command</emphasis>
	<emphasis>base-command</emphasis>
	<emphasis>api-command</emphasis>
	<emphasis>template-command</emphasis>
	<emphasis>promotion-command</emphasis>
	<emphasis>error-command</emphasis>
	<emphasis>path-command</emphasis>
	<emphasis>file-command</emphasis>
	<emphasis>include-command</emphasis>
	<emphasis>string-command</emphasis></programlisting>
  The various kinds of command are discussed below.  The first command
  in the dump file should be of the form:
  <programlisting language="BNF">
<emphasis>version-command</emphasis> :
	V <emphasis>number number string</emphasis></programlisting>
  where the two numbers give the version of the dump file format (the
  version described here is 1.1 so both numbers should be 1) and the
  string gives the language being represented, for example,
  <code>&lt;C++&gt;</code>.
  </para>
  </section>

  <section id="file-locations">
    <title>File locations</title>
  <para>
  A location within a source file can be specified using three
  <emphasis>number</emphasis>s and two <emphasis>string</emphasis>s.  These give respectively, the
  column number, the line number taking <code>#line</code> directives
  into account, the line number not taking <code>#line</code> directives
  into account, the file name taking <code>#line</code> directives into
  account, and the file name not taking <code>#line</code> directives
  into account.  Any or all of the trailing elements can be replaced
  by
  <code>*</code> to indicate that they have not changed relative to
  the last <emphasis>location</emphasis> given.  Note that for the two line numbers,
  unchanged means that the difference of the line numbers, taking
  <code>#line</code> directives into account or not, is unchanged.
  Thus:
  <programlisting language="BNF">
<emphasis>location</emphasis> :
	<emphasis>number number number string string</emphasis>
	<emphasis>number number number string</emphasis> *
	<emphasis>number number number</emphasis> *
	<emphasis>number number</emphasis> *
	<emphasis>number</emphasis> *
	*</programlisting>
  Note that there is a concept of the <A id="crt_loc">current file
  location</A>, relative to which other locations are given.  The initial
  value of the current file location is undefined.  Unless otherwise
  stated, all <emphasis>location</emphasis> elements update the current file location.
  </para>
  </section>

  <section id="identifiers">
    <title>Identifiers</title>
  <para>
  Each identifier is represented in the symbol table dump by a unique
  number.  The same number always represents the same identifier.
  </para>

  <section id="identifier-names">
<title>Identifier names</title>
  <para>
  The number representing an identifier is introduced in the first declaration
  or use of that identifier and thereafter the number alone is used
  to denote the identifier:
  <programlisting language="BNF">
<emphasis>identifier</emphasis> :
	<emphasis>number</emphasis> = <emphasis>identifier-name access<subscript>opt</subscript> scope-identifier</emphasis>
	<emphasis>number</emphasis></programlisting>
  </para>
  <para>
  The identifier name is given by:
  <programlisting language="BNF">
<emphasis>identifier-name</emphasis> :
	<emphasis>string</emphasis>
	C <emphasis>type</emphasis>
	D <emphasis>type</emphasis>
	O <emphasis>string</emphasis>
	T <emphasis>type</emphasis></programlisting>
  denoting respectively, a simple identifier name, a constructor for
  a type, a destructor for a type, an overloaded operator function name,
  and a conversion function name.  The empty string is used for anonymous
  identifiers.
  </para>
  <para>
  The optional identifier access is given by:
  <programlisting language="BNF">
<emphasis>access</emphasis> :
	N
	B
	P</programlisting>
  denoting <code>public</code>, <code>protected</code> and
  <code>private</code> respectively.  An absent <emphasis>access</emphasis> is equivalent
  to <code>public</code>.  Note that all identifiers, not just class
  members, can have access specifiers; however the access of a non-member
  is always <code>public</code>.
  </para>
  <para>
  The <link linkend="scope">scope</link> (i.e. class, namespace, block etc.)
  in which an identifier is declared is given by:
  <programlisting language="BNF">
<emphasis>scope-identifier</emphasis> :
	<emphasis>identifier</emphasis>
	*</programlisting>
  denoting either a named or an unnamed scope.
  </para>
</section>

<section id="use">
	<title>Identifier uses</title>
  <para>
  Each declaration or use of an identifier is represented by a command
  of the form:
  <programlisting language="BNF">
<emphasis>identifier-command</emphasis> :
	D <emphasis>identifier-info type-info</emphasis>
	M <emphasis>identifier-info type-info</emphasis>
	T <emphasis>identifier-info type-info</emphasis>
	Q <emphasis>identifier-info</emphasis>
	U <emphasis>identifier-info</emphasis>
	L <emphasis>identifier-info</emphasis>
	C <emphasis>identifier-info</emphasis>
	W <emphasis>identifier-info type-info</emphasis></programlisting>
  where:
  <programlisting language="BNF">
<emphasis>identifier-info</emphasis> :
	<emphasis>identifier-key location identifier</emphasis></programlisting>
  gives the kind of identifier being declared or used, the location
  of the declaration or use, and the number associated with the identifier.
  Each declaration may, depending on the <emphasis>identifier-key</emphasis>, associate
  various <emphasis>type-info</emphasis> with the identifier, giving its type etc.
  </para>
  <para>
  The various kinds of <emphasis>identifier-command</emphasis> are described below.
  Any can be preceded by <code>I</code> to indicate an implicit declaration
  or use.  <code>D</code> denotes a definition.  <code>M</code> (make)
  denotes a declaration.  <code>T</code> denotes a tentative definition
  (C only).  <code>Q</code> denotes the end of a definition, for those
  identifiers such as classes and functions whose definitions may be
  spread over several lines.  <code>U</code> denotes an undefine operation
  (such as <code>#undef</code> for macro identifiers).  <code>C</code>
  denotes a call to a function identifier; <code>L</code> (load) denotes
  other identifier uses.  Finally <code>W</code> denotes implicit type
  information such as the C producer gleans from its
  <A HREF="pragma.html#weak">weak prototype analysis</A>.
  </para>
  <para>
  The various <emphasis>identifier-key</emphasis>s are their associated <emphasis>type-info</emphasis>
  fields are given by the following table:
  </para>

  <table>
  <tr><th>Key</th>
  <th>Type information</th>
  <th>Description</th>
  </tr>
  <tr><td><code>K</code></td>
  <td><code>*</code></td>
  <td>keyword</td>
  </tr>
  <tr><td><code>MO</code></td>
  <td><emphasis>sort</emphasis></td>
  <td>object macro</td>
  </tr>
  <tr><td><code>MF</code></td>
  <td><emphasis>sort</emphasis></td>
  <td>function macro</td>
  </tr>
  <tr><td><code>MB</code></td>
  <td><emphasis>sort</emphasis></td>
  <td>built-in macro</td>
  </tr>
  <tr><td><code>TC</code></td>
  <td><emphasis>type</emphasis></td>
  <td>class tag</td>
  </tr>
  <tr><td><code>TS</code></td>
  <td><emphasis>type</emphasis></td>
  <td>structure tag</td>
  </tr>
  <tr><td><code>TU</code></td>
  <td><emphasis>type</emphasis></td>
  <td>union tag</td>
  </tr>
  <tr><td><code>TE</code></td>
  <td><emphasis>type</emphasis></td>
  <td>enumeration tag</td>
  </tr>
  <tr><td><code>TA</code></td>
  <td><emphasis>type</emphasis></td>
  <td><code>typedef</code> name</td>
  </tr>
  <tr><td><code>NN</code></td>
  <td><code>*</code></td>
  <td>namespace name</td>
  </tr>
  <tr><td><code>NA</code></td>
  <td><emphasis>scope-identifier</emphasis></td>
  <td>namespace alias</td>
  </tr>
  <tr><td><code>VA</code></td>
  <td><emphasis>type</emphasis></td>
  <td>automatic variable</td>
  </tr>
  <tr><td><code>VP</code></td>
  <td><emphasis>type</emphasis></td>
  <td>function parameter</td>
  </tr>
  <tr><td><code>VE</code></td>
  <td><emphasis>type</emphasis></td>
  <td><code>extern</code> variable</td>
  </tr>
  <tr><td><code>VS</code></td>
  <td><emphasis>type</emphasis></td>
  <td><code>static</code> variable</td>
  </tr>
  <tr><td><code>FE</code></td>
  <td><emphasis>type identifier<subscript>opt</subscript></emphasis></td>
  <td><code>extern</code> function</td>
  </tr>
  <tr><td><code>FS</code></td>
  <td><emphasis>type identifier<subscript>opt</subscript></emphasis></td>
  <td><code>static</code> function</td>
  </tr>
  <tr><td><code>FB</code></td>
  <td><emphasis>type identifier<subscript>opt</subscript></emphasis></td>
  <td>built-in operator function</td>
  </tr>
  <tr><td><code>CF</code></td>
  <td><emphasis>type identifier<subscript>opt</subscript></emphasis></td>
  <td>member function</td>
  </tr>
  <tr><td><code>CS</code></td>
  <td><emphasis>type identifier<subscript>opt</subscript></emphasis></td>
  <td><code>static</code> member function</td>
  </tr>
  <tr><td><code>CV</code></td>
  <td><emphasis>type identifier<subscript>opt</subscript></emphasis></td>
  <td>virtual member function</td>
  </tr>
  <tr><td><code>CM</code></td>
  <td><emphasis>type</emphasis></td>
  <td>data member</td>
  </tr>
  <tr><td><code>CD</code></td>
  <td><emphasis>type</emphasis></td>
  <td><code>static</code> data member</td>
  </tr>
  <tr><td><code>E</code></td>
  <td><emphasis>type</emphasis></td>
  <td>enumerator</td>
  </tr>
  <tr><td><code>L</code></td>
  <td><code>*</code></td>
  <td>label</td>
  </tr>
  <tr><td><code>XO</code></td>
  <td><emphasis>sort</emphasis></td>
  <td>object token</td>
  </tr>
  <tr><td><code>XF</code></td>
  <td><emphasis>sort</emphasis></td>
  <td>procedure token</td>
  </tr>
  <tr><td><code>XP</code></td>
  <td><emphasis>sort</emphasis></td>
  <td>token parameter</td>
  </tr>
  <tr><td><code>XT</code></td>
  <td><emphasis>sort</emphasis></td>
  <td>template parameter</td>
  </tr>
  </table>

  <para>
  The function identifier keys can optionally be followed by
  <code>C</code> indicating that the function has C linkage, and
  <code>I</code> indicating that the function is inline.  By default,
  functions declared in a C++ dump file have C++ linkage and functions
  declared in a C dump file have C linkage.  The optional
  <emphasis>identifier</emphasis> which forms part of the <emphasis>type-info</emphasis> of these
  functions is used to form linked lists of overloaded functions.
  </para>
</section>

<section id="ident-scope">
	<title>Identifier scopes</title>
  <para>
  Each identifier belongs to a scope, called its parent scope, in which
  it is declared.  For example, the parent of a member of a class is
  the class itself.  This information is expressed in an identifier
  declaration using a <emphasis>scope-identifier</emphasis>.  In addition to the obvious
  scopes such as classes and namespaces, there are other scopes such
  as blocks in function definitions.  It is possible to introduce dummy
  identifiers to name such scopes.  The parent of such a dummy identifier
  will be the enclosing scope identifier, so these dummy identifiers
  naturally represent the block structure.  The parent of the top-level
  block in a function definition can be considered to be the function
  itself.
  </para>
  <para>
  Information on the start and end of such scopes is given by:
  <programlisting language="BNF">
<emphasis>scope-command</emphasis> :
	SS <emphasis>scope-key location identifier</emphasis>
	SE <emphasis>scope-key location identifier</emphasis></programlisting>
  where:
  <programlisting language="BNF">
<emphasis>scope-key</emphasis> :
	N
	S
	B
	D
	H
	CT
	CF
	CC</programlisting>
  gives the kind of scope involved: a namespace, a class, a block, some
  other declarative scope, a declaration block (see below), a true conditional
  scope, a false conditional scope or a target dependent conditional
  scope.
  </para>
  <para>
  A declaration block is a sequence of declarations enclosed in directives
  of the form:
  <programlisting language="C++">
#pragma TenDRA declaration block <emphasis>identifier</emphasis> begin
....
#pragma TenDRA declaration block end</programlisting>
  This allows the sequence of declarations to be associated with the
  given
  <emphasis>identifier</emphasis> in the symbol dump file.  This technique is used
  in the API description files to aid analysis tools in determining
  which declarations are part of the API.
  </para>
</section>

<section id="other-ident-info">
	<title>Other identifier information</title>
  <para>
  Other information associated with an identifier may be expressed using
  other dump commands.  For example:
  <programlisting language="BNF">
<emphasis>override-command</emphasis> :
	O <emphasis>identifier identifier</emphasis></programlisting>
  is used to express the fact that the two <emphasis>identifier</emphasis>s are virtual
  member functions, the first of which overrides the second.
  </para>
  <para>
  The command:
  <programlisting language="BNF">
<emphasis>base-command</emphasis> :
	B <emphasis>identifier-key identifier base-graph</emphasis>

<emphasis>base-graph</emphasis> :
	<emphasis>base-class</emphasis>
	<emphasis>base-class</emphasis> ( <emphasis>base-list</emphasis> )

<emphasis>base-class</emphasis> :
	<emphasis>number</emphasis> = V<emphasis><subscript>opt</subscript> access<subscript>opt</subscript> type-name</emphasis>
	<emphasis>number</emphasis> :

<emphasis>base-list</emphasis> :
	<emphasis>base-graph base-list<subscript>opt</subscript></emphasis>
</programlisting>
  associates a base class graph with a class identifier.  Any class
  which does not have an associated <emphasis>base-command</emphasis> can be assumed
  to have no base classes.  Each node in the graph is a <emphasis>type-name</emphasis>
  with an associated list of base classes.  A <code>V</code> is used
  to indicate a virtual base class.  Each node is numbered; duplicate
  numbers are used to indicate bases identified via the virtual base
  class structure.  Any base class can then be referred to as:
  <programlisting language="BNF">
<emphasis>base-number</emphasis> :
	<emphasis>number</emphasis> : <emphasis>type-name</emphasis></programlisting>
  indicating the base class with the given number in the given class.
  </para>
  <para>
  The command:
  <programlisting language="BNF">
<emphasis>api-command</emphasis> :
	X <emphasis>identifier-key identifier string</emphasis></programlisting>
  associates the external token name given by the <emphasis>string</emphasis> with
  the given tokenised identifier.
  </para>
  <para>
  The command:
  <programlisting language="BNF">
<emphasis>template-command</emphasis> :
	Z <emphasis>identifier-key identifier token-application specialise-info</emphasis></programlisting>
  is used to introduce an identifier corresponding to an instance of
  a template, <emphasis>token-application</emphasis>.  This instance may correspond
  to a specialisation of the primary template; this information is represented
  by:
  <programlisting language="BNF">
<emphasis>specialise-info</emphasis> :
	<emphasis>identifier</emphasis>
	<emphasis>token-application</emphasis>
	*</programlisting>
  where <code>*</code> indicates a non-specialised instance.
  </para>
</section>
  </section>

  <section id="types">
    <title>Types</title>
  <para>
  The <A id="built-in">built-in types</A> are represented in the symbol
  table dump as follows:
  </para>

  <table>
  <tr><th>Type</th>
  <th>Encoding</th>
  <th>Type</th>
  <th>Encoding</th>
  </tr>
  <tr><td>char</td>
  <td><code>c</code></td>
  <td>float</td>
  <td><code>f</code></td>
  </tr>
  <tr><td>signed char</td>
  <td><code>Sc</code></td>
  <td>double</td>
  <td><code>d</code></td>
  </tr>
  <tr><td>unsigned char</td>
  <td><code>Uc</code></td>
  <td>long double</td>
  <td><code>r</code></td>
  </tr>
  <tr><td>signed short</td>
  <td><code>s</code></td>
  <td>void</td>
  <td><code>v</code></td>
  </tr>
  <tr><td>unsigned short</td>
  <td><code>Us</code></td>
  <td>(bottom)</td>
  <td><code>u</code></td>
  </tr>
  <tr><td>signed int</td>
  <td><code>i</code></td>
  <td>bool</td>
  <td><code>b</code></td>
  </tr>
  <tr><td>unsigned int</td>
  <td><code>Ui</code></td>
  <td>ptrdiff_t</td>
  <td><code>y</code></td>
  </tr>
  <tr><td>signed long</td>
  <td><code>l</code></td>
  <td>size_t</td>
  <td><code>z</code></td>
  </tr>
  <tr><td>unsigned long</td>
  <td><code>Ul</code></td>
  <td>wchar_t</td>
  <td><code>w</code></td>
  </tr>
  <tr><td>signed long long</td>
  <td><code>x</code></td>
  <td>-</td>
  <td>-</td>
  </tr>
  <tr><td>unsigned long long</td>
  <td><code>Ux</code></td>
  <td>-</td>
  <td>-</td>
  </tr>
  </table>

  <para>
  Named types (classes, enumeration types etc.) can be represented by
  the corresponding identifier or token application:
  <programlisting language="BNF">
<emphasis>type-name</emphasis> :
	<emphasis>identifier</emphasis>
	<emphasis>token-application</emphasis></programlisting>
  <A id="composite">Composite and qualified types</A> are represented
  in terms of their subtypes as follows:
  </para>

  <table>
  <tr><th>Type</th>
  <th>Encoding</th>
  </tr>
  <tr><td><code>const</code> type</td>
  <td><code>C</code> <emphasis>type</emphasis></td>
  </tr>
  <tr><td><code>volatile</code> type</td>
  <td><code>V</code> <emphasis>type</emphasis></td>
  </tr>
  <tr><td>pointer type</td>
  <td><code>P</code> <emphasis>type</emphasis></td>
  </tr>
  <tr><td>reference type</td>
  <td><code>R</code> <emphasis>type</emphasis></td>
  </tr>
  <tr><td>pointer to member type</td>
  <td><code>M</code> <emphasis>type-name</emphasis> <code>:</code> <emphasis>type</emphasis></td>
  </tr>
  <tr><td>function type</td>
  <td><code>F</code> <emphasis>type parameter-types</emphasis></td>
  </tr>
  <tr><td>array type</td>
  <td><code>A</code> <emphasis>nat<subscript>opt</subscript></emphasis> <code>:</code> <emphasis>type</emphasis></td>
  </tr>
  <tr><td>bitfield type</td>
  <td><code>B</code> <emphasis>nat</emphasis> <code>:</code> <emphasis>type</emphasis></td>
  </tr>
  <tr><td>template type</td>
  <td><code>t</code> <emphasis>parameter-list<subscript>opt</subscript></emphasis> <code>:</code> <emphasis>type</emphasis></td>
  </tr>
  <tr><td>promotion type</td>
  <td><code>p</code> <emphasis>type</emphasis></td>
  </tr>
  <tr><td>arithmetic type</td>
  <td><code>a</code> <emphasis>type</emphasis> <code>:</code> <emphasis>type</emphasis></td>
  </tr>
  <tr><td>integer literal type</td>
  <td><code>n</code> <emphasis>lit-base<subscript>opt</subscript> lit-suffix<subscript>opt</subscript></emphasis></td>
  </tr>
  <tr><td>weak function prototype (C only)</td>
  <td><code>W</code> <emphasis>type parameter-types</emphasis></td>
  </tr>
  <tr><td>weak parameter type (C only)</td>
  <td><code>q</code> <emphasis>type</emphasis></td>
  </tr>
  </table>

  <para>
  Other types can be represented by their textual representation using
  the form <code>Q</code> <emphasis>string</emphasis>, or by <code>*</code>, indicating
  an unknown type.
  </para>
  <para>
  The parameter types for a function type are represented as follows:
  <programlisting language="BNF">
<emphasis>parameter-types</emphasis> :
	: <emphasis>exception-spec<subscript>opt</subscript> func-qualifier<subscript>opt</subscript></emphasis> :
	. <emphasis>exception-spec<subscript>opt</subscript> func-qualifier<subscript>opt</subscript></emphasis> :
	. <emphasis>exception-spec<subscript>opt</subscript> func-qualifier<subscript>opt</subscript></emphasis> .
	, <emphasis>type parameter-types</emphasis></programlisting>
  where the <code>::</code> form indicates that there are no further
  parameters, the <code>.:</code> form indicates that the parameters
  are terminated by an ellipsis, and the <code>..</code> form indicates
  that no information is available on the further parameters (this can
  only happen with non-prototyped functions in C).  The function qualifiers
  are given by:
  <programlisting language="BNF">
<emphasis>func-qualifier</emphasis> :
	C <emphasis>func-qualifier<subscript>opt</subscript></emphasis>
	V <emphasis>func-qualifier<subscript>opt</subscript></emphasis></programlisting>
  representing <code>const</code> and <code>volatile</code> member functions.
  The function exception specifier is given by:
  <programlisting language="BNF">
<emphasis>exception-spec</emphasis> :
	( <emphasis>exception-list<subscript>opt</subscript></emphasis> )

<emphasis>exception-list</emphasis> :
	<emphasis>type</emphasis>
	<emphasis>type</emphasis> , <emphasis>exception-list</emphasis></programlisting>
  with an absent exception specifier, as in C++, indicating that any
  exception may be thrown.
  </para>
  <para>
  Array and bitfield sizes are represented as follows:
  <programlisting language="BNF">
<emphasis>nat</emphasis> :
	+ <emphasis>number</emphasis>
	- <emphasis>number</emphasis>
	<emphasis>identifier</emphasis>
	<emphasis>token-application</emphasis>
	<emphasis>string</emphasis></programlisting>
  where a <emphasis>string</emphasis> is used to hold a textual representation of
  complex values.
  </para>
  <para>
  Template types are represented by a list of template parameters, which
  will have previously been declared using the <code>XT</code> identifier
  key, followed by the underlying type expressed in terms of these parameters.
  The parameters are represented as follows:
  <programlisting language="BNF">
<emphasis>parameter-list</emphasis> :
	<emphasis>identifier</emphasis>
	<emphasis>identifier</emphasis> , <emphasis>parameter-list</emphasis></programlisting>
  </para>
  <para>
  Integer literal types are represented by the value of the literal
  followed by a representation of the literal base and suffix.  These
  are given by:
  <programlisting language="BNF">
<emphasis>lit-base</emphasis> :
	O
	X</programlisting>
  representing octal and hexadecimal literals respectively (decimal
  is the default), and:
  <programlisting language="BNF">
<emphasis>lit-suffix</emphasis> :
	U
	l
	Ul
	x
	Ux</programlisting>
  representing the <code>U</code>, <code>L</code>, <code>UL</code>,
  <code>LL</code> and <code>ULL</code> suffixes respectively.
  </para>
  <para>
  Target dependent integral promotion types are represented using
  <code>p</code>, so for example the promotion of <code>unsigned short</code>
  is represented as <code>pUs</code>.  Information on the other cases,
  where the promotion type is known, can be given in a command of the
  form:
  <programlisting language="BNF">
<emphasis>promotion-command</emphasis> :
	P <emphasis>type</emphasis> : <emphasis>type</emphasis></programlisting>
  Thus the fact that the promotion of <code>short</code> is <code>int</code>
  would be expressed by the command <code>Ps:i</code>.
  </para>
  </section>

  <section id="sort">
    <title>Sorts</title>
  <para>
  A <emphasis>sort</emphasis> in the symbol table dump corresponds to the sort of
  a token declared in the <A HREF="token.html#spec"><code>#pragma token</code>
  syntax</A>.  Expression tokens are represented as follows:
  <programlisting language="BNF">
<emphasis>expression-sort</emphasis> :
	ZEL <emphasis>type</emphasis>
	ZER <emphasis>type</emphasis>
	ZEC <emphasis>type</emphasis>
	ZN</programlisting>
  corresponding to <code>lvalue</code>, <code>rvalue</code> and
  <code>const</code> <code>EXP</code> tokens of the given type, and
  <code>NAT</code> or <code>INTEGER</code> tokens, respectively. Statement
  tokens are represent by:
  <programlisting language="BNF">
<emphasis>statement-sort</emphasis> :
	ZS</programlisting>
  </para>
  <para>
  Type tokens are represented as follows:
  <programlisting language="BNF">
<emphasis>type-sort</emphasis> :
	ZTO
	ZTI
	ZTF
	ZTA
	ZTP
	ZTS
	ZTU</programlisting>
  corresponding to <code>TYPE</code>, <code>VARIETY</code>, <code>FLOAT</code>,
  <code>ARITHMETIC</code>, <code>SCALAR</code>, <code>STRUCT</code>
  or
  <code>CLASS</code>, and <code>UNION</code> token respectively.  There
  are corresponding <code>TAG</code> forms:
  <programlisting language="BNF">
<emphasis>tag-type-sort</emphasis> :
	ZTTS
	ZTTU</programlisting>
  </para>
  <para>
  Member tokens are represented using:
  <programlisting language="BNF">
<emphasis>member-sort</emphasis> :
	ZM <emphasis>type</emphasis> : <emphasis>type-name</emphasis></programlisting>
  where the first type gives the member type and the second gives the
  parent structure or union type.
  </para>
  <para>
  Procedure tokens can be represented using:
  <programlisting language="BNF">
<emphasis>proc-sort</emphasis> :
	ZPG <emphasis>parameter-list<subscript>opt</subscript></emphasis> ; <emphasis>parameter-list<subscript>opt</subscript></emphasis> : <emphasis>sort</emphasis>
	ZPS <emphasis>parameter-list<subscript>opt</subscript></emphasis> : <emphasis>sort</emphasis></programlisting>
  The first form corresponds to the more general form of <code>PROC</code>
  token, that expressed using <code>{ .... | .... }</code>, which has
  separate lists of bound and program parameters.  These token parameters
  will have previously been declared using the <code>XP</code> identifier
  key.  The second form corresponds to the case where the bound and
  program parameter lists are equal, that expressed as a <code>PROC</code>
  token using <code>( .... )</code>.  A more specialised version of
  this second form is a <code>FUNC</code> token, which is represented
  as:
  <programlisting language="BNF">
<emphasis>func-sort</emphasis> :
	ZF <emphasis>type</emphasis></programlisting>
  </para>
  <para>
  As noted above, template parameters are represented by a <emphasis>sort</emphasis>.
  Template type parameters are represented by <code>ZTO</code>, while
  template expression parameters are represent by <code>ZEC</code>
  (recall that such parameters are always constant expressions).  The
  remaining case, template template parameters, can be represented as:
  <programlisting language="BNF">
<emphasis>template-sort</emphasis> :
	ZTt <emphasis>parameter-list<subscript>opt</subscript></emphasis> :</programlisting>
  </para>
  <para>
  Finally, the number of parameters in a macro definition is represented
  by a <emphasis>sort</emphasis> of the form:
  <programlisting language="BNF">
<emphasis>macro-sort</emphasis> :
	ZUO
	ZUF <emphasis>number</emphasis></programlisting>
  corresponding to a object-like macro and a function-like macro with
  the given number of parameters, respectively.
  </para>
  </section>

  <section id="token-applications">
    <title>Token applications</title>
  <para>
  Given an identifier representing a <code>PROC</code> token or a template,
  an application of that token or an instance of that template can be
  represented using:
  <programlisting language="BNF">
<emphasis>token-application</emphasis> :
	T <emphasis>identifier</emphasis> , <emphasis>token-argument-list</emphasis> :</programlisting>
  where the token or template arguments are given by:
  <programlisting language="BNF">
<emphasis>token-argument-list</emphasis> :
	<emphasis>token-argument</emphasis>
	<emphasis>token-argument</emphasis> , <emphasis>token-argument-list</emphasis></programlisting>
  Note that the case where there are no arguments is generally just
  represented by <emphasis>identifier</emphasis>; this case is specified separately
  in the rest of the grammar.
  </para>
  <para>
  A <emphasis>token-argument</emphasis> can represent a value of any of the sorts
  listed above: expressions, integer constants, statements, types, members,
  functions and templates.  These are given respectively by:
  <programlisting language="BNF">
<emphasis>token-argument</emphasis> :
	E <emphasis>expression</emphasis>
	N <emphasis>nat</emphasis>
	S <emphasis>statement</emphasis>
	T <emphasis>type</emphasis>
	M <emphasis>member</emphasis>
	F <emphasis>identifier</emphasis>
	C <emphasis>identifier</emphasis></programlisting>
  where:
  <programlisting language="BNF">
<emphasis>expression</emphasis> :
	<emphasis>nat</emphasis>

<emphasis>statement</emphasis> :
	<emphasis>expression</emphasis>

<emphasis>member</emphasis> :
	<emphasis>identifier</emphasis>
	<emphasis>string</emphasis></programlisting>
  </para>
  </section>

  <section id="error">
    <title>Errors</title>
  <para>
  Each error in the C++ <A HREF="error.html">error catalogue</A> is
  represented by a number.  These numbers happen to correspond to the
  position of the error within the catalogue, but in general this need
  not be the case.  The first use of each error introduces the error
  number by associating it with a <emphasis>string</emphasis> giving the error name.
  This has the form <code>cpp.</code><emphasis>error</emphasis> where <emphasis>error</emphasis>
  gives an error name from the C++ (<code>cpp</code>) error catalogue.
  Thus:
  <programlisting language="BNF">
<emphasis>error-name</emphasis> :
	<emphasis>number</emphasis> = <emphasis>string</emphasis>
	<emphasis>number</emphasis></programlisting>
  </para>
  <para>
  Each error message written to the symbol table dump has the form:
  <programlisting language="BNF">
<emphasis>error-command</emphasis> :
	ES <emphasis>location error-info</emphasis>
	EW <emphasis>location error-info</emphasis>
	EI <emphasis>location error-info</emphasis>
	EF <emphasis>location error-info</emphasis>
	EC <emphasis>error-info</emphasis>
	EA <emphasis>error-argument</emphasis></programlisting>
  denoting constraint errors, warnings, internal errors, fatal errors,
  continuation errors and error arguments respectively.  Note that an
  error message may consist of several components; the initial error
  plus a number of continuation errors.  Each error message may also
  have a number of error argument associated with it.  This error information
  is given by:
  <programlisting language="BNF">
<emphasis>error-info</emphasis> :
	<emphasis>error-name number number</emphasis></programlisting>
  where the first <emphasis>number</emphasis> gives the number of error arguments
  which should be read, and the second is nonzero to indicate that a
  continuation error should be read.
  </para>
  <para>
  Each error argument has one of the forms:
  <programlisting language="BNF">
<emphasis>error-argument</emphasis> :
	B <emphasis>base-number</emphasis>
	C <emphasis>scope-identifier</emphasis>
	E <emphasis>expression</emphasis>
	H <emphasis>identifier-name</emphasis>
	I <emphasis>identifier</emphasis>
	L <emphasis>location</emphasis>
	N <emphasis>nat</emphasis>
	S <emphasis>string</emphasis>
	T <emphasis>type</emphasis>
	V <emphasis>number</emphasis>
	V - <emphasis>number</emphasis></programlisting>
  corresponding to the various syntactic categories described above.
  Note that a <emphasis>location</emphasis> error argument, while expressed relative
  to the
  <link linkend="crt_loc">current file location</link>, does not change this
  location.
  </para>
  </section>

  <section id="file">
    <title>File inclusions</title>
  <para>
  It is possible to include information on header files within the symbol
  table dump.  Firstly a number is associated with each directory on
  the <code>#include</code> search path:
  <programlisting language="BNF">
<emphasis>path-command</emphasis> :
	FD <emphasis>number</emphasis> = <emphasis>string string<subscript>opt</subscript></emphasis></programlisting>
  The first <emphasis>string</emphasis> gives the directory pathname; the second,
  if present, gives the associated directory name as specified in the
  <A HREF="man.html#directory"><code>-N</code> command-line option</A>.
  </para>
  <para>
  Now the start and end of each file are marked using:
  <programlisting language="BNF">
<emphasis>file-command</emphasis> :
	FS <emphasis>location directory</emphasis>
	FE <emphasis>location</emphasis></programlisting>
  where <emphasis>directory</emphasis> gives the number of the directory in the search
  path where the file was found, or <code>*</code> if the file was found
  by other means.  It is worth noting that if, for example, a function
  definition is the last item in a file, the <code>FE</code> command
  will appear in the symbol table dump before the <code>QFE</code> command
  for the end of the function definition.  This is because lexical analysis,
  where the end of file is detected, takes place before parsing, where
  the end of function is detected.
  </para>
  <para>
  A <code>#include</code> directive, whether explicit or implicit, can
  be represented using:
  <programlisting language="BNF">
<emphasis>include-command</emphasis> :
	FIA <emphasis>location string</emphasis>
	FIQ <emphasis>location string</emphasis>
	FIN <emphasis>location string</emphasis>
	FIS <emphasis>location string</emphasis>
	FIE <emphasis>location string</emphasis>
	FIR <emphasis>location</emphasis></programlisting>
  the first three corresponding to header names of the forms
  <code>&lt;....&gt;</code>, <code>&quot;....&quot;</code> and <code>[....]</code>
  respectively, the next two corresponding to <A HREF="man.html#start-up">start-up
  </A>
  and <A HREF="man.html#end-up">end-up</A> files, and the final form
  being used to resume the original file after the <code>#include</code>
  directive has been processed.
  </para>
  </section>

  <section id="string-literals">
    <title>String literals</title>
  <para>
  It is possible to dump information on string literals to the symbol
  table dump file using the commands:
  <programlisting language="BNF">
<emphasis>string-command</emphasis> :
	A <emphasis>location string</emphasis>
	AC <emphasis>location string</emphasis>
	AL <emphasis>location string</emphasis>
	ACL <emphasis>location string</emphasis></programlisting>
  representing string literals, character literals, wide string literals
  and wide character literals respectively.  The given <emphasis>string</emphasis>
  gives the string text.
  </para>
  </section>
</chapter>

