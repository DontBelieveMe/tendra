/*
 * Copyright (c) 2004, The Tendra Project <http://www.ten15.org/>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice unmodified, this list of conditions, and the following
 *    disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $TenDRA$
 */


ENTRIES:

expected_basic(ccp: class_name)
{
	USAGE: FATAL
	KEY(STD) isline"expected terminal '"class_name"'"
}

expected_begin_action()
{
	USAGE: ERROR
	KEY(STD) isline"expected '<'"
}

expected_end_action()
{
	USAGE: ERROR
	KEY(STD) isline"expected '>'"
}

expected_define()
{
	USAGE: ERROR
	KEY(STD) isline"expected '='"
}

expected_end_rule()
{
	USAGE: ERROR
	KEY(STD) isline"expected '}'"
}

expected_other_defn()
{
	USAGE: ERROR
	KEY(STD) isline"expected rule declaration or rule or non local name definition"
}

expected_production_defn()
{
	USAGE: ERROR
	KEY(STD) isline"expected rule declaration or definition, or action declaration"
}

expected_separator()
{
	USAGE: ERROR
	KEY(STD) isline"expected ','"
}

expected_terminal_decn()
{
	USAGE: ERROR
	KEY(STD) isline"expected identifier or '!'"
}

expected_open_tuple()
{
	USAGE: ERROR
	KEY(STD) isline"expected '('"
}

expected_item()
{
	USAGE: ERROR
	KEY(STD) isline"expected item"
}

expected_blt_terminals()
{
	USAGE: ERROR
	KEY(STD) isline"expected '%terminals%'"
}

expected_blt_entry()
{
	USAGE: ERROR
	KEY(STD) isline"expected '%entry%'"
}

expected_blt_types()
{
	USAGE: ERROR
	KEY(STD) isline"expected '%types%'"
}

expected_terminator_or_define()
{
	USAGE: ERROR
	KEY(STD) isline"expected ';' or '='"
}

expected_tuple_defn()
{
	USAGE: ERROR
	KEY(STD) isline"expected identifier or ':'"
}

expected_tuple_or_term()
{
	USAGE: ERROR
	KEY(STD) isline"expected tuple or ';'"
}

expected_begin_rule()
{
	USAGE: ERROR
	KEY(STD) isline"expected '{'"
}

expected_end_scope()
{
	USAGE: ERROR
	KEY(STD) isline"expected ']'"
}

expected_blt_productions()
{
	USAGE: ERROR
	KEY(STD) isline"expected '%productions%'"
}

expected_terminator()
{
	USAGE: ERROR
	KEY(STD) isline"expected ';'"
}

expected_tuple_def_or_term()
{
	USAGE: ERROR
	KEY(STD) isline"expected tuple, '=' or ';'"
}

expected_lhs_name()
{
	USAGE: ERROR
	KEY(STD) isline"expected identifier, '?' or '!'"
}

expected_item_rhs()
{
	USAGE: ERROR
	KEY(STD) isline"expected item right hand side"
}

expected_arrow()
{
	USAGE: ERROR
	KEY(STD) isline"expected '->'"
}

expected_identifier()
{
	USAGE: ERROR
	KEY(STD) isline"expected identifier"
}

expected_typemark()
{
	USAGE: ERROR
	KEY(STD) isline"expected ':'"
}

expected_rhs_name()
{
	USAGE: ERROR
	KEY(STD) isline"expected identifier or '&'"
}

expected_eof()
{
	USAGE: ERROR
	KEY(STD) isline"expected end of file"
}

expected_alternative()
{
	USAGE: ERROR
	KEY(STD) isline"expected alternative"
}

expected_close_tuple()
{
	USAGE: ERROR
	KEY(STD) isline"expected ')'"
}


handler_result_mismatch(KeyP: rule_name)
{
	USAGE: ERROR
	KEY(STD) isline"result formals are not defined in exception handler alternative of production '"rule_name"'"
}

rule_result_has_names(KeyP: rule_name, TypeTupleP: result_type)
{
	USAGE: ERROR
	KEY(STD) isline"result of declaration of rule '"rule_name"' has names [result = "result_type"]"
}

rule_already_defined(KeyP: rule_name)
{
	USAGE: ERROR
	KEY(STD) isline"production '"rule_name"' is already defined"
}

rule_formal_clash(KeyP: rule_name, TypeTupleP: parameter_type, TypeTupleP: result_type)
{
	USAGE: ERROR
	KEY(STD) isline"parameter and result names are not disjoint for production '"rule_name"' [parameter = "parameter_type", result = "result_type"]"
}

rule_param_clash(KeyP: rule_name, TypeTupleP: parameter_type)
{
	USAGE: ERROR
	KEY(STD) isline"parameter names are not disjoint (or are missing) for production '"rule_name"' [parameter = "parameter_type"]"
}

rule_param_call_mismatch(KeyP: rule_name, TypeTupleP: correct_type, TypeTupleP: erroneous_type)
{
	USAGE: ERROR
	KEY(STD) isline"parameter type mismatch for invocation of rule '"rule_name"' ["erroneous_type" should be "correct_type"]"
}

rule_result_call_mismatch(KeyP: rule_name, TypeTupleP: correct_type, TypeTupleP: erroneous_type)
{
	USAGE: ERROR
	KEY(STD) isline"result type mismatch for invocation of rule '"rule_name"' ["erroneous_type" should be "correct_type"]"
}

rule_param_mismatch(KeyP: rule_name, TypeTupleP: correct_type, TypeTupleP: erroneous_type)
{
	USAGE: ERROR
	KEY(STD) isline"parameter type mismatch for production '"rule_name"' ["erroneous_type" should be "correct_type"]"
}

rule_result_call_clash(KeyP: rule_name, TypeTupleP: result_type)
{
	USAGE: ERROR
	KEY(STD) isline"result names are not disjoint for invocation of rule '"rule_name"' [result = "result_type"]"
}

rule_result_mismatch(KeyP: rule_name, TypeTupleP: correct_type, TypeTupleP: erroneous_type)
{
	USAGE: ERROR
	KEY(STD) isline"result type mismatch for production '"rule_name"' ["erroneous_type" should be "correct_type"]"
}

rule_param_has_names(KeyP: rule_name, TypeTupleP: parameter_type)
{
	USAGE: ERROR
	KEY(STD) isline"parameter of declaration of rule '"rule_name"' has names [parameter = "parameter_type"]"
}

rule_result_clash(KeyP: rule_name, TypeTupleP: result_type)
{
	USAGE: ERROR
	KEY(STD) isline"result names are not disjoint (or are missing) for production '"rule_name"' [result = "result_type"]"
}

rule_result_has_refs(KeyP: rule_name, TypeTupleP: result_type)
{
	USAGE: ERROR
	KEY(STD) isline"result of declaration or definition of rule '"rule_name"' has references [result = "result_type"]"
}

too_many_alternatives()
{
	USAGE: FATAL
	KEY(STD) isline"too many alternatives in grammar"
}

multiple_empty_alts(KeyP: rule_name)
{
	USAGE: ERROR
	KEY(STD) isline"production '"rule_name"' has multiple empty alternatives"
}

alt_result_mismatch(KeyP: rule_name, unsigned: alternative)
{
	USAGE: ERROR
	KEY(STD) isline"result formals are not defined in alternative "alternative" of production '"rule_name"'"
}

duplicate_rule(NStringP: identifier_name)
{
	USAGE: ERROR
	KEY(STD) isline"identifier '"identifier_name"' redeclared as rule"
}

global_scope_non_local(NStringP: name_name)
{
	USAGE: ERROR
	KEY(STD) isline"definition of non local name '"name_name"' at global scope"
}

unknown_type(NStringP: type_name)
{
	USAGE: ERROR
	KEY(STD) isline"type '"type_name"' hasn't been declared"
}

duplicate_non_local(NStringP: identifier_name)
{
	USAGE: ERROR
	KEY(STD) isline"identifier '"identifier_name"' redeclared as non local"
}

unknown_action(NStringP: action_name)
{
	USAGE: ERROR
	KEY(STD) isline"action '"action_name"' hasn't been declared"
}

action_param_call_mismatch(KeyP: action_name, TypeTupleP: correct_type, TypeTupleP: erroneous_type)
{
	USAGE: ERROR
	KEY(STD) isline"parameter type mismatch for invocation of action '"action_name"' ["erroneous_type" should be "correct_type"]"
}

initialiser_param_mismatch(KeyP: name_name, TypeTupleP: correct_type, TypeTupleP: correct_ref_type, TypeTupleP: erroneous_type)
{
	USAGE: ERROR
	KEY(STD) isline"parameter type mismatch for initialiser of non local name '"name_name"' ["erroneous_type" should be "correct_type", "correct_ref_type" or ()]"
}

basic_result_has_names(KeyP: terminal_name, TypeTupleP: result_type)
{
	USAGE: ERROR
	KEY(STD) isline"result of declaration of terminal '"terminal_name"' has names [result = "result_type"]"
}

basic_result_call_clash(KeyP: terminal_name, TypeTupleP: result_type)
{
	USAGE: ERROR
	KEY(STD) isline"result names are not disjoint for invocation of terminal '"terminal_name"' [result = "result_type"]"
}

basic_param_call_mismatch(KeyP: terminal_name, TypeTupleP: erroneous_type)
{
	USAGE: ERROR
	KEY(STD) isline"parameter type mismatch for invocation of terminal '"terminal_name"' ["erroneous_type" should be ()])"
}

basic_param_has_names(KeyP: terminal_name, TypeTupleP: parameter_type)
{
	USAGE: ERROR
	KEY(STD) isline"parameter of declaration of terminal '"terminal_name"' has names [parameter = "parameter_type"]"
}

basic_result_has_refs(KeyP: terminal_name, TypeTupleP: result_type)
{
	USAGE: ERROR
	KEY(STD) isline"result of declaration of terminal '"terminal_name"' has references [result = "result_type"]"
}

basic_param_mismatch(KeyP: terminal_name, TypeTupleP: erroneous_type)
{
	USAGE: ERROR
	KEY(STD) isline"parameter type mismatch for declaration of terminal '"terminal_name"' ["erroneous_type" should be ()])"
}

basic_result_call_mismatch(KeyP: terminal_name, TypeTupleP: correct_type, TypeTupleP: erroneous_type)
{
	USAGE: ERROR
	KEY(STD) isline"result type mismatch for invocation of terminal '"terminal_name"' ["erroneous_type" should be "correct_type"]"
}

initialiser_result_mismatch(KeyP: name_name, TypeTupleP: correct_type, TypeTupleP: erroneous_type)
{
	USAGE: ERROR
	KEY(STD) isline"result type mismatch for initialiser of non local name '"name_name"' ["erroneous_type" should be "correct_type"]"
}

multi_predicate_return()
{
	USAGE: ERROR
	KEY(STD) isline"result contains more than one predicate result symbol"
}

duplicate_type(NStringP: identifier_name)
{
	USAGE: ERROR
	KEY(STD) isline"identifier '"identifier_name"' redeclared as type"
}

undefined_name(KeyP: identifier_name, KeyP: rule_name, unsigned: alternative)
{
	USAGE: ERROR
	KEY(STD) isline"undefined parameter name '"identifier_name"' in alternative "alternative" of production '"rule_name"'"
}

identity_mismatch(TypeTupleP: correct_type, TypeTupleP: erroneous_type)
{
	USAGE: ERROR
	KEY(STD) isline"type mismatch for identity ["erroneous_type" should be "correct_type"]"
}

identity_param_has_refs(TypeTupleP: parameter_type, KeyP: rule_name, unsigned: alternative)
{
	USAGE: ERROR
	KEY(STD) isline"cannot take address of identity parameters in alternative "alternative" of production '"rule_name"' [parameter = "parameter_type"]"
}

unknown_rule(NStringP: rule_name)
{
	USAGE: ERROR
	KEY(STD) isline"rule '"rule_name"' hasn't been declared or defined"
}

duplicate_basic(NStringP: identifier_name)
{
	USAGE: ERROR
	KEY(STD) isline"identifier '"identifier_name"' redeclared as terminal"
}

unknown_rule_or_basic(NStringP: identifier_name)
{
	USAGE: ERROR
	KEY(STD) isline"identifier '"identifier_name"' hasn't been declared or defined"
}

predicate()
{
	USAGE: ERROR
	KEY(STD) isline"predicate result symbol used in result of something other than an action"
}

identity_result_clash(TypeTupleP: result_type)
{
	USAGE: ERROR
	KEY(STD) isline"result names are not disjoint for identity [result = "result_type"]"
}

action_param_has_names(KeyP: action_name, TypeTupleP: parameter_type)
{
	USAGE: ERROR
	KEY(STD) isline"parameter of declaration of action '"action_name"' has names [parameter = "parameter_type"]"
}

action_param_mismatch(KeyP: action_name, TypeTupleP: correct_type, TypeTupleP: erroneous_type)
{
	USAGE: ERROR
	KEY(STD) isline"parameter type mismatch for action '"action_name"' ["erroneous_type" should be "correct_type"]"
}

action_result_mismatch(KeyP: action_name, TypeTupleP: correct_type,
		TypeTupleP: erroneous_type)
{
	USAGE: ERROR
	KEY(STD) isline"result type mismatch for action '"action_name"' ["erroneous_type" should be "correct_type"]"
}

action_result_call_mismatch(KeyP: action_name, TypeTupleP: correct_type, TypeTupleP: erroneous_type)
{
	USAGE: ERROR
	KEY(STD) isline"result type mismatch for invocation of action '"action_name"' ["erroneous_type" should be "correct_type"]"
}

action_result_has_names(KeyP: action_name, TypeTupleP: result_type)
{
	USAGE: ERROR
	KEY(STD) isline"result of declaration of action '"action_name"' has names [result = "result_type"]"
}

action_result_has_refs(KeyP: action_name, TypeTupleP: result_type)
{
	USAGE: ERROR
	KEY(STD) isline"result of declaration of action '"action_name"' has references [result = "result_type"]"
}

action_result_call_clash(KeyP: action_name, TypeTupleP: result_type)
{
	USAGE: ERROR
	KEY(STD) isline"result names are not disjoint for invocation of action '"action_name"' [result = "result_type"]"
}

duplicate_action(NStringP: identifier_name)
{
	USAGE: ERROR
	KEY(STD) isline"identifier '"identifier_name"' redeclared as action"
}

redefined_name(KeyP: identifier_name, KeyP: rule_name, unsigned: alternative)
{
	USAGE: ERROR
	KEY(STD) isline"redefined name '"identifier_name"' in alternative "alternative" of production '"rule_name"'"
}

ambiguous_call(NStringP: identifier_name)
{
	USAGE: ERROR
	KEY(STD) isline"identifier '"identifier_name"' used in ambiguous context [may be name, rule or terminal]"
}

predicate_type(EntryP: correct_type, EntryP: erroneous_type)
{
	USAGE: ERROR
	KEY(STD) isline"predicate type mismatch ["erroneous_type" should be "correct_type"]"
}

mult_entry(KeyP: rule_name)
{
	USAGE: ERROR
	KEY(STD) isline"rule '"rule_name"' occurs in the entry list more than once"
}

undefined_assignment(NStringP: name_name)
{
	USAGE: ERROR
	KEY(STD) isline"assignment to undefined name '"name_name"'"
}

ignored_basic_call(NStringP: terminal_name)
{
	USAGE: ERROR
	KEY(STD) isline"invocation of ignored terminal '"terminal_name"'"
}

