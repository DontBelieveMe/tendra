.\" Copyright (c) 2002-2004 The TenDRA Project <http://www.ten15.org/> 
.\" All rights reserved. 
.\"  
.\" Redistribution and use in source and binary forms, with or without 
.\" modification, are permitted provided that the following conditions 
.\" are met: 
.\" 1. Redistributions of source code must retain the above copyright 
.\"    notice, this list of conditions and the following disclaimer. 
.\" 2. Redistributions in binary form must reproduce the above copyright 
.\"    notice, this list of conditions and the following disclaimer in the 
.\"    documentation and/or other materials provided with the distribution. 
.\"  
.\" THIS SOFTWARE IS PROVIDED BY THE AUTHOR AND CONTRIBUTORS ``AS IS'' AND 
.\" ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE 
.\" IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE 
.\" ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE 
.\" FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL 
.\" DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS 
.\" OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) 
.\" HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT 
.\" LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY 
.\" OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF 
.\" SUCH DAMAGE. 
.\" 
.\" $TenDRA$ 
.\" 
.TH "lexi" "1" "Sun 23 Oct 2005, 12:36" "lexi @PROGRAM_VERSION@" "TenDRA @TENDRA_VERSION@" 
.SH "NAME" 
.PP 
\fBlexi\fP - lexical analyser tool
.SH "SYNOPSIS"
.PP
\fBlexi\fP [\fIoptions\fP] \fIinput-file\fP  [\fIoutput-file\fP] 
.SH "DESCRIPTION"
.PP
\fBlexi\fP translates a description of a lexical analyser,
\fIinput-file\fP, into code implementing that analyser\&.
This is output into the \fIoutput-file\fP argument, if
present, or the standard output otherwise\&.
.SH "OPTIONS"
.IP "\fB-V\fP" 5
Causes \fBlexi\fP print its version number\&.
.IP "\fB-f\fP" 5
Causes \fBlexi\fP to generate code describing any
functions specified in the input\&.
.IP "\fB-h\fP" 5
Prints a summary of all options\&.
.IP "\fB-k\fP" 5
Causes \fBlexi\fP to generate code describing any
keywords specified in the input\&.
.IP "\fB-l\fP\fIstring\fP" 5
Causes \fBlexi\fP to use \fIstring\fP as a prefix for its generated lexical tokens\&.  The default is
\fIlex_\fP\&.
.IP "\fB-m\fP" 5
Causes \fBlexi\fP to generate code describing any
macros specified in the input\&.
.IP "\fB-t\fP" 5
Causes \fBlexi\fP to generate code describing the
lookup table\&.
.SH "INPUT FILE"
.PP
The \fBlexi\fP input file defines the lexical analyzer
to be created\&. It contains character group definitions, token mappings,
keyword mappings, character mappings, and control flow sequences\&.
.PP
Character group definitions are of form \fBGROUP
identifier = string;\fP where \fIidentifier\fP is
composed of one or more letters and underscores\&. Strings may contain
arbitrary characters surrounded by quotes\&. It is possible to concatenate
strings with a ``\fI+\fP'' operator\&. For example,
\fBqabc + qdef\fP will form \fBqabcdef\fP\&.
.PP
There are pre-defined character sequences \fB{A-Z}\fP,
\fB{a-z}\fP and \fB{0-9}\fP\&. It is possible
to use already defined character groups to define new character groups\&.
For example, if we have definitions for letters
(\fBGROUP alpha = {A-Z};\fP) and for digits (\fBGROUP
digit = {0-9};\fP) then definition for alphanumeric characters
will be \fBGROUP alnum = "[alpha][digit]";\fP\&.
Special group \fBwhite\fP is supposed to contain whitespace
characters, wich are silently ignored by the lexer\&.
.PP
The maximum number of character groups wich can be defined is 31\&.
.PP
The statement \fBTOKEN string -> identifier;\fP maps
character sequence to the C or \fBsid\fP identifier\&. The C
identifier may be one of variable or function, the variable or result of
the function call is returned by the lexer routine\&. Matched characters are
passed as an argument to the function\&.
.PP
The statement \fBKEYWORD string -> identifier;\fP maps
character string to the \fBsid\fP terminal\&.
.PP
The statement \fBMAPPING string -> identifier;\fP maps
string of the arbitrary length to the one character\&. If any
\fBMAPPING\fP command is present, pre-pass analyzer will be
created\&. Pre-pass analyzer is run before the main pass, this is particulary
usable, for example, when mapping ANSI trigraph sequences to characters\&.
.PP
Character groups, tokens, keywords and mappings can be defined
conditionally\&. This is accomplished with IF and ELSE keywords\&. The general
form of control sequence is \fBIF (identifier) command;
ELSE command;\fP where \fBidentifier\fP is a C variable
and command is character group or mapping definition\&. The ELSE part is
optional\&. It is possible use multiple commands, surrounding them with
curly brackets\&.
.PP
It is possible to use C style comments in the input file\&.
.SH "EXAMPLES"
.PP
The first example is taken from \fBlexi\fP sources,
this is snippet from input grammar specification\&.
.PP
.nf
\f(CW/* Character groups */

/* These characters are silently ignored\&. */
GROUP white = " \\t\\n\\r" ;
GROUP alpha = {A-Z} + {a-z} + "_";
GROUP digit = {0-9};
GROUP alphanum = "[alpha][digit]";

/* Simple symbols */
TOKEN "(" -> $open;
TOKEN ")" -> $close;

/* Comments, strings and identifiers */
TOKEN "/*" -> get_comment();
TOKEN """ -> get_string();

/* Keywords */
KEYWORD "GROUP" -> $group;
KEYWORD "TOKEN" -> $token;\fR
.fi
.PP
.PP
Next example illustrates some additional features of
\fBlexi\fP\&.
.PP
.nf
\f(CW/* Map ANSI trigraph sequence to the ordinary bracket\&. */
MAPPING "??>" -> "}";

/* Define conditionally some character groups and mappings\&. */
IF (with_trigraphs) {
	GROUP foo = "foo";
	MAPPING "??<" -> "{";
}\fR
.fi
.PP
.SH "THE C INTERFACE"
.IP "\fBint read_token(void);\fP" 5
The main analyzer routine produced by
\fBlexi\fP\&.
.PP
The following functions are used by the analyzer\&.
.IP "\fBint read_char(void);\fP" 5
Reads the next token from the input stream\&.
.IP "\fBvoid unread_char(int);\fP" 5
Returns a character to the input stream\&.
.IP "\fBint unknown_token(int);\fP" 5
This function is called by \fBread_token()\fP when an unknown token is found\&.
.SH "BUGS"
.PP
The \fBlexi\fP input file must contain at least one TOKEN
directive, unless invalid lexer is produced\&.
.SH "SEE ALSO"
.PP
\fBtcc\fP\fB(1)\fP ,
\fBsid\fP\fB(1)\fP \&.
...\" created by instant / docbook-to-man, Sun 23 Oct 2005, 12:36
