pragma_r :
    error semicolon
{
   declare
      New_Node : constant Pragma_Ptr := new Pragma_Node;
   begin
      $$ := YYSTYPE (New_Node);
      Set_Start_Position
        (New_Node.all, (Get_Current_Line, Get_Current_Column - 1));
      Set_Pragma_Name_Image (New_Node.all, "Syntax_Error");
      Set_Pragma_Kind (New_Node.all, Asis.An_Implementation_Defined_Pragma);
      Set_End_Position
        (New_Node.all, (Get_Current_Line, Get_Current_Column - 1));
   end;
}
;

%%
with Gela;                     use Gela;
with Gela.Decoders;
with Gela.Encodings;
with Gela.Source_Buffers;

##
   function Run
     (The_Context : Asis.Context;
      Input       : Source_Buffers.Source_Buffer'Class;
      Encoding    : Encodings.Encoding;
      Decoder     : Decoders.Decoder'Class) return Asis.Element;
##


with Asis.Gela.Scanners;
with Gela.Character_Class_Buffers;
with Gela.Classificators;
with Asis.Gela.Classificators_Create;

with Ada.Text_IO;
with Ada.Characters.Handling;

with Asis.Gela.Elements;               use Asis.Gela.Elements;
with Asis.Gela.Elements.Assoc;         use Asis.Gela.Elements.Assoc;
with Asis.Gela.Elements.Clause;        use Asis.Gela.Elements.Clause;
with Asis.Gela.Elements.Clause.Rep;    use Asis.Gela.Elements.Clause.Rep;
with Asis.Gela.Elements.Decl;          use Asis.Gela.Elements.Decl;
with Asis.Gela.Elements.Defs;          use Asis.Gela.Elements.Defs;
with Asis.Gela.Elements.Defs.Accs;     use Asis.Gela.Elements.Defs.Accs;
with Asis.Gela.Elements.Defs.Const;    use Asis.Gela.Elements.Defs.Const;
with Asis.Gela.Elements.Defs.Formal;   use Asis.Gela.Elements.Defs.Formal;
with Asis.Gela.Elements.Defs.Types;    use Asis.Gela.Elements.Defs.Types;
with Asis.Gela.Elements.Defs.Rng;      use Asis.Gela.Elements.Defs.Rng;
with Asis.Gela.Elements.Defs.Sub;      use Asis.Gela.Elements.Defs.Sub;
with Asis.Gela.Elements.Expr;          use Asis.Gela.Elements.Expr;
with Asis.Gela.Elements.Def_Names;     use Asis.Gela.Elements.Def_Names;
with Asis.Gela.Elements.Pathes;        use Asis.Gela.Elements.Pathes;
with Asis.Gela.Elements.Stmt;          use Asis.Gela.Elements.Stmt;
with Asis.Gela.Elements.Helpers;       use Asis.Gela.Elements.Helpers;
with Asis.Gela.Units;                  use Asis.Gela.Units;
with Asis.Gela.Base_Lists;             use Asis.Gela.Base_Lists;
with Asis.Gela.Lists;                  use Asis.Gela.Lists;
with Asis.Gela.Library;

with Asis.Gela.Parser_Utils;           use Asis.Gela.Parser_Utils;

##

   package text_io renames Ada.Text_IO;

   function Run
     (The_Context : Asis.Context;
      Input       : Source_Buffers.Source_Buffer'Class;
      Encoding    : Encodings.Encoding;
      Decoder     : Decoders.Decoder'Class) return Asis.Element
   is

      Chooser : aliased Classificators.Classificator'Class :=
        Classificators_Create (Encoding, Decoder);
      Scanner : Scanners.Scanner (Chooser'Access);

      use Ada.Characters.Handling;

      Last_Compilation   : Asis.Element;
      Get_Current_Line   : Positive := 1;
      Get_Current_Column : Positive := 1;

      function Get_Token_Value return Wide_String is
         From    : Source_Buffers.Cursor;
         To      : Source_Buffers.Cursor;
         Line    : Wide_String (1 .. 2048);
         Last    : Natural;
      begin
         Scanners.Token_Span (Scanner, From, To);
         Decoders.Decode (Decoder, From, To, Line, Last);
         return Line (1 .. Last);
      end Get_Token_Value;

      function YYLex return Tokens.Token is
         use type Source_Buffers.Cursor;
         Token : Tokens.Token;
         From  : Source_Buffers.Cursor;
         To    : Source_Buffers.Cursor;
      begin
         Scanners.Next_Token (Scanner, Token);
text_io.put_Line (Token'Img & To_String (Get_Token_Value));
         Scanners.Token_Span (Scanner, From, To);
         Get_Current_Column := Get_Current_Column + (To - From - 1);

         while Token = New_Line_Token or
           Token = Separator_Token or
           Token = Comment_Token
         loop
            if Token = New_Line_Token then
               Get_Current_Line := Get_Current_Line + 1;
               Get_Current_Column := 1;
            end if;

            Scanners.Next_Token (Scanner, Token);
text_io.put_Line (Token'Img & To_String (Get_Token_Value));
            Scanners.Token_Span (Scanner, From, To);
            Get_Current_Column := Get_Current_Column + (To - From - 1);
         end loop;

         return Token;
      end YYLex;

      pragma Inline (YYLex);

      procedure YYError (Text : String) is
         Where : constant Text_Position :=
           (Get_Current_Line, Get_Current_Column - 1);
      begin
         Report_Error
           (The_Context.all, Asis.Nil_Compilation_Unit,
            Where, "Syntax Error", Error);
      end YYError;

##

   begin
      Scanners.Initialize (Scanner, Source_Buffers.Buffer_Start (Input));
      YYParse;
      return Last_Compilation;
   end Run;

