/* Automatically generated by 'BUILD_ERRORS' */

#include "gen-errors.h"
#include "error.h"
#include "ostream.h"

/* Header from input file '/u/g/release/Source/src/tools/tld/errors/arg-data.e' */
#include "solve-cycles.h"

/* Header from input file '/u/g/release/Source/src/tools/tld/errors/builder.e' */

/* Header from input file '/u/g/release/Source/src/tools/tld/errors/capsule.e' */
#include "solve-cycles.h"

/* Header from input file '/u/g/release/Source/src/tools/tld/errors/contents.e' */

/* Header from input file '/u/g/release/Source/src/tools/tld/errors/extract.e' */

/* Header from input file '/u/g/release/Source/src/tools/tld/errors/library.e' */
#include "solve-cycles.h"

/* Header from input file '/u/g/release/Source/src/tools/tld/errors/linker.e' */
#include "solve-cycles.h"

/* Header from input file '/u/g/release/Source/src/tools/tld/errors/main.e' */
#include "solve-cycles.h"

/* Header from input file '/u/g/release/Source/src/tools/tld/errors/name-entry.e' */
#include "solve-cycles.h"

/* Header from input file '/u/g/release/Source/src/tools/tld/errors/rename-file.e' */

/* Header from input file '/u/g/release/Source/src/tools/tld/errors/shape-entry.e' */

/* Header from input file '/u/g/release/Source/src/tools/tld/errors/tdf-read.e' */
#include "solve-cycles.h"


static ETagDataT ET [] = {
    UB "file name" UE,
    UB "system error" UE,
    UB "shape name" UE,
    UB "name" UE,
    UB "option" UE,
    UB "usage" UE,
    UB "option location" UE,
    UB "cap name" UE,
    UB "line number" UE,
    UB "unit set name" UE,
    UB "byte number" UE,
    UB "magic name" UE,
    UB "proper magic name" UE,
    UB "major version" UE,
    UB "proper major version" UE,
    UB "shape count" UE,
    UB "name count" UE,
    UB "identifier" UE,
    UB "identifier limit" UE,
    UB "correct offset" UE,
    UB "offset" UE,
    UB "version number" UE,
    UB "unit set count" UE,
    UB "unit count" UE,
    UB "previous file name" UE,
    UB "count number" UE,
    UB "shape number" UE,
    UB "unit number" UE,
    UB "mapping number" UE,
    UB "builtin name" UE,
    UB "character" UE,
    UB "string name" UE,
    UB "error name" UE,
    UB "message" UE,
    UB "except name" UE,
    UB "assertion" UE,
    UB "block address" UE,
    UB "allocation file name" UE,
    UB "allocation line number" UE,
    UB "lib name" UE,
    UB "capsule index" UE,
    UB "num capsules" UE,
    UB "mode" UE,
    UB "character size" UE,
    UB "name type" UE,
    ERROR_END_TAG_LIST
};

static ErrorDataT EE [] = {
    UB {
	"tld multiple debug files",
	ERROR_SEVERITY_FATAL,
	"more than one debug file specified",
	NIL (GenericP)
    } UE,
    UB {
	"tld cannot open debug file",
	ERROR_SEVERITY_FATAL,
	"cannot open debug file '${file name}': ${system error}",
	NIL (GenericP)
    } UE,
    UB {
	"tld multiple output files",
	ERROR_SEVERITY_FATAL,
	"more than one output file specified",
	NIL (GenericP)
    } UE,
    UB {
	"tld multiple unit files",
	ERROR_SEVERITY_FATAL,
	"more than one unit set file specified",
	NIL (GenericP)
    } UE,
    UB {
	"multiply renamed name",
	ERROR_SEVERITY_ERROR,
	"${shape name} '${name}' is renamed multiple times",
	NIL (GenericP)
    } UE,
    UB {
	"arg parse unknown option",
	ERROR_SEVERITY_FATAL,
	"unknown option '${option}'\n\
${usage}",
	NIL (GenericP)
    } UE,
    UB {
	"arg parse unknown short opt",
	ERROR_SEVERITY_FATAL,
	"unknown short option '${option}' at '${option location}'\n\
${usage}",
	NIL (GenericP)
    } UE,
    UB {
	"arg parse ambiguous option",
	ERROR_SEVERITY_FATAL,
	"ambiguous option '${option}'\n\
${usage}",
	NIL (GenericP)
    } UE,
    UB {
	"arg parse missing argument",
	ERROR_SEVERITY_FATAL,
	"missing argument for option '${option}'\n\
${usage}",
	NIL (GenericP)
    } UE,
    UB {
	"arg parse missing short arg",
	ERROR_SEVERITY_FATAL,
	"missing argument for option '${option}' at '${option location}'\n\
${usage}",
	NIL (GenericP)
    } UE,
    UB {
	"duplicate capsule name",
	ERROR_SEVERITY_ERROR,
	"capsule name '${cap name}' occurs more than once in input capsule list",
	NIL (GenericP)
    } UE,
    UB {
	"cannot open unit set file",
	ERROR_SEVERITY_FATAL,
	"cannot open unit set file '${file name}': ${system error}",
	NIL (GenericP)
    } UE,
    UB {
	"unit set expected quote",
	ERROR_SEVERITY_FATAL,
	"${file name}: ${line number}: expected double quote to begin unit set name",
	NIL (GenericP)
    } UE,
    UB {
	"unit set illegal escape",
	ERROR_SEVERITY_FATAL,
	"${file name}: ${line number}: illegal escape sequence in unit set name",
	NIL (GenericP)
    } UE,
    UB {
	"unit set eof in name",
	ERROR_SEVERITY_FATAL,
	"${file name}: ${line number}: end of file in unit set name",
	NIL (GenericP)
    } UE,
    UB {
	"unit set duplicate name",
	ERROR_SEVERITY_FATAL,
	"${file name}: unit set name '${unit set name}' occurs more than once",
	NIL (GenericP)
    } UE,
    UB {
	"unit set no tld name",
	ERROR_SEVERITY_FATAL,
	"${file name}: linker information unit set name 'tld' does not occur",
	NIL (GenericP)
    } UE,
    UB {
	"capsule bad magic",
	ERROR_SEVERITY_ERROR,
	"${file name}: byte ${byte number}: bad magic number '${magic name}' should be '${proper magic name}'",
	NIL (GenericP)
    } UE,
    UB {
	"capsule bad version",
	ERROR_SEVERITY_ERROR,
	"${file name}: byte ${byte number}: illegal major version number ${major version}",
	NIL (GenericP)
    } UE,
    UB {
	"capsule version mismatch",
	ERROR_SEVERITY_ERROR,
	"${file name}: byte ${byte number}: major version number mismatch (${major version} should be ${proper major version})",
	NIL (GenericP)
    } UE,
    UB {
	"duplicate unit set name",
	ERROR_SEVERITY_ERROR,
	"${file name}: byte ${byte number}: unit set '${unit set name}' occurs more than once",
	NIL (GenericP)
    } UE,
    UB {
	"out of order unit set name",
	ERROR_SEVERITY_ERROR,
	"${file name}: byte ${byte number}: unit set '${unit set name}' occurs in wrong order",
	NIL (GenericP)
    } UE,
    UB {
	"unknown unit set name",
	ERROR_SEVERITY_ERROR,
	"${file name}: byte ${byte number}: unit set '${unit set name}' is unknown",
	NIL (GenericP)
    } UE,
    UB {
	"duplicate shape name",
	ERROR_SEVERITY_ERROR,
	"${file name}: byte ${byte number}: shape '${shape name}' occurs more than once",
	NIL (GenericP)
    } UE,
    UB {
	"shape and name count mismatch",
	ERROR_SEVERITY_ERROR,
	"${file name}: byte ${byte number}: external name count ${name count} does not equal shape count ${shape count}",
	NIL (GenericP)
    } UE,
    UB {
	"name id out of range",
	ERROR_SEVERITY_ERROR,
	"${file name}: byte ${byte number}: external ${shape name} name '${name}' has out of range identifier ${identifier} (greater than ${identifier limit})",
	NIL (GenericP)
    } UE,
    UB {
	"name id used multiple times",
	ERROR_SEVERITY_ERROR,
	"${file name}: byte ${byte number}: external ${shape name} name '${name}' is bound to previously used identifier ${identifier}",
	NIL (GenericP)
    } UE,
    UB {
	"too many tld units",
	ERROR_SEVERITY_ERROR,
	"${file name}: byte ${byte number}: capsule contains wrong number of units in linker information unit set (should be one)",
	NIL (GenericP)
    } UE,
    UB {
	"tld2 unit set type obsolete",
	ERROR_SEVERITY_WARNING,
	"${file name}: byte ${byte number}: capsule contains 'tld2' unit set type which is no longer supported",
	NIL (GenericP)
    } UE,
    UB {
	"too many tld unit counts",
	ERROR_SEVERITY_ERROR,
	"${file name}: byte ${byte number}: capsule contains wrong number of counts in linker information unit (should be zero)",
	NIL (GenericP)
    } UE,
    UB {
	"too many tld unit mappings",
	ERROR_SEVERITY_ERROR,
	"${file name}: byte ${byte number}: capsule contains wrong number of mappings in linker information unit (should be zero)",
	NIL (GenericP)
    } UE,
    UB {
	"tld unit wrong size",
	ERROR_SEVERITY_ERROR,
	"${file name}: byte ${byte number}: linker information unit contents is the wrong size (final offset is ${offset} but should be ${correct offset})",
	NIL (GenericP)
    } UE,
    UB {
	"unknown tld unit type",
	ERROR_SEVERITY_ERROR,
	"${file name}: byte ${byte number}: linker information unit version number ${version number} is not supported in this implementation",
	NIL (GenericP)
    } UE,
    UB {
	"unit set count mismatch",
	ERROR_SEVERITY_ERROR,
	"${file name}: byte ${byte number}: unit count ${unit count} does not equal unit set count ${unit set count}",
	NIL (GenericP)
    } UE,
    UB {
	"missing tld unit set",
	ERROR_SEVERITY_WARNING,
	"capsule '${file name}' has no linker information unit set",
	NIL (GenericP)
    } UE,
    UB {
	"extra tld unit set",
	ERROR_SEVERITY_ERROR,
	"${file name}: byte ${byte number}: capsule contains both a 'tld' and a 'tld2' unit set",
	NIL (GenericP)
    } UE,
    UB {
	"defined but not declared",
	ERROR_SEVERITY_ERROR,
	"${file name}: byte ${byte number}: external ${shape name} '${name}' is defined but not declared",
	NIL (GenericP)
    } UE,
    UB {
	"illegally multiply defined",
	ERROR_SEVERITY_ERROR,
	"${file name}: byte ${byte number}: external ${shape name} '${name}' has the multiply defined bit set illegally",
	NIL (GenericP)
    } UE,
    UB {
	"bad usage",
	ERROR_SEVERITY_ERROR,
	"${file name}: byte ${byte number}: external ${shape name} '${name}' has usage ${usage} which has no meaning in this implementation",
	NIL (GenericP)
    } UE,
    UB {
	"multiply defined",
	ERROR_SEVERITY_ERROR,
	"${file name}: byte ${byte number}: external ${shape name} '${name}' is defined more than once (previous definition in '${previous file name}')",
	NIL (GenericP)
    } UE,
    UB {
	"unit count num mismatch",
	ERROR_SEVERITY_ERROR,
	"${file name}: byte ${byte number}: illegal count number ${count number} in ${unit set name} unit ${unit number} (should be 0 or ${shape number})",
	NIL (GenericP)
    } UE,
    UB {
	"unit mapping num mismatch",
	ERROR_SEVERITY_ERROR,
	"${file name}: byte ${byte number}: illegal mapping number ${mapping number} in ${unit set name} unit ${unit number} (should be ${count number})",
	NIL (GenericP)
    } UE,
    UB {
	"id out of range",
	ERROR_SEVERITY_ERROR,
	"${file name}: byte ${byte number}: ${shape name} identifier ${identifier} is out of range in mapping table of ${unit set name} unit ${unit number} (should be less than ${identifier limit})",
	NIL (GenericP)
    } UE,
    UB {
	"too many library files",
	ERROR_SEVERITY_FATAL,
	"too many library files specified (should be one)",
	NIL (GenericP)
    } UE,
    UB {
	"errf null char in builtin",
	ERROR_SEVERITY_FATAL,
	"${file name}: ${line number}: null character in builtin",
	NIL (GenericP)
    } UE,
    UB {
	"errf null character in name",
	ERROR_SEVERITY_FATAL,
	"${file name}: ${line number}: null character in name",
	NIL (GenericP)
    } UE,
    UB {
	"errf null character in string",
	ERROR_SEVERITY_FATAL,
	"${file name}: ${line number}: null character in string",
	NIL (GenericP)
    } UE,
    UB {
	"errf newline in builtin",
	ERROR_SEVERITY_FATAL,
	"${file name}: ${line number}: unescaped newline in builtin",
	NIL (GenericP)
    } UE,
    UB {
	"errf newline in name",
	ERROR_SEVERITY_FATAL,
	"${file name}: ${line number}: unescaped newline in name",
	NIL (GenericP)
    } UE,
    UB {
	"errf newline in string",
	ERROR_SEVERITY_FATAL,
	"${file name}: ${line number}: unescaped newline in string",
	NIL (GenericP)
    } UE,
    UB {
	"errf eof in builtin",
	ERROR_SEVERITY_FATAL,
	"${file name}: ${line number}: unexpected end of file in builtin",
	NIL (GenericP)
    } UE,
    UB {
	"errf eof in name",
	ERROR_SEVERITY_FATAL,
	"${file name}: ${line number}: unexpected end of file in name",
	NIL (GenericP)
    } UE,
    UB {
	"errf eof in string",
	ERROR_SEVERITY_FATAL,
	"${file name}: ${line number}: unexpected end of file in string",
	NIL (GenericP)
    } UE,
    UB {
	"errf illegal esc in builtin",
	ERROR_SEVERITY_FATAL,
	"${file name}: ${line number}: illegal escape sequence in builtin",
	NIL (GenericP)
    } UE,
    UB {
	"errf illegal escape in name",
	ERROR_SEVERITY_FATAL,
	"${file name}: ${line number}: illegal escape sequence in name",
	NIL (GenericP)
    } UE,
    UB {
	"errf illegal escape in string",
	ERROR_SEVERITY_FATAL,
	"${file name}: ${line number}: illegal escape sequence in string",
	NIL (GenericP)
    } UE,
    UB {
	"errf unknown builtin",
	ERROR_SEVERITY_FATAL,
	"${file name}: ${line number}: unknown builtin '%${builtin name}%'",
	NIL (GenericP)
    } UE,
    UB {
	"errf illegal character",
	ERROR_SEVERITY_FATAL,
	"${file name}: ${line number}: illegal character '${character}'",
	NIL (GenericP)
    } UE,
    UB {
	"errf expected string",
	ERROR_SEVERITY_FATAL,
	"${file name}: ${line number}: expected string",
	NIL (GenericP)
    } UE,
    UB {
	"errf expected section",
	ERROR_SEVERITY_FATAL,
	"${file name}: ${line number}: expected name or section header (one of '%strings%', '%prefix%' or '%errors%')",
	NIL (GenericP)
    } UE,
    UB {
	"errf unknown string",
	ERROR_SEVERITY_FATAL,
	"${file name}: ${line number}: unknown string name '${string name}'",
	NIL (GenericP)
    } UE,
    UB {
	"errf unknown error",
	ERROR_SEVERITY_FATAL,
	"${file name}: ${line number}: unknown error name '${error name}'",
	NIL (GenericP)
    } UE,
    UB {
	"errf illegal message",
	ERROR_SEVERITY_FATAL,
	"${file name}: ${line number}: malformed or unterminated tag in message '${message}'",
	NIL (GenericP)
    } UE,
    UB {
	"errf cannot open",
	ERROR_SEVERITY_FATAL,
	"cannot open error file '${file name}': ${system error}",
	NIL (GenericP)
    } UE,
    UB {
	"all specified with capsules",
	ERROR_SEVERITY_FATAL,
	"cannot extract all capsules and named capsules",
	NIL (GenericP)
    } UE,
    UB {
	"no capsules specified",
	ERROR_SEVERITY_FATAL,
	"no capsules specified to extract",
	NIL (GenericP)
    } UE,
    UB {
	"exception unhandled",
	ERROR_SEVERITY_INTERNAL,
	"unhandled exception '${except name}' thrown from line ${line number}, file '${file name}'",
	NIL (GenericP)
    } UE,
    UB {
	"exception corrupt handler",
	ERROR_SEVERITY_INTERNAL,
	"corrupt exception handler installed at line ${line number}, file '${file name}'",
	NIL (GenericP)
    } UE,
    UB {
	"assertion failed",
	ERROR_SEVERITY_INTERNAL,
	"assertion '${assertion}' failed at line ${line number}, file '${file name}'",
	NIL (GenericP)
    } UE,
    UB {
	"dalloc multi deallocate",
	ERROR_SEVERITY_INTERNAL,
	"memory block ${block address} allocated at line ${allocation line number} in '${allocation file name}' is deallocated more than once (second deallocation at line ${line number} in file '${file name}'",
	NIL (GenericP)
    } UE,
    UB {
	"dalloc corrupt block",
	ERROR_SEVERITY_INTERNAL,
	"memory block ${block address} is corrupt at deallocation (deallocation at line ${line number} in file '${file name}'",
	NIL (GenericP)
    } UE,
    UB {
	"library bad magic",
	ERROR_SEVERITY_ERROR,
	"${file name}: byte ${byte number}: bad magic number '${magic name}' should be '${proper magic name}'",
	NIL (GenericP)
    } UE,
    UB {
	"library bad version",
	ERROR_SEVERITY_ERROR,
	"${file name}: byte ${byte number}: illegal major version number ${major version}",
	NIL (GenericP)
    } UE,
    UB {
	"library version mismatch",
	ERROR_SEVERITY_ERROR,
	"${file name}: byte ${byte number}: major version number mismatch (${major version} should be ${proper major version})",
	NIL (GenericP)
    } UE,
    UB {
	"null in file name",
	ERROR_SEVERITY_ERROR,
	"${file name}: byte ${byte number}: capsule name '${cap name}' contains null character",
	NIL (GenericP)
    } UE,
    UB {
	"capsule not found",
	ERROR_SEVERITY_ERROR,
	"capsule '${cap name}' is not contained in library '${lib name}'",
	NIL (GenericP)
    } UE,
    UB {
	"extracting capsule",
	ERROR_SEVERITY_INFORMATION,
	"extracted capsule '${cap name}' into '${file name}'",
	NIL (GenericP)
    } UE,
    UB {
	"lib unknown type",
	ERROR_SEVERITY_ERROR,
	"${file name}: byte ${byte number}: library version number ${version number} is not supported in this implementation",
	NIL (GenericP)
    } UE,
    UB {
	"lib defined but not declared",
	ERROR_SEVERITY_ERROR,
	"${file name}: byte ${byte number}: external ${shape name} '${name}' is defined but not declared",
	NIL (GenericP)
    } UE,
    UB {
	"lib illegally mult defined",
	ERROR_SEVERITY_ERROR,
	"${file name}: byte ${byte number}: external ${shape name} '${name}' has the multiply defined bit set illegally",
	NIL (GenericP)
    } UE,
    UB {
	"lib bad usage",
	ERROR_SEVERITY_ERROR,
	"${file name}: byte ${byte number}: external ${shape name} '${name}' has usage ${usage} which has no meaning in this implementation",
	NIL (GenericP)
    } UE,
    UB {
	"lib multiply defined",
	ERROR_SEVERITY_ERROR,
	"${file name}: byte ${byte number}: external ${shape name} '${name}' is defined more than once in libraries (previous definition in '${previous file name}')",
	NIL (GenericP)
    } UE,
    UB {
	"capsule index too big",
	ERROR_SEVERITY_ERROR,
	"${file name}: byte ${byte number}: external ${shape name} '${name}' has capsule index ${capsule index} (should be less than ${num capsules})",
	NIL (GenericP)
    } UE,
    UB {
	"cannot hide shape",
	ERROR_SEVERITY_ERROR,
	"there are no external ${shape name} names to hide",
	NIL (GenericP)
    } UE,
    UB {
	"cannot hide",
	ERROR_SEVERITY_ERROR,
	"there is no external ${shape name} named '${name}' to hide",
	NIL (GenericP)
    } UE,
    UB {
	"cannot hide undefined",
	ERROR_SEVERITY_ERROR,
	"cannot hide undefined external ${shape name} named '${name}'",
	NIL (GenericP)
    } UE,
    UB {
	"cannot keep shape",
	ERROR_SEVERITY_ERROR,
	"there are no external ${shape name} names to keep",
	NIL (GenericP)
    } UE,
    UB {
	"cannot keep",
	ERROR_SEVERITY_ERROR,
	"there is no external ${shape name} named '${name}' to keep",
	NIL (GenericP)
    } UE,
    UB {
	"bad mode",
	ERROR_SEVERITY_FATAL,
	"illegal mode character '${mode}'; should be one of 'c', 'l', 't' or 'x'",
	NIL (GenericP)
    } UE,
    UB {
	"missing files",
	ERROR_SEVERITY_FATAL,
	"no files specified for processing",
	NIL (GenericP)
    } UE,
    UB {
	"no memory",
	ERROR_SEVERITY_FATAL,
	"cannot allocate memory",
	NIL (GenericP)
    } UE,
    UB {
	"read error",
	ERROR_SEVERITY_FATAL,
	"error reading from file '${file name}': ${system error}",
	NIL (GenericP)
    } UE,
    UB {
	"write error",
	ERROR_SEVERITY_FATAL,
	"error writing to file '${file name}': ${system error}",
	NIL (GenericP)
    } UE,
    UB {
	"cannot open input file",
	ERROR_SEVERITY_ERROR,
	"cannot open input file '${file name}': ${system error}",
	NIL (GenericP)
    } UE,
    UB {
	"cannot open output file",
	ERROR_SEVERITY_FATAL,
	"cannot open output file '${file name}': ${system error}",
	NIL (GenericP)
    } UE,
    UB {
	"cannot open library file",
	ERROR_SEVERITY_ERROR,
	"cannot open library file '${file name}': ${system error}",
	NIL (GenericP)
    } UE,
    UB {
	"illegal external name",
	ERROR_SEVERITY_ERROR,
	"illegal external name '${name}'",
	NIL (GenericP)
    } UE,
    UB {
	"no single definition",
	ERROR_SEVERITY_FATAL,
	"no single definition for ${shape name} '${name}'",
	NIL (GenericP)
    } UE,
    UB {
	"rename cycle",
	ERROR_SEVERITY_ERROR,
	"cycle in ${shape name} renaming including name '${name}'",
	NIL (GenericP)
    } UE,
    UB {
	"no definition found",
	ERROR_SEVERITY_WARNING,
	"no definition found for ${shape name} '${name}'",
	NIL (GenericP)
    } UE,
    UB {
	"cannot open rename file",
	ERROR_SEVERITY_ERROR,
	"cannot open rename file '${file name}': ${system error}",
	NIL (GenericP)
    } UE,
    UB {
	"rename expected shape",
	ERROR_SEVERITY_ERROR,
	"${file name}: ${line number}: expected shape name",
	NIL (GenericP)
    } UE,
    UB {
	"rename expected name",
	ERROR_SEVERITY_ERROR,
	"${file name}: ${line number}: expected external name",
	NIL (GenericP)
    } UE,
    UB {
	"rename expected semi",
	ERROR_SEVERITY_ERROR,
	"${file name}: ${line number}: expected semi colon",
	NIL (GenericP)
    } UE,
    UB {
	"rename unexpected eof",
	ERROR_SEVERITY_ERROR,
	"${file name}: ${line number}: unexpected end of file",
	NIL (GenericP)
    } UE,
    UB {
	"rename unexpected newline",
	ERROR_SEVERITY_ERROR,
	"${file name}: ${line number}: unexpected newline",
	NIL (GenericP)
    } UE,
    UB {
	"rename illegal escape",
	ERROR_SEVERITY_ERROR,
	"${file name}: ${line number}: illegal escape sequence",
	NIL (GenericP)
    } UE,
    UB {
	"rename illegal char",
	ERROR_SEVERITY_ERROR,
	"${file name}: ${line number}: illegal character '${character}'",
	NIL (GenericP)
    } UE,
    UB {
	"too many ids",
	ERROR_SEVERITY_FATAL,
	"too many identifiers for this implementation",
	NIL (GenericP)
    } UE,
    UB {
	"unexpected eof in tdf",
	ERROR_SEVERITY_ERROR,
	"${file name}: byte ${byte number}: unexpected end of file",
	NIL (GenericP)
    } UE,
    UB {
	"tdf integer too big in tdf",
	ERROR_SEVERITY_ERROR,
	"${file name}: byte ${byte number}: TDF integer is too large for this machine",
	NIL (GenericP)
    } UE,
    UB {
	"unsupported char size in tdf",
	ERROR_SEVERITY_ERROR,
	"${file name}: byte ${byte number}: string character size ${character size} is not supported on this machine",
	NIL (GenericP)
    } UE,
    UB {
	"bad name type in tdf",
	ERROR_SEVERITY_ERROR,
	"${file name}: byte ${byte number}: name type ${name type} is unknown",
	NIL (GenericP)
    } UE,
    UB {
	"expected eof in tdf",
	ERROR_SEVERITY_ERROR,
	"${file name}: byte ${byte number}: expected end of file",
	NIL (GenericP)
    } UE,
    ERROR_END_ERROR_LIST
};

struct ES_00000 {
    CStringP                  file_name;
    int                       system_error;
};
struct ES_00001 {
    NStringP                  shape_name;
    NameKeyP                  name;
};
struct ES_00002 {
    CStringP                  option;
    ArgUsageP                 usage;
};
struct ES_00003 {
    CStringP                  option;
    CStringP                  option_location;
    ArgUsageP                 usage;
};
struct ES_00004 {
    CStringP                  cap_name;
};
struct ES_00005 {
    CStringP                  file_name;
    unsigned                  line_number;
};
struct ES_00006 {
    CStringP                  file_name;
    NStringP                  unit_set_name;
};
struct ES_00007 {
    CStringP                  file_name;
};
struct ES_00008 {
    CStringP                  file_name;
    unsigned                  byte_number;
    NStringP                  magic_name;
    NStringP                  proper_magic_name;
};
struct ES_00009 {
    CStringP                  file_name;
    unsigned                  byte_number;
    unsigned                  major_version;
};
struct ES_00010 {
    CStringP                  file_name;
    unsigned                  byte_number;
    unsigned                  major_version;
    unsigned                  proper_major_version;
};
struct ES_00011 {
    CStringP                  file_name;
    unsigned                  byte_number;
    NStringP                  unit_set_name;
};
struct ES_00012 {
    CStringP                  file_name;
    unsigned                  byte_number;
    NStringP                  shape_name;
};
struct ES_00013 {
    CStringP                  file_name;
    unsigned                  byte_number;
    unsigned                  shape_count;
    unsigned                  name_count;
};
struct ES_00014 {
    CStringP                  file_name;
    unsigned                  byte_number;
    NStringP                  shape_name;
    NameKeyP                  name;
    unsigned                  identifier;
    unsigned                  identifier_limit;
};
struct ES_00015 {
    CStringP                  file_name;
    unsigned                  byte_number;
    NStringP                  shape_name;
    NameKeyP                  name;
    unsigned                  identifier;
};
struct ES_00016 {
    CStringP                  file_name;
    unsigned                  byte_number;
};
struct ES_00017 {
    CStringP                  file_name;
    unsigned                  byte_number;
    unsigned                  correct_offset;
    unsigned                  offset;
};
struct ES_00018 {
    CStringP                  file_name;
    unsigned                  byte_number;
    unsigned                  version_number;
};
struct ES_00019 {
    CStringP                  file_name;
    unsigned                  byte_number;
    unsigned                  unit_set_count;
    unsigned                  unit_count;
};
struct ES_00020 {
    CStringP                  file_name;
    unsigned                  byte_number;
    NStringP                  shape_name;
    NameKeyP                  name;
};
struct ES_00021 {
    CStringP                  file_name;
    unsigned                  byte_number;
    NStringP                  shape_name;
    NameKeyP                  name;
    unsigned                  usage;
};
struct ES_00022 {
    CStringP                  file_name;
    unsigned                  byte_number;
    NStringP                  shape_name;
    NameKeyP                  name;
    CStringP                  previous_file_name;
};
struct ES_00023 {
    CStringP                  file_name;
    unsigned                  byte_number;
    unsigned                  count_number;
    unsigned                  shape_number;
    unsigned                  unit_number;
    NStringP                  unit_set_name;
};
struct ES_00024 {
    CStringP                  file_name;
    unsigned                  byte_number;
    unsigned                  mapping_number;
    unsigned                  count_number;
    unsigned                  unit_number;
    NStringP                  unit_set_name;
};
struct ES_00025 {
    CStringP                  file_name;
    unsigned                  byte_number;
    unsigned                  identifier;
    unsigned                  identifier_limit;
    NStringP                  shape_name;
    unsigned                  unit_number;
    NStringP                  unit_set_name;
};
struct ES_00026 {
    CStringP                  file_name;
    unsigned                  line_number;
    CStringP                  builtin_name;
};
struct ES_00027 {
    CStringP                  file_name;
    unsigned                  line_number;
    char                      character;
};
struct ES_00028 {
    CStringP                  file_name;
    unsigned                  line_number;
    CStringP                  string_name;
};
struct ES_00029 {
    CStringP                  file_name;
    unsigned                  line_number;
    CStringP                  error_name;
};
struct ES_00030 {
    CStringP                  file_name;
    unsigned                  line_number;
    CStringP                  message;
};
struct ES_00031 {
    ExceptionP                except_name;
    CStringP                  file_name;
    unsigned                  line_number;
};
struct ES_00032 {
    CStringP                  assertion;
    CStringP                  file_name;
    unsigned                  line_number;
};
struct ES_00033 {
    GenericP                  block_address;
    CStringP                  file_name;
    unsigned                  line_number;
    CStringP                  allocation_file_name;
    unsigned                  allocation_line_number;
};
struct ES_00034 {
    GenericP                  block_address;
    CStringP                  file_name;
    unsigned                  line_number;
};
struct ES_00035 {
    CStringP                  file_name;
    unsigned                  byte_number;
    NStringP                  cap_name;
};
struct ES_00036 {
    CStringP                  cap_name;
    CStringP                  lib_name;
};
struct ES_00037 {
    CStringP                  cap_name;
    CStringP                  file_name;
};
struct ES_00038 {
    CStringP                  file_name;
    unsigned                  byte_number;
    NStringP                  shape_name;
    NameKeyP                  name;
    LibCapsuleP               previous_file_name;
};
struct ES_00039 {
    CStringP                  file_name;
    unsigned                  byte_number;
    NStringP                  shape_name;
    NameKeyP                  name;
    unsigned                  capsule_index;
    unsigned                  num_capsules;
};
struct ES_00040 {
    NStringP                  shape_name;
};
struct ES_00041 {
    char                      mode;
};
struct ES_00042 {
    CStringP                  name;
};
struct ES_00043 {
    CStringP                  file_name;
    unsigned                  byte_number;
    unsigned                  character_size;
};
struct ES_00044 {
    CStringP                  file_name;
    unsigned                  byte_number;
    unsigned                  name_type;
};

static void
ET_00000 PROTO_N ((ostream, tag, gclosure))
         PROTO_T (OStreamP ostream X
                  ETagP    tag X
                  GenericP gclosure)
{
    UNUSED (ostream);
    UNUSED (tag);
    UNUSED (gclosure);
}
static void
ET_00001 PROTO_N ((ostream, tag, gclosure))
         PROTO_T (OStreamP ostream X
                  ETagP    tag X
                  GenericP gclosure)
{
    struct ES_00000 *closure = (struct ES_00000 *) gclosure;

    if (tag == ET [0].tag) {
	    write_cstring (ostream, closure->file_name);
    } else if (tag == ET [1].tag) {
	    write_system_error (ostream);
    }
}
static void
ET_00002 PROTO_N ((ostream, tag, gclosure))
         PROTO_T (OStreamP ostream X
                  ETagP    tag X
                  GenericP gclosure)
{
    struct ES_00001 *closure = (struct ES_00001 *) gclosure;

    if (tag == ET [2].tag) {
	    write_nstring (ostream, closure->shape_name);
    } else if (tag == ET [3].tag) {
	    write_name_key (ostream, closure->name);
    }
}
static void
ET_00003 PROTO_N ((ostream, tag, gclosure))
         PROTO_T (OStreamP ostream X
                  ETagP    tag X
                  GenericP gclosure)
{
    struct ES_00002 *closure = (struct ES_00002 *) gclosure;

    if (tag == ET [4].tag) {
	    write_cstring (ostream, closure->option);
    } else if (tag == ET [5].tag) {
	    write_arg_usage (ostream, closure->usage);
    }
}
static void
ET_00004 PROTO_N ((ostream, tag, gclosure))
         PROTO_T (OStreamP ostream X
                  ETagP    tag X
                  GenericP gclosure)
{
    struct ES_00003 *closure = (struct ES_00003 *) gclosure;

    if (tag == ET [4].tag) {
	    write_cstring (ostream, closure->option);
    } else if (tag == ET [6].tag) {
	    write_cstring (ostream, closure->option_location);
    } else if (tag == ET [5].tag) {
	    write_arg_usage (ostream, closure->usage);
    }
}
static void
ET_00005 PROTO_N ((ostream, tag, gclosure))
         PROTO_T (OStreamP ostream X
                  ETagP    tag X
                  GenericP gclosure)
{
    struct ES_00004 *closure = (struct ES_00004 *) gclosure;

    if (tag == ET [7].tag) {
	    write_cstring (ostream, closure->cap_name);
    }
}
static void
ET_00006 PROTO_N ((ostream, tag, gclosure))
         PROTO_T (OStreamP ostream X
                  ETagP    tag X
                  GenericP gclosure)
{
    struct ES_00005 *closure = (struct ES_00005 *) gclosure;

    if (tag == ET [0].tag) {
	    write_cstring (ostream, closure->file_name);
    } else if (tag == ET [8].tag) {
	    write_unsigned (ostream, closure->line_number);
    }
}
static void
ET_00007 PROTO_N ((ostream, tag, gclosure))
         PROTO_T (OStreamP ostream X
                  ETagP    tag X
                  GenericP gclosure)
{
    struct ES_00006 *closure = (struct ES_00006 *) gclosure;

    if (tag == ET [0].tag) {
	    write_cstring (ostream, closure->file_name);
    } else if (tag == ET [9].tag) {
	    write_nstring (ostream, closure->unit_set_name);
    }
}
static void
ET_00008 PROTO_N ((ostream, tag, gclosure))
         PROTO_T (OStreamP ostream X
                  ETagP    tag X
                  GenericP gclosure)
{
    struct ES_00007 *closure = (struct ES_00007 *) gclosure;

    if (tag == ET [0].tag) {
	    write_cstring (ostream, closure->file_name);
    }
}
static void
ET_00009 PROTO_N ((ostream, tag, gclosure))
         PROTO_T (OStreamP ostream X
                  ETagP    tag X
                  GenericP gclosure)
{
    struct ES_00008 *closure = (struct ES_00008 *) gclosure;

    if (tag == ET [0].tag) {
	    write_cstring (ostream, closure->file_name);
    } else if (tag == ET [10].tag) {
	    write_unsigned (ostream, closure->byte_number);
    } else if (tag == ET [11].tag) {
	    write_nstring (ostream, closure->magic_name);
    } else if (tag == ET [12].tag) {
	    write_nstring (ostream, closure->proper_magic_name);
    }
}
static void
ET_00010 PROTO_N ((ostream, tag, gclosure))
         PROTO_T (OStreamP ostream X
                  ETagP    tag X
                  GenericP gclosure)
{
    struct ES_00009 *closure = (struct ES_00009 *) gclosure;

    if (tag == ET [0].tag) {
	    write_cstring (ostream, closure->file_name);
    } else if (tag == ET [10].tag) {
	    write_unsigned (ostream, closure->byte_number);
    } else if (tag == ET [13].tag) {
	    write_unsigned (ostream, closure->major_version);
    }
}
static void
ET_00011 PROTO_N ((ostream, tag, gclosure))
         PROTO_T (OStreamP ostream X
                  ETagP    tag X
                  GenericP gclosure)
{
    struct ES_00010 *closure = (struct ES_00010 *) gclosure;

    if (tag == ET [0].tag) {
	    write_cstring (ostream, closure->file_name);
    } else if (tag == ET [10].tag) {
	    write_unsigned (ostream, closure->byte_number);
    } else if (tag == ET [13].tag) {
	    write_unsigned (ostream, closure->major_version);
    } else if (tag == ET [14].tag) {
	    write_unsigned (ostream, closure->proper_major_version);
    }
}
static void
ET_00012 PROTO_N ((ostream, tag, gclosure))
         PROTO_T (OStreamP ostream X
                  ETagP    tag X
                  GenericP gclosure)
{
    struct ES_00011 *closure = (struct ES_00011 *) gclosure;

    if (tag == ET [0].tag) {
	    write_cstring (ostream, closure->file_name);
    } else if (tag == ET [10].tag) {
	    write_unsigned (ostream, closure->byte_number);
    } else if (tag == ET [9].tag) {
	    write_nstring (ostream, closure->unit_set_name);
    }
}
static void
ET_00013 PROTO_N ((ostream, tag, gclosure))
         PROTO_T (OStreamP ostream X
                  ETagP    tag X
                  GenericP gclosure)
{
    struct ES_00012 *closure = (struct ES_00012 *) gclosure;

    if (tag == ET [0].tag) {
	    write_cstring (ostream, closure->file_name);
    } else if (tag == ET [10].tag) {
	    write_unsigned (ostream, closure->byte_number);
    } else if (tag == ET [2].tag) {
	    write_nstring (ostream, closure->shape_name);
    }
}
static void
ET_00014 PROTO_N ((ostream, tag, gclosure))
         PROTO_T (OStreamP ostream X
                  ETagP    tag X
                  GenericP gclosure)
{
    struct ES_00013 *closure = (struct ES_00013 *) gclosure;

    if (tag == ET [0].tag) {
	    write_cstring (ostream, closure->file_name);
    } else if (tag == ET [10].tag) {
	    write_unsigned (ostream, closure->byte_number);
    } else if (tag == ET [15].tag) {
	    write_unsigned (ostream, closure->shape_count);
    } else if (tag == ET [16].tag) {
	    write_unsigned (ostream, closure->name_count);
    }
}
static void
ET_00015 PROTO_N ((ostream, tag, gclosure))
         PROTO_T (OStreamP ostream X
                  ETagP    tag X
                  GenericP gclosure)
{
    struct ES_00014 *closure = (struct ES_00014 *) gclosure;

    if (tag == ET [0].tag) {
	    write_cstring (ostream, closure->file_name);
    } else if (tag == ET [10].tag) {
	    write_unsigned (ostream, closure->byte_number);
    } else if (tag == ET [2].tag) {
	    write_nstring (ostream, closure->shape_name);
    } else if (tag == ET [3].tag) {
	    write_name_key (ostream, closure->name);
    } else if (tag == ET [17].tag) {
	    write_unsigned (ostream, closure->identifier);
    } else if (tag == ET [18].tag) {
	    write_unsigned (ostream, closure->identifier_limit);
    }
}
static void
ET_00016 PROTO_N ((ostream, tag, gclosure))
         PROTO_T (OStreamP ostream X
                  ETagP    tag X
                  GenericP gclosure)
{
    struct ES_00015 *closure = (struct ES_00015 *) gclosure;

    if (tag == ET [0].tag) {
	    write_cstring (ostream, closure->file_name);
    } else if (tag == ET [10].tag) {
	    write_unsigned (ostream, closure->byte_number);
    } else if (tag == ET [2].tag) {
	    write_nstring (ostream, closure->shape_name);
    } else if (tag == ET [3].tag) {
	    write_name_key (ostream, closure->name);
    } else if (tag == ET [17].tag) {
	    write_unsigned (ostream, closure->identifier);
    }
}
static void
ET_00017 PROTO_N ((ostream, tag, gclosure))
         PROTO_T (OStreamP ostream X
                  ETagP    tag X
                  GenericP gclosure)
{
    struct ES_00016 *closure = (struct ES_00016 *) gclosure;

    if (tag == ET [0].tag) {
	    write_cstring (ostream, closure->file_name);
    } else if (tag == ET [10].tag) {
	    write_unsigned (ostream, closure->byte_number);
    }
}
static void
ET_00018 PROTO_N ((ostream, tag, gclosure))
         PROTO_T (OStreamP ostream X
                  ETagP    tag X
                  GenericP gclosure)
{
    struct ES_00017 *closure = (struct ES_00017 *) gclosure;

    if (tag == ET [0].tag) {
	    write_cstring (ostream, closure->file_name);
    } else if (tag == ET [10].tag) {
	    write_unsigned (ostream, closure->byte_number);
    } else if (tag == ET [19].tag) {
	    write_unsigned (ostream, closure->correct_offset);
    } else if (tag == ET [20].tag) {
	    write_unsigned (ostream, closure->offset);
    }
}
static void
ET_00019 PROTO_N ((ostream, tag, gclosure))
         PROTO_T (OStreamP ostream X
                  ETagP    tag X
                  GenericP gclosure)
{
    struct ES_00018 *closure = (struct ES_00018 *) gclosure;

    if (tag == ET [0].tag) {
	    write_cstring (ostream, closure->file_name);
    } else if (tag == ET [10].tag) {
	    write_unsigned (ostream, closure->byte_number);
    } else if (tag == ET [21].tag) {
	    write_unsigned (ostream, closure->version_number);
    }
}
static void
ET_00020 PROTO_N ((ostream, tag, gclosure))
         PROTO_T (OStreamP ostream X
                  ETagP    tag X
                  GenericP gclosure)
{
    struct ES_00019 *closure = (struct ES_00019 *) gclosure;

    if (tag == ET [0].tag) {
	    write_cstring (ostream, closure->file_name);
    } else if (tag == ET [10].tag) {
	    write_unsigned (ostream, closure->byte_number);
    } else if (tag == ET [22].tag) {
	    write_unsigned (ostream, closure->unit_set_count);
    } else if (tag == ET [23].tag) {
	    write_unsigned (ostream, closure->unit_count);
    }
}
static void
ET_00021 PROTO_N ((ostream, tag, gclosure))
         PROTO_T (OStreamP ostream X
                  ETagP    tag X
                  GenericP gclosure)
{
    struct ES_00020 *closure = (struct ES_00020 *) gclosure;

    if (tag == ET [0].tag) {
	    write_cstring (ostream, closure->file_name);
    } else if (tag == ET [10].tag) {
	    write_unsigned (ostream, closure->byte_number);
    } else if (tag == ET [2].tag) {
	    write_nstring (ostream, closure->shape_name);
    } else if (tag == ET [3].tag) {
	    write_name_key (ostream, closure->name);
    }
}
static void
ET_00022 PROTO_N ((ostream, tag, gclosure))
         PROTO_T (OStreamP ostream X
                  ETagP    tag X
                  GenericP gclosure)
{
    struct ES_00021 *closure = (struct ES_00021 *) gclosure;

    if (tag == ET [0].tag) {
	    write_cstring (ostream, closure->file_name);
    } else if (tag == ET [10].tag) {
	    write_unsigned (ostream, closure->byte_number);
    } else if (tag == ET [2].tag) {
	    write_nstring (ostream, closure->shape_name);
    } else if (tag == ET [3].tag) {
	    write_name_key (ostream, closure->name);
    } else if (tag == ET [5].tag) {
	    write_unsigned (ostream, closure->usage);
    }
}
static void
ET_00023 PROTO_N ((ostream, tag, gclosure))
         PROTO_T (OStreamP ostream X
                  ETagP    tag X
                  GenericP gclosure)
{
    struct ES_00022 *closure = (struct ES_00022 *) gclosure;

    if (tag == ET [0].tag) {
	    write_cstring (ostream, closure->file_name);
    } else if (tag == ET [10].tag) {
	    write_unsigned (ostream, closure->byte_number);
    } else if (tag == ET [2].tag) {
	    write_nstring (ostream, closure->shape_name);
    } else if (tag == ET [3].tag) {
	    write_name_key (ostream, closure->name);
    } else if (tag == ET [24].tag) {
	    write_cstring (ostream, closure->previous_file_name);
    }
}
static void
ET_00024 PROTO_N ((ostream, tag, gclosure))
         PROTO_T (OStreamP ostream X
                  ETagP    tag X
                  GenericP gclosure)
{
    struct ES_00023 *closure = (struct ES_00023 *) gclosure;

    if (tag == ET [0].tag) {
	    write_cstring (ostream, closure->file_name);
    } else if (tag == ET [10].tag) {
	    write_unsigned (ostream, closure->byte_number);
    } else if (tag == ET [25].tag) {
	    write_unsigned (ostream, closure->count_number);
    } else if (tag == ET [26].tag) {
	    write_unsigned (ostream, closure->shape_number);
    } else if (tag == ET [27].tag) {
	    write_unsigned (ostream, closure->unit_number);
    } else if (tag == ET [9].tag) {
	    write_nstring (ostream, closure->unit_set_name);
    }
}
static void
ET_00025 PROTO_N ((ostream, tag, gclosure))
         PROTO_T (OStreamP ostream X
                  ETagP    tag X
                  GenericP gclosure)
{
    struct ES_00024 *closure = (struct ES_00024 *) gclosure;

    if (tag == ET [0].tag) {
	    write_cstring (ostream, closure->file_name);
    } else if (tag == ET [10].tag) {
	    write_unsigned (ostream, closure->byte_number);
    } else if (tag == ET [28].tag) {
	    write_unsigned (ostream, closure->mapping_number);
    } else if (tag == ET [25].tag) {
	    write_unsigned (ostream, closure->count_number);
    } else if (tag == ET [27].tag) {
	    write_unsigned (ostream, closure->unit_number);
    } else if (tag == ET [9].tag) {
	    write_nstring (ostream, closure->unit_set_name);
    }
}
static void
ET_00026 PROTO_N ((ostream, tag, gclosure))
         PROTO_T (OStreamP ostream X
                  ETagP    tag X
                  GenericP gclosure)
{
    struct ES_00025 *closure = (struct ES_00025 *) gclosure;

    if (tag == ET [0].tag) {
	    write_cstring (ostream, closure->file_name);
    } else if (tag == ET [10].tag) {
	    write_unsigned (ostream, closure->byte_number);
    } else if (tag == ET [17].tag) {
	    write_unsigned (ostream, closure->identifier);
    } else if (tag == ET [18].tag) {
	    write_unsigned (ostream, closure->identifier_limit);
    } else if (tag == ET [2].tag) {
	    write_nstring (ostream, closure->shape_name);
    } else if (tag == ET [27].tag) {
	    write_unsigned (ostream, closure->unit_number);
    } else if (tag == ET [9].tag) {
	    write_nstring (ostream, closure->unit_set_name);
    }
}
static void
ET_00027 PROTO_N ((ostream, tag, gclosure))
         PROTO_T (OStreamP ostream X
                  ETagP    tag X
                  GenericP gclosure)
{
    struct ES_00026 *closure = (struct ES_00026 *) gclosure;

    if (tag == ET [0].tag) {
	    write_cstring (ostream, closure->file_name);
    } else if (tag == ET [8].tag) {
	    write_unsigned (ostream, closure->line_number);
    } else if (tag == ET [29].tag) {
	    write_cstring (ostream, closure->builtin_name);
    }
}
static void
ET_00028 PROTO_N ((ostream, tag, gclosure))
         PROTO_T (OStreamP ostream X
                  ETagP    tag X
                  GenericP gclosure)
{
    struct ES_00027 *closure = (struct ES_00027 *) gclosure;

    if (tag == ET [0].tag) {
	    write_cstring (ostream, closure->file_name);
    } else if (tag == ET [8].tag) {
	    write_unsigned (ostream, closure->line_number);
    } else if (tag == ET [30].tag) {
	    write_escaped_char (ostream, closure->character);
    }
}
static void
ET_00029 PROTO_N ((ostream, tag, gclosure))
         PROTO_T (OStreamP ostream X
                  ETagP    tag X
                  GenericP gclosure)
{
    struct ES_00028 *closure = (struct ES_00028 *) gclosure;

    if (tag == ET [0].tag) {
	    write_cstring (ostream, closure->file_name);
    } else if (tag == ET [8].tag) {
	    write_unsigned (ostream, closure->line_number);
    } else if (tag == ET [31].tag) {
	    write_cstring (ostream, closure->string_name);
    }
}
static void
ET_00030 PROTO_N ((ostream, tag, gclosure))
         PROTO_T (OStreamP ostream X
                  ETagP    tag X
                  GenericP gclosure)
{
    struct ES_00029 *closure = (struct ES_00029 *) gclosure;

    if (tag == ET [0].tag) {
	    write_cstring (ostream, closure->file_name);
    } else if (tag == ET [8].tag) {
	    write_unsigned (ostream, closure->line_number);
    } else if (tag == ET [32].tag) {
	    write_cstring (ostream, closure->error_name);
    }
}
static void
ET_00031 PROTO_N ((ostream, tag, gclosure))
         PROTO_T (OStreamP ostream X
                  ETagP    tag X
                  GenericP gclosure)
{
    struct ES_00030 *closure = (struct ES_00030 *) gclosure;

    if (tag == ET [0].tag) {
	    write_cstring (ostream, closure->file_name);
    } else if (tag == ET [8].tag) {
	    write_unsigned (ostream, closure->line_number);
    } else if (tag == ET [33].tag) {
	    write_cstring (ostream, closure->message);
    }
}
static void
ET_00032 PROTO_N ((ostream, tag, gclosure))
         PROTO_T (OStreamP ostream X
                  ETagP    tag X
                  GenericP gclosure)
{
    struct ES_00031 *closure = (struct ES_00031 *) gclosure;

    if (tag == ET [34].tag) {
	    write_cstring (ostream, exception_name (closure->except_name));
    } else if (tag == ET [0].tag) {
	    write_cstring (ostream, closure->file_name);
    } else if (tag == ET [8].tag) {
	    write_unsigned (ostream, closure->line_number);
    }
}
static void
ET_00033 PROTO_N ((ostream, tag, gclosure))
         PROTO_T (OStreamP ostream X
                  ETagP    tag X
                  GenericP gclosure)
{
    struct ES_00032 *closure = (struct ES_00032 *) gclosure;

    if (tag == ET [35].tag) {
	    write_cstring (ostream, closure->assertion);
    } else if (tag == ET [0].tag) {
	    write_cstring (ostream, closure->file_name);
    } else if (tag == ET [8].tag) {
	    write_unsigned (ostream, closure->line_number);
    }
}
static void
ET_00034 PROTO_N ((ostream, tag, gclosure))
         PROTO_T (OStreamP ostream X
                  ETagP    tag X
                  GenericP gclosure)
{
    struct ES_00033 *closure = (struct ES_00033 *) gclosure;

    if (tag == ET [36].tag) {
	    write_pointer (ostream, closure->block_address);
    } else if (tag == ET [0].tag) {
	    write_cstring (ostream, closure->file_name);
    } else if (tag == ET [8].tag) {
	    write_unsigned (ostream, closure->line_number);
    } else if (tag == ET [37].tag) {
	    write_cstring (ostream, closure->allocation_file_name);
    } else if (tag == ET [38].tag) {
	    write_unsigned (ostream, closure->allocation_line_number);
    }
}
static void
ET_00035 PROTO_N ((ostream, tag, gclosure))
         PROTO_T (OStreamP ostream X
                  ETagP    tag X
                  GenericP gclosure)
{
    struct ES_00034 *closure = (struct ES_00034 *) gclosure;

    if (tag == ET [36].tag) {
	    write_pointer (ostream, closure->block_address);
    } else if (tag == ET [0].tag) {
	    write_cstring (ostream, closure->file_name);
    } else if (tag == ET [8].tag) {
	    write_unsigned (ostream, closure->line_number);
    }
}
static void
ET_00036 PROTO_N ((ostream, tag, gclosure))
         PROTO_T (OStreamP ostream X
                  ETagP    tag X
                  GenericP gclosure)
{
    struct ES_00035 *closure = (struct ES_00035 *) gclosure;

    if (tag == ET [0].tag) {
	    write_cstring (ostream, closure->file_name);
    } else if (tag == ET [10].tag) {
	    write_unsigned (ostream, closure->byte_number);
    } else if (tag == ET [7].tag) {
	    write_nstring (ostream, closure->cap_name);
    }
}
static void
ET_00037 PROTO_N ((ostream, tag, gclosure))
         PROTO_T (OStreamP ostream X
                  ETagP    tag X
                  GenericP gclosure)
{
    struct ES_00036 *closure = (struct ES_00036 *) gclosure;

    if (tag == ET [7].tag) {
	    write_cstring (ostream, closure->cap_name);
    } else if (tag == ET [39].tag) {
	    write_cstring (ostream, closure->lib_name);
    }
}
static void
ET_00038 PROTO_N ((ostream, tag, gclosure))
         PROTO_T (OStreamP ostream X
                  ETagP    tag X
                  GenericP gclosure)
{
    struct ES_00037 *closure = (struct ES_00037 *) gclosure;

    if (tag == ET [7].tag) {
	    write_cstring (ostream, closure->cap_name);
    } else if (tag == ET [0].tag) {
	    write_cstring (ostream, closure->file_name);
    }
}
static void
ET_00039 PROTO_N ((ostream, tag, gclosure))
         PROTO_T (OStreamP ostream X
                  ETagP    tag X
                  GenericP gclosure)
{
    struct ES_00038 *closure = (struct ES_00038 *) gclosure;

    if (tag == ET [0].tag) {
	    write_cstring (ostream, closure->file_name);
    } else if (tag == ET [10].tag) {
	    write_unsigned (ostream, closure->byte_number);
    } else if (tag == ET [2].tag) {
	    write_nstring (ostream, closure->shape_name);
    } else if (tag == ET [3].tag) {
	    write_name_key (ostream, closure->name);
    } else if (tag == ET [24].tag) {
	    write_lib_capsule_full_name (ostream, closure->previous_file_name);
    }
}
static void
ET_00040 PROTO_N ((ostream, tag, gclosure))
         PROTO_T (OStreamP ostream X
                  ETagP    tag X
                  GenericP gclosure)
{
    struct ES_00039 *closure = (struct ES_00039 *) gclosure;

    if (tag == ET [0].tag) {
	    write_cstring (ostream, closure->file_name);
    } else if (tag == ET [10].tag) {
	    write_unsigned (ostream, closure->byte_number);
    } else if (tag == ET [2].tag) {
	    write_nstring (ostream, closure->shape_name);
    } else if (tag == ET [3].tag) {
	    write_name_key (ostream, closure->name);
    } else if (tag == ET [40].tag) {
	    write_unsigned (ostream, closure->capsule_index);
    } else if (tag == ET [41].tag) {
	    write_unsigned (ostream, closure->num_capsules);
    }
}
static void
ET_00041 PROTO_N ((ostream, tag, gclosure))
         PROTO_T (OStreamP ostream X
                  ETagP    tag X
                  GenericP gclosure)
{
    struct ES_00040 *closure = (struct ES_00040 *) gclosure;

    if (tag == ET [2].tag) {
	    write_nstring (ostream, closure->shape_name);
    }
}
static void
ET_00042 PROTO_N ((ostream, tag, gclosure))
         PROTO_T (OStreamP ostream X
                  ETagP    tag X
                  GenericP gclosure)
{
    struct ES_00041 *closure = (struct ES_00041 *) gclosure;

    if (tag == ET [42].tag) {
	    write_char (ostream, closure->mode);
    }
}
static void
ET_00043 PROTO_N ((ostream, tag, gclosure))
         PROTO_T (OStreamP ostream X
                  ETagP    tag X
                  GenericP gclosure)
{
    struct ES_00042 *closure = (struct ES_00042 *) gclosure;

    if (tag == ET [3].tag) {
	    write_cstring (ostream, closure->name);
    }
}
static void
ET_00044 PROTO_N ((ostream, tag, gclosure))
         PROTO_T (OStreamP ostream X
                  ETagP    tag X
                  GenericP gclosure)
{
    struct ES_00043 *closure = (struct ES_00043 *) gclosure;

    if (tag == ET [0].tag) {
	    write_cstring (ostream, closure->file_name);
    } else if (tag == ET [10].tag) {
	    write_unsigned (ostream, closure->byte_number);
    } else if (tag == ET [43].tag) {
	    write_unsigned (ostream, closure->character_size);
    }
}
static void
ET_00045 PROTO_N ((ostream, tag, gclosure))
         PROTO_T (OStreamP ostream X
                  ETagP    tag X
                  GenericP gclosure)
{
    struct ES_00044 *closure = (struct ES_00044 *) gclosure;

    if (tag == ET [0].tag) {
	    write_cstring (ostream, closure->file_name);
    } else if (tag == ET [10].tag) {
	    write_unsigned (ostream, closure->byte_number);
    } else if (tag == ET [44].tag) {
	    write_unsigned (ostream, closure->name_type);
    }
}

void
E_tld_multiple_debug_files PROTO_Z ()
{
    error_call_init_proc ();
    error_report (EE [0].error, ET_00000, NIL (GenericP));
    UNREACHED;
}
void
E_tld_cannot_open_debug_file PROTO_N ((file_name))
                             PROTO_T (CStringP file_name)
{
    struct ES_00000 closure; 

    closure.file_name = file_name;
    error_call_init_proc ();
    error_report (EE [1].error, ET_00001, (GenericP) &closure);
    UNREACHED;
}
void
E_tld_multiple_output_files PROTO_Z ()
{
    error_call_init_proc ();
    error_report (EE [2].error, ET_00000, NIL (GenericP));
    UNREACHED;
}
void
E_tld_multiple_unit_files PROTO_Z ()
{
    error_call_init_proc ();
    error_report (EE [3].error, ET_00000, NIL (GenericP));
    UNREACHED;
}
void
E_multiply_renamed_name PROTO_N ((shape_name, name))
                        PROTO_T (NStringP shape_name X
                                 NameKeyP name)
{
    struct ES_00001 closure; 

    closure.shape_name = shape_name;
    closure.name = name;
    error_call_init_proc ();
    error_report (EE [4].error, ET_00002, (GenericP) &closure);
}
void
E_arg_parse_unknown_option PROTO_N ((option, usage))
                           PROTO_T (CStringP option X
                                    ArgUsageP usage)
{
    struct ES_00002 closure; 

    closure.option = option;
    closure.usage = usage;
    error_call_init_proc ();
    error_report (EE [5].error, ET_00003, (GenericP) &closure);
    UNREACHED;
}
void
E_arg_parse_unknown_short_opt PROTO_N ((option, option_location, usage))
                              PROTO_T (CStringP option X
                                       CStringP option_location X
                                       ArgUsageP usage)
{
    struct ES_00003 closure; 

    closure.option = option;
    closure.option_location = option_location;
    closure.usage = usage;
    error_call_init_proc ();
    error_report (EE [6].error, ET_00004, (GenericP) &closure);
    UNREACHED;
}
void
E_arg_parse_ambiguous_option PROTO_N ((option, usage))
                             PROTO_T (CStringP option X
                                      ArgUsageP usage)
{
    struct ES_00002 closure; 

    closure.option = option;
    closure.usage = usage;
    error_call_init_proc ();
    error_report (EE [7].error, ET_00003, (GenericP) &closure);
    UNREACHED;
}
void
E_arg_parse_missing_argument PROTO_N ((option, usage))
                             PROTO_T (CStringP option X
                                      ArgUsageP usage)
{
    struct ES_00002 closure; 

    closure.option = option;
    closure.usage = usage;
    error_call_init_proc ();
    error_report (EE [8].error, ET_00003, (GenericP) &closure);
    UNREACHED;
}
void
E_arg_parse_missing_short_arg PROTO_N ((option, option_location, usage))
                              PROTO_T (CStringP option X
                                       CStringP option_location X
                                       ArgUsageP usage)
{
    struct ES_00003 closure; 

    closure.option = option;
    closure.option_location = option_location;
    closure.usage = usage;
    error_call_init_proc ();
    error_report (EE [9].error, ET_00004, (GenericP) &closure);
    UNREACHED;
}
void
E_duplicate_capsule_name PROTO_N ((cap_name))
                         PROTO_T (CStringP cap_name)
{
    struct ES_00004 closure; 

    closure.cap_name = cap_name;
    error_call_init_proc ();
    error_report (EE [10].error, ET_00005, (GenericP) &closure);
}
void
E_cannot_open_unit_set_file PROTO_N ((file_name))
                            PROTO_T (CStringP file_name)
{
    struct ES_00000 closure; 

    closure.file_name = file_name;
    error_call_init_proc ();
    error_report (EE [11].error, ET_00001, (GenericP) &closure);
    UNREACHED;
}
void
E_unit_set_expected_quote PROTO_N ((istream))
                          PROTO_T (IStreamP istream)
{
    struct ES_00005 closure; 

	    closure.file_name = istream_name (istream);
	    closure.line_number = istream_line (istream);
    error_call_init_proc ();
    error_report (EE [12].error, ET_00006, (GenericP) &closure);
    UNREACHED;
}
void
E_unit_set_illegal_escape PROTO_N ((istream))
                          PROTO_T (IStreamP istream)
{
    struct ES_00005 closure; 

	    closure.file_name = istream_name (istream);
	    closure.line_number = istream_line (istream);
    error_call_init_proc ();
    error_report (EE [13].error, ET_00006, (GenericP) &closure);
    UNREACHED;
}
void
E_unit_set_eof_in_name PROTO_N ((istream))
                       PROTO_T (IStreamP istream)
{
    struct ES_00005 closure; 

	    closure.file_name = istream_name (istream);
	    closure.line_number = istream_line (istream);
    error_call_init_proc ();
    error_report (EE [14].error, ET_00006, (GenericP) &closure);
    UNREACHED;
}
void
E_unit_set_duplicate_name PROTO_N ((file_name, unit_set_name))
                          PROTO_T (CStringP file_name X
                                   NStringP unit_set_name)
{
    struct ES_00006 closure; 

    closure.file_name = file_name;
    closure.unit_set_name = unit_set_name;
    error_call_init_proc ();
    error_report (EE [15].error, ET_00007, (GenericP) &closure);
    UNREACHED;
}
void
E_unit_set_no_tld_name PROTO_N ((file_name))
                       PROTO_T (CStringP file_name)
{
    struct ES_00007 closure; 

    closure.file_name = file_name;
    error_call_init_proc ();
    error_report (EE [16].error, ET_00008, (GenericP) &closure);
    UNREACHED;
}
void
E_capsule_bad_magic PROTO_N ((capsule, magic_name, proper_magic_name))
                    PROTO_T (CapsuleP capsule X
                             NStringP magic_name X
                             NStringP proper_magic_name)
{
    struct ES_00008 closure; 

	    closure.file_name = capsule_name (capsule);
	    closure.byte_number = capsule_byte (capsule);
    closure.magic_name = magic_name;
    closure.proper_magic_name = proper_magic_name;
    error_call_init_proc ();
    error_report (EE [17].error, ET_00009, (GenericP) &closure);
}
void
E_capsule_bad_version PROTO_N ((capsule, major_version))
                      PROTO_T (CapsuleP capsule X
                               unsigned major_version)
{
    struct ES_00009 closure; 

	    closure.file_name = capsule_name (capsule);
	    closure.byte_number = capsule_byte (capsule);
    closure.major_version = major_version;
    error_call_init_proc ();
    error_report (EE [18].error, ET_00010, (GenericP) &closure);
}
void
E_capsule_version_mismatch PROTO_N ((capsule, major_version, proper_major_version))
                           PROTO_T (CapsuleP capsule X
                                    unsigned major_version X
                                    unsigned proper_major_version)
{
    struct ES_00010 closure; 

	    closure.file_name = capsule_name (capsule);
	    closure.byte_number = capsule_byte (capsule);
    closure.major_version = major_version;
    closure.proper_major_version = proper_major_version;
    error_call_init_proc ();
    error_report (EE [19].error, ET_00011, (GenericP) &closure);
}
void
E_duplicate_unit_set_name PROTO_N ((capsule, unit_set_name))
                          PROTO_T (CapsuleP capsule X
                                   NStringP unit_set_name)
{
    struct ES_00011 closure; 

	    closure.file_name = capsule_name (capsule);
	    closure.byte_number = capsule_byte (capsule);
    closure.unit_set_name = unit_set_name;
    error_call_init_proc ();
    error_report (EE [20].error, ET_00012, (GenericP) &closure);
}
void
E_out_of_order_unit_set_name PROTO_N ((capsule, unit_set_name))
                             PROTO_T (CapsuleP capsule X
                                      NStringP unit_set_name)
{
    struct ES_00011 closure; 

	    closure.file_name = capsule_name (capsule);
	    closure.byte_number = capsule_byte (capsule);
    closure.unit_set_name = unit_set_name;
    error_call_init_proc ();
    error_report (EE [21].error, ET_00012, (GenericP) &closure);
}
void
E_unknown_unit_set_name PROTO_N ((capsule, unit_set_name))
                        PROTO_T (CapsuleP capsule X
                                 NStringP unit_set_name)
{
    struct ES_00011 closure; 

	    closure.file_name = capsule_name (capsule);
	    closure.byte_number = capsule_byte (capsule);
    closure.unit_set_name = unit_set_name;
    error_call_init_proc ();
    error_report (EE [22].error, ET_00012, (GenericP) &closure);
}
void
E_duplicate_shape_name PROTO_N ((capsule, shape_name))
                       PROTO_T (CapsuleP capsule X
                                NStringP shape_name)
{
    struct ES_00012 closure; 

	    closure.file_name = capsule_name (capsule);
	    closure.byte_number = capsule_byte (capsule);
    closure.shape_name = shape_name;
    error_call_init_proc ();
    error_report (EE [23].error, ET_00013, (GenericP) &closure);
}
void
E_shape_and_name_count_mismatch PROTO_N ((capsule, shape_count, name_count))
                                PROTO_T (CapsuleP capsule X
                                         unsigned shape_count X
                                         unsigned name_count)
{
    struct ES_00013 closure; 

	    closure.file_name = capsule_name (capsule);
	    closure.byte_number = capsule_byte (capsule);
    closure.shape_count = shape_count;
    closure.name_count = name_count;
    error_call_init_proc ();
    error_report (EE [24].error, ET_00014, (GenericP) &closure);
}
void
E_name_id_out_of_range PROTO_N ((capsule, shape_name, name, identifier, identifier_limit))
                       PROTO_T (CapsuleP capsule X
                                NStringP shape_name X
                                NameKeyP name X
                                unsigned identifier X
                                unsigned identifier_limit)
{
    struct ES_00014 closure; 

	    closure.file_name = capsule_name (capsule);
	    closure.byte_number = capsule_byte (capsule);
    closure.shape_name = shape_name;
    closure.name = name;
    closure.identifier = identifier;
    closure.identifier_limit = identifier_limit;
    error_call_init_proc ();
    error_report (EE [25].error, ET_00015, (GenericP) &closure);
}
void
E_name_id_used_multiple_times PROTO_N ((capsule, shape_name, name, identifier))
                              PROTO_T (CapsuleP capsule X
                                       NStringP shape_name X
                                       NameKeyP name X
                                       unsigned identifier)
{
    struct ES_00015 closure; 

	    closure.file_name = capsule_name (capsule);
	    closure.byte_number = capsule_byte (capsule);
    closure.shape_name = shape_name;
    closure.name = name;
    closure.identifier = identifier;
    error_call_init_proc ();
    error_report (EE [26].error, ET_00016, (GenericP) &closure);
}
void
E_too_many_tld_units PROTO_N ((capsule))
                     PROTO_T (CapsuleP capsule)
{
    struct ES_00016 closure; 

	    closure.file_name = capsule_name (capsule);
	    closure.byte_number = capsule_byte (capsule);
    error_call_init_proc ();
    error_report (EE [27].error, ET_00017, (GenericP) &closure);
}
void
E_tld2_unit_set_type_obsolete PROTO_N ((capsule))
                              PROTO_T (CapsuleP capsule)
{
    struct ES_00016 closure; 

	    closure.file_name = capsule_name (capsule);
	    closure.byte_number = capsule_byte (capsule);
    error_call_init_proc ();
    error_report (EE [28].error, ET_00017, (GenericP) &closure);
}
void
E_too_many_tld_unit_counts PROTO_N ((capsule))
                           PROTO_T (CapsuleP capsule)
{
    struct ES_00016 closure; 

	    closure.file_name = capsule_name (capsule);
	    closure.byte_number = capsule_byte (capsule);
    error_call_init_proc ();
    error_report (EE [29].error, ET_00017, (GenericP) &closure);
}
void
E_too_many_tld_unit_mappings PROTO_N ((capsule))
                             PROTO_T (CapsuleP capsule)
{
    struct ES_00016 closure; 

	    closure.file_name = capsule_name (capsule);
	    closure.byte_number = capsule_byte (capsule);
    error_call_init_proc ();
    error_report (EE [30].error, ET_00017, (GenericP) &closure);
}
void
E_tld_unit_wrong_size PROTO_N ((capsule, correct_offset, offset))
                      PROTO_T (CapsuleP capsule X
                               unsigned correct_offset X
                               unsigned offset)
{
    struct ES_00017 closure; 

	    closure.file_name = capsule_name (capsule);
	    closure.byte_number = capsule_byte (capsule);
    closure.correct_offset = correct_offset;
    closure.offset = offset;
    error_call_init_proc ();
    error_report (EE [31].error, ET_00018, (GenericP) &closure);
}
void
E_unknown_tld_unit_type PROTO_N ((capsule, version_number))
                        PROTO_T (CapsuleP capsule X
                                 unsigned version_number)
{
    struct ES_00018 closure; 

	    closure.file_name = capsule_name (capsule);
	    closure.byte_number = capsule_byte (capsule);
    closure.version_number = version_number;
    error_call_init_proc ();
    error_report (EE [32].error, ET_00019, (GenericP) &closure);
}
void
E_unit_set_count_mismatch PROTO_N ((capsule, unit_set_count, unit_count))
                          PROTO_T (CapsuleP capsule X
                                   unsigned unit_set_count X
                                   unsigned unit_count)
{
    struct ES_00019 closure; 

	    closure.file_name = capsule_name (capsule);
	    closure.byte_number = capsule_byte (capsule);
    closure.unit_set_count = unit_set_count;
    closure.unit_count = unit_count;
    error_call_init_proc ();
    error_report (EE [33].error, ET_00020, (GenericP) &closure);
}
void
E_missing_tld_unit_set PROTO_N ((file_name))
                       PROTO_T (CStringP file_name)
{
    struct ES_00007 closure; 

    closure.file_name = file_name;
    error_call_init_proc ();
    error_report (EE [34].error, ET_00008, (GenericP) &closure);
}
void
E_extra_tld_unit_set PROTO_N ((capsule))
                     PROTO_T (CapsuleP capsule)
{
    struct ES_00016 closure; 

	    closure.file_name = capsule_name (capsule);
	    closure.byte_number = capsule_byte (capsule);
    error_call_init_proc ();
    error_report (EE [35].error, ET_00017, (GenericP) &closure);
}
void
E_defined_but_not_declared PROTO_N ((capsule, shape_name, name))
                           PROTO_T (CapsuleP capsule X
                                    NStringP shape_name X
                                    NameKeyP name)
{
    struct ES_00020 closure; 

	    closure.file_name = capsule_name (capsule);
	    closure.byte_number = capsule_byte (capsule);
    closure.shape_name = shape_name;
    closure.name = name;
    error_call_init_proc ();
    error_report (EE [36].error, ET_00021, (GenericP) &closure);
}
void
E_illegally_multiply_defined PROTO_N ((capsule, shape_name, name))
                             PROTO_T (CapsuleP capsule X
                                      NStringP shape_name X
                                      NameKeyP name)
{
    struct ES_00020 closure; 

	    closure.file_name = capsule_name (capsule);
	    closure.byte_number = capsule_byte (capsule);
    closure.shape_name = shape_name;
    closure.name = name;
    error_call_init_proc ();
    error_report (EE [37].error, ET_00021, (GenericP) &closure);
}
void
E_bad_usage PROTO_N ((capsule, shape_name, name, usage))
            PROTO_T (CapsuleP capsule X
                     NStringP shape_name X
                     NameKeyP name X
                     unsigned usage)
{
    struct ES_00021 closure; 

	    closure.file_name = capsule_name (capsule);
	    closure.byte_number = capsule_byte (capsule);
    closure.shape_name = shape_name;
    closure.name = name;
    closure.usage = usage;
    error_call_init_proc ();
    error_report (EE [38].error, ET_00022, (GenericP) &closure);
}
void
E_multiply_defined PROTO_N ((capsule, shape_name, name, previous_file_name))
                   PROTO_T (CapsuleP capsule X
                            NStringP shape_name X
                            NameKeyP name X
                            CStringP previous_file_name)
{
    struct ES_00022 closure; 

	    closure.file_name = capsule_name (capsule);
	    closure.byte_number = capsule_byte (capsule);
    closure.shape_name = shape_name;
    closure.name = name;
    closure.previous_file_name = previous_file_name;
    error_call_init_proc ();
    error_report (EE [39].error, ET_00023, (GenericP) &closure);
}
void
E_unit_count_num_mismatch PROTO_N ((capsule, count_number, shape_number, unit_number, unit_set_name))
                          PROTO_T (CapsuleP capsule X
                                   unsigned count_number X
                                   unsigned shape_number X
                                   unsigned unit_number X
                                   NStringP unit_set_name)
{
    struct ES_00023 closure; 

	    closure.file_name = capsule_name (capsule);
	    closure.byte_number = capsule_byte (capsule);
    closure.count_number = count_number;
    closure.shape_number = shape_number;
    closure.unit_number = unit_number;
    closure.unit_set_name = unit_set_name;
    error_call_init_proc ();
    error_report (EE [40].error, ET_00024, (GenericP) &closure);
}
void
E_unit_mapping_num_mismatch PROTO_N ((capsule, mapping_number, count_number, unit_number, unit_set_name))
                            PROTO_T (CapsuleP capsule X
                                     unsigned mapping_number X
                                     unsigned count_number X
                                     unsigned unit_number X
                                     NStringP unit_set_name)
{
    struct ES_00024 closure; 

	    closure.file_name = capsule_name (capsule);
	    closure.byte_number = capsule_byte (capsule);
    closure.mapping_number = mapping_number;
    closure.count_number = count_number;
    closure.unit_number = unit_number;
    closure.unit_set_name = unit_set_name;
    error_call_init_proc ();
    error_report (EE [41].error, ET_00025, (GenericP) &closure);
}
void
E_id_out_of_range PROTO_N ((capsule, identifier, identifier_limit, shape_name, unit_number, unit_set_name))
                  PROTO_T (CapsuleP capsule X
                           unsigned identifier X
                           unsigned identifier_limit X
                           NStringP shape_name X
                           unsigned unit_number X
                           NStringP unit_set_name)
{
    struct ES_00025 closure; 

	    closure.file_name = capsule_name (capsule);
	    closure.byte_number = capsule_byte (capsule);
    closure.identifier = identifier;
    closure.identifier_limit = identifier_limit;
    closure.shape_name = shape_name;
    closure.unit_number = unit_number;
    closure.unit_set_name = unit_set_name;
    error_call_init_proc ();
    error_report (EE [42].error, ET_00026, (GenericP) &closure);
}
void
E_too_many_library_files PROTO_Z ()
{
    error_call_init_proc ();
    error_report (EE [43].error, ET_00000, NIL (GenericP));
    UNREACHED;
}
void
E_errf_null_char_in_builtin PROTO_N ((istream))
                            PROTO_T (IStreamP istream)
{
    struct ES_00005 closure; 

	    closure.file_name = istream_name (istream);
	    closure.line_number = istream_line (istream);
    error_call_init_proc ();
    error_report (EE [44].error, ET_00006, (GenericP) &closure);
    UNREACHED;
}
void
E_errf_null_character_in_name PROTO_N ((istream))
                              PROTO_T (IStreamP istream)
{
    struct ES_00005 closure; 

	    closure.file_name = istream_name (istream);
	    closure.line_number = istream_line (istream);
    error_call_init_proc ();
    error_report (EE [45].error, ET_00006, (GenericP) &closure);
    UNREACHED;
}
void
E_errf_null_character_in_string PROTO_N ((istream))
                                PROTO_T (IStreamP istream)
{
    struct ES_00005 closure; 

	    closure.file_name = istream_name (istream);
	    closure.line_number = istream_line (istream);
    error_call_init_proc ();
    error_report (EE [46].error, ET_00006, (GenericP) &closure);
    UNREACHED;
}
void
E_errf_newline_in_builtin PROTO_N ((istream))
                          PROTO_T (IStreamP istream)
{
    struct ES_00005 closure; 

	    closure.file_name = istream_name (istream);
	    closure.line_number = istream_line (istream);
    error_call_init_proc ();
    error_report (EE [47].error, ET_00006, (GenericP) &closure);
    UNREACHED;
}
void
E_errf_newline_in_name PROTO_N ((istream))
                       PROTO_T (IStreamP istream)
{
    struct ES_00005 closure; 

	    closure.file_name = istream_name (istream);
	    closure.line_number = istream_line (istream);
    error_call_init_proc ();
    error_report (EE [48].error, ET_00006, (GenericP) &closure);
    UNREACHED;
}
void
E_errf_newline_in_string PROTO_N ((istream))
                         PROTO_T (IStreamP istream)
{
    struct ES_00005 closure; 

	    closure.file_name = istream_name (istream);
	    closure.line_number = istream_line (istream);
    error_call_init_proc ();
    error_report (EE [49].error, ET_00006, (GenericP) &closure);
    UNREACHED;
}
void
E_errf_eof_in_builtin PROTO_N ((istream))
                      PROTO_T (IStreamP istream)
{
    struct ES_00005 closure; 

	    closure.file_name = istream_name (istream);
	    closure.line_number = istream_line (istream);
    error_call_init_proc ();
    error_report (EE [50].error, ET_00006, (GenericP) &closure);
    UNREACHED;
}
void
E_errf_eof_in_name PROTO_N ((istream))
                   PROTO_T (IStreamP istream)
{
    struct ES_00005 closure; 

	    closure.file_name = istream_name (istream);
	    closure.line_number = istream_line (istream);
    error_call_init_proc ();
    error_report (EE [51].error, ET_00006, (GenericP) &closure);
    UNREACHED;
}
void
E_errf_eof_in_string PROTO_N ((istream))
                     PROTO_T (IStreamP istream)
{
    struct ES_00005 closure; 

	    closure.file_name = istream_name (istream);
	    closure.line_number = istream_line (istream);
    error_call_init_proc ();
    error_report (EE [52].error, ET_00006, (GenericP) &closure);
    UNREACHED;
}
void
E_errf_illegal_esc_in_builtin PROTO_N ((istream))
                              PROTO_T (IStreamP istream)
{
    struct ES_00005 closure; 

	    closure.file_name = istream_name (istream);
	    closure.line_number = istream_line (istream);
    error_call_init_proc ();
    error_report (EE [53].error, ET_00006, (GenericP) &closure);
    UNREACHED;
}
void
E_errf_illegal_escape_in_name PROTO_N ((istream))
                              PROTO_T (IStreamP istream)
{
    struct ES_00005 closure; 

	    closure.file_name = istream_name (istream);
	    closure.line_number = istream_line (istream);
    error_call_init_proc ();
    error_report (EE [54].error, ET_00006, (GenericP) &closure);
    UNREACHED;
}
void
E_errf_illegal_escape_in_string PROTO_N ((istream))
                                PROTO_T (IStreamP istream)
{
    struct ES_00005 closure; 

	    closure.file_name = istream_name (istream);
	    closure.line_number = istream_line (istream);
    error_call_init_proc ();
    error_report (EE [55].error, ET_00006, (GenericP) &closure);
    UNREACHED;
}
void
E_errf_unknown_builtin PROTO_N ((istream, builtin_name))
                       PROTO_T (IStreamP istream X
                                CStringP builtin_name)
{
    struct ES_00026 closure; 

	    closure.file_name = istream_name (istream);
	    closure.line_number = istream_line (istream);
    closure.builtin_name = builtin_name;
    error_call_init_proc ();
    error_report (EE [56].error, ET_00027, (GenericP) &closure);
    UNREACHED;
}
void
E_errf_illegal_character PROTO_N ((istream, character))
                         PROTO_T (IStreamP istream X
                                  char character)
{
    struct ES_00027 closure; 

	    closure.file_name = istream_name (istream);
	    closure.line_number = istream_line (istream);
    closure.character = character;
    error_call_init_proc ();
    error_report (EE [57].error, ET_00028, (GenericP) &closure);
    UNREACHED;
}
void
E_errf_expected_string PROTO_N ((istream))
                       PROTO_T (IStreamP istream)
{
    struct ES_00005 closure; 

	    closure.file_name = istream_name (istream);
	    closure.line_number = istream_line (istream);
    error_call_init_proc ();
    error_report (EE [58].error, ET_00006, (GenericP) &closure);
    UNREACHED;
}
void
E_errf_expected_section PROTO_N ((istream))
                        PROTO_T (IStreamP istream)
{
    struct ES_00005 closure; 

	    closure.file_name = istream_name (istream);
	    closure.line_number = istream_line (istream);
    error_call_init_proc ();
    error_report (EE [59].error, ET_00006, (GenericP) &closure);
    UNREACHED;
}
void
E_errf_unknown_string PROTO_N ((istream, string_name))
                      PROTO_T (IStreamP istream X
                               CStringP string_name)
{
    struct ES_00028 closure; 

	    closure.file_name = istream_name (istream);
	    closure.line_number = istream_line (istream);
    closure.string_name = string_name;
    error_call_init_proc ();
    error_report (EE [60].error, ET_00029, (GenericP) &closure);
    UNREACHED;
}
void
E_errf_unknown_error PROTO_N ((istream, error_name))
                     PROTO_T (IStreamP istream X
                              CStringP error_name)
{
    struct ES_00029 closure; 

	    closure.file_name = istream_name (istream);
	    closure.line_number = istream_line (istream);
    closure.error_name = error_name;
    error_call_init_proc ();
    error_report (EE [61].error, ET_00030, (GenericP) &closure);
    UNREACHED;
}
void
E_errf_illegal_message PROTO_N ((istream, message))
                       PROTO_T (IStreamP istream X
                                CStringP message)
{
    struct ES_00030 closure; 

	    closure.file_name = istream_name (istream);
	    closure.line_number = istream_line (istream);
    closure.message = message;
    error_call_init_proc ();
    error_report (EE [62].error, ET_00031, (GenericP) &closure);
    UNREACHED;
}
void
E_errf_cannot_open PROTO_N ((file_name))
                   PROTO_T (CStringP file_name)
{
    struct ES_00000 closure; 

    closure.file_name = file_name;
    error_call_init_proc ();
    error_report (EE [63].error, ET_00001, (GenericP) &closure);
    UNREACHED;
}
void
E_all_specified_with_capsules PROTO_Z ()
{
    error_call_init_proc ();
    error_report (EE [64].error, ET_00000, NIL (GenericP));
    UNREACHED;
}
void
E_no_capsules_specified PROTO_Z ()
{
    error_call_init_proc ();
    error_report (EE [65].error, ET_00000, NIL (GenericP));
    UNREACHED;
}
void
E_exception_unhandled PROTO_N ((except_name, file_name, line_number))
                      PROTO_T (ExceptionP except_name X
                               CStringP file_name X
                               unsigned line_number)
{
    struct ES_00031 closure; 

    closure.except_name = except_name;
    closure.file_name = file_name;
    closure.line_number = line_number;
    error_call_init_proc ();
    error_report (EE [66].error, ET_00032, (GenericP) &closure);
    UNREACHED;
}
void
E_exception_corrupt_handler PROTO_N ((file_name, line_number))
                            PROTO_T (CStringP file_name X
                                     unsigned line_number)
{
    struct ES_00005 closure; 

    closure.file_name = file_name;
    closure.line_number = line_number;
    error_call_init_proc ();
    error_report (EE [67].error, ET_00006, (GenericP) &closure);
    UNREACHED;
}
void
E_assertion_failed PROTO_N ((assertion, file_name, line_number))
                   PROTO_T (CStringP assertion X
                            CStringP file_name X
                            unsigned line_number)
{
    struct ES_00032 closure; 

    closure.assertion = assertion;
    closure.file_name = file_name;
    closure.line_number = line_number;
    error_call_init_proc ();
    error_report (EE [68].error, ET_00033, (GenericP) &closure);
    UNREACHED;
}
void
E_dalloc_multi_deallocate PROTO_N ((block_address, file_name, line_number, allocation_file_name, allocation_line_number))
                          PROTO_T (GenericP block_address X
                                   CStringP file_name X
                                   unsigned line_number X
                                   CStringP allocation_file_name X
                                   unsigned allocation_line_number)
{
    struct ES_00033 closure; 

    closure.block_address = block_address;
    closure.file_name = file_name;
    closure.line_number = line_number;
    closure.allocation_file_name = allocation_file_name;
    closure.allocation_line_number = allocation_line_number;
    error_call_init_proc ();
    error_report (EE [69].error, ET_00034, (GenericP) &closure);
    UNREACHED;
}
void
E_dalloc_corrupt_block PROTO_N ((block_address, file_name, line_number))
                       PROTO_T (GenericP block_address X
                                CStringP file_name X
                                unsigned line_number)
{
    struct ES_00034 closure; 

    closure.block_address = block_address;
    closure.file_name = file_name;
    closure.line_number = line_number;
    error_call_init_proc ();
    error_report (EE [70].error, ET_00035, (GenericP) &closure);
    UNREACHED;
}
void
E_library_bad_magic PROTO_N ((library, magic_name, proper_magic_name))
                    PROTO_T (LibraryP library X
                             NStringP magic_name X
                             NStringP proper_magic_name)
{
    struct ES_00008 closure; 

	    closure.file_name = library_name (library);
	    closure.byte_number = library_byte (library);
    closure.magic_name = magic_name;
    closure.proper_magic_name = proper_magic_name;
    error_call_init_proc ();
    error_report (EE [71].error, ET_00009, (GenericP) &closure);
}
void
E_library_bad_version PROTO_N ((library, major_version))
                      PROTO_T (LibraryP library X
                               unsigned major_version)
{
    struct ES_00009 closure; 

	    closure.file_name = library_name (library);
	    closure.byte_number = library_byte (library);
    closure.major_version = major_version;
    error_call_init_proc ();
    error_report (EE [72].error, ET_00010, (GenericP) &closure);
}
void
E_library_version_mismatch PROTO_N ((library, major_version, proper_major_version))
                           PROTO_T (LibraryP library X
                                    unsigned major_version X
                                    unsigned proper_major_version)
{
    struct ES_00010 closure; 

	    closure.file_name = library_name (library);
	    closure.byte_number = library_byte (library);
    closure.major_version = major_version;
    closure.proper_major_version = proper_major_version;
    error_call_init_proc ();
    error_report (EE [73].error, ET_00011, (GenericP) &closure);
}
void
E_null_in_file_name PROTO_N ((library, cap_name))
                    PROTO_T (LibraryP library X
                             NStringP cap_name)
{
    struct ES_00035 closure; 

	    closure.file_name = library_name (library);
	    closure.byte_number = library_byte (library);
    closure.cap_name = cap_name;
    error_call_init_proc ();
    error_report (EE [74].error, ET_00036, (GenericP) &closure);
}
void
E_capsule_not_found PROTO_N ((cap_name, lib_name))
                    PROTO_T (CStringP cap_name X
                             CStringP lib_name)
{
    struct ES_00036 closure; 

    closure.cap_name = cap_name;
    closure.lib_name = lib_name;
    error_call_init_proc ();
    error_report (EE [75].error, ET_00037, (GenericP) &closure);
}
void
E_extracting_capsule PROTO_N ((cap_name, file_name))
                     PROTO_T (CStringP cap_name X
                              CStringP file_name)
{
    struct ES_00037 closure; 

    closure.cap_name = cap_name;
    closure.file_name = file_name;
    error_call_init_proc ();
    error_report (EE [76].error, ET_00038, (GenericP) &closure);
}
void
E_lib_unknown_type PROTO_N ((library, version_number))
                   PROTO_T (LibraryP library X
                            unsigned version_number)
{
    struct ES_00018 closure; 

	    closure.file_name = library_name (library);
	    closure.byte_number = library_byte (library);
    closure.version_number = version_number;
    error_call_init_proc ();
    error_report (EE [77].error, ET_00019, (GenericP) &closure);
}
void
E_lib_defined_but_not_declared PROTO_N ((library, shape_name, name))
                               PROTO_T (LibraryP library X
                                        NStringP shape_name X
                                        NameKeyP name)
{
    struct ES_00020 closure; 

	    closure.file_name = library_name (library);
	    closure.byte_number = library_byte (library);
    closure.shape_name = shape_name;
    closure.name = name;
    error_call_init_proc ();
    error_report (EE [78].error, ET_00021, (GenericP) &closure);
}
void
E_lib_illegally_mult_defined PROTO_N ((library, shape_name, name))
                             PROTO_T (LibraryP library X
                                      NStringP shape_name X
                                      NameKeyP name)
{
    struct ES_00020 closure; 

	    closure.file_name = library_name (library);
	    closure.byte_number = library_byte (library);
    closure.shape_name = shape_name;
    closure.name = name;
    error_call_init_proc ();
    error_report (EE [79].error, ET_00021, (GenericP) &closure);
}
void
E_lib_bad_usage PROTO_N ((library, shape_name, name, usage))
                PROTO_T (LibraryP library X
                         NStringP shape_name X
                         NameKeyP name X
                         unsigned usage)
{
    struct ES_00021 closure; 

	    closure.file_name = library_name (library);
	    closure.byte_number = library_byte (library);
    closure.shape_name = shape_name;
    closure.name = name;
    closure.usage = usage;
    error_call_init_proc ();
    error_report (EE [80].error, ET_00022, (GenericP) &closure);
}
void
E_lib_multiply_defined PROTO_N ((library, shape_name, name, previous_file_name))
                       PROTO_T (LibraryP library X
                                NStringP shape_name X
                                NameKeyP name X
                                LibCapsuleP previous_file_name)
{
    struct ES_00038 closure; 

	    closure.file_name = library_name (library);
	    closure.byte_number = library_byte (library);
    closure.shape_name = shape_name;
    closure.name = name;
    closure.previous_file_name = previous_file_name;
    error_call_init_proc ();
    error_report (EE [81].error, ET_00039, (GenericP) &closure);
}
void
E_capsule_index_too_big PROTO_N ((library, shape_name, name, capsule_index, num_capsules))
                        PROTO_T (LibraryP library X
                                 NStringP shape_name X
                                 NameKeyP name X
                                 unsigned capsule_index X
                                 unsigned num_capsules)
{
    struct ES_00039 closure; 

	    closure.file_name = library_name (library);
	    closure.byte_number = library_byte (library);
    closure.shape_name = shape_name;
    closure.name = name;
    closure.capsule_index = capsule_index;
    closure.num_capsules = num_capsules;
    error_call_init_proc ();
    error_report (EE [82].error, ET_00040, (GenericP) &closure);
}
void
E_cannot_hide_shape PROTO_N ((shape_name))
                    PROTO_T (NStringP shape_name)
{
    struct ES_00040 closure; 

    closure.shape_name = shape_name;
    error_call_init_proc ();
    error_report (EE [83].error, ET_00041, (GenericP) &closure);
}
void
E_cannot_hide PROTO_N ((shape_name, name))
              PROTO_T (NStringP shape_name X
                       NameKeyP name)
{
    struct ES_00001 closure; 

    closure.shape_name = shape_name;
    closure.name = name;
    error_call_init_proc ();
    error_report (EE [84].error, ET_00002, (GenericP) &closure);
}
void
E_cannot_hide_undefined PROTO_N ((shape_name, name))
                        PROTO_T (NStringP shape_name X
                                 NameKeyP name)
{
    struct ES_00001 closure; 

    closure.shape_name = shape_name;
    closure.name = name;
    error_call_init_proc ();
    error_report (EE [85].error, ET_00002, (GenericP) &closure);
}
void
E_cannot_keep_shape PROTO_N ((shape_name))
                    PROTO_T (NStringP shape_name)
{
    struct ES_00040 closure; 

    closure.shape_name = shape_name;
    error_call_init_proc ();
    error_report (EE [86].error, ET_00041, (GenericP) &closure);
}
void
E_cannot_keep PROTO_N ((shape_name, name))
              PROTO_T (NStringP shape_name X
                       NameKeyP name)
{
    struct ES_00001 closure; 

    closure.shape_name = shape_name;
    closure.name = name;
    error_call_init_proc ();
    error_report (EE [87].error, ET_00002, (GenericP) &closure);
}
void
E_bad_mode PROTO_N ((mode))
           PROTO_T (char mode)
{
    struct ES_00041 closure; 

    closure.mode = mode;
    error_call_init_proc ();
    error_report (EE [88].error, ET_00042, (GenericP) &closure);
    UNREACHED;
}
void
E_missing_files PROTO_Z ()
{
    error_call_init_proc ();
    error_report (EE [89].error, ET_00000, NIL (GenericP));
    UNREACHED;
}
void
E_no_memory PROTO_Z ()
{
    error_call_init_proc ();
    error_report (EE [90].error, ET_00000, NIL (GenericP));
    UNREACHED;
}
void
E_read_error PROTO_N ((file_name))
             PROTO_T (CStringP file_name)
{
    struct ES_00000 closure; 

    closure.file_name = file_name;
    error_call_init_proc ();
    error_report (EE [91].error, ET_00001, (GenericP) &closure);
    UNREACHED;
}
void
E_write_error PROTO_N ((file_name))
              PROTO_T (CStringP file_name)
{
    struct ES_00000 closure; 

    closure.file_name = file_name;
    error_call_init_proc ();
    error_report (EE [92].error, ET_00001, (GenericP) &closure);
    UNREACHED;
}
void
E_cannot_open_input_file PROTO_N ((file_name))
                         PROTO_T (CStringP file_name)
{
    struct ES_00000 closure; 

    closure.file_name = file_name;
    error_call_init_proc ();
    error_report (EE [93].error, ET_00001, (GenericP) &closure);
}
void
E_cannot_open_output_file PROTO_N ((file_name))
                          PROTO_T (CStringP file_name)
{
    struct ES_00000 closure; 

    closure.file_name = file_name;
    error_call_init_proc ();
    error_report (EE [94].error, ET_00001, (GenericP) &closure);
    UNREACHED;
}
void
E_cannot_open_library_file PROTO_N ((file_name))
                           PROTO_T (CStringP file_name)
{
    struct ES_00000 closure; 

    closure.file_name = file_name;
    error_call_init_proc ();
    error_report (EE [95].error, ET_00001, (GenericP) &closure);
}
void
E_illegal_external_name PROTO_N ((name))
                        PROTO_T (CStringP name)
{
    struct ES_00042 closure; 

    closure.name = name;
    error_call_init_proc ();
    error_report (EE [96].error, ET_00043, (GenericP) &closure);
}
void
E_no_single_definition PROTO_N ((shape_name, name))
                       PROTO_T (NStringP shape_name X
                                NameKeyP name)
{
    struct ES_00001 closure; 

    closure.shape_name = shape_name;
    closure.name = name;
    error_call_init_proc ();
    error_report (EE [97].error, ET_00002, (GenericP) &closure);
    UNREACHED;
}
void
E_rename_cycle PROTO_N ((shape_name, name))
               PROTO_T (NStringP shape_name X
                        NameKeyP name)
{
    struct ES_00001 closure; 

    closure.shape_name = shape_name;
    closure.name = name;
    error_call_init_proc ();
    error_report (EE [98].error, ET_00002, (GenericP) &closure);
}
void
E_no_definition_found PROTO_N ((shape_name, name))
                      PROTO_T (NStringP shape_name X
                               NameKeyP name)
{
    struct ES_00001 closure; 

    closure.shape_name = shape_name;
    closure.name = name;
    error_call_init_proc ();
    error_report (EE [99].error, ET_00002, (GenericP) &closure);
}
void
E_cannot_open_rename_file PROTO_N ((file_name))
                          PROTO_T (CStringP file_name)
{
    struct ES_00000 closure; 

    closure.file_name = file_name;
    error_call_init_proc ();
    error_report (EE [100].error, ET_00001, (GenericP) &closure);
}
void
E_rename_expected_shape PROTO_N ((istream))
                        PROTO_T (IStreamP istream)
{
    struct ES_00005 closure; 

	    closure.file_name = istream_name (istream);
	    closure.line_number = istream_line (istream);
    error_call_init_proc ();
    error_report (EE [101].error, ET_00006, (GenericP) &closure);
}
void
E_rename_expected_name PROTO_N ((istream))
                       PROTO_T (IStreamP istream)
{
    struct ES_00005 closure; 

	    closure.file_name = istream_name (istream);
	    closure.line_number = istream_line (istream);
    error_call_init_proc ();
    error_report (EE [102].error, ET_00006, (GenericP) &closure);
}
void
E_rename_expected_semi PROTO_N ((istream))
                       PROTO_T (IStreamP istream)
{
    struct ES_00005 closure; 

	    closure.file_name = istream_name (istream);
	    closure.line_number = istream_line (istream);
    error_call_init_proc ();
    error_report (EE [103].error, ET_00006, (GenericP) &closure);
}
void
E_rename_unexpected_eof PROTO_N ((istream))
                        PROTO_T (IStreamP istream)
{
    struct ES_00005 closure; 

	    closure.file_name = istream_name (istream);
	    closure.line_number = istream_line (istream);
    error_call_init_proc ();
    error_report (EE [104].error, ET_00006, (GenericP) &closure);
}
void
E_rename_unexpected_newline PROTO_N ((istream))
                            PROTO_T (IStreamP istream)
{
    struct ES_00005 closure; 

	    closure.file_name = istream_name (istream);
	    closure.line_number = istream_line (istream);
    error_call_init_proc ();
    error_report (EE [105].error, ET_00006, (GenericP) &closure);
}
void
E_rename_illegal_escape PROTO_N ((istream))
                        PROTO_T (IStreamP istream)
{
    struct ES_00005 closure; 

	    closure.file_name = istream_name (istream);
	    closure.line_number = istream_line (istream);
    error_call_init_proc ();
    error_report (EE [106].error, ET_00006, (GenericP) &closure);
}
void
E_rename_illegal_char PROTO_N ((istream, character))
                      PROTO_T (IStreamP istream X
                               char character)
{
    struct ES_00027 closure; 

	    closure.file_name = istream_name (istream);
	    closure.line_number = istream_line (istream);
    closure.character = character;
    error_call_init_proc ();
    error_report (EE [107].error, ET_00028, (GenericP) &closure);
}
void
E_too_many_ids PROTO_Z ()
{
    error_call_init_proc ();
    error_report (EE [108].error, ET_00000, NIL (GenericP));
    UNREACHED;
}
void
E_unexpected_eof_in_tdf PROTO_N ((reader))
                        PROTO_T (TDFReaderP reader)
{
    struct ES_00016 closure; 

	    closure.file_name = tdf_reader_name (reader);
	    closure.byte_number = tdf_reader_byte (reader);
    error_call_init_proc ();
    error_report (EE [109].error, ET_00017, (GenericP) &closure);
}
void
E_tdf_integer_too_big_in_tdf PROTO_N ((reader))
                             PROTO_T (TDFReaderP reader)
{
    struct ES_00016 closure; 

	    closure.file_name = tdf_reader_name (reader);
	    closure.byte_number = tdf_reader_byte (reader);
    error_call_init_proc ();
    error_report (EE [110].error, ET_00017, (GenericP) &closure);
}
void
E_unsupported_char_size_in_tdf PROTO_N ((reader, character_size))
                               PROTO_T (TDFReaderP reader X
                                        unsigned character_size)
{
    struct ES_00043 closure; 

	    closure.file_name = tdf_reader_name (reader);
	    closure.byte_number = tdf_reader_byte (reader);
    closure.character_size = character_size;
    error_call_init_proc ();
    error_report (EE [111].error, ET_00044, (GenericP) &closure);
}
void
E_bad_name_type_in_tdf PROTO_N ((reader, name_type))
                       PROTO_T (TDFReaderP reader X
                                unsigned name_type)
{
    struct ES_00044 closure; 

	    closure.file_name = tdf_reader_name (reader);
	    closure.byte_number = tdf_reader_byte (reader);
    closure.name_type = name_type;
    error_call_init_proc ();
    error_report (EE [112].error, ET_00045, (GenericP) &closure);
}
void
E_expected_eof_in_tdf PROTO_N ((reader))
                      PROTO_T (TDFReaderP reader)
{
    struct ES_00016 closure; 

	    closure.file_name = tdf_reader_name (reader);
	    closure.byte_number = tdf_reader_byte (reader);
    error_call_init_proc ();
    error_report (EE [113].error, ET_00017, (GenericP) &closure);
}

void
gen_errors_init_errors PROTO_Z ()
{
    error_intern_tags (ET);
    error_intern_errors (EE);
}
