/*
 * Copyright (c) 2004, The Tendra Project <http://www.ten15.org/>
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice unmodified, this list of conditions, and the following
 *    disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $TenDRA$
 */


GLOBALS:
	fileline: fileline

ENTRIES:

name_already_defined_at(ccp: name, ccp: nm, ccp: fn, unsigned: line)
{
	USAGE: ERROR
	KEY(STD) fileline name" '"nm"' already defined ("fn", line "line")"
}

name_already_defined(ccp: name, ccp: nm)
{
	USAGE: ERROR
	KEY(STD) fileline name" '"nm"' already defined"
}

unknown_type_identifier(int: id)
{
	USAGE: FATAL
	KEY(STD) fileline"Unknown type identifier, '"id"'"
}

unknown_object_type(int: objtype)
{
	USAGE: FATAL
	KEY(STD) fileline"Unknown object type, '"objtype"'"
}

identifier_too_long()
{
	USAGE: ERROR
	KEY(STD) fileline"Identifier too long"
}

unknown_command(ccp: cmd)
{
	USAGE: ERROR
	KEY(STD) fileline"Unknown command, '"cmd"'"
}

number_too_long()
{
	USAGE: ERROR
	KEY(STD) fileline"Number too long"
}

new_line_in_string()
{
	USAGE: ERROR
	KEY(STD) fileline"New line in string"
}

string_too_long()
{
	USAGE: ERROR
	KEY(STD) fileline"String too long"
}

insert_too_long()
{
	USAGE: ERROR
	KEY(STD) fileline"Insert too long"
}

end_of_file_in_quoted_text()
{
	USAGE: ERROR
	KEY(STD) fileline"End of file in quoted text"
}

end_of_file_in_comment()
{
	USAGE: ERROR
	KEY(STD) fileline"End of file in comment"
}

comment_too_long()
{
	USAGE: ERROR
	KEY(STD) fileline"Comment too long"
}

string_expected()
{
	USAGE: ERROR
	KEY(STD) fileline"Syntax error - string expected"
}

close_round_expected()
{
	USAGE: ERROR
	KEY(STD) fileline"Syntax error - ')' expected"
}

illegally_bracketed_string()
{
	USAGE: ERROR
	KEY(STD) fileline"Illegally bracketed string"
}

semicolon_or_open_round_expected()
{
	USAGE: ERROR
	KEY(STD) fileline"';' or '(' expected"
}

recursive_inclusion(ccp: sn)
{
	USAGE: ERROR
	KEY(STD) fileline"Recursive inclusion of '"sn"'"
}

set_not_found(ccp: sn)
{
	USAGE: ERROR
	KEY(STD) fileline"Set '%s' not found"
}

set_not_found_no_file(ccp: sn, ccp: file)
{
	USAGE: ERROR
	KEY(STD) fileline"Set '"sn"' not found (can't find file "file")"
}

assign_expected()
{
	USAGE: ERROR
	KEY(STD) fileline"Syntax error - ':=' expected"
}

open_hbrace_expected()
{
	USAGE: ERROR
	KEY(STD) fileline"Syntax error - '{' expected"
}

cant_find_end_of_subset(ccp: subset)
{
	USAGE: ERROR
	KEY(STD) fileline"Can't find end of subset '"subset"'"
}

semicolon_expected()
{
	USAGE: ERROR
	KEY(STD) fileline"Syntax error - ';' expected"
}

set_already_defined_at(ccp: setname, int: line)
{
	USAGE: ERROR
	KEY(STD) fileline"Set '"setname"' already defined (line "line")"
}

pset_directive_in_preprocessor()
{
	USAGE: ERROR
	KEY(STD) fileline"+SET directive in preprocessor"
}

pelse_without_pif()
{
	USAGE: ERROR
	KEY(STD) fileline"+ELSE without +IF"
}

duplicate_pelse()
{
	USAGE: ERROR
	KEY(STD) fileline"Duplicate +ELSE"
}

pendif_without_pif()
{
	USAGE: ERROR
	KEY(STD) fileline"+ENDIF without +IF"
}

unmatched_close_hbrace()
{
	USAGE: ERROR
	KEY(STD) fileline"Unmatched '}'"
}

bracket_imbalance_of(int: brackets)
{
	USAGE: ERROR
	KEY(STD) fileline"Bracket imbalance of %d"
}

pif_without_pendif()
{
	USAGE: ERROR
	KEY(STD) fileline"+IF without +ENDIF"
}

set_not_found_no_subset(ccp: setname, ccp: subset)
{
	USAGE: ERROR
	KEY(STD) fileline"Set '"setname"' not found (can't find subset '"subset"')"
}

separate_compilation_failed(ccp: name)
{
	USAGE: ERROR
	KEY(STD) fileline"Separate compilation of "name" failed"
}

cant_open_temporary_file()
{
	USAGE: FATAL
	KEY(STD) "Can't open temporary file"
}

errors_in_preprocessor_phase(int: n)
{
	USAGE: FATAL
	KEY(STD) fileline n" error(s) in preprocessor phase"
}

errors_in_separate_compilation(int: n)
{
	USAGE: FATAL
	KEY(STD) fileline n" error(s) in separate compilation"
}

errors_in_analyser_phase(int: n)
{
	USAGE: FATAL
	KEY(STD) fileline n" error(s) in analyser phase"
}

duplicate_type_specifier()
{
	USAGE: ERROR
	KEY(STD) fileline"Duplicate type specifier"
}

duplicate_type_qualifier()
{
	USAGE: ERROR
	KEY(STD) fileline"Duplicate type qualifier"
}

constant_cant_be_lvalue()
{
	USAGE: ERROR
	KEY(STD) fileline"Constant can't be an lvalue"
}

empty_parameter_list()
{
	USAGE: WARNING
	KEY(STD) fileline"Empty parameter list"
}

undefined_nat(ccp: name)
{
	USAGE: ERROR
	KEY(STD) fileline"Undefined NAT, '"name"'"
}

not_a_nat(ccp: name)
{
	USAGE: ERROR
	KEY(STD) fileline"'"name"' is not a NAT"
}

non_integral_promotion_type()
{
	USAGE: ERROR
	KEY(STD) fileline"Non-integral promotion type"
}

illegal_field_type(ccp: name)
{
	USAGE: ERROR
	KEY(STD) fileline"Illegal field type, '"name"'"
}

redefinition_of_type(ccp: name)
{
	USAGE: ERROR
	KEY(STD) fileline"Redefinition of type '"name"'"
}

empty_struct_union_definition()
{
	USAGE: ERROR
	KEY(STD) fileline"Empty struct/union definition"
}

syntax_error()
{
	USAGE: ERROR
	KEY(STD) fileline"Syntax error"
}

invalid_type_specifier()
{
	USAGE: ERROR
	KEY(STD) fileline"Invalid type specifier"
}

unknown_special_type(ccp: name)
{
	USAGE: ERROR
	KEY(STD) fileline"Unknown special type '"name"'"
}

type_not_defined(ccp: hname, ccp: name)
{
	USAGE: ERROR
	KEY(STD) fileline hname "'"name"' not defined"
}

type_used_inconsistently(ccp: hname, ccp: nm, ccp: file, ccp: line)
{
	USAGE: ERROR
	KEY(STD) fileline hname "'"nm"' used inconsistently (see "file", line "line")"
}

type_void_is_incomplete()
{
	USAGE: ERROR
	KEY(STD) fileline"The type 'void' is incomplete"
}

incomplete_array_type()
{
	USAGE: ERROR
	KEY(STD) fileline"Incomplete array type"
}

function_cant_return_an_array()
{
	USAGE: ERROR
	KEY(STD) fileline"A function can't return an array"
}

non_integral_bitfield_type()
{
	USAGE: ERROR
	KEY(STD) fileline"Non-integral bitfield type"
}

object_type_expected()
{
	USAGE: ERROR
	KEY(STD) fileline"Object type expected"
}

function_type_expected()
{
	USAGE: ERROR
	KEY(STD) fileline"Function type expected"
}

illegal_directory(ccp: dir)
{
	USAGE: ERROR
	KEY(STD) "Illegal directory, "dir
}

cant_create_directory(ccp: dir)
{
	USAGE: ERROR
	KEY(STD) "Can't create directory "dir": "strerror
}

path_component_too_long(ccp: nm, int: len)
{
	USAGE: WARNING
	KEY(STD) "The filename "nm" contains a component of length "len
}

unknown_string_variable(ccp: name)
{
	USAGE: ERROR
	KEY(STD) fileline"Unknown string variable, '"name"'"
}

unknown_integer_variable(ccp: name)
{
	USAGE: ERROR
	KEY(STD) fileline"Unknown integer variable, '"name"'"
}
