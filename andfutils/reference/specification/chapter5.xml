<?xml version="1.0" standalone="no"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
  "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">

<!--
  $Id$
-->

<chapter id="C5">
  <title>Specification of TDF constructs</title>

  <section id="C5S1">
    <title>Access</title>

    <emphasis role="bold">Number of encoding bits</emphasis>: 4<sbr/>
    <emphasis role="bold">Is coding extendable</emphasis>: yes

    <para>
      An <code>ACCESS</code> describes properties a variable or identity may
      have which may constrain or describe the ways in which the variable or
      identity is used.
    </para>

    <para>
      Each construction which needs an <code>ACCESS</code> uses it in the form
      <code>OPTION</code>(<code>ACCESS</code>). If the option is absent the
      variable or identity has no special properties.
    </para>

    <para>
      An <code>ACCESS</code> acts like a set of the values
      <emphasis>constant</emphasis>, <emphasis>long_jump_access</emphasis>,
      <emphasis>no_other_read</emphasis>, <emphasis>no_other_write</emphasis>,
      <emphasis>register</emphasis>, <emphasis>out_par</emphasis>,
      <emphasis>used_as_volatile</emphasis>, and <emphasis>visible</emphasis>.
      <emphasis>standard_access</emphasis> acts like the empty set.
      <emphasis>add_accesses</emphasis> is the set union operation.
    </para>

    <section id="C5S1.1">
      <title>access_apply_token</title>
      <emphasis role="bold">Encoding number</emphasis>: 1

        <programlisting language="TDF">
      token_value:     TOKEN
      token_args:      BITSTREAM param_sorts(token_value)
                 -&gt; ACCESS</programlisting>

      <para>
        The token is applied to the arguments encoded in the
        <code>BITSTREAM</code> <emphasis>token_args</emphasis> to give an
        <code>ACCESS</code>.
      </para>

      <para>
        The notation <emphasis>param_sorts(token_value)</emphasis> is intended
        to mean the following. The token definition or token declaration for
        <emphasis>token_value</emphasis> gives the <code>SORT</code>s of its
        arguments in the <code>SORTNAME</code> component. The
        <code>BITSTREAM</code> in <emphasis>token_args</emphasis> consists of
        these <code>SORT</code>s in the given order. If no token declaration or
        definition exists in the <code>CAPSULE</code>, the
        <code>BITSTREAM</code> cannot be read.
      </para>
    </section>

    <section id="C5S1.2">
      <title>access_cond</title>

      <emphasis role="bold">Encoding Number</emphasis>: 2

      <programlisting language="TDF">
      control: EXP INTEGER(v)
      e1:              BITSTREAM ACCESS
      e2:              BITSTREAM ACCESS
                 -&gt; ACCESS</programlisting>

      <emphasis>control</emphasis> is evaluated. It will be a constant at
      install time under the constant evaluation rules. If it is non-zero,
      <emphasis>e1</emphasis> is installed at this point and
      <emphasis>e2</emphasis> is ignored and never processed. If
      <emphasis>control</emphasis> is zero then <emphasis>e2</emphasis> is
      installed at this point and <emphasis>e1</emphasis> is ignored and never
      processed.
    </section>

    <section id="C5S1.3">
      <title>add_access</title>

      <emphasis role="bold">Encoding number</emphasis>: 3

      <programlisting language="TDF">
      a1:              ACCESS
      a2:              ACCESS
                 -&gt; ACCESS</programlisting>

      A construction qualified with <emphasis>add_accesses</emphasis> has both
      <code>ACCESS</code> properties <emphasis>a1</emphasis> and
      <emphasis>a2</emphasis>. This operation is associative and commutative.
    </section>

    <section id="C5S1.4">
      <title>constant</title>

      <emphasis role="bold">Encoding number</emphasis>: 4

      <programlisting language="TDF">
                 -&gt; ACCESS</programlisting>

      Only a variable (not an identity) may be qualified with
      <emphasis>constant</emphasis>. A variable qualified with
      <emphasis>constant</emphasis> will retain its initialising value unchanged
      throughout its lifetime.
    </section>

    <section id="C5S1.5">
      <title>long_jump_access</title>

      <emphasis role="bold">Encoding number</emphasis>: 5

      <programlisting language="TDF">
                 -&gt; ACCESS</programlisting>

      An object must also have this property if it is to have a defined value
      when a <emphasis>long_jump</emphasis> returns to the procedure declaring
      the object.
    </section>

    <section id="C5S1.6">
      <title>no_other_read</title>

      <emphasis role="bold">Encoding number</emphasis>: 6

      <programlisting language="TDF">
                 -&gt; ACCESS</programlisting>

      <para>
        This property refers to a <code>POINTER</code>, <emphasis>p</emphasis>.
        It says that, within the lifetime of the declaration being qualified,
        there are no <emphasis>contents</emphasis>,
        <emphasis>contents_with_mode</emphasis> or
        <emphasis>move_some</emphasis> source accesses to any pointer not
        derived from <emphasis>p</emphasis> which overlap with any of the
        <emphasis>contents</emphasis>, <emphasis>contents_with_mode</emphasis>,
        <emphasis>assign</emphasis>, <emphasis>assign_with_mode</emphasis> or
        <emphasis>move_some</emphasis> accesses to pointers derived from
        <emphasis>p</emphasis>.
      </para>

      <para>
        The <code>POINTER</code> being described is that obtained by applying
        <emphasis>obtain_tag</emphasis> to the <code>TAG</code> of the
        declaration. If the declaration is an <emphasis>identity</emphasis>, the
        <code>SHAPE</code> of the <code>TAG</code> will be a
        <code>POINTER</code>.
      </para>
    </section>

    <section id="C5S1.7">
      <title>no_other_write</title>

      <emphasis role="bold">Encoding number</emphasis>: 7

      <programlisting language="TDF">
                 -&gt; ACCESS</programlisting>

      <para>
        This property refers to a <code>POINTER</code>, <emphasis>p</emphasis>.
        It says that, within the lifetime of the declaration being qualified,
        there are no <emphasis>assign</emphasis>,
        <emphasis>assign_with_mode</emphasis> or <emphasis>move_some</emphasis>
        destination accesses to any pointer not derived from
        <emphasis>p</emphasis> which overlap with any of the
        <emphasis>contents</emphasis>, <emphasis>contents_with_mode</emphasis>,
        <emphasis>assign</emphasis>, <emphasis>assign_with_mode</emphasis> or
        <emphasis>move_some</emphasis> accesses to pointers derived from
        <emphasis>p</emphasis>.
      </para>

      <para>
        The <code>POINTER</code> being described is that obtained by applying
        <emphasis>obtain_tag</emphasis> to the <code>TAG</code> of the
        declaration. If the declaration is an <emphasis>identity</emphasis>, the
        <code>SHAPE</code> of the <code>TAG</code> will be a
        <code>POINTER</code>.
      </para>
    </section>

    <section id="C5S1.8">
      <title>out_par</title>

      <emphasis role="bold">Encoding number</emphasis>: 8

      <programlisting language="TDF">
                 -&gt; ACCESS</programlisting>

      An object qualified by <emphasis>out_par</emphasis> will be an output
      parameter in a <emphasis>make_general_proc</emphasis> construct. This will
      indicate that the final value of the parameter is required in
      <emphasis>postlude</emphasis> part of an
      <emphasis>apply_general_proc</emphasis> of this procedure.
    </section>

    <section id="C5S1.9">
      <title>preserve</title>

      <emphasis role="bold">Encoding number</emphasis>: 9

      <programlisting language="TDF">
                 -&gt; ACCESS</programlisting>

      This property refers to a global object. It says that the object will be
      included in the final program, whether or not all possible accesses to
      that object are optimised away; for example by inlining all possible uses
      of procedure object.
    </section>

    <section id="C5S1.10">
      <title>register</title>

      <emphasis role="bold">Encoding number</emphasis>: 10

      <programlisting language="TDF">
                 -&gt; ACCESS</programlisting>

      Indicates that an object with this property is frequently used. This can
      be taken as a recommendation to place it in a register.
    </section>

    <section id="C5S1.11">
      <title>standard_access</title>

      <emphasis role="bold">Encoding number</emphasis>: 11

      <programlisting language="TDF">
                 -&gt; ACCESS</programlisting>

      An object qualified as having <emphasis>standard_access</emphasis> has
      normal (i.e.  no special) access properties.
    </section>

    <section id="C5S1.12">
      <title>used_as_volatile</title>

      <emphasis role="bold">Encoding number</emphasis>: 12

      <programlisting language="TDF">
                 -&gt; ACCESS</programlisting>

      An object qualified as having <emphasis>used_as_volatile</emphasis> will
      be used in a <emphasis>move_some</emphasis>,
      <emphasis>contents_with_mode</emphasis> or an
      <emphasis>assign_with_mode</emphasis> construct with
      <code>TRANSFER_MODE</code> <emphasis>volatile</emphasis>.
    </section>

    <section id="C5S1.13">
      <title>visible</title>

      <emphasis role="bold">Encoding number</emphasis>: 13

      <programlisting language="TDF">
                 -&gt; ACCESS</programlisting>

      An object qualified as <emphasis>visible</emphasis> may be accessed when
      the procedure in which it is declared is not the current procedure. A
      <code>TAG</code> must have this property if it is to be used by
      <emphasis>env_offset</emphasis>.
    </section>
  </section>

  <section id="C5S2">
    <title>AL_TAG</title>

    <emphasis role="bold">Number of encoding bits</emphasis>: 1<sbr/>
    <emphasis role="bold">Is coding extendable</emphasis>: yes<sbr/>
    <emphasis role="bold">Linkable entity identification</emphasis>:
    alignment

    <para>
      <code>AL_TAG</code>s name <code>ALIGNMENT</code>s. They are used so that
      circular definitions can be written in TDF. However, because of the
      definition of alignments, intrinsic circularities cannot occur.
    </para>

    <para>
      <emphasis>For example, the following equation has a circular form x =
      alignment(pointer(alignment(x))) and it or a similar equation might
      occur in TDF. But since alignment(pointer(x)) is {pointer}, this reduces
      to x = {pointer}.</emphasis>
    </para>

    <section id="C5S2.1">
      <title>al_tag_apply_token</title>

      <emphasis role="bold">Encoding number</emphasis>: 2

      <programlisting language="TDF">
      token_value:     TOKEN
      token_args:      BITSTREAM param_sorts(token_value)
                 -&gt; AL_TAG</programlisting>

      The token is applied to the arguments encoded in the
      <code>BITSTREAM</code> <emphasis>token_args</emphasis> to give an
      <code>AL_TAG</code>.

      <para>
        If there is a definition for <emphasis>token_value</emphasis> in the
        <code>CAPSULE</code> then <emphasis>token_args</emphasis> is a
        <code>BITSTREAM</code> encoding of the <code>SORT</code>s of its
        parameters, in the order specified.
      </para>
    </section>

    <section id="C5S2.2">
      <title>make_al_tag</title>

      <emphasis role="bold">Encoding number</emphasis>: 1

      <programlisting language="TDF">
      al_tagno:        TDFINT
                 -&gt; AL_TAG</programlisting>

      <emphasis>make_al_tag</emphasis> constructs an <code>AL_TAG</code>
      identified by <emphasis>al_tagno</emphasis>.
    </section>
  </section>

  <section id="C5S3">
    <title>AL_TAGDEF</title>

    <emphasis role="bold">Number of encoding bits</emphasis>: 1<sbr/>
    <emphasis role="bold">Is coding extendable</emphasis>: yes<sbr/>

    <para>
      An <code>AL_TAGDEF</code> gives the definition of an <code>AL_TAG</code>
      for incorporation into a <code>AL_TAGDEF_PROPS</code>.
    </para>

    <section id="C5S3.1">
      <title>make_al_tagdef</title>

      <emphasis role="bold">Encoding number</emphasis>: 1

      <programlisting language="TDF">
      t:               TDFINT
      a:               ALIGNMENT
                 -&gt; AL_TAGDEF</programlisting>

      <para>
        The <code>AL_TAG</code> identified by <emphasis>t</emphasis> is defined
        to stand for the <code>ALIGNMENT</code> <emphasis>a</emphasis>. All the
        <code>AL_TAGDEF</code>s in a <code>CAPSULE</code> must be considered
        together as a set of simultaneous equations defining
        <code>ALIGNMENT</code> values for the <code>AL_TAG</code>s. No order is
        imposed on the definitions.
      </para>

      <para>
        In any particular <code>CAPSULE</code> the set of equations may be
        incomplete, but a <code>CAPSULE</code> which is being translated into
        code will have a set of equations which defines all the
        <code>AL_TAG</code>s which it uses.
      </para>

      <para>
        The result of the evaluation of the <emphasis>control</emphasis>
        argument of any <emphasis>x_cond</emphasis> construction (e.g
        <emphasis>alignment_cond</emphasis>) used in <emphasis>a</emphasis>
        shall be independent of any <code>AL_TAG</code>s used in the
        <emphasis>control</emphasis>.  Simultaneous equations defining
        <code>ALIGNMENT</code>s can then always be solved.
      </para>

      <para>
        See <!-- TODO link to 7.13.3 circular types in languages -->Circular
        types in languages<!-- end link -->.
      </para>
    </section>
  </section>

  <section id="C5S4">
    <title>AL_TAGDEF_PROPS</title>

    <emphasis role="bold">Number of encoding bits</emphasis>: 0<sbr/>
    <emphasis role="bold">Is coding extendable</emphasis>: no<sbr/>
    <emphasis role="bold">Unit identificaiton</emphasis>: aldef

    <section id="C5S4.1">
      <title>make_al_tagdefs</title>

      <emphasis role="bold">Encoding number</emphasis>: 0

      <programlisting language="TDF">
      no_labels:       TDFINT
      tds:             SLIST(AL_TAGDEF)
                 -&gt; AL_TAGDEF_PROPS</programlisting>

      <para>
        <emphasis>no_labels</emphasis> is the number of local
        <code>LABEL</code>s used in <emphasis>tds</emphasis>.
        <emphasis>tds</emphasis> is a list of <code>AL_TAGDEF</code>s which
        define the bindings for <emphasis>al_tags</emphasis>.
      </para>
    </section>
  </section>

  <section id="C5S5">
    <title>ALIGNMENT</title>

    <emphasis role="bold">Number of encoding bits</emphasis>: 4<sbr/>
    <emphasis role="bold">Is coding extendable</emphasis>: yes<sbr/>

    <para>
      An <code>ALIGNMENT</code> gives information about the layout of data in
      memory and hence is a parameter for the <code>POINTER</code> and
      <code>OFFSET SHAPE</code>s (see <!-- TODO link to 7.13. Memory Model
      -->Memory Model<!-- end link -->). This information consists of a set of
      elements.
    </para>

    <para>
      The possible values of the elements in such a set are
      <emphasis>proc</emphasis>, <emphasis>code</emphasis>,
      <emphasis>pointer</emphasis>, <emphasis>offset</emphasis>, all
      <code>VARIETY</code>s, all <code>FLOATING_VARIETY</code>s and all
      <code>BITFIELD_VARIETY</code>s. The sets are written here as, for example,
      {<emphasis>pointer</emphasis>, <emphasis>proc</emphasis>} meaning the set
      containing <emphasis>pointer</emphasis> and <emphasis>proc</emphasis>.
    </para>

    <para>
      In addition, there are <quote>special</quote> <code>ALIGNMENT</code>s
      <emphasis>alloca_alignment</emphasis>,
      <emphasis>callers_alignment</emphasis>,
      <emphasis>callees_alignment</emphasis>,
      <emphasis>locals_alignment</emphasis> and
      <emphasis>var_param_alignment</emphasis>. Each of these are considered to
      be sets which include all of the <quote>ordinary</quote>
      <code>ALIGNMENT</code>s above.
    </para>

    <para>
      There is a function, <emphasis>alignment</emphasis>, which can be applied
      to a <code>SHAPE</code> to give an <code>ALIGNMENT</code> (see the
      definition below). The interpretation of a <code>POINTER</code> to an
      <code>ALIGNMENT</code>, <emphasis>a</emphasis>, is that it can serve as a
      <code>POINTER</code> to any <code>SHAPE</code>, <emphasis>s</emphasis>,
      such that <emphasis>alignment</emphasis>(<emphasis>s</emphasis>) is a
      subset of the set <emphasis>a</emphasis>.
    </para>

    <para>
      So given a <code>POINTER</code>({<emphasis>proc</emphasis>,
      <emphasis>pointer</emphasis>}) it is permitted to assign a
      <code>PROC</code> or a <code>POINTER</code> to it, or indeed a compound
      containing only <code>PROC</code>s and <code>POINTER</code>s. This
      permission is valid only in respect of the space being of the right kind;
      it may or may not be big enough for the data.
    </para>

    <para>
      The most usual use for <code>ALIGNMENT</code> is to ensure that addresses
      of <emphasis>int</emphasis> values are aligned on 4-byte boundaries,
      <emphasis>float</emphasis> values are aligned on 4-byte boundaries,
      <emphasis>double</emphasis>s on 8-bit boundaries etc. and whatever may be
      implied by the definitions of the machines and languages involved.
    </para>

    <para>
      In the specification the phrase <quote><emphasis>a</emphasis> will include
      <emphasis>b</emphasis></quote> where <emphasis>a</emphasis> and
      <emphasis>b</emphasis> are <code>ALIGNMENT</code>s, means that the set
      <emphasis>b</emphasis> will be a subset of <emphasis>a</emphasis> (or
      equal to <emphasis>a</emphasis>).
    </para>

    <section id="C5S5.1">
      <title>alignment_apply_token</title>

      <emphasis role="bold">Encoding number</emphasis>: 1

      <programlisting language="TDF">
      token_value:     TOKEN
      token_args:      BITSTREAM param_sorts(token_value)
                 -&gt; ALIGNMENT</programlisting>

      <para>
        The token is applied to the arguments encoded in the
        <code>BITSTREAM</code> <emphasis>token_args</emphasis> to give an
        <code>ALIGNMENT</code>.
      </para>

      <para>
        If there is a definition for <emphasis>token_value</emphasis> in the
        <code>CAPSULE</code> then <emphasis>token_args</emphasis> is a
        <code>BITSTREAM</code> encoding of the <code>SORT</code>s of its
        parameters, in the order specified.
      </para>
    </section>

    <section id="C5S5.2">
      <title>alignment_cond</title>

      <emphasis role="bold">Encoding number</emphasis>: 2

      <programlisting language="TDF">
      control: EXP INTEGER(v)
      e1:              BITSTREAM ALIGNMENT
      e2:              BITSTREAM ALIGNMENT
                 -&gt; ALIGNMENT</programlisting>

      <para>
        <emphasis>control</emphasis> is evaluated. It will be a constant at
        install time under the constant evaluation rules. If it is non-zero,
        <emphasis>e1</emphasis> is installed at this point and
        <emphasis>e2</emphasis> is ignored and never processed. If
        <emphasis>control</emphasis> is zero then <emphasis>e2</emphasis> is
        installed at this point and <emphasis>e1</emphasis> is ignored and never
        processed.
      </para>
    </section>

    <section id="C5S5.3">
      <title>alignment</title>

      <emphasis role="bold">Encoding number</emphasis>: 3

      <programlisting language="TDF">
      sha:             SHAPE
                 -&gt; ALIGNMENT</programlisting>

      <para>
        The <emphasis>alignment</emphasis> construct is defined as follows:
      </para>

      <itemizedlist>
        <listitem>
          <para>
            If <emphasis>sha</emphasis> is <code>PROC</code> then the resulting
            <code>ALIGNMENT</code> is {<emphasis>proc</emphasis>}.
          </para>
        </listitem>

        <listitem>
          <para>
            If <emphasis>sha</emphasis> is
            <code>INTEGER</code>(<emphasis>v</emphasis>) then the resulting
            <code>ALIGNMENT</code> is {<emphasis>v</emphasis>}.
          </para>
        </listitem>

        <listitem>
          <para>
            If <emphasis>sha</emphasis> is
            <code>FLOATING</code>(<emphasis>v</emphasis>) then the resulting
            <code>ALIGNMENT</code> is {<emphasis>v</emphasis>}.
          </para>
        </listitem>

        <listitem>
          <para>
            If <emphasis>sha</emphasis> is
            <code>BITFIELD</code>(<emphasis>v</emphasis>) then the resulting
            <code>ALIGNMENT</code> is {<emphasis>v</emphasis>}.
          </para>
        </listitem>

        <listitem>
          <para>
            If <emphasis>sha</emphasis> is <code>TOP</code> the resulting
            <code>ALIGNMENT</code> is {} - the empty set.
          </para>
        </listitem>

        <listitem>
          <para>
            If <emphasis>sha</emphasis> is <code>BOTTOM</code> the resulting
            <code>ALIGNMENT</code> is undefined.
          </para>
        </listitem>

        <listitem>
          <para>
            If <emphasis>sha</emphasis> is
            <code>POINTER</code>(<emphasis>x</emphasis>) the resulting
            <code>ALIGNMENT</code> is {<emphasis>pointer</emphasis>}.
          </para>
        </listitem>

        <listitem>
          <para>
            If <emphasis>sha</emphasis> is
            <code>OFFSET</code>(<emphasis>x</emphasis>, <emphasis>y</emphasis>)
            the resulting <code>ALIGNMENT</code> is
            {<emphasis>offset</emphasis>}.
          </para>
        </listitem>

        <listitem>
          <para>
            If <emphasis>sha</emphasis> is
            <code>NOF</code>(<emphasis>n</emphasis>, <emphasis>s</emphasis>) the
            resulting <code>ALIGNMENT</code> is
            <emphasis>alignment</emphasis>(<emphasis>s</emphasis>).
          </para>
        </listitem>

        <listitem>
          <para>
            If <emphasis>sha</emphasis> is <code>COMPOUND</code>(<code>EXP
            OFFSET</code>(<emphasis>x</emphasis>, <emphasis>y</emphasis>)) then
            the resulting <code>ALIGNMENT</code> is <emphasis>x</emphasis>.
          </para>
        </listitem>
      </itemizedlist>
    </section>

    <section id="C5S5.4">
      <title>alloca_allignment</title>

      <emphasis role="bold">Encoding number</emphasis>: 4

      <programlisting language="TDF">
                 -&gt; ALIGNMENT</programlisting>

      <para>
        Delivers the <code>ALIGNMENT</code> of <code>POINTER</code>s produced
        from <emphasis>local_alloc</emphasis>.
      </para>
    </section>

    <section id="C5S5.5">
      <title>callees_alignment</title>

      <emphasis role="bold">Encoding number</emphasis>: 5

      <programlisting language="TDF">
      var:             BOOL
                 -&gt; ALIGNMENT</programlisting>

      <para>
        If <emphasis>var</emphasis> is <emphasis>true</emphasis> the
        <code>ALIGNMENT</code> is that of callee parameters qualified by the
        <code>PROCPROPS</code> <emphasis>var_callees</emphasis>. If
        <emphasis>var</emphasis> is <emphasis>false</emphasis>, the
        <code>ALIGNMENT</code> is that of callee parameters not qualified by
        <code>PROCPROPS</code> <emphasis>var_callees</emphasis>.
      </para>

      <para>
        Delivers the <code>base ALIGNMENT</code> of <code>OFFSET</code>s from a
        frame-pointer to a <code>CALLEE</code> parameter. Values of such
        <code>OFFSET</code>s can only be produced by
        <emphasis>env_offset</emphasis> applied to <code>CALLEE</code>
        parameters, or offset arithmetic operations applied to existing
        <code>OFFSET</code>s.
      </para>
    </section>

    <section id="C5S5.6">
      <title>callers_alignment</title>

      <emphasis role="bold">Encoding number</emphasis>: 6

      <programlisting language="TDF">
      var:             BOOL
                 -&gt; ALIGNMENT</programlisting>

      <para>
        If <emphasis>var</emphasis> is <emphasis>true</emphasis> the
        <code>ALIGNMENT</code> is that of caller parameters qualified by the
        <code>PROCPROPS</code> <emphasis>var_callers</emphasis>. If
        <emphasis>var</emphasis> is <emphasis>false</emphasis>, the
        <code>ALIGNMENT</code> is that of caller parameters not qualified by
        <code>PROCPROPS</code> <emphasis>var_callers</emphasis>.
      </para>

      <para>
        Delivers the <code>base ALIGNMENT</code> of <code>OFFSET</code>s from a
        frame-pointer to a <code>CALLER</code> parameter. Values of such
        <code>OFFSET</code>s can only be produced by
        <emphasis>env_offset</emphasis> applied to <code>CALLER</code>
        parameters, or offset arithmetic operations applied to existing
        <code>OFFSET</code>s.
      </para>
    </section>

    <section id="C5S5.7">
      <title>code_alignment</title>

      <emphasis role="bold">Encoding number</emphasis>: 7

      <programlisting language="TDF">
                 -&gt; ALIGNMENT</programlisting>

      <para>
        Delivers {<emphasis>code</emphasis>}, the <code>ALIGNMENT</code> of the
        <code>POINTER</code> produced by <emphasis>make_local_lv</emphasis>.
      </para>
    </section>

    <section id="C5S5.8">
      <title>locals_alignment</title>

      <emphasis role="bold">Encoding number</emphasis>: 8

      <programlisting language="TDF">
                 -&gt; ALIGNMENT</programlisting>

      <para>
        Delivers the <code>base ALIGNMENT</code> of <code>OFFSET</code>s from a
        frame-pointer to a value defined by <emphasis>variable</emphasis> or
        <emphasis>identify</emphasis>. Values of such <code>OFFSET</code>s can
        only be produced by <emphasis>env_offset</emphasis> applied to
        <code>TAG</code>s so defined, or offset arithmetic operations applied to
        existing <code>OFFSET</code>s.
      </para>
    </section>

    <section id="C5S5.9">
      <title>obtain_al_tag</title>

      <emphasis role="bold">Encoding number</emphasis>: 9

      <programlisting language="TDF">
      at:              AL_TAG
                 -&gt; ALIGNMENT</programlisting>

      <para>
        <emphasis>obtain_al_tag</emphasis> produces the <code>ALIGNMENT</code>
        with which the <code>AL_TAG</code> <emphasis>at</emphasis> is bound.
      </para>
    </section>

    <section id="C5S5.10">
      <title>parameter_alignment</title>

      <emphasis role="bold">Encoding number</emphasis>: 10

      <programlisting language="TDF">
      sha:             SHAPE
                 -&gt; ALIGNMENT</programlisting>

      <para>
        Delivers the <code>ALIGNMENT</code> of a parameter of a procedure of
        <code>SHAPE</code> <emphasis>sha</emphasis>.
      </para>
    </section>

    <section id="C5S5.11">
      <title>unite_alignments</title>

      <emphasis role="bold">Encoding number</emphasis>: 11

      <programlisting language="TDF">
      a1:              ALIGNMENT
      a2:              ALIGNMENT
                 -&gt; ALIGNMENT</programlisting>

      <para>
        <emphasis>unite_alignments</emphasis> produces the alignment at which
        all the members of the <code>ALIGNMENT</code> sets
        <emphasis>a1</emphasis> and <emphasis>a2</emphasis> can be placed - in
        other words the <code>ALIGNMENT</code> set which is the union of
        <emphasis>a1</emphasis> and <emphasis>a2</emphasis>.
      </para>
    </section>

    <section id="C5S5.12">
      <title>var_param_alignment</title>

      <emphasis role="bold">Encoding number</emphasis>: 12

      <programlisting language="TDF">
                 -&gt; ALIGNMENT</programlisting>
      <para>
        Delivers the <code>ALIGNMENT</code> used in the
        <emphasis>var_param</emphasis> argument of
        <emphasis>make_proc</emphasis>.
      </para>
    </section>
  </section>

  <section id="C5S6">
    <title>BITFIELD_VARIETY</title>

    <emphasis role="bold">Number of encoding bits</emphasis>: 2<sbr/>
    <emphasis role="bold">Is coding extendable</emphasis>: yes<sbr/>

    <para>
      These describe runtime bitfield values. The intention is that these values
      are usually kept in memory locations which need not be aligned on
      addressing boundaries.
    </para>

    <para>
      There is no limit on the size of bitfield values in TDF, but an installer
      may specify limits. See <!-- TODO link to 7.24. Representing bitfields
      -->Representing bitfields<!-- end link --> and <!-- TODO link to 7.25.
      Permitted limits -->Permitted limits<!-- end link -->.
    </para>

    <section id="C5S6.1">
      <title>bfvar_apply_token</title>

      <emphasis role="bold">Encoding number</emphasis>: 1

      <programlisting language="TDF">
      token_value:     TOKEN
      token_args:      BITSTREAM param_sorts(token_value)
                 -&gt; BITFIELD_VARIETY</programlisting>

      <para>
        The token is applied to the arguments encoded in the
        <code>BITSTREAM</code> <emphasis>token_args</emphasis> to give a
        <code>BITFIELD_VARIETY</code>.
      </para>

      <para>
        If there is a definition for <emphasis>token_value</emphasis> in the
        <code>CAPSULE</code> then <emphasis>token_args</emphasis> is a
        <code>BITSTREAM</code> encoding of the <code>SORT</code>s of its
        parameters, in the order specified.
      </para>
    </section>

    <section id="C5S6.2">
      <title>bfvar_cond</title>

      <emphasis role="bold">Encoding number</emphasis>: 2

      <programlisting language="TDF">
      control: EXP INTEGER(v)
      e1:              BITSTREAM BITFIELD_VARIETY
      e2:              BITSTREAM BITFIELD_VARIETY
                 -&gt; BITFIELD_VARIETY</programlisting>

      <para>
        <emphasis>control</emphasis> is evaluated. It will be a constant at
        install time under the constant evaluation rules. If it is non-zero,
        <emphasis>e1</emphasis> is installed at this point and
        <emphasis>e2</emphasis> is ignored and never processed. If
        <emphasis>control</emphasis> is zero then <emphasis>e2</emphasis> is
        installed at this point and <emphasis>e1</emphasis> is ignored and never
        processed.
      </para>
    </section>

    <section id="C5S6.3">
      <title>bfvar_bits</title>

      <emphasis role="bold">Encoding number</emphasis>: 3

      <programlisting language="TDF">
      issigned:        BOOL
      bits:            NAT
                 -&gt; BITFIELD_VARIETY</programlisting>

      <para>
        <emphasis>bfvar_bits</emphasis> constructs a
        <code>BITFIELD_VARIETY</code> describing a pattern of
        <emphasis>bits</emphasis> bits. If <emphasis>issigned</emphasis> is
        <emphasis>true</emphasis>, the pattern is considered to be a
        twos-complement signed number: otherwise it is considered to be
        unsigned.
      </para>
    </section>
  </section>

  <section id="C5S7">
    <title>BITSTREAM</title>

    <para>
      A <code>BITSTREAM</code> consists of an encoding of any number of bits.
      This encoding is such that any program reading TDF can determine how to
      skip over it. To read it meaningfully extra knowledge of what it
      represents may be needed.
    </para>

    <para>
      A <code>BITSTREAM</code> is used, for example, to supply parameters in a
      <code>TOKEN</code> application. If there is a definition of this
      <code>TOKEN</code> available, this will provide the information needed to
      decode the bitstream.
    </para>

    <para>
      See <!-- TODO link to 8.4. The TDF encoding -->The TDF encoding<!-- end
      link -->.
    </para>
  </section>

  <section id="C5S8">
    <title>BOOL</title>

    <emphasis role="bold">Number of encoding bits</emphasis>: 3<sbr/>
    <emphasis role="bold">Is coding extendable</emphasis>: yes<sbr/>

    <para>
      A <code>BOOL</code> is a piece of TDF which can take two values,
      <emphasis>true</emphasis> or <emphasis>false</emphasis>.
    </para>

    <section id="C5S8.1">
      <title>bool_apply_token</title>

      <emphasis role="bold">Encoding number</emphasis>: 1

      <programlisting language="TDF">
      token_value:     TOKEN
      token_args:      BITSTREAM param_sorts(token_value)
                 -&gt; BOOL</programlisting>

      <para>
        The token is applied to the arguments encoded in the
        <code>BITSTREAM</code> <emphasis>token_args</emphasis> to give a
        <code>BOOL</code>.
      </para>

      <para>
        If there is a definition for <emphasis>token_value</emphasis> in the
        <code>CAPSULE</code> then <emphasis>token_args</emphasis> is a
        <code>BITSTREAM</code> encoding of the <code>SORT</code>s of its
        parameters, in the order specified.
      </para>
    </section>

    <section id="C5S8.2">
      <title>bool_cond</title>

      <emphasis role="bold">Encoding number</emphasis>: 2

      <programlisting language="TDF">
      control: EXP INTEGER(v)
      e1:              BITSTREAM BOOL
      e2:              BITSTREAM BOOL
                 -&gt; BOOL</programlisting>

      <para>
        <emphasis>control</emphasis> is evaluated. It will be a constant at
        install time under the constant evaluation rules. If it is non-zero,
        <emphasis>e1</emphasis> is installed at this point and
        <emphasis>e2</emphasis> is ignored and never processed.  If
        <emphasis>control</emphasis> is zero then <emphasis>e2</emphasis> is
        installed at this point and <emphasis>e1</emphasis> is ignored and never
        processed.
      </para>
    </section>

    <section id="C5S8.3">
      <title>false</title>

      <emphasis role="bold">Encoding number</emphasis>: 3

      <programlisting language="TDF">
                 -&gt; BOOL</programlisting>

      <para>
        <emphasis>false</emphasis> produces a false <code>BOOL</code>.
      </para>
    </section>

    <section id="C5S8.4">
      <title>true</title>

      <emphasis role="bold">Encoding number</emphasis>: 4

      <programlisting language="TDF">
                 -&gt; BOOL</programlisting>

      <para>
        <emphasis>true</emphasis> produces a true <code>BOOL</code>.
      </para>
    </section>
  </section>

  <section id="C5S9">
    <title>BYTESTREAM</title>

    <para>
      A <code>BYTESTREAM</code> is analogous to a <code>BITSTREAM</code>, but is
      encoded to permit fast copying.
    </para>

    <para>
      See <!-- TODO link to 8.4. The TDF encoding -->The TDF encoding<!-- end
      link -->.
    </para>
  </section>

  <section id="C5S10">
    <title>CALLEES</title>

    <emphasis role="bold">Number of encoding bits</emphasis>: 2<sbr/>
    <emphasis role="bold">Is coding extendable</emphasis>: yes

    <para>
      This is an auxilliary <code>SORT</code> used in calling procedures by
      <emphasis>apply_general_proc</emphasis> and <emphasis>tail_call</emphasis>
      to provide their actual callee parameters.
    </para>

    <section id="C5S10.1">
      <title>make_callee_list</title>

      <emphasis role="bold">Encoding number</emphasis>: 1

      <programlisting language="TDF">
      args:            LIST(EXP)
                 -&gt; CALLEES</programlisting>

      <para>
        The list of <code>EXP</code>s <emphasis>args</emphasis> are evaluated in
        any interleaved order and the resulting list of values form the actual
        callee parameters of the call.
      </para>
    </section>

    <section id="C5S10.2">
      <title>make_dynamic_callees</title>

      <emphasis role="bold">Encoding number</emphasis>: 2

      <programlisting language="TDF">
      ptr:             EXP POINTER(x)
      sze:             EXP OFFSET(x, y)
                 -&gt; CALLEES</programlisting>

      <para>
        The value of size <emphasis>sze</emphasis> pointed at by
        <emphasis>ptr</emphasis> forms the actual callee parameters of the call.
      </para>

      <para>
        The <code>CALLEES</code> value is intended to refer to a sequence of
        zero or more callee parameters. <emphasis>x</emphasis> will include
        <emphasis>parameter_alignment</emphasis>(<emphasis>s</emphasis>) for
        each <emphasis>s</emphasis> that is the <code>SHAPE</code> of an
        intended callee parameter. The value addressed by
        <emphasis>ptr</emphasis> may be produced in one of two ways.  It may be
        produced as a <code>COMPOUND SHAPE</code> value in the normal sense of a
        structure, whose successive elements will be used to generate the
        sequence of callee parameters. In this case, each element in the
        sequence of <code>SHAPE</code> <emphasis>s</emphasis> must additionally
        be padded to
        <emphasis>parameter_alignment</emphasis>(<emphasis>s</emphasis>).
        Alternatively, <emphasis>ptr</emphasis> may address the callee
        parameters of an already activated procedure, by referring to the first
        of the sequence.  <emphasis>sze</emphasis> will be equivalent to
        <emphasis>shape_offset</emphasis>(<emphasis>c</emphasis>) where
        <emphasis>c</emphasis> is the <code>COMPOUND SHAPE</code> just
        described.
      </para>

      <para>
        The call involved (i.e. <emphasis>apply_general_proc</emphasis> or
        <emphasis>tail_call</emphasis>) must have a
        <emphasis>var_callees</emphasis> <code>PROCPROPS</code>.
      </para>
    </section>

    <section id="C5S10.3">
      <title>same_callees</title>

      <emphasis role="bold">Encoding number</emphasis>: 3

      <programlisting language="TDF">
                 -&gt; CALLEES</programlisting>

      <para>
        The callee parameters of the call are the same as those of the current
        procedure.
      </para>
    </section>
  </section>

  <section id="C5S11">
    <title>CAPSULE</title>

    <emphasis role="bold">Number of encoding bits</emphasis>: 0<sbr/>
    <emphasis role="bold">Is coding extendable</emphasis>: no<sbr/>

    <para>
      A <code>CAPSULE</code> is an independent piece of TDF. There is only one
      construction, <emphasis>make_capsule</emphasis>.
    </para>

    <section id="C5S11.1">
      <title>make_capsule</title>

      <emphasis role="bold">Encoding number</emphasis>: 0

      <programlisting language="TDF">
      prop_names:      SLIST(TDFIDENT)
      cap_linking:     SLIST(CAPSULE_LINK)
      ext_linkage:     SLIST(EXTERN_LINK)
      groups:          SLIST(GROUP)
                 -&gt; CAPSULE</programlisting>

      <para>
        <emphasis>make_capsule</emphasis> brings together <code>UNIT</code>s and
        linking and naming information. See <!-- TODO link to 2.1. The Overall
        Structure -->The Overall Structure<!-- end link -->.
      </para>

      <para>
        The elements of the list, <emphasis>prop_names</emphasis>, correspond
        one-to-one with the elements of the list, <emphasis>groups</emphasis>.
        The element of <emphasis>prop_names</emphasis> is the unit
        identification of all the <code>UNIT</code>s in the corresponding
        <code>GROUP</code>. See <!-- TODO link to 5.29. PROPS
        --><code>PROPS</code><!-- link end -->.  A <code>CAPSULE</code> need not
        contain all the kinds of <code>UNIT</code>.
      </para>

      <para>
        It is intended that new kinds of <code>PROPS</code> with new unit
        identifications can be added to the standard in a purely additive
        fashion, either to form a new standard or for private purposes.
      </para>

      <para>
        The elements of the list, <emphasis>cap_linking</emphasis>, correspond
        one-to-one with the elements of the list,
        <emphasis>ext_linkage</emphasis>. The element of
        <emphasis>cap_linking</emphasis> gives the linkable entity
        identification for all the <code>LINKEXTERN</code>s in the element of
        <emphasis>ext_linkage</emphasis>.  It also gives the number of
        <code>CAPSULE</code> level linkable entities having that identification.
      </para>

      <para>
        The elements of the list, <emphasis>cap_linking</emphasis>, also
        correspond one-to-one with the elements of the lists called
        <emphasis>local_vars</emphasis> in each of the
        <emphasis>make_unit</emphasis> constructions for the <code>UNIT</code>s
        in <emphasis>groups</emphasis>. The element of
        <emphasis>local_vars</emphasis> gives the number of <code>UNIT</code>
        level linkable entities having the identification in the corresponding
        member of <emphasis>cap_linking</emphasis>.
      </para>

      <para>
        It is intended that new kinds of linkable entity can be added to the
        standard in a purely additive fashion, either to form a new standard or
        for private purposes.
      </para>

      <para>
        <emphasis>ext_linkage</emphasis> provides a list of lists of
        <code>LINKEXTERN</code>s. These <code>LINKEXTERN</code>s specify the
        associations between the names to be used outside the
        <code>CAPSULE</code> and the linkable entities by which the
        <code>UNIT</code>s make objects available within the
        <code>CAPSULE</code>.
      </para>

      <para>
        The list, <emphasis>groups</emphasis>, provides the non-linkage
        information of the <code>CAPSULE</code>.
      </para>
    </section>
  </section>

  <section id="C5S12">
    <title>CAPSULE_LINK</title>

    <emphasis role="bold">Number of encoding bits</emphasis>: 0<sbr/>
    <emphasis role="bold">Is coding extendable</emphasis>: no<sbr/>

    <para>
      An auxiliary <code>SORT</code> which gives the number of linkable entities
      of a given kind at <code>CAPSULE</code> level. It is used only in
      <emphasis>make_capsule</emphasis>.
    </para>

    <section id="C5S12.1">
      <title>make_capsule_link</title>

      <emphasis role="bold">Encoding number</emphasis>: 0

      <programlisting language="TDF">
      sn:              TDFIDENT
      n:               TDFINT
                 -&gt; CAPSULE_LINK</programlisting>

      <para>
        <emphasis>n</emphasis> is the number of <code>CAPSULE</code> level
        linkable entities (numbered from 0 to <emphasis>n</emphasis>-1) of the
        kind given by <emphasis>sn</emphasis>.  <emphasis>sn</emphasis>
        corresponds to the linkable entity identification.
      </para>
    </section>
  </section>

  <section id="C5S13">
    <title>CASELIM</title>

    <emphasis role="bold">Number of encoding bits</emphasis>: 0<sbr/>
    <emphasis role="bold">Is coding extendable</emphasis>: no<sbr/>

    <para>
      An auxiliary <code>SORT</code> which provides lower and upper bounds and
      the <code>LABEL</code> destination for the <emphasis>case</emphasis>
      construction.
    </para>

    <section id="C5S13.1">
      <title>make_caselim</title>

      <emphasis role="bold">Encoding number</emphasis>: 0

      <programlisting language="TDF">
      branch:          LABEL
      lower:           SIGNED_NAT
      upper:           SIGNED_NAT
                 -&gt; CASELIM</programlisting>

      <para>
        Makes a triple of destination and limits. The <emphasis>case</emphasis>
        construction uses a list of <code>CASELIM</code>s. If the control
        variable of the <emphasis>case</emphasis> lies between
        <emphasis>lower</emphasis> and <emphasis>upper</emphasis>, control
        passes to <emphasis>branch</emphasis>.
      </para>
    </section>
  </section>

  <section id="C5S14">
    <title>ERROR_code</title>

    <emphasis role="bold">Number of encoding bits</emphasis>: 2<sbr/>
    <emphasis role="bold">Is coding extendable</emphasis>: yes<sbr/>

    <section id="C5S14.1">
      <title>nil_access</title>

      <emphasis role="bold">Encoding number</emphasis>: 1

      <programlisting language="TDF">
                 -&gt; ERROR_code</programlisting>

      <para>
        Delivers the <code>ERROR_code</code> arising from an attempt to access a
        nil pointer in an operation with <code>TRANSFER_MODE</code>
        <emphasis>trap_on_nil</emphasis>.
      </para>
    </section>

    <section id="C5S14.2">
      <title>overflow</title>

      <emphasis role="bold">Encoding number</emphasis>: 2

      <programlisting language="TDF">
                 -&gt; ERROR_code</programlisting>

      <para>
        Delivers the <code>ERROR_code</code> arising from a numerical
        exceptional result in an operation with <code>ERROR_TREATMENT</code>
        <emphasis>trap</emphasis>(<emphasis>overflow</emphasis>).
      </para>
    </section>

    <section id="C5S14.3">
      <title>stack_overflow</title>

      <emphasis role="bold">Encoding number</emphasis>: 3

      <programlisting language="TDF">
                 -&gt; ERROR_code</programlisting>

      <para>
        Delivers the <code>ERROR_code</code> arising from a stack overflow in
        the call of a procedure defined with <code>PROCPROPS</code>
        <emphasis>check_stack.</emphasis>
      </para>
    </section>
  </section>

  <section id="C5S15">
    <title>ERROR_TREATMENT</title>

    <emphasis role="bold">Number of encoding bits</emphasis>: 3<sbr/>
    <emphasis role="bold">Is coding extendable</emphasis>: yes<sbr/>

    <para>
      These values describe the way to handle various forms of error which can
      occur during the evaluation of operations.
    </para>

    <para>
      <emphasis>It is expected that additional <code>ERROR_TREATMENT</code>s
      will be needed.</emphasis>
    </para>

    <section id="C5S15.1">
      <title>errt_apply_token</title>

      <emphasis role="bold">Encoding number</emphasis>: 1

      <programlisting language="TDF">
      token_value:     TOKEN
      token_args:      BITSTREAM param_sorts(token_value)
                 -&gt; ERROR_TREATMENT</programlisting>

      <para>
        The token is applied to the arguments encoded in the
        <code>BITSTREAM</code> <emphasis>token_args</emphasis> to give an
        <code>ERROR_TREATMENT</code>.
      </para>

      <para>
        If there is a definition for <emphasis>token_value</emphasis> in the
        <code>CAPSULE</code> then <emphasis>token_args</emphasis> is a
        <code>BITSTREAM</code> encoding of the <code>SORT</code>s of its
        parameters, in the order specified.
      </para>
    </section>

    <section id="C5S15.2">
      <title>errt_cond</title>

      <emphasis role="bold">Encoding number</emphasis>: 2

      <programlisting language="TDF">
      control: EXP INTEGER(v)
      e1:              BITSTREAM ERROR_TREATMENT
      e2:              BITSTREAM ERROR_TREATMENT
                 -&gt; ERROR_TREATMENT</programlisting>

      <para>
        <emphasis>control</emphasis> is evaluated. It will be a constant at
        install time under the constant evaluation rules. If it is non-zero,
        <emphasis>e1</emphasis> is installed at this point and
        <emphasis>e2</emphasis> is ignored and never processed. If
        <emphasis>control</emphasis> is zero then <emphasis>e2</emphasis> is
        installed at this point and <emphasis>e1</emphasis> is ignored and never
        processed.
      </para>
    </section>

    <section id="C5S15.3">
      <title>continue</title>

      <emphasis role="bold">Encoding number</emphasis>: 3

      <programlisting language="TDF">
                 -&gt; ERROR_TREATMENT</programlisting>

      <para>
        If an operation with a <emphasis>continue</emphasis>
        <code>ERROR_TREATMENT</code> causes an error, some value of the correct
        <code>SHAPE</code> shall be delivered. This value shall have the same
        properties as is specified in <emphasis>make_value</emphasis>.
      </para>
    </section>

    <section id="C5S15.4">
      <title>error_jump</title>

      <emphasis role="bold">Encoding number</emphasis>: 4

      <programlisting language="TDF">
      lab:             LABEL
                 -&gt; ERROR_TREATMENT</programlisting>

      <para>
        <emphasis>error_jump</emphasis> produces an <code>ERROR_TREATMENT</code>
        which requires that control be passed to <emphasis>lab</emphasis> if it
        is invoked. <emphasis>lab</emphasis> will be in scope.
      </para>

      <para>
        If a construction has an <emphasis>error_jump</emphasis>
        <code>ERROR_TREATMENT</code> and the jump is taken, the canonical order
        specifies only that the jump occurs after evaluating the construction.
        It is not specified how many further constructions are evaluated.
      </para>

      <para>
        <emphasis>This rule implies that a further construction is needed to
        guarantee that errors have been processed. This is not yet included.
        The effect of nearby procedure calls or exits also needs
        definition.</emphasis>
      </para>
    </section>

    <section id="C5S15.5">
      <title>trap</title>

      <emphasis role="bold">Encoding number</emphasis>: 5

      <programlisting language="TDF">
      trap_list:       LIST(ERROR_code)
                 -&gt; ERROR_TREATMENT</programlisting>

      <para>
        The list of <code>ERROR_codeS</code> in <emphasis>trap_list</emphasis>
        specifies a set of possible exceptional behaviours. If any of these
        occur in an construction with <code>ERROR_TREATMENT</code>
        <emphasis>trap</emphasis>, the TDF exception handling is invoked (see
        <!-- TODO link to 7.8. Exceptions and jumps -->section 7.8<!-- link end
        -->).
      </para>

      <para>
        The observations on canonical ordering in
        <emphasis>error_jump</emphasis> apply equally here.
      </para>
    </section>

    <section id="C5S15.6">
      <title>wrap</title>

      <emphasis role="bold">Encoding number</emphasis>: 6

      <programlisting language="TDF">
                 -&gt; ERROR_TREATMENT</programlisting>

      <para>
        <emphasis>wrap</emphasis> is an <code>ERROR_TREATMENT</code> which will
        only be used in constructions with integer operands and delivering
        <code>EXP</code> <code>INTEGER</code>(<emphasis>v</emphasis>) where
        either the lower bound of <emphasis>v</emphasis> is zero or the
        construction is not one of <emphasis>mult, power, div0, div1, div2,
        rem0, rem1, rem2</emphasis>. The result will be evaluated and any bits
        in the result lying outside the representing <code>VARIETY</code> will
        be discarded (see <!-- TODO link to 7.18. Representing integers
        -->Representing integers<!-- end link -->
      </para>
    </section>

    <section id="C5S15.7">
      <title>impossible</title>

      <emphasis role="bold">Encoding number</emphasis>: 7

      <programlisting language="TDF">
                 -&gt; ERROR_TREATMENT</programlisting>

      <para>
        <emphasis>impossible</emphasis> is an <code>ERROR_TREATMENT</code> which
        means that this error will not occur in the construct concerned.
      </para>

      <para>
        <emphasis>impossible is possibly a misnomer. If an error occurs the
        result is undefined.</emphasis>
      </para>
    </section>
  </section>

  <section id="C5S16">
    <title>EXP</title>

    <emphasis role="bold">Number of encoding bits</emphasis>: 7<sbr/>
    <emphasis role="bold">Is coding extendable</emphasis>: yes<sbr/>

    <para>
      <code>EXP</code>s are pieces of TDF which are translated into program.
      <code>EXP</code> is by far the richest <code>SORT</code>. There are few
      primitive <code>EXP</code>s: most of the constructions take arguments
      which are a mixture of <code>EXP</code>s and other <code>SORT</code>s.
      There are constructs delivering <code>EXP</code>s that correspond to the
      declarations, program structure, procedure calls, assignments, pointer
      manipulation, arithmetic operations, tests etc. of programming languages.
    </para>

    <section id="C5S16.1">
      <title>exp_apply_token</title>

      <emphasis role="bold">Encoding number</emphasis>: 1

      <programlisting language="TDF">
      token_value:     TOKEN
      token_args:      BITSTREAM param_sorts(token_value)
                 -&gt; EXP x</programlisting>

      <para>
        The token is applied to the arguments encoded in the
        <code>BITSTREAM</code> <emphasis>token_args</emphasis> to give an
        <code>EXP</code>.
      </para>

      <para>
        If there is a definition for <emphasis>token_value</emphasis> in the
        <code>CAPSULE</code> then <emphasis>token_args</emphasis> is a
        <code>BITSTREAM</code> encoding of the <code>SORT</code>s of its
        parameters, in the order specified.
      </para>
    </section>

    <section id="C5S16.2">
      <title>exp_cond</title>

      <emphasis role="bold">Encoding number</emphasis>: 2

      <programlisting language="TDF">
      control: EXP INTEGER(v)
      e1:              BITSTREAM EXP x
      e2:              BITSTREAM EXP y
                 -&gt; EXP (control ? x : y)</programlisting>

      <para>
        <emphasis>control</emphasis> is evaluated. It will be a constant at
        install time under the constant evaluation rules. If it is non-zero,
        <emphasis>e1</emphasis> is installed at this point and
        <emphasis>e2</emphasis> is ignored and never processed.  If
        <emphasis>control</emphasis> is zero then <emphasis>e2</emphasis> is
        installed at this point and <emphasis>e1</emphasis> is ignored and never
        processed.
      </para>
    </section>

    <section id="C5S16.3">
      <title>abs</title>

      <emphasis role="bold">Encoding number</emphasis>: 3

      <programlisting language="TDF">
      ov_err:          ERROR_TREATMENT
      arg1:            EXP INTEGER(v)
                 -&gt; EXP INTEGER(v)</programlisting>

      <para>
        The absolute value of the result produced by <emphasis>arg1</emphasis>
        is delivered.
      </para>

      <para>
        If the result cannot be expressed in the <code>VARIETY</code> being used
        to represent <emphasis>v</emphasis>, an overflow error is caused and is
        handled in the way specified by <emphasis>ov_err</emphasis>.
      </para>
    </section>

    <section id="C5S16.4">
      <title>add_to_ptr</title>

      <emphasis role="bold">Encoding number</emphasis>: 4

      <programlisting language="TDF">
      arg1:            EXP POINTER(x)
      arg2:            EXP OFFSET(y, z)
                 -&gt; EXP POINTER(z)</programlisting>

      <para>
        <emphasis>arg1</emphasis> is evaluated, giving <emphasis>p</emphasis>,
        and <emphasis>arg2</emphasis> is evaluated and the results are added to
        produce the answer. The result is derived from the pointer delivered by
        <emphasis>arg1</emphasis>. The intention is to produce a
        <code>POINTER</code> displaced from the argument <code>POINTER</code> by
        the given amount.
      </para>

      <para>
        <emphasis>x</emphasis> will include <emphasis>y</emphasis>.
      </para>

      <para>
        <emphasis>arg1</emphasis> may deliver a null <code>POINTER</code>. In
        this case the result is derived from a null <code>POINTER</code> which
        counts as an original <code>POINTER</code>. Further <code>OFFSET</code>s
        may be added to the result, but the only other useful operation on the
        result of adding a number of <code>OFFSET</code>s to a null
        <code>POINTER </code> is to <emphasis>subtract_ptrs</emphasis> a null
        <code>POINTER</code> from it.
      </para>

      <para>
        The result will be less than or equal (in the sense of
        <emphasis>pointer_test</emphasis>) to the result of applying
        <emphasis>add_to_ptr</emphasis> to the original pointer from which
        <emphasis>p</emphasis> is derived and the size of the space allocated
        for the original pointer.
      </para>

      <para>
        <emphasis>In the simple representation of <code>POINTER</code>
        arithmetic (see <!-- TODO link to 7.13. Memory Model -->Memory
        Model<!-- end link -->) add_to_ptr is represented by addition. The
        constraint <quote>x includes y</quote> ensures that no padding has to
        be inserted in this case.</emphasis>
      </para>
    </section>

    <section id="C5S16.5">
      <title>and</title>

      <emphasis role="bold">Encoding number</emphasis>: 5

      <programlisting language="TDF">
      arg1:            EXP INTEGER(v)
      arg2:            EXP INTEGER(v)
                 -&gt; EXP INTEGER(v)</programlisting>

      <para>
        The arguments are evaluated producing integer values of the same
        <code>VARIETY</code>, <emphasis>v</emphasis>. The result is the bitwise
        <emphasis>and</emphasis> of the two values in the representing
        <code>VARIETY</code>. The result is delivered with the same
        <code>SHAPE</code> as the arguments.
      </para>

      <para>
        See <!-- TODO link to 7.18. Representing integers -->Representing
        integers<!-- link end -->.
      </para>
    </section>

    <section id="C5S16.6">
      <title>apply_proc</title>

      <emphasis role="bold">Encoding number</emphasis>: 6

      <programlisting language="TDF">
      result_shape:    SHAPE
      p:               EXP PROC
      params:          LIST(EXP)
      var_param:       OPTION(EXP)
                 -&gt; EXP result_shape</programlisting>

      <para>
        <emphasis>p, params</emphasis> and <emphasis>var_param</emphasis> (if
        present) are evaluated in any interleaved order. The procedure,
        <emphasis>p</emphasis>, is applied to the parameters. The result of the
        procedure call, which will have <emphasis>result_shape</emphasis>, is
        delivered as the result of the construction.
      </para>

      <para>
        The canonical order of evaluation is as if the definition were in-lined.
        That is, the actual parameters are evaluated interleaved in any order
        and used to initialise variables which are identified by the formal
        parameters during the evaluation of the procedure body. When this is
        complete the body is evaluated. So <emphasis>apply_proc</emphasis> is
        evaluated like a <emphasis>variable</emphasis> construction, and obeys
        similar rules for order of evaluation.
      </para>

      <para>
        If <emphasis>p</emphasis> delivers a null procedure the effect is
        undefined.
      </para>

      <para>
        <emphasis>var_param</emphasis> is intended to communicate parameters
        which vary in <code>SHAPE</code> from call to call. Access to these
        parameters during the procedure is performed by using
        <code>OFFSET</code> arithmetic.  Note that it is necessary to place
        these values on <emphasis>var_param_alignment</emphasis> because of the
        definition of <emphasis>make_proc</emphasis>.
      </para>

      <para>
        The optional <emphasis>var_param</emphasis> should not be confused with
        variable argument lists in the C (<emphasis>&lt;stdarg.h&gt;</emphasis>
        or <emphasis>&lt;varargs.h&gt;</emphasis>) sense, which are communicated
        by extending the <emphasis>params</emphasis> list.  This is discussed
        further in <!-- TODO link to 7.9. Procedures -->section 7.9<!-- end link
        -->. If the number of arguments in the <emphasis>params</emphasis> list
        differs from the number of elements in the
        <emphasis>params_intro</emphasis> of the corresponding
        <emphasis>make_proc</emphasis>, then <emphasis>var_param</emphasis> must
        not be present.
      </para>

      <para>
        All calls to the same procedure will yield results of the same
        <code>SHAPE</code>.
      </para>

      <para>
        For notes on the intended implementation of procedures see <!-- TODO
        link to 7.9. Procedures -->section 7.9<!-- end link -->.
      </para>
    </section>

    <section id="C5S16.7">
      <title>apply_general_proc</title>

      <emphasis role="bold">Encoding number</emphasis>: 7

      <programlisting language="TDF">
      result_shape:    SHAPE
      prcprops:        OPTION(PROCPROPS)
      p:               EXP PROC
      callers_intro:   LIST(OTAGEXP)
      callee_pars:     CALLEES
      postlude:        EXP TOP
                 -&gt; EXP result_shape</programlisting>

      <para>
        <emphasis>p</emphasis>, <emphasis>callers_intro</emphasis> and
        <emphasis>callee_pars</emphasis> are evaluated in any order. The
        procedure, <emphasis>p</emphasis>, is applied to the parameters.  The
        result of the procedure call, which will have
        <emphasis>result_shape</emphasis>, is delivered as the result of the
        construction.
      </para>

      <para>
        If <emphasis>p</emphasis> delivers a null procedure the effect is
        undefined.
      </para>

      <para>
        Any <code>TAG</code> introduced by an <code>OTAGEXP</code> in
        <emphasis>callers_intro</emphasis> is available in
        <emphasis>postlude</emphasis> which will be evaluated after the
        application.
      </para>

      <para>
        <emphasis>postlude</emphasis> will not contain any
        <emphasis>local_allocs</emphasis> or calls of procedures with untidy
        returns. If <emphasis>prcprops</emphasis> include
        <emphasis>untidy</emphasis>, <emphasis>postlude</emphasis> will be
        <emphasis>make_top</emphasis>.
      </para>

      <para>
        The canonical order of evaluation is as if the definition of
        <emphasis>p</emphasis> were inlined in a manner dependent on
        <emphasis>prcprops</emphasis>.
      </para>

      <para>
        If none of the <code>PROCPROPS</code> <emphasis>var_callers</emphasis>,
        <emphasis>var_callees</emphasis> and <emphasis>check_stack</emphasis>
        are present the inlining is as follows, supposing that P is the body of
        the definition of <emphasis>p</emphasis>:
      </para>

      <para>
        Let R<emphasis>i</emphasis> be the value of the <code>EXP</code> of the
        i<emphasis>th</emphasis> <code>OTAGEXP</code> in
        <emphasis>callers_intro</emphasis> and T<emphasis>i</emphasis> be its
        <code>TAG</code> (if it is present). Let E<emphasis>i</emphasis> be the
        i<emphasis>th</emphasis> value in
        <emphasis>callee_pars</emphasis>.<sbr/> Let r<emphasis>i</emphasis> be
        the i<emphasis>th</emphasis> formal caller parameter <code>TAG</code> of
        <emphasis>p</emphasis>.<sbr/> Let e<emphasis>i</emphasis> be the
        i<emphasis>th</emphasis> formal callee parameter <code>TAG</code> of
        <emphasis>p</emphasis>.
      </para>

      <para>
        Each R<emphasis>i</emphasis> is used to initialise a variable which is
        identified by r<emphasis>i</emphasis>; there will be exactly as many
        R<emphasis>i</emphasis> as r<emphasis>i</emphasis>.The scope of these
        variable definitions is a sequence consisting of three components - the
        identification of a <code>TAG</code> <emphasis>res</emphasis> with the
        result of a binding of P, followed by a binding of
        <emphasis>postlude</emphasis>, followed by an
        <emphasis>obtain_tag</emphasis> of <emphasis>res</emphasis> giving the
        result of the inlined procedure call.
      </para>

      <para>
        The binding of P consists of using each E<emphasis>i</emphasis> to
        initialise a variable identified with e<emphasis>i</emphasis>; there
        will be exactly as many E<emphasis>i</emphasis> as
        e<emphasis>i</emphasis>. The scope of these variable definitions is P
        modified so that the first <emphasis>return</emphasis> or
        <emphasis>untidy_return</emphasis> encountered in P gives the result of
        the binding. If it ends with a <emphasis>return</emphasis>, any space
        generated by <emphasis>local_allocs</emphasis> within the binding is
        freed (in the sense of <emphasis>local_free</emphasis>) at this point.
        If it ends with <emphasis>untidy_return</emphasis>, no freeing will take
        place.
      </para>

      <para>
        The binding of <emphasis>postlude</emphasis> consists of identifying
        each T<emphasis>i</emphasis> (if present) with the contents of the
        variable identified by r<emphasis>i</emphasis>.  The scope of these
        identifications is <emphasis>postlude</emphasis>.
      </para>

      <para>
        If the <code>PROCPROPS</code> <emphasis>var_callers</emphasis> is
        present, the inlining process is modified by:<sbr/> A compound variable
        is constructed initialised to R<emphasis>i</emphasis> in order; the
        alignment and padding of each individual R<emphasis>i</emphasis> will be
        given by an exact application of
        <emphasis>parameter_alignment</emphasis> on the <code>SHAPE</code> of
        R<emphasis>i</emphasis>. Each r<emphasis>i</emphasis> is then identified
        with a pointer to the copy of R<emphasis>i</emphasis> within the
        compound variable; there will be at least as many
        R<emphasis>i</emphasis> as r<emphasis>i</emphasis>. The evaluation then
        continues as above with the scope of these identifications being the
        sequence.
      </para>

      <para>
        If the <code>PROCPROPS</code> <emphasis>var_callees</emphasis> is
        present, the inlining process is modified by:<sbr/> The binding of P is
        done by generating (as if by <emphasis>local_alloc</emphasis>) a pointer
        to space for a compound value constructed from each
        E<emphasis>i</emphasis> in order (just as for
        <emphasis>var_callers</emphasis>). Each e<emphasis>i</emphasis> is
        identified with a pointer to the copy of E<emphasis>i</emphasis> within
        the generated space; there will be at least as many
        e<emphasis>i</emphasis> as E<emphasis>i</emphasis>. P is evaluated
        within the scope of these identifications as before. Note that the
        generation of space for these callee parameters is a
        <emphasis>local_alloc</emphasis> with the binding of P, and hence will
        not be freed if P ends with an <emphasis>untidy_return</emphasis>.
      </para>
    </section>

    <section id="C5S16.8">
      <title>assign</title>

      <emphasis role="bold">Encoding number</emphasis>: 8

      <programlisting language="TDF">
      arg1:            EXP POINTER(x)
      arg2:            EXP y
                 -&gt; EXP TOP</programlisting>

      <para>
        The value produced by <emphasis>arg2</emphasis> will be put in the space
        indicated by <emphasis>arg1</emphasis>.
      </para>

      <para>
        <emphasis>x</emphasis> will include
        <emphasis>alignment</emphasis>(<emphasis>y</emphasis>).
      </para>

      <para>
        <emphasis>y</emphasis> will not be a <code>BITFIELD</code>.
      </para>

      <para>
        If the space which the pointer indicates does not lie wholly within the
        space indicated by the original pointer from which it is derived, the
        effect is undefined.
      </para>

      <para>
        If the value delivered by <emphasis>arg1</emphasis> is a null pointer
        the effect is undefined.
      </para>

      <para>
        See <!-- TODO link to 7.16. Overlapping -->Overlapping<!-- link end -->
        and <!-- TODO link to 7.17. Incomplete assignment -->Incomplete
        assignment<!-- link end -->.
      </para>

      <para>
        <emphasis>The constraint <quote>x will include alignment(y)</quote>
        ensures in the simple memory model that no change is needed to the
        <code>POINTER</code>.</emphasis>
      </para>
    </section>

    <section id="C5S16.9">
      <title>assign_with_mode</title>

      <emphasis role="bold">Encoding number</emphasis>: 9

      <programlisting language="TDF">
      md:              TRANSFER_MODE
      arg1:            EXP POINTER(x)
      arg2:            EXP y
                 -&gt; EXP TOP</programlisting>

      <para>
        The value produced by <emphasis>arg2</emphasis> will be put in the space
        indicated by <emphasis>arg1</emphasis>. The assignment will be carried
        out as specified by the <code>TRANSFER_MODE</code> (q.v.).
      </para>

      <para>
        If <emphasis>md</emphasis> consists of
        <emphasis>standard_transfer_mode</emphasis> only, then
        <emphasis>assign_with_mode</emphasis> is the same as
        <emphasis>assign</emphasis>.
      </para>

      <para>
        <emphasis>x</emphasis> will include
        <emphasis>alignment</emphasis>(<emphasis>y</emphasis>).
      </para>

      <para>
        <emphasis>y</emphasis> will not be a <code>BITFIELD</code>.
      </para>

      <para>
        If the space which the pointer indicates does not lie wholly within the
        space indicated by the original pointer from which it is derived, the
        effect is undefined.
      </para>

      <para>
        If the value delivered by <emphasis>arg1</emphasis> is a null pointer
        the effect is undefined.
      </para>

      <para>
        See <!-- TODO link to 7.16. Overlapping -->Overlapping<!-- end link -->
        and <!-- TODO link to 7.17. Incomplete assignment -->Incomplete
        assignment<!-- link end -->.
      </para>
    </section>

    <section id="C5S16.10">
      <title>bitfield_assign</title>

      <emphasis role="bold">Encoding number</emphasis>: 10

      <programlisting language="TDF">
      arg1:            EXP POINTER(x)
      arg2:            EXP OFFSET(y, z)
      arg3:            EXP BITFIELD(v)
                 -&gt; EXP TOP</programlisting>

      <para>
        The value delivered by <emphasis>arg3</emphasis> is assigned at a
        displacement given by <emphasis>arg2</emphasis> from the pointer
        delivered by <emphasis>arg1</emphasis>.
      </para>

      <para>
        <emphasis>x</emphasis> will include <emphasis>y</emphasis> and
        <emphasis>z</emphasis> will include <emphasis>v</emphasis>.
      </para>

      <para>
        <emphasis>arg2</emphasis>, <code>BITFIELD</code>(<emphasis>v</emphasis>)
        will be <emphasis>variety-enclosed</emphasis> (see <!-- TODO link to
        7.24. Representing bitfields -->section 7.24<!-- end link -->).
      </para>
    </section>

    <section id="C5S16.11">
      <title>bitfield_assign_with_mode</title>

      <emphasis role="bold">Encoding number</emphasis>: 11

      <programlisting language="TDF">
      md:              TRANSFER_MODE
      arg1:            EXP POINTER(x)
      arg2:            EXP OFFSET(y, z)
      arg3:            EXP BITFIELD(v)
                 -&gt; EXP TOP</programlisting>

      <para>
        The value delivered by <emphasis>arg3</emphasis> is assigned at a
        displacement given by <emphasis>arg2</emphasis> from the pointer
        delivered by <emphasis>arg1</emphasis>.The assignment will be carried
        out as specified by the <code>TRANSFER_MODE</code> (q.v.).
      </para>

      <para>
        If <emphasis>md</emphasis> consists of
        <emphasis>standard_transfer_mode</emphasis> only, then
        <emphasis>bitfield_assign_with_mode</emphasis> is the same as
        <emphasis>bitfield_assign</emphasis>.
      </para>

      <para>
        <emphasis>arg2</emphasis>, <code>BITFIELD</code>(<emphasis>v</emphasis>)
        will be <emphasis>variety-enclosed</emphasis>.(see <!-- TODO link to
        7.24. Representing bitfields -->section 7.24<!-- link end -->).
      </para>
    </section>

    <section id="C5S16.12">
      <title>bitfield_contents</title>

      <emphasis role="bold">Encoding number</emphasis>: 12

      <programlisting language="TDF">
      v:               BITFIELD_VARIETY
      arg1:            EXP POINTER(x)
      arg2:            EXP OFFSET(y, z)
                 -&gt; EXP BITFIELD(v)</programlisting>

      <para>
        The bitfield of <code>BITFIELD_VARIETY</code> <emphasis>v</emphasis>,
        located at the displacement delivered by <emphasis>arg2</emphasis> from
        the pointer delivered by <emphasis>arg1</emphasis> is extracted and
        delivered.
      </para>

      <para>
        <emphasis>x</emphasis> will include <emphasis>y</emphasis> and
        <emphasis>z</emphasis> will include <emphasis>v</emphasis>.
      </para>

      <para>
        <emphasis>arg2</emphasis>, <code>BITFIELD</code>(<emphasis>v</emphasis>)
        will be <emphasis>variety_enclosed</emphasis> (see <!-- TODO link to
        7.24. Representing bitfields -->section 7.24<!-- end link -->).
      </para>
    </section>

    <section id="C5S16.13">
      <title>bitfield_contents_with_mode</title>

      <emphasis role="bold">Encoding number</emphasis>: 13

      <programlisting language="TDF">
      md:              TRANSFER_MODE
      v:               BITFIELD_VARIETY
      arg1:            EXP POINTER(x)
      arg2:            EXP OFFSET(y, z)
                 -&gt; EXP BITFIELD(v)</programlisting>

      <para>
        The bitfield of <code>BITFIELD_VARIETY </code><emphasis>v</emphasis>,
        located at the displacement delivered by <emphasis>arg2</emphasis> from
        the pointer delivered by <emphasis>arg1</emphasis> is extracted and
        delivered.The operation will be carried out as specified by the
        <code>TRANSFER_MODE</code> (q.v.).
      </para>

      <para>
        If <emphasis>md</emphasis> consists of
        <emphasis>standard_transfer_mode</emphasis> only, then
        <emphasis>bitfield_contents_with_mode</emphasis> is the same as
        <emphasis>bitfield_contents</emphasis>.
      </para>

      <para>
        <emphasis>x</emphasis> will include <emphasis>y</emphasis> and
        <emphasis>z</emphasis> will include <emphasis>v</emphasis>.
      </para>

      <para>
        <emphasis>arg2</emphasis>, <code>BITFIELD</code>(<emphasis>v</emphasis>)
        will be <emphasis>variety_enclosed</emphasis> (see <!-- TODO link to
        7.24.  Representing bitfields -->section 7.24<!-- end link -->).
      </para>
    </section>

    <section id="C5S16.14">
      <title>case</title>

      <emphasis role="bold">Encoding number</emphasis>: 14

      <programlisting language="TDF">
      exhaustive:      BOOL
      control: EXP INTEGER(v)
      branches:        LIST(CASELIM)
                 -&gt; EXP (exhaustive ? BOTTOM : TOP)</programlisting>

      <para>
        <emphasis>control</emphasis> is evaluated to produce an integer value,
        <emphasis>c</emphasis>. Then <emphasis>c</emphasis> is tested to see if
        it lies inclusively between <emphasis>lower</emphasis> and
        <emphasis>upper</emphasis>, for each element of
        <emphasis>branches</emphasis>. If this tests succeeds, control passes to
        the label <emphasis>branch</emphasis> belonging to that
        <code>CASELIM</code> (see <!-- TODO link to 5.13. CASELIM -->section
        5.13<!-- end link -->). If <emphasis>c</emphasis> lies between no pair,
        the construct delivers a value of <code>SHAPE TOP</code>. The order in
        which the comparisons are made is undefined.
      </para>

      <para>
        The sets of <code>SIGNED_NAT</code>s in <emphasis>branches</emphasis>
        will be disjoint.
      </para>

      <para>
        If <emphasis>exhaustive</emphasis> is true the value delivered by
        <emphasis>control</emphasis> will lie between one of the
        <emphasis>lower</emphasis>/<emphasis>upper</emphasis> pairs.
      </para>
    </section>

    <section id="C5S16.15">
      <title>change_bitfield_to_int</title>

      <emphasis role="bold">Encoding number</emphasis>: 15

      <programlisting language="TDF">
      v:               VARIETY
      arg1:            EXP BITFIELD(bv)
                 -&gt; EXP INTEGER(v)</programlisting>

      <para>
        <emphasis>arg1</emphasis> is evaluated and converted to a
        <code>INTEGER</code>(<emphasis>v</emphasis>).
      </para>

      <para>
        If <emphasis>arg1</emphasis> exceed the bounds of
        <emphasis>v</emphasis>, the effect is undefined.
      </para>
    </section>

    <section id="C5S16.16">
      <title>change_floating_variety</title>

      <emphasis role="bold">Encoding number</emphasis>: 16

      <programlisting language="TDF">
      flpt_err:        ERROR_TREATMENT
      r:               FLOATING_VARIETY
      arg1:            EXP FLOATING(f)
                 -&gt; EXP FLOATING(r)</programlisting>

      <para>
        <emphasis>arg1</emphasis> is evaluated and will produce floating point
        value, <emphasis>fp</emphasis>. The value <emphasis>fp</emphasis> is
        delivered, changed to the representation of the
        <code>FLOATING_VARIETY</code> <emphasis>r</emphasis>.
      </para>

      <para>
        Either <emphasis>r</emphasis> and <emphasis>f</emphasis> will both real
        or both complex.
      </para>

      <para>
        If there is a floating point error it is handled by
        <emphasis>flpt_err</emphasis>.
      </para>

      <para>
        See <!-- TODO link to 7.21. Floating point errors -->Floating point
        errors<!-- end link -->.
      </para>
    </section>

    <section id="C5S16.17">
      <title>change_variety</title>

      <emphasis role="bold">Encoding number</emphasis>: 17

      <programlisting language="TDF">
      ov_err:          ERROR_TREATMENT
      r:               VARIETY
      arg1:            EXP INTEGER(v)
                 -&gt; EXP INTEGER(r)</programlisting>

      <para>
        <emphasis>arg1</emphasis> is evaluated and will produce an integer
        value, <emphasis>a</emphasis>.  The value <emphasis>a</emphasis> is
        delivered, changed to the representation of the <code>VARIETY</code>
        <emphasis>r</emphasis>.
      </para>

      <para>
        If <emphasis>a</emphasis> is not contained in the <code>VARIETY</code>
        being used to represent <emphasis>r</emphasis>, an overflow occurs and
        is handled according to <emphasis>ov_err</emphasis>.
      </para>
    </section>

    <section id="C5S16.18">
      <title>change_int_to_bitfield</title>

      <emphasis role="bold">Encoding number</emphasis>: 18

      <programlisting language="TDF">
      bv:              BITFIELD_VARIETY
      arg1:            EXP INTEGER(v)
                 -&gt; EXP BITFIELD(bv)</programlisting>

      <para>
        <emphasis>arg1</emphasis> is evaluated and converted to a
        <code>BITFIELD</code>(<emphasis>bv</emphasis>).
      </para>

      <para>
        If <emphasis>arg1</emphasis> exceed the bounds of
        <emphasis>bv</emphasis>, the effect is undefined.
      </para>
    </section>

    <section id="C5S16.19">
      <title>complex_conjugate</title>

      <emphasis role="bold">Encoding number</emphasis>: 19

      <programlisting language="TDF">
      c:               EXP FLOATING(cv)
                 -&gt; EXP FLOATING(cv)</programlisting>

      <para>
        Delivers the complex conjugate of <emphasis>c</emphasis>.
      </para>

      <para>
        <emphasis>cv</emphasis> will be a complex floating variety.
      </para>
    </section>

    <section id="C5S16.20">
      <title>component</title>

      <emphasis role="bold">Encoding number</emphasis>: 20

      <programlisting language="TDF">
      sha:             SHAPE
      arg1:            EXP COMPOUND(EXP OFFSET(x, y))
      arg2:            EXP OFFSET(x, alignment(sha))
                 -&gt; EXP sha</programlisting>

      <para>
        <emphasis>arg1</emphasis> is evaluated to produce a
        <code>COMPOUND</code> value.  The component of this value at the
        <code>OFFSET</code> given by <emphasis>arg2</emphasis> is delivered.
        This will have <code>SHAPE</code> <emphasis>sha</emphasis>.
      </para>

      <para>
        <emphasis>arg2</emphasis> will be a constant and non-negative (see <!--
        TODO link to 7.3. Constant evaluation -->Constant evaluation<!-- end
        link -->).
      </para>

      <para>
        If <emphasis>sha</emphasis> is a <code>BITFIELD</code> then
        <emphasis>arg2</emphasis>, <emphasis>sha</emphasis> will be
        <emphasis>variety_enclosed</emphasis> (see <!-- TODO link to 7.24.
        Representing bitfields -->section 7.24<!-- end link -->).
      </para>
    </section>

    <section id="C5S16.21">
      <title>concat_nof</title>

      <emphasis role="bold">Encoding number</emphasis>: 21

      <programlisting language="TDF">
      arg1:            EXP NOF(n, s)
      arg2:            EXP NOF(m, s)
                 -&gt; EXP NOF(n+m, s)</programlisting>

      <para>
        <emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated
        and their results concatenated. In the result the components derived
        from <emphasis>arg1</emphasis> will have lower indices than those
        derived from <emphasis>arg2</emphasis>.
      </para>
    </section>

    <section id="C5S16.22">
      <title>conditional</title>

      <emphasis role="bold">Encoding number</emphasis>: 22

      <programlisting language="TDF">
      altlab_intro:    LABEL
      first:           EXP x
      alt:             EXP z
                 -&gt; EXP (x LUB z)</programlisting>

      <para>
        <emphasis>first</emphasis> is evaluated. If <emphasis>first</emphasis>
        produces a result, <emphasis>f</emphasis>, this value is delivered as
        the result of the whole construct, and <emphasis>alt</emphasis> is not
        evaluated.
      </para>

      <para>
        If <emphasis>goto</emphasis>(<emphasis>altlab_intro</emphasis>) or any
        other jump (including <emphasis>long_jump</emphasis>) to
        <emphasis>altlab_intro</emphasis> is obeyed during the evaluation of
        <emphasis>first</emphasis>, then the evaluation of
        <emphasis>first</emphasis> will stop, <emphasis>alt</emphasis> will be
        evaluated and its result delivered as the result of the construction.
      </para>

      <para>
        The lifetime of <emphasis>altlab_intro</emphasis> is the evaluation of
        <emphasis>first</emphasis>. <emphasis>altlab_intro</emphasis> will not
        be used within <emphasis>alt</emphasis>.
      </para>

      <para>
        The actual order of evaluation of the constituents shall be
        indistinguishable in all observable effects (apart from time) from
        evaluating all the obeyed parts of <emphasis>first</emphasis> before any
        obeyed part of <emphasis>alt</emphasis>.  Note that this specifically
        includes any defined error handling.
      </para>

      <para>
        For LUB see <!-- TODO link to 7.26. Least Upper Bound -->Least Upper
        Bound<!-- link end -->.
      </para>
    </section>

    <section id="C5S16.23">
      <title>contents</title>

      <emphasis role="bold">Encoding number</emphasis>: 23

      <programlisting language="TDF">
      s:               SHAPE
      arg1:            EXP POINTER(x)
                 -&gt; EXP s</programlisting>

      <para>
        A value of <code>SHAPE</code> <emphasis>s</emphasis> will be extracted
        from the start of the space indicated by the pointer, and this is
        delivered.
      </para>

      <para>
        <emphasis>x</emphasis> will include
        <emphasis>alignment</emphasis>(<emphasis>s</emphasis>).
      </para>

      <para>
        <emphasis>s</emphasis> will not be a <code>BITFIELD</code>.
      </para>

      <para>
        If the space which the pointer indicates does not lie wholly within the
        space indicated by the original pointer from which it is derived, the
        effect is undefined.
      </para>

      <para>
        If the value delivered by <emphasis>arg1</emphasis> is a null pointer
        the effect is undefined.
      </para>

      <para>
        <emphasis>The constraint <quote>x will include alignment(s)</quote>
        ensures in the simple memory model that no change is needed to the
        <code>POINTER</code>.</emphasis>
      </para>
    </section>

    <section id="C5S16.24">
      <title>contents_with_mode</title>

      <emphasis role="bold">Encoding number</emphasis>: 24

      <programlisting language="TDF">
      md:              TRANSFER_MODE
      s:               SHAPE
      arg1:            EXP POINTER(x)
                 -&gt; EXP s</programlisting>

      <para>
        A value of <code>SHAPE</code> <emphasis>s</emphasis> will be extracted
        from the start of the space indicated by the pointer, and this is
        delivered. The operation will be carried out as specified by the
        <code>TRANSFER_MODE</code> (q.v.).
      </para>

      <para>
        If <emphasis>md</emphasis> consists of
        <emphasis>standard_transfer_mode</emphasis> only, then
        <emphasis>contents_with_mode</emphasis> is the same as
        <emphasis>contents</emphasis>.
      </para>

      <para>
        <emphasis>x</emphasis> will include
        <emphasis>alignment</emphasis>(<emphasis>s</emphasis>).
      </para>

      <para>
        <emphasis>s</emphasis> will not be a <code>BITFIELD</code>.
      </para>

      <para>
        If the space which the pointer indicates does not lie wholly within the
        space indicated by the original pointer from which it is derived, the
        effect is undefined.
      </para>

      <para>
        If the value delivered by <emphasis>arg1</emphasis> is a null pointer
        the effect is undefined.
      </para>
    </section>

    <section id="C5S16.25">
      <title>current_env</title>

      <emphasis role="bold">Encoding number</emphasis>: 25

      <programlisting language="TDF">
                 -&gt; EXP POINTER(fa)</programlisting>

      <para>
        A value of <code>SHAPE POINTER</code>(<emphasis>fa</emphasis>) is
        created and delivered.  It gives access to the variables, identities and
        parameters in the current procedure activation which are declared as
        having <code>ACCESS</code> <emphasis>visible</emphasis>.
      </para>

      <para>
        If the immediately enclosing procedure is defined by
        <emphasis>make_general_proc</emphasis>, then <emphasis>fa</emphasis> is
        the set union of <emphasis>local_alignment</emphasis> and the alignments
        of the kinds of parameters defined. That is to say, if there are caller
        parameters, then the alignment includes
        <emphasis>callers_alignment</emphasis>(<emphasis>x</emphasis>) where
        <emphasis>x</emphasis> is true if and only if the <code>PROCPROPS</code>
        <emphasis>var_callers</emphasis> is present; if there are callee
        parameters, the alignment includes
        <emphasis>callees_alignment</emphasis>(<emphasis>x</emphasis>) where
        <emphasis>x</emphasis> is true if and only if the <code>PROCPROPS</code>
        <emphasis>var_callees</emphasis> is present.
      </para>

      <para>
        If the immediately enclosing procedure is defined by
        <emphasis>make_proc</emphasis>, then <emphasis>fa</emphasis> = {
        <emphasis>locals_alignment</emphasis>,
        <emphasis>callers_alignment</emphasis>(<emphasis>false</emphasis>) }.
      </para>

      <para>
        If an <code>OFFSET</code> produced by <emphasis>env_offset</emphasis> is
        added to a <code>POINTER</code> produced by
        <emphasis>current_env</emphasis> from an activation of the procedure
        which contains the declaration of the <code>TAG</code> used by
        <emphasis>env_offset</emphasis>, then the result is an original
        <code>POINTER</code>, notwithstanding the normal rules for
        <emphasis>add_to_ptr</emphasis> (see <!-- TODO link to 7.15. Original
        pointers -->Original pointers<!-- link end -->).
      </para>

      <para>
        If an <code>OFFSET</code> produced by env_offset is added to such a
        pointer from an inappropriate procedure the effect is undefined.
      </para>
    </section>

    <section id="C5S16.26">
      <title>div0</title>

      <emphasis role="bold">Encoding number</emphasis>: 26

      <programlisting language="TDF">
      div_by_0_err:    ERROR_TREATMENT
      ov_err:          ERROR_TREATMENT
      arg1:            EXP INTEGER(v)
      arg2:            EXP INTEGER(v)
                 -&gt; EXP INTEGER(v)</programlisting>

      <para>
        <emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated
        and will produce integer values, <emphasis>a</emphasis> and
        <emphasis>b</emphasis>, of the same <code>VARIETY</code>,
        <emphasis>v</emphasis>. Either the value <emphasis>a</emphasis> D1
        <emphasis>b</emphasis> or the value <emphasis>a</emphasis> D2
        <emphasis>b</emphasis> is delivered as the result of the construct, with
        the same <code>SHAPE</code> as the arguments. Different occurrences of
        <emphasis>div0</emphasis> in the same capsule can use D1 or D2
        independently.
      </para>

      <para>
        If <emphasis>b</emphasis> is zero a div_by_zero error occurs and is
        handled by <emphasis>div_by_0_err</emphasis>.
      </para>

      <para>
        If <emphasis>b</emphasis> is not zero and the result cannot be expressed
        in the <code>VARIETY</code> being used to represent
        <emphasis>v</emphasis> an overflow occurs and is handled by
        <emphasis>ov_err</emphasis>.
      </para>

      <para>
        Producers may assume that shifting and <emphasis>div0</emphasis> by a
        constant which is a power of two yield equally good code.
      </para>

      <para>
        See <!-- TODO link to 7.4. Division and modulus -->Division and
        modulus<!-- end link --> for the definitions of D1, D2, M1 and M2.
      </para>
    </section>

    <section id="C5S16.27">
      <title>div1</title>

      <emphasis role="bold">Encoding number</emphasis>: 27

      <programlisting language="TDF">
      div_by_0_err:    ERROR_TREATMENT
      ov_err:          ERROR_TREATMENT
      arg1:            EXP INTEGER(v)
      arg2:            EXP INTEGER(v)
                 -&gt; EXP INTEGER(v)</programlisting>

      <para>
        <emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated
        and will produce integer values, <emphasis>a</emphasis> and
        <emphasis>b</emphasis>, of the same <code>VARIETY</code>,
        <emphasis>v</emphasis>. The value <emphasis>a</emphasis> D1
        <emphasis>b</emphasis> is delivered as the result of the construct, with
        the same <code>SHAPE</code> as the arguments.
      </para>

      <para>
        If <emphasis>b</emphasis> is zero a div_by_zero error occurs and is
        handled by <emphasis>div_by_0_err</emphasis>.
      </para>

      <para>
        If <emphasis>b</emphasis> is not zero and the result cannot be expressed
        in the <code>VARIETY</code> being used to represent
        <emphasis>v</emphasis> an overflow occurs and is handled by
        <emphasis>ov_err</emphasis>.
      </para>

      <para>
        Producers may assume that shifting and <emphasis>div1</emphasis> by a
        constant which is a power of two yield equally good code.
      </para>

      <para>
        See <!-- TODO link to 7.4. Division and modulus -->Division and
        modulus<!-- end link --> for the definitions of D1, D2, M1 and M2.
      </para>
    </section>

    <section id="C5S16.28">
      <title>div2</title>

      <emphasis role="bold">Encoding number</emphasis>: 28

      <programlisting language="TDF">
      div_by_0_err:    ERROR_TREATMENT
      ov_err:          ERROR_TREATMENT
      arg1:            EXP INTEGER(v)
      arg2:            EXP INTEGER(v)
                 -&gt; EXP INTEGER(v)</programlisting>

      <para>
        <emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated
        and will produce integer values, <emphasis>a</emphasis> and
        <emphasis>b</emphasis>, of the same <code>VARIETY</code>,
        <emphasis>v</emphasis>. The value <emphasis>a</emphasis> D2
        <emphasis>b</emphasis> is delivered as the result of the construct, with
        the same <code>SHAPE</code> as the arguments.
      </para>

      <para>
        If <emphasis>b</emphasis> is zero a div_by_zero error occurs and is
        handled by <emphasis>div_by_0_err</emphasis>.
      </para>

      <para>
        If <emphasis>b</emphasis> is not zero and the result cannot be expressed
        in the <code>VARIETY</code> being used to represent
        <emphasis>v</emphasis> an overflow occurs and is handled by
        <emphasis>ov_err</emphasis>.
      </para>

      <para>
        Producers may assume that shifting and <emphasis>div2</emphasis> by a
        constant which is a power of two yield equally good code if the lower
        bound of <emphasis>v</emphasis> is zero.
      </para>

      <para>
        See <!-- TODO link to 7.4. Division and modulus -->Division and
        modulus<!-- end link --> for the definitions of D1, D2, M1 and M2.
      </para>
    </section>

    <section id="C5S16.29">
      <title>env_offset</title>

      <emphasis role="bold">Encoding number</emphasis>: 29

      <programlisting language="TDF">
      fa:              ALIGNMENT
      y:               ALIGNMENT
      t:               TAG x
                 -&gt; EXP OFFSET(fa, y)</programlisting>

      <para>
        <emphasis>t</emphasis> will be the tag of a
        <emphasis>variable</emphasis>, <emphasis>identify</emphasis> or
        procedure parameter with the <emphasis>visible</emphasis> property
        within a procedure defined by <emphasis>make_general_proc</emphasis> or
        <emphasis>make_proc</emphasis>.
      </para>

      <para>
        If it is defined in a make_general_proc, let P be its associated
        <code>PROCPROPS</code>; otherwise let P be the <code>PROCPROPS</code>
        {<emphasis>locals_alignment</emphasis>,
        <emphasis>caller_alignment</emphasis>(<emphasis>false</emphasis>)}.
      </para>

      <para>
        If <emphasis>t</emphasis> is the <code>TAG</code> of a
        <emphasis>variable</emphasis> or <emphasis>identify, fa</emphasis> will
        contain <emphasis>locals_alignment</emphasis>; if it is a caller
        parameter <emphasis>fa</emphasis> will contain a
        <emphasis>caller_alignment</emphasis>(<emphasis>b</emphasis>) where
        <emphasis>b </emphasis>is true if and only if P contains
        <emphasis>var_callers</emphasis> ; if it is a callee parameter
        <emphasis>fa</emphasis> will contain a
        <emphasis>callee_alignment</emphasis>(<emphasis>b</emphasis>) where
        <emphasis>b</emphasis> is true if and only if P contains
        <emphasis>var_callees</emphasis>.
      </para>

      <para>
        If t is the <code>TAG</code> of a <emphasis>variable</emphasis> or
        parameter, the result is the <code>OFFSET</code> of its position, within
        any procedure environment which derives from the procedure containing
        the declaration of the variable or parameter, relative to its
        environment pointer. In this case <emphasis>x</emphasis> will be
        <code>POINTER</code>(<emphasis>y).</emphasis>
      </para>

      <para>
        If t is the <code>TAG</code> of an <emphasis>identify</emphasis>, the
        result will be an <code>OFFSET</code> of space which holds the value.
        This pointer will not be used to alter the value. In this case
        <emphasis>y</emphasis> will be
        <emphasis>alignment</emphasis>(<emphasis>x</emphasis>).
      </para>

      <para>
        See <!-- TODO link to 7.10. Frames -->section 7.10<!-- link end -->.
      </para>
    </section>

    <section id="C5S16.30">
      <title>env_size</title>

      <emphasis role="bold">Encoding number</emphasis>: 30

      <programlisting language="TDF">
      proctag: TAG PROC
                 -&gt; EXP OFFSET(locals_alignment, {})</programlisting>

      <para>
        Delivers an <code>OFFSET</code> of a space sufficient to contain all the
        variables and identifications, explicit or implicit in the procedure
        identified by <emphasis>proctag</emphasis>. This will not include the
        space required for any <emphasis>local_allocs</emphasis> or procedure
        calls within the procedure.
      </para>

      <para>
        <emphasis>proctag</emphasis> will be defined in the current
        <code>CAPSULE</code> by a <code>TAGDEF</code> identification of a
        <emphasis>make_proc</emphasis> or a
        <emphasis>make_general_proc</emphasis>.
      </para>
    </section>

    <section id="C5S16.31">
      <title>fail_installer</title>

      <emphasis role="bold">Encoding number</emphasis>: 31

      <programlisting language="TDF">
      message: STRING(k, n)
                 -&gt; EXP BOTTOM</programlisting>

      <para>
        Any attempt to use this operation to produce code will result in a
        failure of the installation process. <emphasis>message</emphasis> will
        give information about the reason for this failure which should be
        passed to the installation manager.
      </para>
    </section>

    <section id="C5S16.32">
      <title>float_int</title>

      <emphasis role="bold">Encoding number</emphasis>: 32

      <programlisting language="TDF">
      flpt_err:        ERROR_TREATMENT
      f:               FLOATING_VARIETY
      arg1:            EXP INTEGER(v)
                 -&gt; EXP FLOATING(f)</programlisting>

      <para>
        <emphasis>arg1</emphasis> is evaluated to produce an integer value,
        which is converted to the representation of <emphasis>f</emphasis> and
        delivered.
      </para>

      <para>
        If <emphasis>f</emphasis> is complex the real part of the result will be
        derived from <emphasis>arg1</emphasis> and the imaginary part will be
        zero.
      </para>

      <para>
        If there is a floating point error it is handled by
        <emphasis>flpt_err</emphasis>.  See <!-- TODO link to 7.21. Floating
        point errors -->Floating point errors<!-- link end -->.
      </para>
    </section>

    <section id="C5S16.33">
      <title>floating_abs</title>

      <emphasis role="bold">Encoding number</emphasis>: 33

      <programlisting language="TDF">
      flpt_err:        ERROR_TREATMENT
      arg1:            EXP FLOATING(f)
                 -&gt; EXP FLOATING(f)</programlisting>

      <para>
        <emphasis>arg1</emphasis> is evaluated and will produce a floating point
        value, <emphasis>a</emphasis>, of the <code>FLOATING_VARIETY</code>,
        <emphasis>f</emphasis>. The absolute value of <emphasis>a</emphasis> is
        delivered as the result of the construct, with the same
        <code>SHAPE</code> as the argument.
      </para>

      <para>
        Though <emphasis>floating_abs</emphasis> cannot produce an overflow it
        can give an invalid operand exception which is handled by
        <emphasis>flpt_err</emphasis>.
      </para>

      <para>
        <emphasis>f</emphasis> will not be complex.
      </para>

      <para>
        See also <!-- TODO link to 7.23. Floating point accuracy -->Floating
        point accuracy<!-- link end -->.
      </para>
    </section>

    <section id="C5S16.34">
      <title>floating_div</title>

      <emphasis role="bold">Encoding number</emphasis>: 34

      <programlisting language="TDF">
      flpt_err:        ERROR_TREATMENT
      arg1:            EXP FLOATING(f)
      arg2:            EXP FLOATING(f)
                 -&gt; EXP FLOATING(f)</programlisting>

      <para>
        <emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated
        and will produce floating point values, <emphasis>a</emphasis> and
        <emphasis>b</emphasis>, of the same <code>FLOATING_VARIETY</code>,
        <emphasis>f</emphasis>. The value
        <emphasis>a</emphasis>/<emphasis>b</emphasis> is delivered as the result
        of the construct, with the same <code>SHAPE</code> as the arguments.
      </para>

      <para>
        If there is a floating point error it is handled by
        <emphasis>flpt_err</emphasis>. See <!-- TODO link to 7.21. Floating
        point errors -->Floating point errors<!-- end link -->.
      </para>

      <para>
        See also <!-- TODO link to 7.23. Floating point accuracy -->Floating
        point accuracy<!-- end link -->.
      </para>
    </section>

    <section id="C5S16.35">
      <title>floating_minus</title>

      <emphasis role="bold">Encoding number</emphasis>: 35

      <programlisting language="TDF">
      flpt_err:        ERROR_TREATMENT
      arg1:            EXP FLOATING(f)
      arg2:            EXP FLOATING(f)
                 -&gt; EXP FLOATING(f)</programlisting>

      <para>
        <emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated
        and will produce floating point values, <emphasis>a</emphasis> and
        <emphasis>b</emphasis>, of the same <code>FLOATING_VARIETY</code>,
        <emphasis>f</emphasis>. The value
        <emphasis>a</emphasis>-<emphasis>b</emphasis> is delivered as the result
        of the construct, with the same <code>SHAPE</code> as the arguments.
      </para>

      <para>
        If there is a floating point error it is handled by
        <emphasis>flpt_err</emphasis>. See <!-- TODO link to 7.21. Floating
        point errors -->Floating point errors<!-- end link -->.
      </para>

      <para>
        See also <!-- TODO link to 7.23. Floating point accuracy -->Floating
        point accuracy<!-- end link -->.
      </para>
    </section>

    <section id="C5S16.36">
      <title>floating_maximum</title>

      <emphasis role="bold">Encoding number</emphasis>: 36

      <programlisting language="TDF">
      flpt_err:        ERROR_TREATMENT
      arg1:            EXP FLOATING(f)
      arg2:            EXP FLOATING(f)
                 -&gt; EXP FLOATING(f)</programlisting>

      <para>
        The maximum of the values delivered by <emphasis>arg1</emphasis> and
        <emphasis>arg2</emphasis> is the result. <emphasis>f</emphasis> will not
        be complex.
      </para>

      <para>
        If <emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are
        incomparable, <emphasis>flpt_err</emphasis> will be invoked.
      </para>

      <para>
        See also <!-- TODO link to 7.23. Floating point accuracy -->Floating
        point accuracy<!-- end link -->.
      </para>
    </section>

    <section id="C5S16.37">
      <title>floating_minimum</title>

      <emphasis role="bold">Encoding number</emphasis>: 37

      <programlisting language="TDF">
      flpt_err:        ERROR_TREATMENT
      arg1:            EXP FLOATING(f)
      arg2:            EXP FLOATING(f)
                 -&gt; EXP FLOATING(f)</programlisting>

      <para>
        The minimum of the values delivered by <emphasis>arg1</emphasis> and
        <emphasis>arg2</emphasis> is the result. <emphasis>f</emphasis> will not
        be complex.
      </para>

      <para>
        If <emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are
        incomparable, <emphasis>flpt_err</emphasis> will be invoked.
      </para>

      <para>
        See also <!-- TODO link to 7.23. Floating point accuracy -->Floating
        point accuracy<!-- end link -->.
      </para>
    </section>

    <section id="C5S16.38">
      <title>floating_mult</title>

      <emphasis role="bold">Encoding number</emphasis>: 38

      <programlisting language="TDF">
      flpt_err:        ERROR_TREATMENT
      arg1:            LIST(EXP)
                 -&gt; EXP FLOATING(f)</programlisting>

      <para>
        The arguments, <emphasis>arg1</emphasis>, are evaluated producing
        floating point values all of the same <code>FLOATING_VARIETY</code>,
        <emphasis>f</emphasis>. These values are multiplied in any order and the
        result of this multiplication is delivered as the result of the
        construct, with the same <code>SHAPE</code> as the arguments.
      </para>

      <para>
        If there is a floating point error it is handled by
        <emphasis>flpt_err</emphasis>. See <!-- TODO link to 7.21. Floating
        point errors -->Floating point errors<!-- link end -->.
      </para>

      <para>
        <emphasis>Note that separate floating_mult operations cannot in general
        be combined, because rounding errors need to be controlled.  The reason
        for allowing floating_mult to take a variable number of arguments is to
        make it possible to specify that a number of multiplications can be
        re-ordered.</emphasis>
      </para>

      <para>
        If <emphasis>arg1</emphasis> contains one element the result is the
        value of that element. There will be at least one element in
        <emphasis>arg1</emphasis>.
      </para>

      <para>
        See also <!-- TODO link to 7.23. Floating point accuracy -->Floating
        point accuracy<!-- end link -->.
      </para>
    </section>

    <section id="C5S16.39">
      <title>floating_negate</title>

      <emphasis role="bold">Encoding number</emphasis>: 39

      <programlisting language="TDF">
      flpt_err:        ERROR_TREATMENT
      arg1:            EXP FLOATING(f)
                 -&gt; EXP FLOATING(f)</programlisting>

      <para>
        <emphasis>arg1</emphasis> is evaluated and will produce a floating point
        value, <emphasis>a</emphasis>, of the <code>FLOATING_VARIETY</code>,
        <emphasis>f</emphasis>. The value -<emphasis>a</emphasis> is delivered
        as the result of the construct, with the same <code>SHAPE</code> as the
        argument.
      </para>

      <para>
        Though <emphasis>floating_negate</emphasis> cannot produce an overflow
        it can give an invalid operand exception which is handled by
        <emphasis>flpt_err</emphasis>.
      </para>

      <para>
        See also <!-- TODO link to 7.23. Floating point accuracy -->Floating
        point accuracy<!-- end link -->.
      </para>
    </section>

    <section id="C5S16.40">
      <title>floating_plus</title>

      <emphasis role="bold">Encoding number</emphasis>: 40

      <programlisting language="TDF">
      flpt_err:        ERROR_TREATMENT
      arg1:            LIST(EXP)
                 -&gt; EXP FLOATING(f)</programlisting>

      <para>
        The arguments, <emphasis>arg1</emphasis>, are evaluated producing
        floating point values, all of the same <code>FLOATING_VARIETY</code>,
        <emphasis>f</emphasis>. These values are added in any order and the
        result of this addition is delivered as the result of the construct,
        with the same <code>SHAPE</code> as the arguments.
      </para>

      <para>
        If there is a floating point error it is handled by
        <emphasis>flpt_err</emphasis>.  See <!-- TODO link to 7.21. Floating
        point errors -->Floating point errors<!-- link end -->.
      </para>

      <para>
        <emphasis>Note that separate floating_plus operations cannot in general
        be combined, because rounding errors need to be controlled.  The reason
        for allowing floating_plus to take a variable number of arguments is to
        make it possible to specify that a number of multiplications can be
        re-ordered.</emphasis>
      </para>

      <para>
        If <emphasis>arg1</emphasis> contains one element the result is the
        value of that element. There will be at least one element in
        <emphasis>arg1</emphasis>.
      </para>

      <para>
        See also <!-- TODO link to 7.23. Floating point accuracy -->Floating
        point accuracy<!-- end link -->.
      </para>
    </section>

    <section id="C5S16.41">
      <title>floating_power</title>

      <emphasis role="bold">Encoding number</emphasis>: 41

      <programlisting language="TDF">
      flpt_err:        ERROR_TREATMENT
      arg1:            EXP FLOATING(f)
      arg2:            EXP INTEGER(v)
                 -&gt; EXP FLOATING(f)</programlisting>

      <para>
        The result of <emphasis>arg1</emphasis> is raised to the power given by
        <emphasis>arg2</emphasis>.
      </para>

      <para>
        If there is a floating point error it is handled by
        <emphasis>flpt_err</emphasis>.  See <!-- TODO link to 7.21. Floating
        point errors -->Floating point errors<!-- link end -->.
      </para>

      <para>
        See also <!-- TODO link to 7.23. Floating point accuracy -->Floating
        point accuracy<!-- end link -->.
      </para>
    </section>

    <section id="C5S16.42">
      <title>floating_test</title>

      <emphasis role="bold">Encoding number</emphasis>: 42

      <programlisting language="TDF">
      prob:            OPTION(NAT)
      flpt_err:        ERROR_TREATMENT
      nt:              NTEST
      dest:            LABEL
      arg1:            EXP FLOATING(f)
      arg2:            EXP FLOATING(f)
                 -&gt; EXP TOP</programlisting>

      <para>
        <emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated
        and will produce floating point values, <emphasis>a</emphasis> and
        <emphasis>b</emphasis>, of the same <code>FLOATING_VARIETY</code>,
        <emphasis>f</emphasis>. These values are compared using
        <emphasis>nt</emphasis>.
      </para>

      <para>
        If <emphasis>f</emphasis> is complex then <emphasis>nt</emphasis> will
        be <emphasis>equal</emphasis> or <emphasis>not_equal</emphasis>.
      </para>

      <para>
        If <emphasis>a nt b</emphasis>, this construction yields
        <code>TOP</code>. Otherwise control passes to <emphasis>dest</emphasis>.
      </para>

      <para>
        If <emphasis>prob</emphasis> is present<emphasis>, prob</emphasis>/100
        gives the probability that control will continue to the next construct
        (ie. not pass to <emphasis>dest</emphasis>). If
        <emphasis>prob</emphasis> is absent this probability is unknown.
      </para>

      <para>
        If there is a floating point error it is handled by
        <emphasis>flpt_err</emphasis>.  See <!-- TODO link to 7.21. Floating
        point errors -->Floating point errors<!-- link end -->.
      </para>

      <para>
        See also <!-- TODO link to 7.23. Floating point accuracy -->Floating
        point accuracy<!-- end link -->.
      </para>
    </section>

    <section id="C5S16.43">
      <title>goto</title>

      <emphasis role="bold">Encoding number</emphasis>: 43

      <programlisting language="TDF">
      dest:            LABEL
                 -&gt; EXP BOTTOM</programlisting>

      <para>
        Control passes to the <code>EXP</code> labelled
        <emphasis>dest</emphasis>. This construct will only be used where
        <emphasis>dest</emphasis> is in scope.
      </para>
    </section>

    <section id="C5S16.44">
      <title>goto_local_lv</title>

      <emphasis role="bold">Encoding number</emphasis>: 44

      <programlisting language="TDF">
      arg1:            EXP POINTER({code})
                 -&gt; EXP BOTTOM</programlisting>

      <para>
        <emphasis>arg1</emphasis> is evaluated. The label from which the value
        delivered by <emphasis>arg1</emphasis> was created will be within its
        lifetime and this construction will be obeyed in the same activation of
        the same procedure as the creation of the
        <code>POINTER(</code><emphasis>{code</emphasis><code>})</code> by
        <emphasis>make_local_lv</emphasis>. Control passes to this activation of
        this <code>LABEL</code>.
      </para>

      <para>
        If <emphasis>arg1</emphasis> delivers a null <code>POINTER</code> the
        effect is undefined.
      </para>
    </section>

    <section id="C5S16.45">
      <title>identify</title>

      <emphasis role="bold">Encoding number</emphasis>: 45

      <programlisting language="TDF">
      opt_access:      OPTION(ACCESS)
      name_intro:      TAG x
      definition:      EXP x
      body:            EXP y
                 -&gt; EXP y</programlisting>

      <para>
        <emphasis>definition</emphasis> is evaluated to produce a value,
        <emphasis>v</emphasis>. Then <emphasis>body</emphasis> is evaluated.
        During this evaluation, <emphasis>v</emphasis> is bound to
        <emphasis>name_intro</emphasis>. This means that inside
        <emphasis>body</emphasis> an evaluation of
        <emphasis>obtain_tag</emphasis>(<emphasis>name_intro</emphasis>) will
        produce the value, <emphasis>v</emphasis>.
      </para>

      <para>
        The value delivered by <emphasis>identify</emphasis> is that produced by
        <emphasis>body</emphasis>.
      </para>

      <para>
        The <code>TAG</code> given for <emphasis>name_intro</emphasis> will not
        be reused within the current <code>UNIT</code>. No rules for the hiding
        of one <code>TAG</code> by another are given: this will not happen. The
        lifetime of <emphasis>name_intro</emphasis> is the evaluation of
        <emphasis>body</emphasis>.
      </para>

      <para>
        If <emphasis>opt_access</emphasis> contains
        <emphasis>visible</emphasis>, it means that the value must not be
        aliased while the procedure containing this declaration is not the
        current procedure. Hence if there are any copies of this value they will
        need to be refreshed when the procedure is returned to. The easiest
        implementation when <emphasis>opt_access</emphasis> is
        <emphasis>visible</emphasis> may be to keep the value in memory, but
        this is not a necessary requirement.
      </para>

      <para>
        The order in which the constituents of <emphasis>definition</emphasis>
        and <emphasis>body</emphasis> are evaluated shall be indistinguishable
        in all observable effects (apart from time) from completely evaluating
        <emphasis>definition</emphasis> before starting
        <emphasis>body</emphasis>. See the note about order in <!-- TODO link to
        5.16.107. sequence -->sequence<!-- end link -->.
      </para>
    </section>

    <section id="C5S16.46">
      <title>ignorable</title>

      <emphasis role="bold">Encoding number</emphasis>: 46

      <programlisting language="TDF">
      arg1:            EXP x
                 -&gt; EXP x</programlisting>

      <para>
        If the result of this construction is discarded,
        <emphasis>arg1</emphasis> need not be evaluated, though evaluation is
        permitted. If the result is used it is the result of
        <emphasis>arg1</emphasis>.
      </para>
    </section>

    <section id="C5S16.47">
      <title>imaginary_part</title>

      <emphasis role="bold">Encoding number</emphasis>: 47

      <programlisting language="TDF">
      arg1:            EXP c
                 -&gt; EXP FLOATING (float_of_complex(c))</programlisting>

      <para>
        <emphasis>c</emphasis> will be complex. Delivers the imaginary part of
        the value produced by <emphasis>arg1</emphasis>.
      </para>
    </section>

    <section id="C5S16.48">
      <title>initial_value</title>

      <emphasis role="bold">Encoding number</emphasis>: 48

      <programlisting language="TDF">
      init:            EXP s
                 -&gt; EXP s</programlisting>

      <para>
        Any tag used as an argument of an <emphasis>obtain_tag</emphasis> in
        <emphasis>init</emphasis> will be global or defined within
        <emphasis>init</emphasis>.
      </para>

      <para>
        All labels used in <emphasis>init</emphasis> will be defined within
        <emphasis>init</emphasis>.
      </para>

      <para>
        <emphasis>init</emphasis> will be evaluated once only before any
        procedure application, other than those involved in this or other
        <emphasis>initial_value</emphasis> constructions, but after all
        load-time constant initialisations of TAGDEFs. The result of this
        evaluation is the value of the construction.
      </para>

      <para>
        The order of evaluation of the different
        <emphasis>initial_values</emphasis> in a program is undefined.
      </para>

      <para>
        See <!-- TODO link to 7.29. Dynamic initialisation -->section 7.29<!--
        end link -->.
      </para>
    </section>

    <section id="C5S16.49">
      <title>integer_test</title>

      <emphasis role="bold">Encoding number</emphasis>: 49

      <programlisting language="TDF">
      prob:            OPTION(NAT)
      nt:              NTEST
      dest:            LABEL
      arg1:            EXP INTEGER(v)
      arg2:            EXP INTEGER(v)
                 -&gt; EXP TOP</programlisting>

      <para>
        <emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated
        and will produce integer values, <emphasis>a</emphasis> and
        <emphasis>b</emphasis>, of the same <code>VARIETY</code>,
        <emphasis>v</emphasis>.  These values are compared using
        <emphasis>nt</emphasis>.
      </para>

      <para>
        If <emphasis>a nt b</emphasis>, this construction yields
        <code>TOP</code>. Otherwise control passes to <emphasis>dest</emphasis>.
      </para>

      <para>
        If <emphasis>prob</emphasis> is present, <emphasis>prob</emphasis>/100
        gives the probability that control will continue to the next construct
        (ie. not pass to <emphasis>dest</emphasis>). If
        <emphasis>prob</emphasis> is absent this probability is unknown.
      </para>
    </section>

    <section id="C5S16.50">
      <title>labelled</title>

      <emphasis role="bold">Encoding number</emphasis>: 50

      <programlisting language="TDF">
      labs_intro:      LIST(LABEL)
      starter: EXP x
      places:          LIST(EXP)
                 -&gt; EXP w</programlisting>

      <para>
        The lists <emphasis>labs_intro</emphasis> and
        <emphasis>places</emphasis> shall have the same number of elements.
      </para>

      <para>
        To evaluate the construction <emphasis>starter</emphasis> is evaluated.
        If its evaluation runs to completion producing a value, then this is
        delivered as the result of the whole construction. If a
        <emphasis>goto</emphasis> one of the <code>LABEL</code>s in
        <emphasis>labs_intro</emphasis> or any other jump to one of these
        <code>LABEL</code>s is evaluated, then the evaluation of
        <emphasis>starter</emphasis> stops and the corresponding element of
        <emphasis>places</emphasis> is evaluated. In the canonical ordering all
        the operations which are evaluated from <emphasis>starter</emphasis> are
        completed before any from an element of <emphasis>places</emphasis> is
        started. If the evaluation of the member of <emphasis>places</emphasis>
        produces a result this is the result of the construction.
      </para>

      <para>
        If a jump to any of the <emphasis>labs_intro</emphasis> is obeyed then
        evaluation continues similarly. Such jumping may continue indefinitely,
        but if any <emphasis>places</emphasis> terminates, then the value it
        produces is the value delivered by the construction.
      </para>

      <para>
        The <code>SHAPE</code> <emphasis>w</emphasis> is the LUB of
        <emphasis>x</emphasis> and all the <emphasis>places</emphasis>. See <!--
        TODO link to 7.26. Least Upper Bound -->Least Upper Bound<!-- end link
        -->.
      </para>

      <para>
        The actual order of evaluation of the constituents shall be
        indistinguishable in all observable effects (apart from time) from that
        described above. Note that this specifically includes any defined error
        handling.
      </para>

      <para>
        The lifetime of each of the <code>LABEL</code>s in
        <emphasis>labs_intro</emphasis>, is the evaluation of
        <emphasis>starter</emphasis> and all the elements of
        <emphasis>places</emphasis>.
      </para>
    </section>

    <section id="C5S16.51">
      <title>last_local</title>

      <emphasis role="bold">Encoding number</emphasis>: 51

      <programlisting language="TDF">
      x:               EXP OFFSET(y, z)
                 -&gt; EXP POINTER(alloca_alignment)</programlisting>

      <para>
        If the last use of <emphasis>local_alloc</emphasis> in the current
        activation of the current procedure was after the last use of
        <emphasis>local_free</emphasis> or <emphasis>local_free_all</emphasis>,
        then the value returned is the last <code>POINTER</code> allocated with
        <emphasis>local_alloc</emphasis>.
      </para>

      <para>
        If the last use of <emphasis>local_free</emphasis> in the current
        activation of the current procedure was after the last use of
        <emphasis>local_alloc</emphasis>, then the result is the
        <code>POINTER</code> last allocated which is still active.
      </para>

      <para>
        The <code>ALIGNMENT</code>, <emphasis>alloca_alignment</emphasis>,
        includes the set union of all the <code>ALIGNMENT</code>s which can be
        produced by <emphasis>alignment</emphasis> from any <code>SHAPE</code>.
        See <!-- TODO link to 7.13.4. Special alignments -->Special
        alignments<!-- end link -->.
      </para>
    </section>

    <section id="C5S16.52">
      <title>local_alloc</title>

      <emphasis role="bold">Encoding number</emphasis>: 52

      <programlisting language="TDF">
      arg1:            EXP OFFSET(x, y)
                 -&gt; EXP POINTER(alloca_alignment)</programlisting>

      <para>
        The <emphasis>arg1</emphasis> expression is evaluated and space is
        allocated sufficient to hold a value of the given size. The result is an
        original pointer to this space.
      </para>

      <para>
        <emphasis>x</emphasis> will not consist entirely of bitfield alignments.
      </para>

      <para>
        The initial contents of the space are not specified.
      </para>

      <para>
        This allocation is as if on the stack of the current procedure, and the
        lifetime of the pointer ends when the current activation of the current
        procedure ends with a <emphasis>return</emphasis>,
        <emphasis>return_to_label</emphasis> or <emphasis>tail_call</emphasis>
        or if there is a long jump out of the activation.  Any use of the
        pointer thereafter is undefined. Note the specific exclusion of the
        procedure ending with <emphasis>untidy_return</emphasis>; in this case
        the calling procedure becomes the current activation.
      </para>

      <para>
        The uses of <emphasis>local_alloc</emphasis> within the procedure are
        ordered dynamically as they occur, and this order affects the meaning of
        <emphasis>local_free</emphasis> and <emphasis>last_local</emphasis>.
      </para>

      <para>
        <emphasis>arg1</emphasis> may be a zero <code>OFFSET</code>. In this
        case suppose the result is <emphasis>p</emphasis>. Then a subsequent
        use, in the same activation of the procedure, of
      </para>

      <para>
        <emphasis>local_free</emphasis>(<emphasis>offset_zero</emphasis>(<emphasis>alloca_alignment</emphasis>),
        <emphasis>p</emphasis>)
      </para>

      <para>
        will return the <emphasis>alloca</emphasis> stack to the state it was in
        immediately before the use of <emphasis>local_alloc</emphasis>.
      </para>

      <para>
        Note that if a procedure which uses <emphasis>local_alloc</emphasis> is
        inlined, it may be necessary to use <emphasis>local_free</emphasis> to
        get the correct semantics.
      </para>

      <para>
        See also <!-- TODO link to 7.12. Alloca -->section 7.12<!-- end link
        -->.
      </para>
    </section>

    <section id="C5S16.53">
      <title>local_alloc_check</title>

      <emphasis role="bold">Encoding number</emphasis>: 53

      <programlisting language="TDF">
      arg1:            EXP OFFSET(x, y)
                 -&gt; EXP POINTER(alloca_alignment)</programlisting>

      <para>
        If the <code>OFFSET</code> <emphasis>arg1</emphasis> can be accomodated
        within the limit of the local_alloc stack (see <!-- TODO link to
        5.16.108. set_stack_limit -->section 5.16.108<!-- end link -->), the
        action is precisely the same as <emphasis>local_alloc</emphasis>.
      </para>

      <para>
        If not, normal action is stopped and a TDF exception is raised with
        ERROR_code <emphasis>stack_overflow</emphasis>.
      </para>
    </section>

    <section id="C5S16.54">
      <title>local_free</title>

      <emphasis role="bold">Encoding number</emphasis>: 54

      <programlisting language="TDF">
      a:               EXP OFFSET(x, y)
      p:               EXP POINTER(alloca_alignment)
                 -&gt; EXP TOP</programlisting>

      <para>
        The <code>POINTER</code>, <emphasis>p</emphasis>, will be an original
        pointer to space allocated by <emphasis>local_alloc</emphasis> within
        the current call of the current procedure. It and all spaces allocated
        after it by <emphasis>local_alloc</emphasis> will no longer be used.
        This <code>POINTER</code> will have been created by
        <emphasis>local_alloc</emphasis> with the value of its
        <emphasis>arg1</emphasis> equal to the value of <emphasis>a</emphasis>.
      </para>

      <para>
        Any subsequent use of pointers to the spaces no longer used will be
        undefined.
      </para>
    </section>

    <section id="C5S16.55">
      <title>local_free_all</title>

      <emphasis role="bold">Encoding number</emphasis>: 55

      <programlisting language="TDF">
                 -&gt; EXP TOP</programlisting>

      <para>
        Every space allocated by <emphasis>local_alloc</emphasis> within the
        current call of the current procedure will no longer be used.
      </para>

      <para>
        Any use of a pointer to space allocated before this operation within the
        current call of the current procedure is undefined.
      </para>

      <para>
        Note that if a procedure which uses <emphasis>local_free_all</emphasis>
        is inlined, it may be necessary to use <emphasis>local_free</emphasis>
        to get the correct semantics.
      </para>
    </section>

    <section id="C5S16.56">
      <title>long_jump</title>

      <emphasis role="bold">Encoding number</emphasis>: 56

      <programlisting language="TDF">
      arg1:            EXP POINTER(fa)
      arg2:            EXP POINTER({code})
                 -&gt; EXP BOTTOM</programlisting>

      <para>
        <emphasis>arg1</emphasis> will be a pointer produced by an application
        of <emphasis>curent_env</emphasis> in a currently active procedure.
      </para>

      <para>
        The frame produced by <emphasis>arg1</emphasis> is reinstated as the
        current procedure. This frame will still be active. Evaluation
        recommences at the label given by <emphasis>arg2</emphasis>. This
        operation will only be used during the lifetime of that label.
      </para>

      <para>
        Only <code>TAG</code>s declared to have
        <emphasis>long_jump_access</emphasis> will be defined at the re-entry.
      </para>

      <para>
        If <emphasis>arg2</emphasis> delivers a null
        <code>POINTER(</code>{<emphasis>code</emphasis><code>})</code> the
        effect is undefined.
      </para>
    </section>

    <section id="C5S16.57">
      <title>make_complex</title>

      <emphasis role="bold">Encoding number</emphasis>: 57

      <programlisting language="TDF">
      c:               FLOATING_VARIETY
      arg1:            EXP FLOATING(f)
      arg2:            EXP FLOATING(f)
                 -&gt; EXP FLOATING(c)</programlisting>

      <para>
        <emphasis>c</emphasis> will be complex and derived from the same
        parameters as <emphasis>f</emphasis>.
      </para>

      <para>
        Delivers a complex number with <emphasis>arg1</emphasis> delivering the
        real part and <emphasis>arg2</emphasis> the imaginary.
      </para>
    </section>

    <section id="C5S16.58">
      <title>make_compound</title>

      <emphasis role="bold">Encoding number</emphasis>: 58

      <programlisting language="TDF">
      arg1:            EXP OFFSET(base, y)
      arg2:            LIST(EXP)
                 -&gt; EXP COMPOUND(arg1)</programlisting>

      <para>
        Let the <emphasis>i</emphasis>th component (<emphasis>i</emphasis>
        starts at one) of <emphasis>arg2</emphasis> be
        <emphasis>x</emphasis>[<emphasis>i</emphasis>]. The list may be empty.
      </para>

      <para>
        The components <emphasis>x</emphasis>[2 * <emphasis>k</emphasis>] are
        values which are to be placed at <code>OFFSET</code>s given by
        <emphasis>x</emphasis>[2 * <emphasis>k</emphasis> - 1]. These
        <code>OFFSET</code>s will be constants and non-negative.
      </para>

      <para>
        The <code>OFFSET</code> <emphasis>x</emphasis>[2 *
        <emphasis>k</emphasis> - 1] will have the <code>SHAPE</code>
        <code>OFFSET</code>(<emphasis>z</emphasis><emphasis>k</emphasis>,
        <emphasis>alignment</emphasis>(<emphasis>shape</emphasis>(<emphasis>x</emphasis>[2
        * <emphasis>k</emphasis>]))), where
        <emphasis>shape</emphasis> gives the <code>SHAPE</code> of the component
        and <emphasis>base</emphasis> includes
        <emphasis>z</emphasis><emphasis>k</emphasis>.
      </para>

      <para>
        <emphasis>arg1</emphasis> will be a constant non-negative
        <code>OFFSET</code>, see <!-- TODO link to 5.16.87. offset_pad
        -->offset_pad<!-- link end -->.
      </para>

      <para>
        The values <emphasis>x</emphasis>[2 * <emphasis>k</emphasis> - 1] will
        be such that the components when in place either do not overlap or
        exactly coincide, in the sense that the <code>OFFSET</code>s are equal
        and the values have the same <code>SHAPE</code>. If they coincide the
        corresponding values <emphasis>x</emphasis>[2 * <emphasis>k</emphasis>]
        will have <code>VARIETY SHAPE</code>s and will be
        <emphasis>ored</emphasis> together.
      </para>

      <para>
        The <code>SHAPE</code> of a <emphasis>x</emphasis>[2 *
        <emphasis>k</emphasis>] component can be <code>TOP</code>. In this case
        the component is evaluated, but no value is placed at the corresponding
        <code>OFFSET</code>.
      </para>

      <para>
        If <emphasis>x[2 * k]</emphasis> is a <code>BITFIELD</code> then
        <emphasis>x[2 * k - 1]</emphasis>, <emphasis>shape(x[2 * k])</emphasis>
        will be <emphasis>variety-enclosed</emphasis> (see <!-- TODO link to
        7.24. Representing bitfields -->section 7.24<!-- link end -->).
      </para>
    </section>

    <section id="C5S16.59">
      <title>make_floating</title>

      <emphasis role="bold">Encoding number</emphasis>: 59

      <programlisting language="TDF">
      f:               FLOATING_VARIETY
      rm:              ROUNDING_MODE
      negative:        BOOL
      mantissa:        STRING(k, n)
      base:            NAT
      exponent:        SIGNED_NAT
                 -&gt; EXP FLOATING(f)</programlisting>

      <para>
        <emphasis>f</emphasis> will not be complex.
      </para>

      <para>
        <emphasis>mantissa</emphasis> will be a <code>STRING</code> of 8-bit
        integers, each of which is either  46 or is greater than or equal to 48.
        Those values, <emphasis>c</emphasis>, which lie between 48 and 63 will
        represent the digit <emphasis>c</emphasis>-48.  A decimal point is
        represented by 46.
      </para>

      <para>
        The <code>BOOL</code> <emphasis>negative</emphasis> determines the sign
        of the result, if true the result will be negative, if false, positive.
      </para>

      <para>
        A floating point number, <emphasis>mantissa</emphasis>*(<emphasis>
        base</emphasis><superscript><emphasis>exponent</emphasis>
        </superscript>) is created and rounded to the representation of
        <emphasis>f</emphasis> as specified by <emphasis>rm</emphasis>.
        <emphasis>rm</emphasis> will not be <emphasis>round_as_state</emphasis>.
        <emphasis>mantissa</emphasis> is read as a sequence of digits to base
        <emphasis>base</emphasis> and may contain one point symbol.
      </para>

      <para>
        <emphasis>base</emphasis> will be one of the numbers 2, 4, 8, 10, 16.
        Note that in base 16 the digit 10 is represented by the character number
        58 etc.
      </para>

      <para>
        The result will lie in <emphasis>f</emphasis>.
      </para>
    </section>

    <section id="S2260">
      <title>make_general_proc</title>

      <emphasis role="bold">Encoding number</emphasis>: 60

      <programlisting language="TDF">
      result_shape:    SHAPE
      prcprops:        OPTION(PROCPROPS)
      caller_intro:    LIST(TAGSHACC)
      callee_intro:    LIST(TAGSHACC)
      body:            EXP BOTTOM
                 -&gt; EXP PROC</programlisting>

      <para>
        Evaluation of <emphasis>make_general_proc</emphasis> delivers a
        <code>PROC</code>. When this procedure is applied to parameters using
        <emphasis>apply_general_proc</emphasis>, space is allocated to hold the
        actual values of the parameters <emphasis>caller_intro </emphasis> and
        <emphasis>callee_intro</emphasis>. The values produced by the actual
        parameters are used to initialise these spaces. Then
        <emphasis>body</emphasis> is evaluated. During this evaluation the
        <code>TAG</code>s in <emphasis>caller_intro</emphasis> and
        <emphasis>callee_intro</emphasis> are bound to original
        <code>POINTER</code>s to these spaces. The lifetime of these
        <code>TAG</code>s is the evaluation of <emphasis>body</emphasis>.
      </para>

      <para>
        The <code>SHAPE</code> of <emphasis>body</emphasis> will be
        <code>BOTTOM</code>.  <emphasis>caller_intro</emphasis> and
        <emphasis>callee_intro</emphasis> may be empty.
      </para>

      <para>
        The <code>TAG</code>s introduced in the parameters will not be reused
        within the current <code>UNIT</code>.
      </para>

      <para>
        The <code>SHAPE</code>s in the parameters specify the <code>SHAPE</code>
        of the corresponding <code>TAG</code>s.
      </para>

      <para>
        The <code>OPTION(ACCESS)</code> (in <emphasis>params_intro</emphasis>)
        specifies the <code>ACCESS</code> properties of the corresponding
        parameter, just as for a variable declaration.
      </para>

      <para>
        In <emphasis>body</emphasis> the only <code>TAG</code>s which may be
        used as an argument of <emphasis>obtain_tag</emphasis> are those which
        are declared by <emphasis>identify</emphasis> or
        <emphasis>variable</emphasis> constructions in <emphasis>body</emphasis>
        and which are in scope, or <code>TAG</code>s which are declared by
        <emphasis>make_id_tagdef</emphasis>,
        <emphasis>make_var_tagdef</emphasis> or
        <emphasis>common_tagdef</emphasis> or are in
        <emphasis>caller_intro</emphasis> or <emphasis>callee_intro</emphasis>.
        If a <emphasis>make_proc</emphasis> occurs in <emphasis>body</emphasis>
        its <code>TAG</code>s are not in scope.
      </para>

      <para>
        The argument of every <emphasis>return</emphasis> or
        <emphasis>untidy_return</emphasis> construction in
        <emphasis>body</emphasis> will have <code>SHAPE</code>
        <emphasis>result_shape</emphasis>. Every
        <emphasis>apply_general_proc</emphasis> using the procedure will specify
        the <code>SHAPE</code> of its result to be
        <emphasis>result_shape</emphasis>.
      </para>

      <para>
        The presence or absence of each of the <code>PROCPROPS</code>
        <emphasis>var_callers</emphasis>, <emphasis>var_callees,
        check_stack</emphasis> and <emphasis>untidy</emphasis> in
        <emphasis>prcprops</emphasis> will be reflected in every
        <emphasis>apply_general_proc</emphasis> or
        <emphasis>tail_call</emphasis> on this procedure.
      </para>

      <para>
        The definition of the canonical ordering of the evaluation of
        <emphasis>apply_general_proc</emphasis> gives the definition of these
        <code>PROCPROPS</code>.
      </para>

      <para>
        If <emphasis>prcprocs</emphasis> contains
        <emphasis>check_stack</emphasis>, a TDF exception will be raised if the
        static space required for the procedure call (in the sense of
        <emphasis>env_size</emphasis>) would exceed the limit given by
        <emphasis>set_stack_limit</emphasis>.
      </para>

      <para>
        If <emphasis>prcprops</emphasis> contains
        <emphasis>no_long_jump_dest</emphasis>, the body of the procedure will
        never contain the destination label of a <emphasis>long_jump</emphasis>.
      </para>

      <para>
        For notes on the intended implementation of procedures see <!-- TODO
        link to 7.9. Procedures -->section 7.9<!-- end link -->.
      </para>
    </section>

    <section id="C5S16.61">
      <title>make_int</title>

      <emphasis role="bold">Encoding number</emphasis>: 61

      <programlisting language="TDF">
      v:               VARIETY
      value:           SIGNED_NAT
                 -&gt; EXP INTEGER(v)</programlisting>

      <para>
        An integer value is delivered of which the value is given by
        <emphasis>value</emphasis>, and the <code>VARIETY</code> by
        <emphasis>v</emphasis>. The <code>SIGNED_NAT</code>
        <emphasis>value</emphasis> will lie between the bounds of
        <emphasis>v</emphasis>.
      </para>
    </section>

    <section id="C5S16.62">
      <title>make_local_lv</title>

      <emphasis role="bold">Encoding number</emphasis>: 62

      <programlisting language="TDF">
      lab:             LABEL
                 -&gt; EXP POINTER({code})</programlisting>

      <para>
        A <code>POINTER(</code><emphasis>{code</emphasis><code>})</code>
        <emphasis>lv</emphasis> is created and delivered. It can be used as an
        argument to <emphasis>goto_local_lv</emphasis> or
        <emphasis>long_jump</emphasis>. If and when one of these is evaluated
        with <emphasis>lv</emphasis> as an argument, control will pass to
        <emphasis>lab</emphasis>.
      </para>
    </section>

    <section id="C5S16.63">
      <title>make_nof</title>

      <emphasis role="bold">Encoding number</emphasis>: 63

      <programlisting language="TDF">
      arg1:            LIST(EXP)
                 -&gt; EXP NOF(n, s)</programlisting>

      <para>
        Creates an array of <emphasis>n</emphasis> values of <code>SHAPE</code>
        <emphasis>s</emphasis>, containing the given values produced by
        evaluating the members of <emphasis>arg1</emphasis> in the same order as
        they occur in the list.
      </para>

      <para>
        <emphasis>n</emphasis> will not be zero.
      </para>
    </section>

    <section id="C5S16.64">
      <title>make_nof_int</title>

      <emphasis role="bold">Encoding number</emphasis>: 64

      <programlisting language="TDF">
      v:               VARIETY
      str:             STRING(k, n)
                 -&gt; EXP NOF(n, INTEGER(v))</programlisting>

      <para>
        An <code>NOF INTEGER</code> is delivered. The conversions are carried
        out as if the elements of <emphasis>str</emphasis> were
        <code>INTEGER</code>(<emphasis>var_limits</emphasis>(0,
        2<superscript><emphasis>k</emphasis></superscript>-1)).
        <emphasis>n</emphasis> may be zero.
      </para>
    </section>

    <section id="C5S16.65">
      <title>make_null_local_lv</title>

      <emphasis role="bold">Encoding number</emphasis>: 65

      <programlisting language="TDF">
                 -&gt; EXP POINTER({code})</programlisting>

      <para>
        Makes a null <code>POINTER</code>({<emphasis>code</emphasis>}) which can
        be detected by <emphasis>pointer_test</emphasis>. The effect of
        <emphasis>goto_local_lv</emphasis> or <emphasis>long_jump</emphasis>
        applied to this value is undefined.
      </para>

      <para>
        All null <code>POINTER</code>({<emphasis>code</emphasis>}) are equal to
        each other and unequal to any other <code>POINTER</code>s.
      </para>
    </section>

    <section id="C5S16.66">
      <title>make_null_proc</title>

      <emphasis role="bold">Encoding number</emphasis>: 66

      <programlisting language="TDF">
                 -&gt; EXP PROC</programlisting>

      <para>
        A null <code>PROC</code> is created and delivered. The null
        <code>PROC</code> may be tested for by using
        <emphasis>proc_test</emphasis>. The effect of using it as the first
        argument of <emphasis>apply_proc</emphasis> is undefined.
      </para>

      <para>
        All null <code>PROC</code> are equal to each other and unequal to any
        other <code>PROC</code>.
      </para>
    </section>

    <section id="C5S16.67">
      <title>make_null_ptr</title>

      <emphasis role="bold">Encoding number</emphasis>: 67

      <programlisting language="TDF">
      a:               ALIGNMENT
                 -&gt; EXP POINTER(a)</programlisting>

      <para>
        A null <code>POINTER</code>(<emphasis>a</emphasis>) is created and
        delivered. The null <code>POINTER</code> may be tested for by
        <emphasis>pointer_test</emphasis>.
      </para>

      <para>
        <emphasis>a</emphasis> will not include <emphasis>code</emphasis>.
      </para>

      <para>
        All null <code>POINTER</code>(<emphasis>x</emphasis>) are equal to each
        other and unequal to any other
        <code>POINTER</code>(<emphasis>x</emphasis>).
      </para>
    </section>

    <section id="C5S16.68">
      <title>make_proc</title>

      <emphasis role="bold">Encoding number</emphasis>: 68

      <programlisting language="TDF">
      result_shape:    SHAPE
      params_intro:    LIST(TAGSHACC)
      var_intro:       OPTION(TAGACC)
      body:            EXP BOTTOM
                 -&gt; EXP PROC</programlisting>

      <para>
        Evaluation of <emphasis>make_proc</emphasis> delivers a
        <code>PROC</code>. When this procedure is applied to parameters using
        <emphasis>apply_proc</emphasis>, space is allocated to hold the actual
        values of the parameters <emphasis>params_intro</emphasis> and
        <emphasis>var_intro</emphasis> (if present). The values produced by the
        actual parameters are used to initialise these spaces. Then
        <emphasis>body</emphasis> is evaluated. During this evaluation the
        <code>TAG</code>s in <emphasis>params_intro</emphasis> and
        <emphasis>var_intro</emphasis> are bound to original
        <code>POINTER</code>s to these spaces. The lifetime of these
        <code>TAG</code>s is the evaluation of <emphasis>body</emphasis>.
      </para>

      <para>
        If <emphasis>var_intro</emphasis> is present, it may be used for one of
        two purposes, with different consequences for corresponding uses of
        <emphasis>apply_proc</emphasis>. See <!-- TODO link to 7.9. Procedures
        -->section 7.9<!-- end link -->. The <code>ALIGNMENT</code>,
        <emphasis>var_param_alignment</emphasis>, includes the set union of all
        the <code>ALIGNMENT</code>s which can be produced by
        <emphasis>alignment</emphasis> from any <code>SHAPE</code>. Note that
        <emphasis>var_intro</emphasis> does not contain an <code>ACCESS</code>
        component and so cannot be marked <emphasis>visible</emphasis>. Hence it
        is not a possible argument of <emphasis>env_offset</emphasis>. If
        present, <emphasis>var_intro</emphasis> is an original pointer.
      </para>

      <para>
        The <code>SHAPE</code> of <emphasis>body</emphasis> will be
        <code>BOTTOM</code>. <emphasis>params_intro</emphasis> may be empty.
      </para>

      <para>
        The <code>TAG</code>s introduced in the parameters will not be reused
        within the current <code>UNIT</code>.
      </para>

      <para>
        The <code>SHAPE</code>s in the parameters specify the <code>SHAPE</code>
        of the corresponding <code>TAG</code>s.
      </para>

      <para>
        The <code>OPTION(ACCESS</code>) (in <emphasis>params_intro</emphasis>)
        specifies the <code>ACCESS</code> properties of the corresponding
        parameter, just as for a variable declaration.
      </para>

      <para>
        In <emphasis>body</emphasis> the only <code>TAG</code>s which may be
        used as an argument of <emphasis>obtain_tag</emphasis> are those which
        are declared by <emphasis>identify</emphasis> or
        <emphasis>variable</emphasis> constructions in <emphasis>body</emphasis>
        and which are in scope, or <code>TAG</code>s which are declared by
        <emphasis>make_id_tagdef</emphasis>,
        <emphasis>make_var_tagdef</emphasis> or
        <emphasis>common_tagdef</emphasis> or are in
        <emphasis>params_intro</emphasis> or <emphasis>var_intro</emphasis>.  If
        a <emphasis>make_proc</emphasis> occurs in <emphasis>body</emphasis> its
        <code>TAG</code>s are not in scope.
      </para>

      <para>
        The argument of every <emphasis>return</emphasis> construction in
        <emphasis>body</emphasis> will have <code>SHAPE</code>
        <emphasis>result_shape</emphasis>. Every <emphasis>apply_proc</emphasis>
        using the procedure will specify the <code>SHAPE</code> of it result to
        be <emphasis>result_shape</emphasis>.
      </para>

      <para>
        For notes on the intended implementation of procedures see <!-- TODO
        link to 7.9 Procedures -->section 7.9<!-- end link -->.
      </para>
    </section>

    <section id="C5S16.69">
      <title>make_stack_limit</title>

      <emphasis role="bold">Encoding number</emphasis>: 116

      <programlisting language="TDF">
      stack_base:      EXP POINTER(fa)
      frame_size:      EXP OFFSET(locals_alignment, x)
      alloc_size:      EXP OFFSET(alloca_alignment, y)
                 -&gt; EXP POINTER(fb)</programlisting>

      <para>
        This creates a POINTER suitable for use with
        <emphasis>set_stack_limit</emphasis>.
      </para>

      <para>
        <emphasis>fa</emphasis> and <emphasis>fb</emphasis> will include
        <emphasis>locals_alignment</emphasis> and, if
        <emphasis>alloc_size</emphasis> is not the zero offset, will also
        contain <emphasis>alloca_alignment</emphasis>.
      </para>

      <para>
        The result will be the same as if given by:<sbr/> Assume
        <emphasis>stack_base</emphasis> is the current frame-pointer as given by
        <emphasis>current_env</emphasis> in a hypothetical procedure P with
        <emphasis>env_size</emphasis> equal to <emphasis>frame_size</emphasis>
        and which has generated <emphasis>alloc_size</emphasis> by a
        <emphasis>local_alloc</emphasis>. If P then calls Q, the result will be
        the same as that of a <emphasis>current_env</emphasis> performed
        immediately in the body of Q.<sbr/> If the following construction is
        performed:<sbr/> set_stack_limit(make_stack_limit(current_env, F,
        A))<sbr/> the frame space and local_alloc space that would be available
        for use by this supposed call of Q will not be reused by procedure calls
        with <emphasis>check_stack</emphasis> or uses of
        <emphasis>local_alloc_check</emphasis> after the
        <emphasis>set_stack_limit</emphasis>. Any attempt to do so will raise a
        TDF exception, <emphasis>stack_overflow</emphasis>.
      </para>
    </section>

    <section id="C5S16.70">
      <title>make_top</title>

      <emphasis role="bold">Encoding number</emphasis>: 69

      <programlisting language="TDF">
                 -&gt; EXP TOP</programlisting>

      <para>
        <emphasis>make_top</emphasis> delivers a value of <code>SHAPE TOP</code>
        (i.e. <emphasis>void</emphasis>).
      </para>
    </section>

    <section id="C5S16.71">
      <title>make_value</title>

      <emphasis role="bold">Encoding number</emphasis>: 70

      <programlisting language="TDF">
      s:               SHAPE
                 -&gt; EXP s</programlisting>

      <para>
        This <code>EXP</code> creates some value with the representation of the
        <code>SHAPE</code> <emphasis>s</emphasis>. This value will have the
        correct size, but its representation is not specified. It can be
        assigned, be the result of a <emphasis>contents</emphasis>, a parameter
        or result of a procedure, or the result of any construction (like
        <emphasis>sequence</emphasis>) which delivers the value delivered by an
        internal <code>EXP</code>. But if it is used for arithmetic or as a
        <code>POINTER</code> for taking <emphasis>contents</emphasis> or
        <emphasis>add_to_ptr</emphasis> etc. the effect is undefined.
      </para>

      <para>
        Installers will usually be able to implement this operation by producing
        no code.
      </para>

      <para>
        <emphasis>Note that a floating point NaN is a possible value for this
        purpose.</emphasis>
      </para>

      <para>
        The <code>SHAPE</code> <emphasis>s</emphasis> will not be
        <code>BOTTOM</code>.
      </para>
    </section>

    <section id="C5S16.72">
      <title>maximum</title>

      <emphasis role="bold">Encoding number</emphasis>: 71

      <programlisting language="TDF">
      arg1:            EXP INTEGER(v)
      arg2:            EXP INTEGER(v)
                 -&gt; EXP INTEGER(v)</programlisting>

      <para>
        The arguments will be evaluated and the maximum of the values delivered
        is the result.
      </para>
    </section>

    <section id="S2273">
      <title>minimum</title>

      <emphasis role="bold">Encoding number</emphasis>: 72

      <programlisting language="TDF">
      arg1:            EXP INTEGER(v)
      arg2:            EXP INTEGER(v)
                 -&gt; EXP INTEGER(v)</programlisting>

      <para>
        The arguments will be evaluated and the minimum of the values delivered
        is the result.
      </para>
    </section>

    <section id="C5S16.74">
      <title>minus</title>

      <emphasis role="bold">Encoding number</emphasis>: 73

      <programlisting language="TDF">
      ov_err:          ERROR_TREATMENT
      arg1:            EXP INTEGER(v)
      arg2:            EXP INTEGER(v)
                 -&gt; EXP INTEGER(v)</programlisting>

      <para>
        <emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated
        and will produce integer values, <emphasis>a</emphasis> and
        <emphasis>b</emphasis>, of the same <code>VARIETY</code>,
        <emphasis>v</emphasis>. The difference
        <emphasis>a</emphasis>-<emphasis>b</emphasis> is delivered as the result
        of the construct, with the same <code>SHAPE</code> as the arguments.
      </para>

      <para>
        If the result cannot be expressed in the <code>VARIETY</code> being used
        to represent <emphasis>v</emphasis>, an overflow error is caused and is
        handled in the way specified by <emphasis>ov_err</emphasis>.
      </para>
    </section>

    <section id="C5S16.75">
      <title>move_some</title>

      <emphasis role="bold">Encoding number</emphasis>: 74

      <programlisting language="TDF">
      md:              TRANSFER_MODE
      arg1:            EXP POINTER(x)
      arg2:            EXP POINTER(y)
      arg3:            EXP OFFSET(z, t)
                 -&gt; EXP TOP</programlisting>

      <para>
        The arguments are evaluated to produce <emphasis>p1</emphasis>,
        <emphasis>p2</emphasis>, and <emphasis>sz</emphasis> respectively. A
        quantity of data measured by <emphasis>sz</emphasis> in the space
        indicated by <emphasis>p1</emphasis> is moved to the space indicated by
        <emphasis>p2</emphasis>.  The operation will be carried out as specified
        by the <code>TRANSFER_MODE</code> (q.v.).
      </para>

      <para>
        <emphasis>x</emphasis> will include <emphasis>z</emphasis> and
        <emphasis>y</emphasis> will include <emphasis>z</emphasis>.
      </para>

      <para>
        <emphasis>sz</emphasis> will be a non-negative <code>OFFSET</code>, see
        <!-- TODO link to 5.16.87. offset_pad -->offset_pad<!-- end link -->.
      </para>

      <para>
        If the spaces of size <emphasis>sz</emphasis> to which
        <emphasis>p1</emphasis> and <emphasis>p2</emphasis> point do not lie
        entirely within the spaces indicated by the original pointers from which
        they are derived, the effect of the operation is undefined.
      </para>

      <para>
        If the value delivered by <emphasis>arg1</emphasis> or
        <emphasis>arg2</emphasis> is a null pointer the effect is undefined.
      </para>

      <para>
        See <!-- TODO link to 7.16. Overlapping -->Overlapping<!-- end link -->.
      </para>
    </section>

    <section id="C5S16.76">
      <title>mult</title>

      <emphasis role="bold">Encoding number</emphasis>: 75

      <programlisting language="TDF">
      ov_err:          ERROR_TREATMENT
      arg1:            EXP INTEGER(v)
      arg2:            EXP INTEGER(v)
                 -&gt; EXP INTEGER(v)</programlisting>

      <para>
        <emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated
        and will produce integer values, <emphasis>a</emphasis> and
        <emphasis>b</emphasis>, of the same <code>VARIETY</code>,
        <emphasis>v</emphasis>. The product
        <emphasis>a</emphasis>*<emphasis>b</emphasis> is delivered as the result
        of the construct, with the same <code>SHAPE</code> as the arguments.
      </para>

      <para>
        If the result cannot be expressed in the <code>VARIETY</code> being used
        to represent <emphasis>v</emphasis>, an overflow error is caused and is
        handled in the way specified by <emphasis>ov_err</emphasis>.
      </para>
    </section>

    <section id="C5S16.77">
      <title>n_copies</title>

      <emphasis role="bold">Encoding number</emphasis>: 76

      <programlisting language="TDF">
      n:               NAT
      arg1:            EXP x
                 -&gt; EXP NOF(n, x)</programlisting>

      <para>
        <emphasis>arg1</emphasis> is evaluated and an <code>NOF</code> value is
        delivered which contains <emphasis>n</emphasis> copies of this value.
        <emphasis>n</emphasis> can be zero or one or greater.
      </para>

      <para>
        Producers are encouraged to use <emphasis>n_copies</emphasis> to
        initialise arrays of known size.
      </para>
    </section>

    <section id="C5S16.78">
      <title>negate</title>

      <emphasis role="bold">Encoding number</emphasis>: 78

      <programlisting language="TDF">
      ov_err:          ERROR_TREATMENT
      arg1:            EXP INTEGER(v)
                 -&gt; EXP INTEGER(v)</programlisting>

      <para>
        <emphasis>arg1</emphasis> is evaluated and will produce an integer
        value, <emphasis>a</emphasis>. The value -<emphasis>a</emphasis> is
        delivered as the result of the construct, with the same
        <code>SHAPE</code> as the argument.
      </para>

      <para>
        If the result cannot be expressed in the <code>VARIETY</code> being used
        to represent <emphasis>v</emphasis>, an overflow error is caused and is
        handled in the way specified by <emphasis>ov_err</emphasis>.
      </para>
    </section>

    <section id="C5S16.79">
      <title>not</title>

      <emphasis role="bold">Encoding number</emphasis>: 78

      <programlisting language="TDF">
      arg1:            EXP INTEGER(v)
                 -&gt; EXP INTEGER(v)</programlisting>

      <para>
        The argument is evaluated producing an integer value, of
        <code>VARIETY</code>, <emphasis>v</emphasis>. The result is the bitwise
        <emphasis>not</emphasis> of this value in the representing
        <code>VARIETY</code>. The result is delivered as the result of the
        construct, with the same <code>SHAPE</code> as the arguments.
      </para>

      <para>
        See <!-- TODO link to 7.18. Representing integers -->Representing
        integers<!-- end link -->.
      </para>
    </section>

    <section id="C5S16.80">
      <title>obtain_tag</title>

      <emphasis role="bold">Encoding number</emphasis>: 79

      <programlisting language="TDF">
      t:               TAG x
                 -&gt; EXP x</programlisting>

      <para>
        The value with which the <code>TAG</code> <emphasis>t</emphasis> is
        bound is delivered. The <code>SHAPE</code> of the result is the
        <code>SHAPE</code> of the value with which the <code>TAG</code> is
        bound.
      </para>
    </section>

    <section id="C5S16.81">
      <title>offset_add</title>

      <emphasis role="bold">Encoding number</emphasis>: 80

      <programlisting language="TDF">
      arg1:            EXP OFFSET(x, y)
      arg2:            EXP OFFSET(z, t)
                 -&gt; EXP OFFSET(x, t)</programlisting>

      <para>
        The two arguments deliver <code>OFFSET</code>s. The result is the sum of
        these <code>OFFSET</code>s, as an <code>OFFSET</code>.
      </para>

      <para>
        <emphasis>y</emphasis> will include <emphasis>z</emphasis>.
      </para>

      <para>
        <emphasis>The effect of the constraint <quote>y will include z</quote>
        is that, in the simple representation of pointer arithmetic, this
        operation can be represented by addition. offset_add can lose
        information, so that offset_subtract does not have the usual relation
        with it.</emphasis>
      </para>
    </section>

    <section id="C5S16.82">
      <title>offset_div</title>

      <emphasis role="bold">Encoding number</emphasis>: 81

      <programlisting language="TDF">
      v:               VARIETY
      arg1:            EXP OFFSET(x, x)
      arg2:            EXP OFFSET(x, x)
                 -&gt; EXP INTEGER(v)</programlisting>

      <para>
        The two arguments deliver <code>OFFSET</code>s, <emphasis>a</emphasis>
        and <emphasis>b</emphasis>.  The result is <emphasis>a/b</emphasis>, as
        an <code>INTEGER</code> of <code>VARIETY</code>, <emphasis>v</emphasis>.
        Division is interpreted in the same sense (with respect to remainder) as
        in <emphasis>div0</emphasis>.
      </para>

      <para>
        The value produced by <emphasis>arg2</emphasis> will be non-zero.
      </para>
    </section>

    <section id="C5S16.83">
      <title>offset_div_by_int</title>

      <emphasis role="bold">Encoding number</emphasis>: 82

      <programlisting language="TDF">
      arg1:            EXP OFFSET(x, x)
      arg2:            EXP INTEGER(v)
                 -&gt; EXP OFFSET(x, x)</programlisting>

      <para>
        The result is the <code>OFFSET</code> produced by
        <emphasis>arg1</emphasis> divided by <emphasis>arg2</emphasis>, as an
        <code>OFFSET</code>(<emphasis>x</emphasis>, <emphasis>x</emphasis>).
      </para>

      <para>
        The value produced by <emphasis>arg2</emphasis> will be greater than
        zero.
      </para>

      <para>
        The following identity will apply for all A and n:
      </para>

      <para>
        <emphasis>offset_mult</emphasis>(<emphasis>offset_div_by_int</emphasis>(A,
        n), n) = A
      </para>
    </section>

    <section id="C5S16.84">
      <title>offset_max</title>

      <emphasis role="bold">Encoding number</emphasis>: 83

      <programlisting language="TDF">
      arg1:            EXP OFFSET(x, y)
      arg2:            EXP OFFSET(z, y)
                 -&gt; EXP OFFSET(unite_alignments(x, z), y)</programlisting>

      <para>
        The two arguments deliver <code>OFFSET</code>s. The result is the
        maximum of these <code>OFFSET</code>s, as an <code>OFFSET</code>.
      </para>

      <para>
        See <!-- TODO link to 7.13.2. Comparison of pointers and offsets
        -->Comparison of pointers and offsets<!-- link end -->.
      </para>

      <para>
        <emphasis>In the simple memory model this operation is represented by
        maximum. The constraint that the second <code>ALIGNMENT</code>
        parameters are both y is to permit the representation of
        <code>OFFSET</code>s in installers by a simple homomorphism.</emphasis>
      </para>
    </section>

    <section id="C5S16.85">
      <title>offset_mult</title>

      <emphasis role="bold">Encoding number</emphasis>: 84

      <programlisting language="TDF">
      arg1:            EXP OFFSET(x, x)
      arg2:            EXP INTEGER(v)
                 -&gt; EXP OFFSET(x, x)</programlisting>

      <para>
        The first argument gives an <code>OFFSET</code>,
        <emphasis>off</emphasis>, and the second an integer,
        <emphasis>n</emphasis>. The result is the product of these, as an
        offset.
      </para>

      <para>
        The result shall be equal to <emphasis>offset_adding off n</emphasis>
        times to <emphasis>offset_zero</emphasis>(<emphasis>x</emphasis>).
      </para>
    </section>

    <section id="C5S16.86">
      <title>offset_negate</title>

      <emphasis role="bold">Encoding number</emphasis>: 85

      <programlisting language="TDF">
      arg1:            EXP OFFSET(x, x)
                 -&gt; EXP OFFSET(x, x)</programlisting>

      <para>
        The inverse of the argument is delivered.
      </para>

      <para>
        <emphasis>In the simple memory model this can be represented by
        negate.</emphasis> </para>
    </section>

    <section id="C5S16.87">
      <title>offset_pad</title>

      <emphasis role="bold">Encoding number</emphasis>: 86

      <programlisting language="TDF">
      a:               ALIGNMENT
      arg1:            EXP OFFSET(z, t)
                 -&gt; EXP OFFSET(unite_alignments(z, a), a)</programlisting>

      <para>
        <emphasis>arg1</emphasis> is evaluated giving <emphasis>off</emphasis>.
        The next greater or equal <code>OFFSET</code> at which a value of
        <code>ALIGNMENT</code> <emphasis>a</emphasis> can be placed is
        delivered. That is, there shall not exist an <code>OFFSET</code> of the
        same <code>SHAPE</code> as the result which is greater than or equal to
        <emphasis>off</emphasis> and less than the result, in the sense of
        <emphasis>offset_test</emphasis>.
      </para>

      <para>
        <emphasis>off</emphasis> will be a non-negative <code>OFFSET</code>,
        that is it will be greater than or equal to a zero <code>OFFSET</code>
        of the same <code>SHAPE</code> in the sense of
        <emphasis>offset_test</emphasis>.
      </para>

      <para>
        <emphasis>In the simple memory model this operation can be represented
        by ((off + a - 1) / a) * a. In the simple model this is the only
        operation which is not represented by a simple corresponding integer
        operation.</emphasis>
      </para>
    </section>

    <section id="C5S16.88">
      <title>offset_subtract</title>

      <emphasis role="bold">Encoding number</emphasis>: 87

      <programlisting language="TDF">
      arg1:            EXP OFFSET(x, y)
      arg2:            EXP OFFSET(x, z)
                 -&gt; EXP OFFSET(z, y)
      </programlisting>

      <para>
        The two arguments deliver offsets, <emphasis>p</emphasis> and
        <emphasis>q</emphasis>. The result is
        <emphasis>p</emphasis>-<emphasis>q</emphasis>, as an offset.
      </para>

      <para>
        Note that <emphasis>x</emphasis> will include <emphasis>y</emphasis>,
        <emphasis>x</emphasis> will include <emphasis>z</emphasis> and
        <emphasis>z</emphasis> will include <emphasis>y</emphasis>, by the
        constraints on <code>OFFSET</code>s.
      </para>

      <para>
        <emphasis>offset_subtract and offset_add do not have the conventional
        relationship because offset_add can lose information, which cannot be
        regenerated by offset_subtract.</emphasis>
      </para>
    </section>

    <section id="C5S16.89">
      <title>offset_test</title>

      <emphasis role="bold">Encoding number</emphasis>: 88

      <programlisting language="TDF">
      prob:            OPTION(NAT)
      nt:              NTEST
      dest:            LABEL
      arg1:            EXP OFFSET(x, y)
      arg2:            EXP OFFSET(x, y)
                 -&gt; EXP TOP</programlisting>

      <para>
        <emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated
        and will produce offset values, <emphasis>a</emphasis> and
        <emphasis>b</emphasis>. These values are compared using
        <emphasis>nt</emphasis>.
      </para>

      <para>
        If <emphasis>a nt b</emphasis>, this construction yields
        <code>TOP</code>. Otherwise control passes to <emphasis>dest</emphasis>.
      </para>

      <para>
        If <emphasis>prob</emphasis> is present, <emphasis>prob</emphasis>/100
        gives the probability that control will continue to the next construct
        (ie. not pass to <emphasis>dest</emphasis>).  If
        <emphasis>prob</emphasis> is absent this probability is unknown.
      </para>

      <para>
        <emphasis>a greater_than_or_equal b</emphasis> is equivalent to
        <emphasis>offset_max</emphasis>(<emphasis>a</emphasis>,
        <emphasis>b</emphasis>) = <emphasis>a</emphasis>, and similarly for the
        other comparisons.
      </para>

      <para>
        <emphasis>In the simple memory model this can be represented by
        integer_test.</emphasis>
      </para>
    </section>

    <section id="C5S16.90">
      <title>offset_zero</title>

      <emphasis role="bold">Encoding number</emphasis>: 89

      <programlisting language="TDF">
      a:               ALIGNMENT
                 -&gt; EXP OFFSET(a, a)</programlisting>

      <para>
        A zero offset of <code>SHAPE OFFSET</code>(<emphasis>a</emphasis>,
        <emphasis>a</emphasis>).
      </para>

      <para>
        <emphasis>offset_pad</emphasis>(<emphasis>b</emphasis>,
        <emphasis>offset_zero</emphasis>(<emphasis>a</emphasis>)) is a zero
        offset of <code>SHAPE
        OFFSET</code>(<emphasis>unite_alignments</emphasis>(<emphasis>a</emphasis>,
        <emphasis>b</emphasis>), <emphasis>b</emphasis>).
      </para>
    </section>

    <section id="C5S16.91">
      <title>or</title>

      <emphasis role="bold">Encoding number</emphasis>: 90

      <programlisting language="TDF">
      arg1:            EXP INTEGER(v)
      arg2:            EXP INTEGER(v)
                 -&gt; EXP INTEGER(v)</programlisting>

      <para>
        The arguments are evaluated producing integer values of the same
        <code>VARIETY</code>, <emphasis>v</emphasis>. The result is the bitwise
        <emphasis>or</emphasis> of these two integers in the representing
        <code>VARIETY</code>. The result is delivered as the result of the
        construct, with the same <code>SHAPE</code> as the arguments.
      </para>

      <para>
        See <!-- TODO link to 7.18. Representing integers -->Representing
        integers<!-- end link -->.
      </para>
    </section>

    <section id="C5S16.92">
      <title>plus</title>

      <emphasis role="bold">Encoding number</emphasis>: 91

      <programlisting language="TDF">
      ov_err:          ERROR_TREATMENT
      arg1:            EXP INTEGER(v)
      arg2:            EXP INTEGER(v)
                 -&gt; EXP INTEGER(v)</programlisting>

      <para>
        <emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated
        and will produce integer values, <emphasis>a</emphasis> and
        <emphasis>b</emphasis>, of the same <code>VARIETY</code>,
        <emphasis>v</emphasis>. The sum
        <emphasis>a</emphasis>+<emphasis>b</emphasis> is delivered as the result
        of the construct, with the same <code>SHAPE</code> as the arguments.
      </para>

      <para>
        If the result cannot be expressed in the <code>VARIETY</code> being used
        to represent <emphasis>v</emphasis>, an overflow error is caused and is
        handled in the way specified by <emphasis>ov_err</emphasis>.
      </para>
    </section>

    <section id="C5S16.93">
      <title>pointer_test</title>

      <emphasis role="bold">Encoding number</emphasis>: 92

      <programlisting language="TDF">
      prob:            OPTION(NAT)
      nt:              NTEST
      dest:            LABEL
      arg1:            EXP POINTER(x)
      arg2:            EXP POINTER(x)
                 -&gt; EXP TOP</programlisting>

      <para>
        <emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated
        and will produce pointer values, <emphasis>a</emphasis> and
        <emphasis>b</emphasis>, which will be derived from the same original
        pointer. These values are compared using <emphasis>nt</emphasis>.
      </para>

      <para>
        If <emphasis>a nt b</emphasis>, this construction yields
        <code>TOP</code>. Otherwise control passes to <emphasis>dest</emphasis>.
      </para>

      <para>
        If <emphasis>prob</emphasis> is present, <emphasis>prob</emphasis>/100
        gives the probability that control will continue to the next construct
        (ie. not pass to <emphasis>dest</emphasis>). If
        <emphasis>prob</emphasis> is absent this probability is unknown.
      </para>

      <para>
        The effect of this construction is the same as:
      </para>

      <para>
        <emphasis>offset_test</emphasis>(<emphasis>prob, nt</emphasis>,
        <emphasis>dest</emphasis>,
        <emphasis>subtract_ptrs</emphasis>(<emphasis>arg1 </emphasis>,
        <emphasis>arg2</emphasis>),
        <emphasis>offset_zero</emphasis>(<emphasis>x</emphasis>))
      </para>

      <para>
        <emphasis>In the simple memory model this construction can be
        represented by integer_test.</emphasis>
      </para>
    </section>

    <section id="C5S16.94">
      <title>power</title>

      <emphasis role="bold">Encoding number</emphasis>: 93

      <programlisting language="TDF">
      ov_err:          ERROR_TREATMENT
      arg1:            EXP INTEGER(v)
      arg2:            EXP INTEGER(w)
                 -&gt; EXP INTEGER(v)</programlisting>

      <para>
        <emphasis>arg2</emphasis> will be non-negative. The result is the result
        of <emphasis>arg1</emphasis> raised to the power given by
        <emphasis>arg2</emphasis>.
      </para>

      <para>
        If the result cannot be expressed in the <code>VARIETY</code> being used
        to represent <emphasis>v</emphasis>, an overflow error is caused and is
        handled in the way specified by <emphasis>ov_err</emphasis>.
      </para>
    </section>

    <section id="C5S16.95">
      <title>proc_test</title>

      <emphasis role="bold">Encoding number</emphasis>: 94

      <programlisting language="TDF">
      prob:            OPTION(NAT)
      nt:              NTEST
      dest:            LABEL
      arg1:            EXP PROC
      arg2:            EXP PROC
                 -&gt; EXP TOP</programlisting>

      <para>
        <emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated
        and will produce <code>PROC</code> values, <emphasis>a</emphasis> and
        <emphasis>b</emphasis>. These values are compared using
        <emphasis>nt</emphasis>.  The only permitted values of
        <emphasis>nt</emphasis> are <emphasis>equal</emphasis> and
        <emphasis>not_equal</emphasis>.
      </para>

      <para>
        If <emphasis>a nt b</emphasis>, this construction yields
        <code>TOP</code>. Otherwise control passes to <emphasis>dest</emphasis>.
      </para>

      <para>
        If <emphasis>prob</emphasis> is present, <emphasis>prob</emphasis>/100
        gives the probability that control will continue to the next construct
        (ie. not pass to <emphasis>dest</emphasis>).  If
        <emphasis>prob</emphasis> is absent this probability is unknown.
      </para>

      <para>
        Two <code>PROC</code>s are equal if they were produced by the same
        instantiation of <emphasis>make_proc</emphasis> or if they were both
        made with <emphasis>make_null_proc</emphasis>. Otherwise they are
        unequal.
      </para>
    </section>

    <section id="C5S16.96">
      <title>profile</title>

      <emphasis role="bold">Encoding number</emphasis>: 95

      <programlisting language="TDF">
      uses:            NAT
                 -&gt; EXP TOP</programlisting>

      <para>
        The integer <emphasis>uses</emphasis> gives the number of times which
        this construct is expected to be evaluated.
      </para>

      <para>
        All uses of <emphasis>profile</emphasis> in the same capsule are to the
        same scale.  They will be mutually consistent.
      </para>
    </section>

    <section id="C5S16.97">
      <title>real_part</title>

      <emphasis role="bold">Encoding number</emphasis>: 96

      <programlisting language="TDF">
      arg1:            EXP c
                 -&gt; EXP FLOATING (float_of_complex(c))</programlisting>

      <para>
        <emphasis>c</emphasis> will be complex. Delivers the real part of the
        value produced by <emphasis>arg1</emphasis>.
      </para>
    </section>

    <section id="C5S16.98">
      <title>rem0</title>

      <emphasis role="bold">Encoding number</emphasis>: 97

      <programlisting language="TDF">
      div_by_0_err:    ERROR_TREATMENT
      ov_err:          ERROR_TREATMENT
      arg1:            EXP INTEGER(v)
      arg2:            EXP INTEGER(v)
                 -&gt; EXP INTEGER(v)</programlisting>

      <para>
        <emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated
        and will produce integer values, <emphasis>a</emphasis> and
        <emphasis>b</emphasis>, of the same <code>VARIETY</code>,
        <emphasis>v</emphasis>. The value <emphasis>a</emphasis> M1
        <emphasis>b</emphasis> or the value <emphasis>a</emphasis> M2
        <emphasis>b</emphasis> is delivered as the result of the construct, with
        the same <code>SHAPE</code> as the arguments. Different occurrences of
        <emphasis>rem0</emphasis> in the same capsule can use M1 or M2
        independently.
      </para>

      <para>
        The following equivalence shall hold:
      </para>

      <programlisting language="TDF">
      x = plus(mult(div0(x, y), y), rem0(x, y))
      </programlisting>

      <para>
        if all the <code>ERROR_TREATMENT</code>s are
        <emphasis>impossible</emphasis>, and <emphasis>x</emphasis> and
        <emphasis>y</emphasis> have no side effects.
      </para>

      <para>
        If <emphasis>b</emphasis> is zero a div_by_zero error occurs and is
        handled by <emphasis>div_by_0_err</emphasis>.
      </para>

      <para>
        If <emphasis>b</emphasis> is not zero and
        <emphasis>div0</emphasis>(<emphasis>a</emphasis>,
        <emphasis>b</emphasis>) cannot be expressed in the <code>VARIETY</code>
        being used to represent <emphasis>v</emphasis> an overflow may occur in
        which case it is handled by <emphasis>ov_err</emphasis>.
      </para>

      <para>
        Producers may assume that suitable masking and <emphasis>rem0</emphasis>
        by a power of two yield equally good code.
      </para>

      <para>
        See <!-- TODO link to 7.4. Division and modulus -->Division and
        modulus<!-- end link --> for the definitions of D1, D2, M1 and M2.
      </para>
    </section>

    <section id="C5S16.99">
      <title>rem1</title>

      <emphasis role="bold">Encoding number</emphasis>: 98

      <programlisting language="TDF">
      div_by_0_err:    ERROR_TREATMENT
      ov_err:          ERROR_TREATMENT
      arg1:            EXP INTEGER(v)
      arg2:            EXP INTEGER(v)
                 -&gt; EXP INTEGER(v)</programlisting>

      <para>
        <emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated
        and will produce integer values, <emphasis>a</emphasis> and
        <emphasis>b</emphasis>, of the same <code>VARIETY</code>,
        <emphasis>v</emphasis>. The value <emphasis>a</emphasis> M1
        <emphasis>b</emphasis> is delivered as the result of the construct, with
        the same <code>SHAPE</code> as the arguments.
      </para>

      <para>
        If <emphasis>b</emphasis> is zero a div_by_zero error occurs and is
        handled by <emphasis>div_by_0_err</emphasis>.
      </para>

      <para>
        If <emphasis>b</emphasis> is not zero and
        <emphasis>div1</emphasis>(<emphasis>a</emphasis>,
        <emphasis>b</emphasis>) cannot be expressed in the <code>VARIETY</code>
        being used to represent <emphasis>v</emphasis> an overflow may occur, in
        which case it is handled by <emphasis>ov_err</emphasis>.
      </para>

      <para>
        Producers may assume that suitable masking and <emphasis>rem1</emphasis>
        by a power of two yield equally good code.
      </para>

      <para>
        See <!-- TODO link to 7.4. Division and modulus -->Division and
        modulus<!-- end link --> for the definitions of D1, D2, M1 and M2.
      </para>
    </section>

    <section id="C5S16.100">
      <title>rem2</title>

      <emphasis role="bold">Encoding number</emphasis>: 99

      <programlisting language="TDF">
      div_by_0_err:    ERROR_TREATMENT
      ov_err:          ERROR_TREATMENT
      arg1:            EXP INTEGER(v)
      arg2:            EXP INTEGER(v)
                 -&gt; EXP INTEGER(v)</programlisting>

      <para>
        <emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated
        and will produce integer values, <emphasis>a</emphasis> and
        <emphasis>b</emphasis>, of the same <code>VARIETY</code>,
        <emphasis>v</emphasis>. The value <emphasis>a</emphasis> M2
        <emphasis>b</emphasis> is delivered as the result of the construct, with
        the same <code>SHAPE</code> as the arguments.
      </para>

      <para>
        If <emphasis>b</emphasis> is zero a div_by_zero error occurs and is
        handled by
      </para>

      <para>
        If <emphasis>b</emphasis> is not zero and
        <emphasis>div2</emphasis>(<emphasis>a</emphasis>,
        <emphasis>b</emphasis>) cannot be expressed in the <code>VARIETY</code>
        being used to represent <emphasis>v</emphasis> an overflow may occur, in
        which case it is handled by <emphasis>ov_err</emphasis>.
      </para>

      <para>
        Producers may assume that suitable masking and <emphasis>rem2</emphasis>
        by a power of two yield equally good code if the lower bound of
        <emphasis>v</emphasis> is zero.
      </para>

      <para>
        See <!-- TODO link to 7.4. Division and modulus -->Division and
        modulus<!-- end link --> for the definitions of D1, D2, M1 and M2.
      </para>
    </section>

    <section id="C5S16.101">
      <title>repeat</title>

      <emphasis role="bold">Encoding number</emphasis>: 100

      <programlisting language="TDF">
      replab_intro:    LABEL
      start:           EXP TOP
      body:            EXP y
                 -&gt; EXP y</programlisting>

      <para>
        <emphasis>start</emphasis> is evaluated. Then <emphasis>body</emphasis>
        is evaluated.
      </para>

      <para>
        If <emphasis>body</emphasis> produces a result, this is the result of
        the whole construction. However if <emphasis>goto</emphasis> or any
        other jump to <emphasis>replab_intro</emphasis> is encountered during
        the evaluation then the current evaluation stops and
        <emphasis>body</emphasis> is evaluated again. In the canonical order all
        evaluated components are completely evaluated before any of the next
        iteration of <emphasis>body</emphasis>. The lifetime of
        <emphasis>replab_intro</emphasis> is the evaluation of
        <emphasis>body</emphasis>.
      </para>

      <para>
        The actual order of evaluation of the constituents shall be
        indistinguishable in all observable effects (apart from time) from that
        described above. Note that this specifically includes any defined error
        handling.
      </para>
    </section>

    <section id="C5S16.102">
      <title>return</title>

      <emphasis role="bold">Encoding number</emphasis>: 101

      <programlisting language="TDF">
      arg1:            EXP x
                 -&gt; EXP BOTTOM</programlisting>

      <para>
        <emphasis>arg1</emphasis> is evaluated to produce a value,
        <emphasis>v</emphasis>. The evaluation of the immediately enclosing
        procedure ceases and <emphasis>v</emphasis> is delivered as the result
        of the procedure.
      </para>

      <para>
        Since the <emphasis>return</emphasis> construct can never produce a
        value, the <code>SHAPE</code> of its result is <code>BOTTOM</code>.
      </para>

      <para>
        All uses of <emphasis>return</emphasis> in the <emphasis>body</emphasis>
        of a <emphasis>make_proc</emphasis> or
        <emphasis>make_general_proc</emphasis> will have
        <emphasis>arg1</emphasis> with the same <code>SHAPE</code>.
      </para>
    </section>

    <section id="C5S16.103">
      <title>return_to_label</title>

      <emphasis role="bold">Encoding number</emphasis>: 102

      <programlisting language="TDF">
      lab_val: EXP POINTER code_alignment
                 -&gt; EXP BOTTOM</programlisting>

      <para>
        <emphasis>lab_val</emphasis> will be a label value in the calling
        procedure.
      </para>

      <para>
        The evaluation of the immediately enclosing procedure ceases and control
        is passed to the calling procedure at the label given by
        <emphasis>lab_val</emphasis>.
      </para>
    </section>

    <section id="C5S16.104">
      <title>round_with_mode</title>

      <emphasis role="bold">Encoding number</emphasis>: 103

      <programlisting language="TDF">
      flpt_err:        ERROR_TREATMENT
      mode:            ROUNDING_MODE
      r:               VARIETY
      arg1:            EXP FLOATING(f)
                 -&gt; EXP INTEGER(r)</programlisting>

      <para>
        <emphasis>arg</emphasis> is evaluated to produce a floating point value,
        <emphasis>v</emphasis>. This is rounded to an integer of
        <code>VARIETY</code>, <emphasis>r</emphasis>, using the
        <code>ROUNDING_MODE</code>, <emphasis>mode</emphasis>. This is the
        result of the construction.
      </para>

      <para>
        If <emphasis>f</emphasis> is complex the result is derived from the real
        part of <emphasis>arg1</emphasis>.
      </para>

      <para>
        If there is a floating point error it is handled by
        <emphasis>flpt_err</emphasis>.  See <!-- TODO link to 7.21. Floating
        point errors -->Floating point errors<!-- link end -->.
      </para>
    </section>

    <section id="C5S16.105">
      <title>rotate_left</title>

      <emphasis role="bold">Encoding number</emphasis>: 104

      <programlisting language="TDF">
      arg1:            EXP INTEGER(v)
      arg2:            EXP INTEGER(w)
                 -&gt; EXP INTEGER(v)</programlisting>

      <para>
        The value delivered by <emphasis>arg1</emphasis> is rotated left
        <emphasis>arg2</emphasis> places.
      </para>

      <para>
        <emphasis>arg2</emphasis> will be non-negative and will be strictly less
        than the number of bits needed to represent <emphasis>v</emphasis>.
      </para>

      <para>
        The use of this construct assumes knowledge of the representational
        variety of <emphasis>v</emphasis>.
      </para>
    </section>

    <section id="C5S16.106">
      <title>rotate_right</title>

      <emphasis role="bold">Encoding number</emphasis>: 105

      <programlisting language="TDF">
      arg1:            EXP INTEGER(v)
      arg2:            EXP INTEGER(w)
                 -&gt; EXP INTEGER(v)</programlisting>

      <para>
        The value delivered by <emphasis>arg1</emphasis> is rotated right
        <emphasis>arg2</emphasis> places.
      </para>

      <para>
        <emphasis>arg2</emphasis> will be non-negative and will be strictly less
        than the number of bits needed to represent <emphasis>v</emphasis>.
      </para>

      <para>
        The use of this construct assumes knowledge of the representational
        variety of <emphasis>v</emphasis>.
      </para>
    </section>

    <section id="C5S16.107">
      <title>sequence</title>

      <emphasis role="bold">Encoding number</emphasis>: 106

      <programlisting language="TDF">
      statements:      LIST(EXP)
      result:          EXP x
                 -&gt; EXP x</programlisting>

      <para>
        The statements are evaluated in the same order as the list,
        <emphasis>statements</emphasis>, and their results are discarded. Then
        <emphasis>result</emphasis> is evaluated and its result forms the result
        of the construction.
      </para>

      <para>
        A canonical order is one in which all the components of each statement
        are completely evaluated before any component of the next statement is
        started. A similar constraint applies between the last statement and the
        <emphasis>result</emphasis>. The actual order in which the statements
        and their components are evaluated shall be indistinguishable in all
        observable effects (apart from time) from a canonical order.
      </para>

      <para>
        Note that this specifically includes any defined error handling.
        However, if in any canonical order the effect of the program is
        undefined, the actual effect of the sequence is undefined.
      </para>

      <para>
        Hence constructions with <emphasis>impossible</emphasis> error handlers
        may be performed before or after those with specified error handlers, if
        the resulting order is otherwise acceptable.
      </para>
    </section>

    <section id="C5S16.108">
      <title>set_stack_limit</title>

      <emphasis role="bold">Encoding number</emphasis>: 107

      <programlisting language="TDF">
      lim:             EXP POINTER({locals_alignment, alloca_alignment})
                 -&gt; EXP TOP</programlisting>

      <para>
        <emphasis>set_stack_limit</emphasis> sets the limits of remaining free
        stack space to <emphasis>lim</emphasis>. This include both the frame
        stack limit and the local_alloc stack. Note that, in implementations
        where the frame stack and local_alloc stack are distinct, this pointer
        will have a special representation, appropriate to its frame alignment.
        Thus the pointer should always be generated using
        <emphasis>make_stack_limit</emphasis> or its equivalent formation.
      </para>

      <para>
        Any later <emphasis>apply_general_proc</emphasis> with
        <code>PROCPROPS</code> including <emphasis>check_stack</emphasis> up to
        the dynamically next <emphasis>set_stack_limit</emphasis> will check
        that the frame required for the procedure will be within the frame stack
        limit. If it is not, normal execution is stopped and a TDF exception
        with ERROR_code <emphasis>stack_overflow</emphasis> is raised.
      </para>

      <para>
        Any later <emphasis>local_alloc_check</emphasis> will check that the
        locally allocated space required is within the local_alloc stack limit.
        If it is not, normal execution is stopped and a TDF exception with
        ERROR_code <emphasis>stack_overflow</emphasis> is raised.
      </para>
    </section>

    <section id="C5S16.109">
      <title>shape_offset</title>

      <emphasis role="bold">Encoding number</emphasis>: 108

      <programlisting language="TDF">
      s:               SHAPE
                 -&gt; EXP OFFSET(alignment(s), {})</programlisting>

      <para>
        This construction delivers the <quote>size</quote> of a value of the
        given <code>SHAPE</code>.
      </para>

      <para>
        Suppose that a value of <code>SHAPE</code>, <emphasis>s</emphasis>, is
        placed in a space indicated by a
        <code>POINTER</code>(<emphasis>x</emphasis>), <emphasis>p</emphasis>,
        where <emphasis>x</emphasis> includes <emphasis>alignment(s</emphasis>).
        Suppose that a value of <code>SHAPE</code>, <emphasis>t</emphasis>,
        where <emphasis>a</emphasis> is
        <emphasis>alignment</emphasis>(<emphasis>t</emphasis>) and
        <emphasis>x</emphasis> includes <emphasis>a</emphasis>, is placed at
      </para>

      <para>
        <emphasis>add_to_ptr</emphasis>(<emphasis>p</emphasis>,
        <emphasis>offset_pad(a,
        shape_offset</emphasis>(<emphasis>s</emphasis>)))
      </para>

      <para>
        Then the values shall not overlap. This shall be true for all legal
        <emphasis>s</emphasis>, <emphasis>x</emphasis> and
        <emphasis>t</emphasis>.
      </para>
    </section>

    <section id="C5S16.110">
      <title>shift_left</title>

      <emphasis role="bold">Encoding number</emphasis>: 109

      <programlisting language="TDF">
      ov_err:          ERROR_TREATMENT
      arg1:            EXP INTEGER(v)
      arg2:            EXP INTEGER(w)
                 -&gt; EXP INTEGER(v)</programlisting>

      <para>
        <emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated
        and will produce integer values, <emphasis>a</emphasis> and
        <emphasis>b</emphasis>. The value <emphasis>a</emphasis> shifted left
        <emphasis>b</emphasis> places is delivered as the result of the
        construct, with the same <code>SHAPE</code> as <emphasis>a</emphasis>.
      </para>

      <para>
        <emphasis>b</emphasis> will be non-negative and will be strictly less
        than the number of bits needed to represent <emphasis>v</emphasis>.
      </para>

      <para>
        If the result cannot be expressed in the <code>VARIETY</code> being used
        to represent <emphasis>v</emphasis>, an overflow error is caused and is
        handled in the way specified by <emphasis>ov_err</emphasis>.
      </para>

      <para>
        Producers may assume that <emphasis>shift_left</emphasis> and
        multiplication by a power of two yield equally efficient code.
      </para>
    </section>

    <section id="C5S16.111">
      <title>shift_right</title>

      <emphasis role="bold">Encoding number</emphasis>: 110

      <programlisting language="TDF">
      arg1:            EXP INTEGER(v)
      arg2:            EXP INTEGER(w)
                 -&gt; EXP INTEGER(v)</programlisting>

      <para>
        <emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated
        and will produce integer values, <emphasis>a</emphasis> and
        <emphasis>b</emphasis>. The value <emphasis>a</emphasis> shifted right
        <emphasis>b</emphasis> places is delivered as the result of the
        construct, with the same <code>SHAPE</code> as
        <emphasis>arg1</emphasis>.
      </para>

      <para>
        <emphasis>b</emphasis> will be non-negative and will be strictly less
        than the number of bits needed to represent <emphasis>v</emphasis>.
      </para>

      <para>
        If the lower bound of <emphasis>v</emphasis> is negative, the sign will
        be propagated.
      </para>
    </section>

    <section id="C5S16.112">
      <title>subtract_ptrs</title>

      <emphasis role="bold">Encoding number</emphasis>: 111

      <programlisting language="TDF">
      arg1:            EXP POINTER(y)
      arg2:            EXP POINTER(x)
                 -&gt; EXP OFFSET(x, y)</programlisting>

      <para>
        <emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated to
        produce pointers <emphasis>p1</emphasis> and <emphasis>p2</emphasis>,
        which will be derived from the same original pointer.  The result,
        <emphasis>r</emphasis>, is the <code>OFFSET</code> from
        <emphasis>p2</emphasis> to <emphasis>p1</emphasis>. Both arguments will
        be derived from the same original pointer.
      </para>

      <para>
        Note that <emphasis>add_to_ptr</emphasis>(<emphasis>p2</emphasis>,
        <emphasis>r</emphasis>) = <emphasis>p1</emphasis>.
      </para>
    </section>

    <section id="C5S16.113">
      <title>tail_call</title>

      <emphasis role="bold">Encoding number</emphasis>: 112

      <programlisting language="TDF">
      prcprops:        OPTION(PROCPROPS)
      p:               EXP PROC
      callee_pars:     CALLEES
                 -&gt; EXP BOTTOM</programlisting>

      <para>
        <emphasis>p</emphasis> is called in the sense of
        <emphasis>apply_general_proc</emphasis> with the caller parameters of
        the immediately enclosing proc and <code>CALLEES</code> given by
        <emphasis>callee_pars</emphasis> and <code>PROCPROPS</code>
        <emphasis>prcprops</emphasis>.
      </para>

      <para>
        The result of the call is delivered as the result of the immediately
        enclosing proc in the sense of <emphasis>return</emphasis>. The
        <code>SHAPE</code> of the result of <emphasis>p</emphasis> will be
        identical to the <code>SHAPE</code> specified as the result of
        immediately enclosing procedure.
      </para>

      <para>
        The presence or absence of each of the <code>PROCPROPS</code>
        <emphasis>check_stack</emphasis> and <emphasis>untidy</emphasis>, in
        <emphasis>prcprops</emphasis> will be reflected in the
        <code>PROCPROPS</code> of the immediately enclosing procedure.
      </para>
    </section>

    <section id="C5S16.114">
      <title>untidy_return</title>

      <emphasis role="bold">Encoding number</emphasis>: 113

      <programlisting language="TDF">
      arg1:            EXP x
                 -&gt; EXP BOTTOM</programlisting>

      <para>
        <emphasis>arg1</emphasis> is evaluated to produce a value,
        <emphasis>v</emphasis>. The evaluation of the immediately enclosing
        procedure ceases and <emphasis>v</emphasis> is delivered as the result
        of the procedure, in such a manner as that pointers to any callee
        parameters or local allocations are valid in the calling procedure.
      </para>

      <para>
        <emphasis>untidy_return</emphasis> can only occur in a procedure defined
        by <emphasis>make_general_proc</emphasis> with <code>PROCPROPS</code>
        including <emphasis>untidy</emphasis>.
      </para>
    </section>

    <section id="C5S16.115">
      <title>variable</title>

      <emphasis role="bold">Encoding number</emphasis>: 114

      <programlisting language="TDF">
      opt_access:      OPTION(ACCESS)
      name_intro:      TAG POINTER(alignment(x))
      init:            EXP x
      body:            EXP y
                 -&gt; EXP y</programlisting>

      <para>
        <emphasis>init</emphasis> is evaluated to produce a value,
        <emphasis>v</emphasis>. Space is allocated to hold a value of
        <code>SHAPE</code> <emphasis>x</emphasis> and this is initialised with
        <emphasis>v</emphasis>. Then <emphasis>body</emphasis> is evaluated.
        During this evaluation, an original <code>POINTER</code> pointing to the
        allocated space is bound to <emphasis>name_intro</emphasis>. This means
        that inside <emphasis>body</emphasis> an evaluation of
        <emphasis>obtain_tag</emphasis>(<emphasis>name_intro</emphasis>) will
        produce a <code>POINTER</code> to this space. The lifetime of
        <emphasis>name_intro</emphasis> is the evaluation of
        <emphasis>body</emphasis>.
      </para>

      <para>
        The value delivered by <emphasis>variable</emphasis> is that produced by
        <emphasis>body</emphasis>.
      </para>

      <para>
        If <emphasis>opt_access</emphasis> contains
        <emphasis>visible</emphasis>, it means that the contents of the space
        may be altered while the procedure containing this declaration is not
        the current procedure. Hence if there are any copies of this value they
        will need to be refreshed from the variable when the procedure is
        returned to. The easiest implementation when
        <emphasis>opt_access</emphasis> is <emphasis>visible</emphasis> may be
        to keep the value in memory, but this is not a necessary requirement.
      </para>

      <para>
        The <code>TAG</code> given for <emphasis>name_intro</emphasis> will not
        be reused within the current <code>UNIT</code>. No rules for the hiding
        of one <code>TAG</code> by another are given: this will not happen.
      </para>

      <para>
        The order in which the constituents of <emphasis>init</emphasis> and
        <emphasis>body</emphasis> are evaluated shall be indistinguishable in
        all observable effects (apart from time) from completely evaluating
        <emphasis>init</emphasis> before starting <emphasis>body</emphasis>.
        See the note about order in <!-- TODO link to 5.16.107. sequence
        -->sequence<!-- end link -->.
      </para>

      <para>
        When compiling languages which permit uninitialised variable
        declarations, <emphasis>make_value</emphasis> may be used to provide an
        initialisation.
      </para>
    </section>

    <section id="C5S16.116">
      <title>xor</title>

      <emphasis role="bold">Encoding number</emphasis>: 115

      <programlisting language="TDF">
      arg1:            EXP INTEGER(v)
      arg2:            EXP INTEGER(v)
                 -&gt; EXP INTEGER(v)</programlisting>

      <para>
        The arguments are evaluated producing integer values of the same
        <code>VARIETY</code>, <emphasis>v</emphasis>. The result is the bitwise
        <emphasis>xor</emphasis> of these two integers in the representing
        <code>VARIETY</code>. The result is delivered as the result of the
        construct, with the same <code>SHAPE</code> as the arguments.
      </para>

      <para>
        See <!-- TODO link to 7.18. Representing integers -->Representing
        integers<!-- end link -->.
      </para>
    </section>
  </section>

  <section id="C5S17">
    <title>EXTERNAL</title>

    <emphasis role="bold">Number of encoding bits</emphasis>: 2<sbr/>
    <emphasis role="bold">Is coding extendable</emphasis>: yes<sbr/>

    <para>
      An <code>EXTERNAL</code> defines the classes of external name available
      for connecting the internal names inside a <code>CAPSULE</code> to the
      world outside the <code>CAPSULE</code>.
    </para>

    <section id="C5S17.1">
      <title>string_extern</title>

      <emphasis role="bold">Encoding number</emphasis>: 1

      <programlisting language="TDF">
      s:               BYTE_ALIGN TDFIDENT(n)
                 -&gt; EXTERNAL</programlisting>

      <para>
        <emphasis>string_extern</emphasis> produces an <code>EXTERNAL</code>
        identified by the <code>TDFIDENT</code> <emphasis>s</emphasis>.
      </para>
    </section>

    <section id="C5S17.2">
      <title>unique_extern</title>

      <emphasis role="bold">Encoding number</emphasis>: 2

      <programlisting language="TDF">
      u:               BYTE_ALIGN UNIQUE
                 -&gt; EXTERNAL</programlisting>

      <para>
        <emphasis>unique_extern</emphasis> produces an <code>EXTERNAL</code>
        identified by the <code>UNIQUE</code> <emphasis>u</emphasis>.
      </para>
    </section>

    <section id="C5S17.3">
      <title>chain_extern</title>

      <emphasis role="bold">Encoding number</emphasis>: 3

      <programlisting language="TDF">
      s:               BYTE_ALIGN TDFIDENT
      prev:            TDFINT
                 -&gt; EXTERNAL</programlisting>

      <para>
        This construct is redundant and should not be used.
      </para>
    </section>
  </section>

  <section id="C5S18">
    <title>EXTERN_LINK</title>

    <emphasis role="bold">Number of encoding bits</emphasis>: 0<sbr/>
    <emphasis role="bold">Is coding extendable</emphasis>: no<sbr/>

    <para>
      An auxiliary <code>SORT</code> providing a list of
      <code>LINKEXTERN</code>.
    </para>

    <section id="C5S18.1">
      <title>make_extern_link</title>

      <emphasis role="bold">Encoding number</emphasis>: 0

      <programlisting language="TDF">
      el:              SLIST(LINKEXTERN)
                 -&gt; EXTERN_LINK</programlisting>

      <para>
        <emphasis>make_capsule</emphasis> requires a
        <code>SLIST</code>(<code>EXTERN_LINK</code>) to express the links
        between the linkable entities and the named (by <code>EXTERNAL</code>s)
        values outside the <code>CAPSULE</code>.
      </para>
    </section>
  </section>

  <section id="C5S19">
    <title>FLOATING_VARIETY</title>

    <emphasis role="bold">Number of encoding bits</emphasis>: 3<sbr/>
    <emphasis role="bold">Is coding extendable</emphasis>: yes<sbr/>

    <para>
      These describe kinds of floating point number.
    </para>

    <section id="C5S19.1">
      <title>flvar_apply_token</title>

      <emphasis role="bold">Encoding number</emphasis>: 1

      <programlisting language="TDF">
      token_value:     TOKEN
      token_args:      BITSTREAM param_sorts(token_value)
                 -&gt; FLOATING_VARIETY</programlisting>

      <para>
        The token is applied to the arguments to give a
        <code>FLOATING_VARIETY</code>
      </para>

      <para>
        If there is a definition for <emphasis>token_value</emphasis> in the
        <code>CAPSULE</code> then <emphasis>token_args</emphasis> is a
        <code>BITSTREAM</code> encoding of the <code>SORT</code>s of its
        parameters, in the order specified.
      </para>
    </section>

    <section id="C5S19.2">
      <title>flvar_cond</title>

      <emphasis role="bold">Encoding number</emphasis>: 2

      <programlisting language="TDF">
      control: EXP INTEGER(v)
      e1:              BITSTREAM FLOATING_VARIETY
      e2:              BITSTREAM FLOATING_VARIETY
                 -&gt; FLOATING_VARIETY</programlisting>

      <para>
        The <emphasis>control</emphasis> is evaluated. It will be a constant at
        install time under the constant evaluation rules. If it is non-zero,
        <emphasis>e1</emphasis> is installed at this point and
        <emphasis>e2</emphasis> is ignored and never processed.  If
        <emphasis>control</emphasis> is zero then <emphasis>e2</emphasis> is
        installed at this point and <emphasis>e1</emphasis> is ignored and never
        processed.
      </para>
    </section>

    <section id="C5S19.3">
      <title>flvar_parms</title>

      <emphasis role="bold">Encoding number</emphasis>: 3

      <programlisting language="TDF">
      base:            NAT
      mantissa_digs:   NAT
      min_exponent:    NAT
      max_exponent:    NAT
                 -&gt; FLOATING_VARIETY</programlisting>

      <para>
        <emphasis>base</emphasis> is the base with respect to which the
        remaining numbers refer. <emphasis>base</emphasis> will be a power of 2.
      </para>

      <para>
        <emphasis>mantissa_digs</emphasis> is the required number of
        <emphasis>base</emphasis> digits, <emphasis>q</emphasis>, such that any
        number with <emphasis>q</emphasis> digits can be rounded to a floating
        point number of the variety and back again without any change to the
        <emphasis>q</emphasis> digits.
      </para>

      <para>
        <emphasis>min_exponent</emphasis> is the negative of the required
        minimum integer such that <emphasis>base</emphasis> raised to that power
        can be represented as a non-zero floating point number in the
        <code>FLOATING_VARIETY</code>.
      </para>

      <para>
        <emphasis>max_exponent</emphasis> is the required maximum integer such
        that <emphasis>base</emphasis> raised to that power can be represented
        in the <code>FLOATING_VARIETY</code>.
      </para>

      <para>
        A TDF translator is required to make available a representing
        <code>FLOATING_VARIETY</code> such that, if only values within the given
        requirements are produced, no overflow error will occur. Where several
        such representative <code>FLOATING_VARIETY</code>s exist, the translator
        will choose one to minimise space requirements or maximise the speed of
        operations.
      </para>

      <para>
        All numbers of the form xb1  M*<emphasis>base N+1-q</emphasis> are
        required to be represented exactly where M and N are integers such
        that<sbr/> <emphasis>base</emphasis><emphasis>q-1</emphasis>  M &lt;
        <emphasis>base</emphasis><emphasis>q</emphasis><sbr/>
        -<emphasis>min_exponent</emphasis>  N <emphasis>max_exponent</emphasis>
      </para>

      <para>
        Zero will also be represented exactly in any
        <code>FLOATING_VARIETY</code>.
      </para>
    </section>

    <section id="C5S19.4">
      <title>complex_parms</title>

      <emphasis role="bold">Encoding number</emphasis>: 4

      <programlisting language="TDF">
      base:            NAT
      mantissa_digs:   NAT
      min_exponent:    NAT
      max_exponent:    NAT
                 -&gt; FLOATING_VARIETY</programlisting>

      <para>
        A <code>FLOATING_VARIETY</code> described by
        <emphasis>complex_parms</emphasis> holds a complex number which is
        likely to be represented by its real and imaginary parts, each of which
        is as if defined by <emphasis>flvar_parms</emphasis> with the same
        arguments.
      </para>
    </section>

    <section id="C5S19.5">
      <title>float_of_complex</title>

      <emphasis role="bold">Encoding number</emphasis>: 5

      <programlisting language="TDF">
      csh:             SHAPE
                 -&gt; FLOATING_VARIETY</programlisting>

      <para>
        <emphasis>csh</emphasis> will be a complex <code>SHAPE</code>.
      </para>

      <para>
        Delivers the <code>FLOATING_VARIETY</code> required for the real (or
        imaginary) part of a complex <code>SHAPE</code>
        <emphasis>csh</emphasis>.
      </para>
    </section>

    <section id="C5S19.6">
      <title>complex_of_float</title>

      <emphasis role="bold">Encoding number</emphasis>: 6

      <programlisting language="TDF">
      fsh:             SHAPE
                 -&gt; FLOATING_VARIETY</programlisting>

      <para>
        <emphasis>fsh</emphasis> will be a floating <code>SHAPE</code>.
      </para>

      <para>
        Delivers <code>FLOATING_VARIETY</code> required for a complex number
        whose real (and imaginary) parts have <code>SHAPE</code>
        <emphasis>fsh</emphasis>.
      </para>
    </section>
  </section>

  <section id="C5S20">
    <title>GROUP</title>

    <emphasis role="bold">Number of encoding bits</emphasis>: 0<sbr/>
    <emphasis role="bold">Is coding extendable</emphasis>: no<sbr/>

    <para>
      A <code>GROUP</code> is a list of <code>UNIT</code>s with the same unit
      identification.
    </para>

    <section id="C5S20.1">
      <title>make_group</title>

      <emphasis role="bold">Encoding number</emphasis>: 0

      <programlisting language="TDF">
      us:              SLIST(UNIT)
                 -&gt; GROUP</programlisting>

      <para>
        <emphasis>make_capsule</emphasis> contains a list of
        <code>GROUPS</code>. Each member of this list has a different unit
        identification deduced from the <emphasis>prop_name</emphasis> argument
        of <emphasis>make_capsule</emphasis>.
      </para>
    </section>
  </section>

  <section id="C5S21">
    <title>LABEL</title>

    <emphasis role="bold">Number of encoding bits</emphasis>: 1<sbr/>
    <emphasis role="bold">Is coding extendable</emphasis>: yes<sbr/>

    <para>
      A <code>LABEL</code> marks an <code>EXP</code> in certain constructions,
      and is used in jump-like constructions to change the control to the
      labelled construction.
    </para>

    <section id="C5S21.1">
      <title>label_apply_token</title>

      <emphasis role="bold">Encoding number</emphasis>: 2

      <programlisting language="TDF">
      token_value:     TOKEN
      token_args:      BITSTREAM param_sorts(token_value)
                 -&gt; LABEL x</programlisting>

      <para>
        The token is applied to the arguments to give a <code>LABEL</code>.
      </para>

      <para>
        If there is a definition for <emphasis>token_value</emphasis> in the
        <code>CAPSULE</code> then <emphasis>token_args</emphasis> is a
        <code>BITSTREAM</code> encoding of the <code>SORT</code>s of its
        parameters, in the order specified.
      </para>
    </section>

    <section id="C5S21.2">
      <title>make_label</title>

      <emphasis role="bold">Encoding number</emphasis>: 1

      <programlisting language="TDF">
      labelno: TDFINT
                 -&gt; LABEL</programlisting>

      <para>
        Labels are represented in TDF by integers, but they are not linkable.
        Hence the definition and all uses of a <code>LABEL</code> occur in the
        same <code>UNIT</code>.
      </para>
    </section>
  </section>

  <section id="C5S22">
    <title>LINK</title>

    <emphasis role="bold">Number of encoding bits</emphasis>: 0<sbr/>
    <emphasis role="bold">Is coding extendable</emphasis>: no<sbr/>

    <para>
      A <code>LINK</code> expresses the connection between two variables of the
      same <code>SORT</code>.
    </para>

    <section id="C5S22.1">
      <title>make_link</title>

      <emphasis role="bold">Encoding number</emphasis>: 0

      <programlisting language="TDF">
      unit_name:       TDFINT
      capsule_name:    TDFINT
                 -&gt; LINK</programlisting>

      <para>
        A <code>LINK</code> defines a linkable entity declared inside a
        <code>UNIT</code> as <emphasis>unit_name</emphasis> to correspond to a
        <code>CAPSULE</code> linkable entity having the same linkable entity
        identification. The <code>CAPSULE</code> linkable entity is
        <emphasis>capsule_name</emphasis>.
      </para>

      <para>
        A <code>LINK</code> is normally constructed by the TDF builder in the
        course of resolving sharing and name clashes when constructing a
        composite <code>CAPSULE</code>.
      </para>
    </section>
  </section>

  <section id="C5S23">
    <title>LINKEXTERN</title>

    <emphasis role="bold">Number of encoding bits</emphasis>: 0<sbr/>
    <emphasis role="bold">Is coding extendable</emphasis>: no<sbr/>

    <para>
      A value of <code>SORT LINKEXTERN</code> expresses the connection between
      the name by which an object is known inside a <code>CAPSULE</code> and a
      name by which it is known outside.
    </para>

    <section id="C5S23.1">
      <title>make_linkextern</title>

      <emphasis role="bold">Encoding number</emphasis>: 0

      <programlisting language="TDF">
      internal:        TDFINT
      ext:             EXTERNAL
                 -&gt; LINKEXTERN</programlisting>

      <para>
        <emphasis>make_linkextern</emphasis> produces a <code>LINKEXTERN</code>
        connecting an object identified within a <code>CAPSULE</code> by a
        <code>TAG</code>, <code>TOKEN</code>, <code>AL_TAG</code> or any
        linkable entity constructed from <emphasis>internal</emphasis>, with an
        <code>EXTERNAL</code>, <emphasis>ext</emphasis>. The
        <code>EXTERNAL</code> is an identifier which linkers and similar
        programs can use.
      </para>
    </section>
  </section>

  <section id="C5S24">
    <title>LINKS</title>

    <emphasis role="bold">Number of encoding bits</emphasis>: 0<sbr/>
    <emphasis role="bold">Is coding extendable</emphasis>: no<sbr/>

    <section id="C5S24.1">
      <title>make_links</title>

      <emphasis role="bold">Encoding number</emphasis>: 0

      <programlisting language="TDF">
      ls:              SLIST(LINK)
                 -&gt; LINKS</programlisting>

      <para>
        <emphasis>make_unit</emphasis> uses a
        <code>SLIST</code>(<code>LINKS</code>) to define which linkable entities
        within a <code>UNIT</code> correspond to the <code>CAPSULE</code>
        linkable entities. Each <code>LINK</code> in a <code>LINKS</code> has
        the same linkable entity identification.
      </para>
    </section>
  </section>

  <section id="C5S25">
    <title>NAT</title>

    <emphasis role="bold">Number of encoding bits</emphasis>: 3<sbr/>
    <emphasis role="bold">Is coding extendable</emphasis>: yes<sbr/>

    <para>
      These are non-negative integers of unlimited size.
    </para>

    <section id="C5S25.1">
      <title>nat_apply_token</title>

      <emphasis role="bold">Encoding number</emphasis>: 1

      <programlisting language="TDF">
      token_value:     TOKEN
      token_args:      BITSTREAM param_sorts(token_value)
                 -&gt; NAT</programlisting>

      <para>
        The token is applied to the arguments to give a <code>NAT</code>.
      </para>

      <para>
        If there is a definition for <emphasis>token_value</emphasis> in the
        <code>CAPSULE</code> then <emphasis>token_args</emphasis> is a
        <code>BITSTREAM</code> encoding of the <code>SORT</code>s of its
        parameters, in the order specified.
      </para>
    </section>

    <section id="C5S25.2">
      <title>nat_cond</title>

      <emphasis role="bold">Encoding number</emphasis>: 2

      <programlisting language="TDF">
      control: EXP INTEGER(v)
      e1:              BITSTREAM NAT
      e2:              BITSTREAM NAT
                 -&gt; NAT</programlisting>

      <para>
        The <emphasis>control</emphasis> is evaluated. It will be a constant at
        install time under the constant evaluation rules. If it is non-zero,
        <emphasis>e1</emphasis> is installed at this point and
        <emphasis>e2</emphasis> is ignored and never processed.  If
        <emphasis>control</emphasis> is zero then <emphasis>e2</emphasis> is
        installed at this point and <emphasis>e1</emphasis> is ignored and never
        processed.
      </para>
    </section>

    <section id="C5S25.3">
      <title>computed_nat</title>

      <emphasis role="bold">Encoding number</emphasis>: 3

      <programlisting language="TDF">
      arg:             EXP INTEGER(v)
                 -&gt; NAT</programlisting>

      <para>
        <emphasis>arg</emphasis> will be an install-time non-negative constant.
        The result is that constant.
      </para>
    </section>

    <section id="C5S25.4">
      <title>error_val</title>

      <emphasis role="bold">Encoding number</emphasis>: 4

      <programlisting language="TDF">
      err:             ERROR_code
                 -&gt; NAT</programlisting>

      <para>
        Gives the <code>NAT</code> corresponding to the <code>ERROR_code</code>
        <emphasis>err</emphasis>. Each distinct <code>ERROR_code</code> will
        give a different <code>NAT</code>.
      </para>
    </section>

    <section id="C5S25.5">
      <title>make_nat</title>

      <emphasis role="bold">Encoding number</emphasis>: 5

      <programlisting language="TDF">
      n:               TDFINT
                 -&gt; NAT</programlisting>

      <para>
        <emphasis>n</emphasis> is a non-negative integer of unbounded magnitude.
      </para>
    </section>
  </section>

  <section id="C5S26">
    <title>NTEST</title>

    <emphasis role="bold">Number of encoding bits</emphasis>: 4<sbr/>
    <emphasis role="bold">Is coding extendable</emphasis>: yes<sbr/>

    <para>
      These describe the comparisons which are possible in the various
      <emphasis>test</emphasis> constructions. Note that
      <emphasis>greater_than</emphasis> is not necessarily the same as
      <emphasis>not_less_than_or_equal</emphasis>, since the result need not be
      defined (e.g. in IEEE floating point).
    </para>

    <section id="C5S26.1">
      <title>ntest_apply</title>

      <emphasis role="bold">Encoding number</emphasis>: 1

      <programlisting language="TDF">
      token_value:     TOKEN
      token_args:      BITSTREAM param_sorts(token_value)
                 -&gt; NTEST</programlisting>

      <para>
        The token is applied to the arguments to give a <code>NTEST</code>.
      </para>

      <para>
        If there is a definition for <emphasis>token_value</emphasis> in the
        <code>CAPSULE</code> then <emphasis>token_args</emphasis> is a
        <code>BITSTREAM</code> encoding of the <code>SORT</code>s of its
        parameters, in the order specified.
      </para>
    </section>

    <section id="C5S26.2">
      <title>ntest_cond</title>

      <emphasis role="bold">Encoding number</emphasis>: 2

      <programlisting language="TDF">
      control: EXP INTEGER(v)
      e1:              BITSTREAM NTEST
      e2:              BITSTREAM NTEST
                 -&gt; NTEST</programlisting>

      <para>
        The <emphasis>control</emphasis> is evaluated. It will be a constant at
        install time under the constant evaluation rules. If it is non-zero,
        <emphasis>e1</emphasis> is installed at this point and
        <emphasis>e2</emphasis> is ignored and never processed.  If
        <emphasis>control</emphasis> is zero then <emphasis>e2</emphasis> is
        installed at this point and <emphasis>e1</emphasis> is ignored and never
        processed.
      </para>
    </section>

    <section id="C5S26.3">
      <title>equal</title>

      <emphasis role="bold">Encoding number</emphasis>: 3

      <programlisting language="TDF">
                 -&gt; NTEST</programlisting>

      <para>
        Signifies <quote>equal</quote> test.
      </para>
    </section>

    <section id="C5S26.4">
      <title>greater_than</title>

      <emphasis role="bold">Encoding number</emphasis>: 4

      <programlisting language="TDF">
                 -&gt; NTEST</programlisting>

      <para>
        Signifies <quote>greater than</quote> test.
      </para>
    </section>

    <section id="C5S26.5">
      <title>greater_than_or_equal</title>

      <emphasis role="bold">Encoding number</emphasis>: 5

      <programlisting language="TDF">
                 -&gt; NTEST</programlisting>

      <para>
        Signifies <quote>greater than or equal</quote> test.
      </para>
    </section>

    <section id="C5S26.6">
      <title>less_than</title>

      <emphasis role="bold">Encoding number</emphasis>: 6

      <programlisting language="TDF">
                 -&gt; NTEST</programlisting>

      <para>
        Signifies <quote>less than</quote> test.
      </para>
    </section>

    <section id="C5S26.7">
      <title>less_than_or_equal</title>

      <emphasis role="bold">Encoding number</emphasis>: 7

      <programlisting language="TDF">
                 -&gt; NTEST</programlisting>

      <para>
        Signifies <quote>less than or equal</quote> test.
      </para>
    </section>

    <section id="C5S26.8">
      <title>not_equal</title>

      <emphasis role="bold">Encoding number</emphasis>: 8

      <programlisting language="TDF">
                 -&gt; NTEST</programlisting>

      <para>
        Signifies <quote>not equal</quote> test.
      </para>
    </section>

    <section id="C5S26.9">
      <title>not_greater_than</title>

      <emphasis role="bold">Encoding number</emphasis>: 9

      <programlisting language="TDF">
                 -&gt; NTEST</programlisting>

      <para>
        Signifies <quote>not greater than</quote> test.
      </para>
    </section>

    <section id="C5S26.10">
      <title>not_greater_than_or_equal</title>

      <emphasis role="bold">Encoding number</emphasis>: 10

      <programlisting language="TDF">
                 -&gt; NTEST</programlisting>

      <para>
        Signifies <quote>not (greater than or equal)</quote> test.
      </para>
    </section>

    <section id="C5S26.11">
      <title>not_less_than</title>

      <emphasis role="bold">Encoding number</emphasis>: 11

      <programlisting language="TDF">
                 -&gt; NTEST</programlisting>

      <para>
        Signifies <quote>not less than</quote> test.
      </para>
    </section>

    <section id="C5S26.12">
      <title>not_less_than_or_equal</title>

      <emphasis role="bold">Encoding number</emphasis>: 12

      <programlisting language="TDF">
                 -&gt; NTEST</programlisting>

      <para>
        Signifies <quote>not (less than or equal)</quote> test.
      </para>
    </section>

    <section id="C5S26.13">
      <title>less_than_or_greater_than</title>

      <emphasis role="bold">Encoding number</emphasis>: 13

      <programlisting language="TDF">
                 -&gt; NTEST</programlisting>

      <para>
        Signifies <quote>less than or greater than</quote> test.
      </para>
    </section>

    <section id="C5S26.14">
      <title>not_less_than_and_not_greater_than</title>

      <emphasis role="bold">Encoding number</emphasis>: 14

      <programlisting language="TDF">
                 -&gt; NTEST</programlisting>

      <para>
        Signifies <quote>not less than and not greater than</quote> test.
      </para>
    </section>

    <section id="C5S26.15">
      <title>comparable</title>

      <emphasis role="bold">Encoding number</emphasis>: 15

      <programlisting language="TDF">
                 -&gt; NTEST</programlisting>

      <para>
        Signifies <quote>comparable</quote> test.
      </para>

      <para>
        With all operands <code>SHAPE</code>s except <code>FLOATING</code>, this
        comparison is always true.
      </para>
    </section>

    <section id="C5S26.16">
      <title>not_comparable</title>

      <emphasis role="bold">Encoding number</emphasis>: 16

      <programlisting language="TDF">
                 -&gt; NTEST</programlisting>

      <para>
        Signifies <quote>not comparable</quote> test.
      </para>

      <para>
        With all operands <code>SHAPE</code>s except <code>FLOATING</code>, this
        comparison is always false.
      </para>
    </section>
  </section>

  <section id="C5S27">
    <title>OTAGEXP</title>

    <emphasis role="bold">Number of encoding bits</emphasis>: 0<sbr/>
    <emphasis role="bold">Is coding extendable</emphasis>: no<sbr/>

    <para>
      This is a auxilliary <code>SORT</code> used in
      <emphasis>apply_general_proc</emphasis>.
    </para>

    <section id="C5S27.1">
      <title>make_otagexp</title>

      <emphasis role="bold">Encoding number</emphasis>: 0

      <programlisting language="TDF">
      tgopt:           OPTION(TAG x)
      e:               EXP x
                 -&gt; OTAGEXP</programlisting>

      <para>
        <emphasis>e</emphasis> is evaluated and its value is the actual caller
        parameter. If <emphasis>tgopt</emphasis> is present, the
        <code>TAG</code> will be bound to the final value of caller parameter in
        the <emphasis>postlude</emphasis> part of the
        <emphasis>apply_general_proc</emphasis>.
      </para>
    </section>
  </section>

  <section id="C5S28">
    <title>PROCPROPS</title>

    <emphasis role="bold">Number of encoding bits</emphasis>: 4<sbr/>
    <emphasis role="bold">Is coding extendable</emphasis>: yes<sbr/>

    <para>
      <code>PROCPROPS</code> is a set of properties ascribed to procedure
      definitions and calls.
    </para>

    <section id="C5S28.1">
      <title>procprops_apply_token</title>

      <emphasis role="bold">Encoding number</emphasis>: 1

      <programlisting language="TDF">
      token_value:     TOKEN
      token_args:      BITSTREAM param_sorts(token_value)
                 -&gt; PROCPROPS</programlisting>

      <para>
        The token is applied to the arguments to give a <code>PROCPROPS</code>.
      </para>

      <para>
        If there is a definition for <emphasis>token_value</emphasis> in the
        <code>CAPSULE</code> then <emphasis>token_args</emphasis> is a
        <code>BITSTREAM</code> encoding of the <code>SORT</code>s of its
        parameters in the order specified.
      </para>
    </section>

    <section id="C5S28.2">
      <title>procprops_cond</title>

      <emphasis role="bold">Encoding number</emphasis>: 2

      <programlisting language="TDF">
      control: EXP INTEGER(v)
      e1:              BITSTREAM PROCPROPS
      e2:              BITSTREAM PROCPROPS
                 -&gt; PROCPROPS</programlisting>

      <para>
        The <emphasis>control</emphasis> is evaluated. It will be a constant at
        install time under the constant evaluation rules. If it is non-zero,
        <emphasis>e1</emphasis> is installed at this point and
        <emphasis>e2</emphasis> is ignored and never processed.  If
        <emphasis>control</emphasis> is zero then <emphasis>e2</emphasis> is
        installed at this point and <emphasis>e1</emphasis> is ignored and never
        processed.
      </para>
    </section>

    <section id="C5S28.3">
      <title>add_procprops</title>

      <emphasis role="bold">Encoding number</emphasis>: 3

      <programlisting language="TDF">
      arg1:            PROCPROPS
      arg2:            PROCPROPS
                 -&gt; PROCPROPS</programlisting>

      <para>
        Delivers the join of <emphasis>arg1</emphasis> and <emphasis>arg2</emphasis>.
      </para>
    </section>

    <section id="C5S28.4">
      <title>check_stack</title>

      <emphasis role="bold">Encoding number</emphasis>: 4

      <programlisting language="TDF">
                 -&gt; PROCPROPS</programlisting>

      <para>
        The procedure body is required to check for stack overflow.
      </para>
    </section>

    <section id="C5S28.5">
      <title>inline</title>

      <emphasis role="bold">Encoding number</emphasis>: 5

      <programlisting language="TDF">
                 -&gt; PROCPROPS</programlisting>

      <para>
        The procedure body is a good candidate for inlining at its application.
      </para>
    </section>

    <section id="C5S28.6">
      <title>no_long_jump_dest</title>

      <emphasis role="bold">Encoding number</emphasis>: 6

      <programlisting language="TDF">
                 -&gt; PROCPROPS</programlisting>

      <para>
        The procedure body will contain no label which is the destination of a
        long_jump.
      </para>
    </section>

    <section id="C5S28.7">
      <title>untidy</title>

      <emphasis role="bold">Encoding number</emphasis>: 7

      <programlisting language="TDF">
                 -&gt; PROCPROPS</programlisting>

      <para>
        The procedure body may be exited using an
        <emphasis>untidy_return</emphasis>.
      </para>
    </section>

    <section id="C5S28.8">
      <title>var_callees</title>

      <emphasis role="bold">Encoding number</emphasis>: 8

      <programlisting language="TDF">
                 -&gt; PROCPROPS</programlisting>

      <para>
        Applications of the procedure may have different numbers of actual
        callee parameters.
      </para>
    </section>

    <section id="C5S28.9">
      <title>var_callers</title>

      <emphasis role="bold">Encoding number</emphasis>: 9

      <programlisting language="TDF">
                 -&gt; PROCPROPS</programlisting>

      <para>
        Applications of the procedure may have different numbers of actual
        caller parameters.
      </para>
    </section>
  </section>

  <section id="C5S29">
    <title>PROPS</title>

    <para>
      A <code>PROPS</code> is an assemblage of program information. This
      standard offers various ways of constructing a <code>PROPS</code>
      - i.e. it defines kinds of information which it is useful to express.
      These are:
    </para>

    <itemizedlist>
      <listitem>
        <para>
          definitions of <code>AL_TAG</code>s standing for
          <code>ALIGNMENT</code>s;
        </para>
      </listitem>

      <listitem>
        <para>
          declarations of <code>TAG</code>s standing for <code>EXP</code>s;
        </para>
      </listitem>

      <listitem>
        <para>
          definitions of the <code>EXP</code>s for which <code>TAG</code>s
          stand;
        </para>
      </listitem>

      <listitem>
        <para>
          declarations of <code>TOKEN</code>s standing for pieces of TDF
          program;
        </para>
      </listitem>

      <listitem>
        <para>
          definitions of the pieces of TDF program for which <code>TOKEN</code>s
          stand;
        </para>
      </listitem>

      <listitem>
        <para>
          linkage and naming information;
        </para>
      </listitem>

      <listitem>
        <para>
          version information
        </para>
      </listitem>
    </itemizedlist>

    <para>
      <code>PROPS</code> giving diagnostic information are described in a
      separate document.
    </para>

    <para>
      The standard can be extended by the definition of new kinds of
      <code>PROPS</code> information and new <code>PROPS</code> constructs for
      expressing them; and private standards can define new kinds of information
      and corresponding constructs without disruption to adherents to the
      present standard.
    </para>

    <para>
      Each <code>GROUP</code> of <code>UNIT</code>s is identified by a unit
      identification - a <code>TDFIDENT</code>. All the <code>UNIT</code>s in
      that <code>GROUP</code> are of the same kind.
    </para>

    <para>
      In addition there is a <emphasis>tld</emphasis> <code>UNIT</code>, see
      <!-- TODO link to 8.4. The TDF encoding -->The TDF encoding<!-- link end
      -->.
    </para>
  </section>

  <section id="C5S30">
    <title>ROUNDING_MODE</title>

    <emphasis role="bold">Number of encoding bits</emphasis>: 3<sbr/>
    <emphasis role="bold">Is coding extendable</emphasis>: yes<sbr/>

    <para>
      <code>ROUNDING_MODE</code> specifies the way rounding is to be performed
      in floating point arithmetic.
    </para>

    <section id="C5S30.1">
      <title>rounding_mode_apply_token</title>

      <emphasis role="bold">Encoding number</emphasis>: 1

      <programlisting language="TDF">
      token_value:     TOKEN
      token_args:      BITSTREAM param_sorts(token_value)
                 -&gt; ROUNDING_MODE</programlisting>

      <para>
        The token is applied to the arguments to give a
        <code>ROUNDING_MODE</code>.
      </para>

      <para>
        If there is a definition for <emphasis>token_value</emphasis> in the
        <code>CAPSULE</code> then <emphasis>token_args</emphasis> is a
        <code>BITSTREAM</code> encoding of the <code>SORT</code>s of its
        parameters, in the order specified.
      </para>
    </section>

    <section id="C5S30.2">
      <title>rounding_mode_cond</title>

      <emphasis role="bold">Encoding number</emphasis>: 2

      <programlisting language="TDF">
      control: EXP INTEGER(v)
      e1:              BITSTREAM ROUNDING_MODE
      e2:              BITSTREAM ROUNDING_MODE
                 -&gt; ROUNDING_MODE</programlisting>

      <para>
        The <emphasis>control</emphasis> is evaluated. It will be a constant at
        install time under the constant evaluation rules. If it is non-zero,
        <emphasis>e1</emphasis> is installed at this point and
        <emphasis>e2</emphasis> is ignored and never processed.  If
        <emphasis>control</emphasis> is zero then <emphasis>e2</emphasis> is
        installed at this point and <emphasis>e1</emphasis> is ignored and never
        processed.
      </para>
    </section>

    <section id="C5S30.3">
      <title>round_as_state</title>

      <emphasis role="bold">Encoding number</emphasis>: 3

      <programlisting language="TDF">
                 -&gt; ROUNDING_MODE</programlisting>

      <para>
        Round as specified by the current state of the machine.
      </para>
    </section>

    <section id="C5S30.4">
      <title>to_nearest</title>

      <emphasis role="bold">Encoding number</emphasis>: 4

      <programlisting language="TDF">
                 -&gt; ROUNDING_MODE</programlisting>

      <para>
        Signifies rounding to nearest. The effect when the number lies half-way
        is not specified.
      </para>
    </section>

    <section id="C5S30.5">
      <title>toward_larger</title>

      <emphasis role="bold">Encoding number</emphasis>: 5

      <programlisting language="TDF">
                 -&gt; ROUNDING_MODE</programlisting>

      <para>
        Signifies rounding toward next largest.
      </para>
    </section>

    <section id="C5S30.6">
      <title>toward_smaller</title>

      <emphasis role="bold">Encoding number</emphasis>: 6

      <programlisting language="TDF">
                 -&gt; ROUNDING_MODE</programlisting>

      <para>
        Signifies rounding toward next smallest.
      </para>
    </section>

    <section id="C5S30.7">
      <title>toward_zero</title>

      <emphasis role="bold">Encoding number</emphasis>: 7

      <programlisting language="TDF">
                 -&gt; ROUNDING_MODE</programlisting>

      <para>
        Signifies rounding toward zero.
      </para>
    </section>
  </section>

  <section id="C5S31">
    <title>SHAPE</title>

    <emphasis role="bold">Number of encoding bits</emphasis>: 4<sbr/>
    <emphasis role="bold">Is coding extendable</emphasis>: yes<sbr/>

    <para>
      <code>SHAPE</code>s express symbolic size and representation information
      about run time values.
    </para>

    <para>
      <code>SHAPE</code>s are constructed from primitive <code>SHAPE</code>s
      which describe values such as procedures and integers, and recursively
      from compound construction in terms of other <code>SHAPE</code>s.
    </para>

    <section id="C5S31.1">
      <title>shape_apply_token</title>

      <emphasis role="bold">Encoding number</emphasis>: 1

      <programlisting language="TDF">
      token_value:     TOKEN
      token_args:      BITSTREAM param_sorts(token_value)
                 -&gt; SHAPE</programlisting>

      <para>
        The token is applied to the arguments to give a <code>SHAPE</code>.
      </para>

      <para>
        If there is a definition for <emphasis>token_value</emphasis> in the
        <code>CAPSULE</code> then <emphasis>token_args</emphasis> is a
        <code>BITSTREAM</code> encoding of the <code>SORT</code>s of its
        parameters, in the order specified.
      </para>
    </section>

    <section id="C5S31.2">
      <title>shape_cond</title>

      <emphasis role="bold">Encoding number</emphasis>: 2

      <programlisting language="TDF">
      control: EXP INTEGER(v)
      e1:              BITSTREAM SHAPE
      e2:              BITSTREAM SHAPE
                 -&gt; SHAPE</programlisting>

      <para>
        The <emphasis>control</emphasis> is evaluated. It will be a constant at
        install time under the constant evaluation rules. If it is non-zero,
        <emphasis>e1</emphasis> is installed at this point and
        <emphasis>e2</emphasis> is ignored and never processed.  If
        <emphasis>control</emphasis> is zero then <emphasis>e2</emphasis> is
        installed at this point and <emphasis>e1</emphasis> is ignored and never
        processed.
      </para>
    </section>

    <section id="C5S31.3">
      <title>bitfield</title>

      <emphasis role="bold">Encoding number</emphasis>: 3

      <programlisting language="TDF">
      bf_var:          BITFIELD_VARIETY
                 -&gt; SHAPE</programlisting>

      <para>
        A <code>BITFIELD</code> is used to represent a pattern of bits which
        will be packed, provided that the <emphasis>variety_enclosed</emphasis>
        constraints are not violated.  (see See <!-- TODO link to 7.24.
        Representing bitfields -->section 7.24<!-- link end -->)
      </para>

      <para>
        A <code>BITFIELD_VARIETY</code> specifies the number of bits and whether
        they are considered to be signed.
      </para>

      <para>
        There are very few operations on <code>BITFIELD</code>s, which have to
        be converted to <code>INTEGER</code>s before arithmetic can be performed
        on them.
      </para>

      <para>
        An installer may place a limit on the number of bits it implements.  See
        <!-- TODO link to 7.25. Permitted limits -->Permitted limits<!-- link
        end -->.
      </para>
    </section>

    <section id="C5S31.4">
      <title>bottom</title>

      <emphasis role="bold">Encoding number</emphasis>: 4

      <programlisting language="TDF">
                 -&gt; SHAPE</programlisting>

      <para>
        <code>BOTTOM</code> is the <code>SHAPE</code> which describes a piece of
        program which does not evaluate to any result. Examples include
        <emphasis>goto</emphasis> and <emphasis>return</emphasis>.
      </para>

      <para>
        If <code>BOTTOM</code> is a parameter to any other <code>SHAPE</code>
        constructor, the result is <code>BOTTOM</code>.
      </para>
    </section>

    <section id="C5S31.5">
      <title>compound</title>

      <emphasis role="bold">Encoding number</emphasis>: 5

      <programlisting language="TDF">
      sz:              EXP OFFSET(x, y)
                 -&gt; SHAPE</programlisting>

      <para>
        The <code>SHAPE</code> constructor <code>COMPOUND</code> describes
        cartesian products and unions.
      </para>

      <para>
        The alignments <emphasis>x</emphasis> and <emphasis>y</emphasis> will be
        <emphasis>alignment</emphasis>(<emphasis>sx</emphasis>) and
        <emphasis>alignment</emphasis>(<emphasis>sy</emphasis>) for some
        <code>SHAPE</code>s <emphasis>sx</emphasis> and <emphasis>sy</emphasis>.
      </para>

      <para>
        <emphasis>sz</emphasis> will evaluate to a constant, non-negative
        <code>OFFSET</code> (see <!-- TODO link to 5.16.87. offset_pad
        -->offset_pad<!-- end link -->). The resulting <code>SHAPE</code>
        describes a value whose size is given by <emphasis>sz</emphasis>.
      </para>
    </section>

    <section id="C5S31.6">
      <title>floating</title>

      <emphasis role="bold">Encoding number</emphasis>: 6

      <programlisting language="TDF">
      fv:              FLOATING_VARIETY
                 -&gt; SHAPE</programlisting>

      <para>
        Most of the floating point arithmetic operations,
        <emphasis>floating_plus</emphasis>, <emphasis>floating_minus</emphasis>
        etc., are defined to work in the same way on different kinds of floating
        point number. If these operations have more than one argument the
        arguments have to be of the same kind, and the result is of the same
        kind.
      </para>

      <para>
        See <!-- TODO link to 7.20. Representing floating point -->Representing
        floating point<!-- link end -->.
      </para>

      <para>
        An installer may limit the <code>FLOATING_VARIETY</code>s it can
        represent. A statement of any such limits shall be part of the
        specification of an installer. See <!-- TODO link to 7.20.  Representing
        floating point -->Representing floating point<!-- link end -->.
      </para>
    </section>

    <section id="C5S31.7">
      <title>integer</title>

      <emphasis role="bold">Encoding number</emphasis>: 7

      <programlisting language="TDF">
      var:             VARIETY
                 -&gt; SHAPE</programlisting>

      <para>
        The different kinds of <code>INTEGER</code> are distinguished by having
        different <code>VARIETY</code>s. A fundamental <code>VARIETY</code> (not
        a <code>TOKEN</code> or conditional) is represented by two
        <code>SIGNED_NAT</code>s, respectively the lower and upper bounds
        (inclusive) of the set of values belonging to the <code>VARIETY</code>.
      </para>

      <para>
        Most architectures require that dyadic integer arithmetic operations
        take arguments of the same size, and so TDF does likewise. Because TDF
        is completely architecture neutral and makes no assumptions about word
        length, this means that the <code>VARIETY</code>s of the two arguments
        must be identical. An example illustrates this. A piece of TDF which
        attempted to add two values whose <code>SHAPE</code>s were:
      </para>

      <para>
                INTEGER(0, 60000)  <emphasis>and</emphasis>  INTEGER(0, 30000)
      </para>

      <para>
        would be undefined. The reason is that without knowledge of the target
        architecture's word length, it is impossible to guarantee that the two
        values are going to be represented in the same number of bytes.  On a
        16-bit machine they probably would, but not on a 15-bit machine.  The
        only way to ensure that two <code>INTEGER</code>s are going to be
        represented in the same way in all machines is to stipulate that their
        <code>VARIETY</code>s are exactly the same.
      </para>

      <para>
        When any construct delivering an <code>INTEGER</code> of a given
        <code>VARIETY</code> produces a result which is not representable in the
        space which an installer has chosen to represent that
        <code>VARIETY</code>, an integer overflow occurs. Whether it occurs in a
        particular case depends on the target, because the installers' decisions
        on representation are inherently target-defined.
      </para>

      <para>
        A particular installer may limit the ranges of integers that it
        implements. See <!-- TODO link to 7.18. Representing integers
        -->Representing integers<!-- end link -->.
      </para>
    </section>

    <section id="C5S31.8">
      <title>nof</title>

      <emphasis role="bold">Encoding number</emphasis>: 8

      <programlisting language="TDF">
      n:               NAT
      s:               SHAPE
                 -&gt; SHAPE</programlisting>

      <para>
        The <code>NOF</code> constructor describes the <code>SHAPE</code> of a
        value consisting of an array of <emphasis>n</emphasis> values of the
        same <code>SHAPE</code>, <emphasis>s</emphasis>.
      </para>
    </section>

    <section id="C5S31.9">
      <title>offset</title>

      <emphasis role="bold">Encoding number</emphasis>: 9

      <programlisting language="TDF">
      arg1:            ALIGNMENT
      arg2:            ALIGNMENT
                 -&gt; SHAPE</programlisting>

      <para>
        The <code>SHAPE</code> constructor <code>OFFSET</code> describes values
        which represent the differences between <code>POINTER</code>s, that is
        they measure offsets in memory. It should be emphasised that these are
        in general run-time values.
      </para>

      <para>
        An <code>OFFSET</code> measures the displacement from the value
        indicated by a <code>POINTER</code>(<emphasis>arg1</emphasis>) to the
        value indicated by a <code>POINTER</code>(<emphasis>arg2</emphasis>).
        Such an offset is only defined if the <code>POINTER</code>s are derived
        from the same original <code>POINTER</code>.
      </para>

      <para>
        An <code>OFFSET</code> may also measure the displacement from a
        <code>POINTER</code> to the start of a <code>BITFIELD_VARIETY</code>, or
        from the start of one <code>BITFIELD_VARIETY</code> to the start of
        another. Hence, unlike the argument of <emphasis>pointer</emphasis>,
        <emphasis>arg1</emphasis> or <emphasis>arg2</emphasis> may consist
        entirely of <code>BITFIELD_VARIETY</code>s.
      </para>

      <para>
        The set <emphasis>arg1</emphasis> will include the set
        <emphasis>arg2</emphasis>.
      </para>

      <para>
        See <!-- TODO link to 7.13. Memory Model -->Memory Model<!-- link end
        -->.
      </para>
    </section>

    <section id="C5S31.10">
      <title>pointer</title>

      <emphasis role="bold">Encoding number</emphasis>: 10

      <programlisting language="TDF">
      arg:             ALIGNMENT
                 -&gt; SHAPE</programlisting>

      <para>
        A <code>POINTER</code> is a value which points to space allocated in a
        computer's memory. The <code>POINTER</code> constructor takes an
        <code>ALIGNMENT</code> argument. This argument will not consist entirely
        of <code>BITFIELD_VARIETY</code>s. See <!-- TODO link to 7.13. Memory
        Model -->Memory Model<!-- end link -->.
      </para>
    </section>

    <section id="C5S31.11">
      <title>proc</title>

      <emphasis role="bold">Encoding number</emphasis>: 11

      <programlisting language="TDF">
                 -&gt; SHAPE</programlisting>

      <para>
        <code>PROC</code> is the <code>SHAPE</code> which describes pieces of
        program.
      </para>
    </section>

    <section id="C5S31.12">
      <title>top</title>

      <emphasis role="bold">Encoding number</emphasis>: 12

      <programlisting language="TDF">
                 -&gt; SHAPE</programlisting>

      <para>
        <code>TOP</code> is the <code>SHAPE</code> which describes pieces of
        program which return no useful value. assign is an example: it performs
        an assignment, but does not deliver any useful value.
      </para>
    </section>
  </section>

  <section id="C5S32">
    <title>SIGNED_NAT</title>

    <emphasis role="bold">Number of encoding bits</emphasis>: 3<sbr/>
    <emphasis role="bold">Is coding extendable</emphasis>: yes<sbr/>

    <para>
      These are positive or negative integers of unbounded size.
    </para>

    <section id="C5S32.1">
      <title>signed_nat_apply_token</title>

      <emphasis role="bold">Encoding number</emphasis>: 1

      <programlisting language="TDF">
      token_value:     TOKEN
      token_args:      BITSTREAM param_sorts(token_value)
                 -&gt; SIGNED_NAT</programlisting>

      <para>
        The token is applied to the arguments to give a <code>SIGNED_NAT</code>.
      </para>

      <para>
        If there is a definition for <emphasis>token_value</emphasis> in the
        <code>CAPSULE</code> then <emphasis>token_args</emphasis> is a
        <code>BITSTREAM</code> encoding of the <code>SORT</code>s of its
        parameters, in the order specified.
      </para>
    </section>

    <section id="C5S32.2">
      <title>signed_nat_cond</title>

      <emphasis role="bold">Encoding number</emphasis>: 2

      <programlisting language="TDF">
      control: EXP INTEGER(v)
      e1:              BITSTREAM SIGNED_NAT
      e2:              BITSTREAM SIGNED_NAT
                 -&gt; SIGNED_NAT</programlisting>

      <para>
        The <emphasis>control</emphasis> is evaluated. It will be a constant at
        install time under the constant evaluation rules. If it is non-zero,
        <emphasis>e1</emphasis> is installed at this point and
        <emphasis>e2</emphasis> is ignored and never processed.  If
        <emphasis>control</emphasis> is zero then <emphasis>e2</emphasis> is
        installed at this point and <emphasis>e1</emphasis> is ignored and never
        processed.
      </para>
    </section>

    <section id="C5S32.3">
      <title>computed_signed_nat</title>

      <emphasis role="bold">Encoding number</emphasis>: 3

      <programlisting language="TDF">
      arg:             EXP INTEGER(v)
                 -&gt; SIGNED_NAT</programlisting>

      <para>
        <emphasis>arg</emphasis> will be an install-time constant. The result is
        that constant.
      </para>
    </section>

    <section id="C5S32.4">
      <title>make_signed_nat</title>

      <emphasis role="bold">Encoding number</emphasis>: 4

      <programlisting language="TDF">
      neg:             TDFBOOL
      n:               TDFINT
                 -&gt; SIGNED_NAT</programlisting>

      <para>
        <emphasis>n</emphasis> is a non-negative integer of unbounded magnitude.
        The result is negative if and only if <emphasis>neg</emphasis> is true.
      </para>
    </section>

    <section id="C5S32.5">
      <title>snat_from_nat</title>

      <emphasis role="bold">Encoding number</emphasis>: 5

      <programlisting language="TDF">
      neg:             BOOL
      n:               NAT
                 -&gt; SIGNED_NAT</programlisting>

      <para>
        The result is negated if and only if <emphasis>neg</emphasis> is true.
      </para>
    </section>
  </section>

  <section id="C5S33">
    <title>SORTNAME</title>

    <emphasis role="bold">Number of encoding bits</emphasis>: 5<sbr/>
    <emphasis role="bold">Is coding extendable</emphasis>: yes<sbr/>

    <para>
      These are the names of the <code>SORT</code>s which can be parameters of
      <code>TOKEN</code> definitions.
    </para>

    <section id="C5S33.1">
      <title>access</title>

      <emphasis role="bold">Encoding number</emphasis>: 1

      <programlisting language="TDF">
                 -&gt; SORTNAME</programlisting>
    </section>

    <section id="C5S33.2">
      <title>al_tag</title>

      <emphasis role="bold">Encoding number</emphasis>: 2

      <programlisting language="TDF">
                 -&gt; SORTNAME</programlisting>
    </section>

    <section id="C5S33.3">
      <title>alignment_sort</title>

      <emphasis role="bold">Encoding number</emphasis>: 3

      <programlisting language="TDF">
                 -&gt; SORTNAME</programlisting>
    </section>

    <section id="C5S33.4">
      <title>bitfield_variety</title>

      <emphasis role="bold">Encoding number</emphasis>: 4

      <programlisting language="TDF">
                 -&gt; SORTNAME</programlisting>
    </section>

    <section id="C5S33.5">
      <title>bool</title>

      <emphasis role="bold">Encoding number</emphasis>: 5

      <programlisting language="TDF">
                 -&gt; SORTNAME</programlisting>
    </section>

    <section id="C5S33.6">
      <title>error_treatment</title>

      <emphasis role="bold">Encoding number</emphasis>: 6

      <programlisting language="TDF">
                 -&gt; SORTNAME</programlisting>
    </section>

    <section id="C5S33.7">
      <title>exp</title>

      <emphasis role="bold">Encoding number</emphasis>: 7

      <programlisting language="TDF">
                 -&gt; SORTNAME</programlisting>
    </section>

    <section id="C5S33.8">
      <title>floating_variety</title>

      <emphasis role="bold">Encoding number</emphasis>: 8

      <programlisting language="TDF">
                 -&gt; SORTNAME</programlisting>
    </section>

    <section id="C5S33.9">
      <title>foreign_sort</title>

      <emphasis role="bold">Encoding number</emphasis>: 9

      <programlisting language="TDF">
      foreign_name:    STRING(k, n)
                 -&gt; SORTNAME</programlisting>

      <para>
        This <code>SORT</code> enables unanticipated kinds of information to be
        placed in TDF.
      </para>
    </section>

    <section id="C5S33.10">
      <title>label</title>

      <emphasis role="bold">Encoding number</emphasis>: 10

      <programlisting language="TDF">
                 -&gt; SORTNAME</programlisting>
    </section>

    <section id="C5S33.11">
      <title>nat</title>

      <emphasis role="bold">Encoding number</emphasis>: 11

      <programlisting language="TDF">
                 -&gt; SORTNAME</programlisting>
    </section>

    <section id="C5S33.12">
      <title>ntest</title>

      <emphasis role="bold">Encoding number</emphasis>: 12

      <programlisting language="TDF">
                 -&gt; SORTNAME</programlisting>
    </section>

    <section id="C5S33.13">
      <title>procprops</title>

      <emphasis role="bold">Encoding number</emphasis>: 13

      <programlisting language="TDF">
                 -&gt; SORTNAME</programlisting>
    </section>

    <section id="C5S33.14">
      <title>rounding_mode</title>

      <emphasis role="bold">Encoding number</emphasis>: 14

      <programlisting language="TDF">
                 -&gt; SORTNAME</programlisting>
    </section>

    <section id="C5S33.15">
      <title>shape</title>

      <emphasis role="bold">Encoding number</emphasis>: 15

      <programlisting language="TDF">
                 -&gt; SORTNAME</programlisting>
    </section>

    <section id="C5S33.16">
      <title>signed_nat</title>

      <emphasis role="bold">Encoding number</emphasis>: 16

      <programlisting language="TDF">
                 -&gt; SORTNAME</programlisting>
    </section>

    <section id="C5S33.17">
      <title>string</title>

      <emphasis role="bold">Encoding number</emphasis>: 17

      <programlisting language="TDF">
                 -&gt; SORTNAME</programlisting>
    </section>

    <section id="C5S33.18">
      <title>tag</title>

      <emphasis role="bold">Encoding number</emphasis>: 18

      <programlisting language="TDF">
                 -&gt; SORTNAME</programlisting>

      <para>
        The <code>SORT</code> of <code>TAG</code>.
      </para>
    </section>

    <section id="C5S33.19">
      <title>transfer_mode</title>

      <emphasis role="bold">Encoding number</emphasis>: 19

      <programlisting language="TDF">
                 -&gt; SORTNAME</programlisting>
    </section>

    <section id="C5S33.20">
      <title>token</title>

      <emphasis role="bold">Encoding number</emphasis>: 20

      <programlisting language="TDF">
      result:          SORTNAME
      params:          LIST(SORTNAME)
                 -&gt; SORTNAME
      </programlisting>

      <para>
        The <code>SORTNAME</code> of a <code>TOKEN</code>. Note that it can have
        tokens as parameters, but not as result.
      </para>
    </section>

    <section id="C5S33.21">
      <title>variety</title>

      <emphasis role="bold">Encoding number</emphasis>: 21

      <programlisting language="TDF">
                 -&gt; SORTNAME
      </programlisting>
    </section>
  </section>

  <section id="C5S34">
    <title>STRING</title>

    <emphasis role="bold">Number of encoding bits</emphasis>: 3<sbr/>
    <emphasis role="bold">Is coding extendable</emphasis>: yes<sbr/>


    <section id="C5S34.1">
      <title>string_apply_token</title>

      <emphasis role="bold">Encoding number</emphasis>: 1

      <programlisting language="TDF">
      token_value:     TOKEN
      token_args:      BITSTREAM param_sorts(token_value)
                 -&gt; STRING(k, n)</programlisting>

      <para>
        The token is applied to the arguments to give a <code>STRING</code>
      </para>

      <para>
        If there is a definition for <emphasis>token_value</emphasis> in the
        <code>CAPSULE</code> then <emphasis>token_args</emphasis> is a
        <code>BITSTREAM</code> encoding of the <code>SORT</code>s of its
        parameters, in the order specified.
      </para>
    </section>

    <section id="C5S34.2">
      <title>string_cond</title>

      <emphasis role="bold">Encoding number</emphasis>: 2

      <programlisting language="TDF">
      control: EXP INTEGER(v)
      e1:              BITSTREAM STRING
      e2:              BITSTREAM STRING
                 -&gt; STRING(k, n)</programlisting>

      <para>
        The <emphasis>control</emphasis> is evaluated. It will be a constant at
        install time under the constant evaluation rules. If it is non-zero,
        <emphasis>e1</emphasis> is installed at this point and
        <emphasis>e2</emphasis> is ignored and never processed.  If
        <emphasis>control</emphasis> is zero then <emphasis>e2</emphasis> is
        installed at this point and <emphasis>e1</emphasis> is ignored and never
        processed.
      </para>
    </section>

    <section id="C5S34.3">
      <title>concat_string</title>

      <emphasis role="bold">Encoding number</emphasis>: 3

      <programlisting language="TDF">
      arg1:            STRING(k, n)
      arg2:            STRING(k, m)
                 -&gt; STRING(k, n+m)</programlisting>

      <para>
        Gives a <code>STRING</code> which is the concatenation of
        <emphasis>arg1</emphasis> with <emphasis>arg2</emphasis>.
      </para>
    </section>

    <section id="C5S34.4">
      <title>make_string</title>

      <emphasis role="bold">Encoding number</emphasis>: 4

      <programlisting language="TDF">
      arg:             TDFSTRING(k, n)
                 -&gt; STRING(k, n)</programlisting>

      <para>
        Delivers the <code>STRING</code> identical to the
        <emphasis>arg</emphasis>.
      </para>
    </section>
  </section>

  <section id="C5S35">
    <title>AL_TAG</title>

    <emphasis role="bold">Number of encoding bits</emphasis>: 1
    <emphasis role="bold">Is coding extendable</emphasis>: yes<sbr/>
    <emphasis role="bold">Linkable entity identification</emphasis>: tag<sbr/>

    <para>
      These are used to name values and variables in the run time program.
    </para>

    <section id="C5S35.1">
      <title>tag_apply_token</title>

      <emphasis role="bold">Encoding number</emphasis>: 2

      <programlisting language="TDF">
      token_value:     TOKEN
      token_args:      BITSTREAM param_sorts(token_value)
                 -&gt; TAG x</programlisting>

      <para>
        The token is applied to the arguments to give a <code>TAG</code>.
      </para>

      <para>
        If there is a definition for <emphasis>token_value</emphasis> in the
        <code>CAPSULE</code> then <emphasis>token_args</emphasis> is a
        <code>BITSTREAM</code> encoding of the <code>SORT</code>s of its
        parameters, in the order specified.
      </para>
    </section>

    <section id="C5S35.2">
      <title>make_tag</title>

      <emphasis role="bold">Encoding number</emphasis>: 1

      <programlisting language="TDF">
      tagno:           TDFINT
                 -&gt; TAG x</programlisting>

      <para>
        <emphasis>make_tag</emphasis> produces a <code>TAG</code> identified by
        <emphasis>tagno</emphasis>.
      </para>
    </section>
  </section>

  <section id="C5S36">
    <title>TAGACC</title>

    <emphasis role="bold">Number of encoding bits</emphasis>: 0<sbr/>
    <emphasis role="bold">Is coding extendable</emphasis>: no<sbr/>

    <para>
      Constructs a pair of a <code>TAG</code> and an <code>OPTION(ACCESS)</code>
      for use in <emphasis>make_proc</emphasis>.
    </para>

    <section id="C5S36.1">
      <title>make_tagacc</title>

      <emphasis role="bold">Encoding number</emphasis>: 0

      <programlisting language="TDF">
      tg:              TAG POINTER var_param_alignment
      acc:             OPTION(ACCESS)
                 -&gt; TAGACC</programlisting>

      <para>
        Constructs the pair for <emphasis>make_proc</emphasis>.
      </para>
    </section>
  </section>

  <section id="C5S37">
    <title>TAGDEC</title>

    <emphasis role="bold">Number of encoding bits</emphasis>: 2<sbr/>
    <emphasis role="bold">Is coding extendable</emphasis>: yes<sbr/>

    <para>
      A <code>TAGDEC</code> declares a <code>TAG</code> for incorporation into a
      <code>TAGDEC_PROPS.</code>
    </para>

    <section id="C5S37.1">
      <title>make_id_tagdec</title>

      <emphasis role="bold">Encoding number</emphasis>: 1

      <programlisting language="TDF">
      t_intro: TDFINT
      acc:             OPTION(ACCESS)
      signature:       OPTION(STRING)
      x:               SHAPE
                 -&gt; TAGDEC</programlisting>

      <para>
        A <code>TAGDEC</code> announcing that the <code>TAG</code>
        <emphasis>t_intro</emphasis> identifies an <code>EXP</code> of
        <code>SHAPE</code> <emphasis>x</emphasis> is constructed.
      </para>

      <para>
        <emphasis>acc</emphasis> specifies the <code>ACCESS</code> properties of
        the <code>TAG</code>.
      </para>

      <para>
        If there is a <emphasis>make_id_tagdec</emphasis> for a <code>TAG</code>
        then all other <emphasis>make_id_tagdec</emphasis> for the same
        <code>TAG</code> will specify the same <code>SHAPE</code> and there will
        be no <emphasis>make_var_tagdec</emphasis> or
        <emphasis>common_tagdec</emphasis> for the <code>TAG</code>.
      </para>

      <para>
        If two <emphasis>make_id_tagdecs</emphasis> specify the same tag and
        both have <emphasis>signatures</emphasis> present, the strings will be
        identical. Possible uses of this signature argument are outlined in <!--
        TODO link to 7.28. Tag and Token signatures -->section 7.28<!-- end link
        -->.
      </para>
    </section>

    <section id="C5S37.2">
      <title>make_var_tagdec</title>

      <emphasis role="bold">Encoding number</emphasis>: 2

      <programlisting language="TDF">
      t_intro: TDFINT
      acc:             OPTION(ACCESS)
      signature:       OPTION(STRING)
      x:               SHAPE
                 -&gt; TAGDEC</programlisting>

      <para>
        A <code>TAGDEC</code> announcing that the <code>TAG</code>
        <emphasis>t_intro</emphasis> identifies an <code>EXP</code> of
        <code>SHAPE POINTER</code>(<emphasis>alignment
        </emphasis>(<emphasis>x</emphasis>)) is constructed.
      </para>

      <para>
        <emphasis>acc</emphasis> specifies the <code>ACCESS</code> properties of
        the <code>TAG</code>.
      </para>

      <para>
        If there is a <emphasis>make_var_tagdec</emphasis> for a
        <code>TAG</code> then all other <emphasis>make_var_tagdec</emphasis>s
        for the same <code>TAG</code> will specify <code>SHAPE</code>s with
        identical <code>ALIGNMENT</code> and there will be no
        <emphasis>make_id_tagdec</emphasis> or
        <emphasis>common_tagdec</emphasis> for the <code>TAG</code>.
      </para>

      <para>
        If two <emphasis>make_var_tagdec</emphasis>s specify the same tag and
        both have <emphasis>signature</emphasis> present, the strings will be
        identical. Possible uses of this signature argument are outlined in <!--
        TODO link to 7.28. Tag and Token signatures -->section 7.28<!-- link end
        -->.
      </para>
    </section>

    <section id="C5S37.3">
      <title>common_tagdec</title>

      <emphasis role="bold">Encoding number</emphasis>: 3

      <programlisting language="TDF">
      t_intro: TDFINT
      acc:             OPTION(ACCESS)
      signature:       OPTION(STRING)
      x:               SHAPE
                 -&gt; TAGDEC</programlisting>

      <para>
        A <code>TAGDEC</code> announcing that the <code>TAG</code>
        <emphasis>t_intro</emphasis> identifies an <code>EXP</code> of
        <code>SHAPE POINTER</code>(<emphasis>alignment
        </emphasis>(<emphasis>x</emphasis>)) is constructed.
      </para>

      <para>
        <emphasis>acc</emphasis> specifies the <code>ACCESS</code> properties of
        the <code>TAG</code>.
      </para>

      <para>
        If there is a <emphasis>common_tagdec</emphasis> for a <code>TAG</code>
        then there will be no <emphasis>make_id_tagdec</emphasis> or
        <emphasis>make_var_tagdec</emphasis> for that <code>TAG</code>. If there
        is more than one <emphasis>common_tagdec</emphasis> for a
        <code>TAG</code> the one having the maximum <code>SHAPE</code> shall be
        taken to apply for the <code>CAPSULE</code>. Each pair of such
        <code>SHAPE</code>s will have a maximum. The maximum of two
        <code>SHAPE</code>s, <emphasis>a</emphasis> and <emphasis>b</emphasis>,
        is defined as follows:
      </para>

      <itemizedlist>
        <listitem>
          <para>
            If the <emphasis>a</emphasis> is equal to <emphasis>b</emphasis> the
            maximum is <emphasis>a</emphasis>.
          </para>
        </listitem>

        <listitem>
          <para>
            If <emphasis>a</emphasis> and <emphasis>b</emphasis> are
            <code>COMPOUND</code>(<emphasis>x</emphasis>) and
            <code>COMPOUND</code>(<emphasis>y</emphasis>) respectively and
            <emphasis>a</emphasis> is an initial segment of
            <emphasis>b</emphasis>, then <emphasis>b</emphasis> is the maximum.
            Similarly if <emphasis>b</emphasis> is an initial segment of
            <emphasis>a</emphasis> then <emphasis>a</emphasis> is the maximum.
          </para>
        </listitem>

        <listitem>
          <para>
            If <emphasis>a</emphasis> and <emphasis>b</emphasis> are
            <code>NOF</code>(<emphasis>n</emphasis>, <emphasis>x</emphasis>) and
            <code>NOF</code>(<emphasis>m</emphasis>, <emphasis>x</emphasis>)
            respectively and <emphasis>n</emphasis> is less than or equal to
            <emphasis>m</emphasis>, then <emphasis>b</emphasis> is the maximum.
            Similarly if <emphasis>m</emphasis> is less than or equal to
            <emphasis>n</emphasis> then <emphasis>a</emphasis> is the maximum.
          </para>
        </listitem>

        <listitem>
          <para>
            Otherwise <emphasis>a</emphasis> and <emphasis>b</emphasis> have no
            maximum.
          </para>
        </listitem>
      </itemizedlist>

      <para>
        If two <emphasis>common_tagdecs</emphasis> specify the same tag and both
        have <emphasis>signatures</emphasis> present, the strings will be
        identical. Possible uses of this signature argument are outlined in <!--
        TODO link to 7.28. Tag and Token signatures -->section 7.28<!-- link end
        -->.
      </para>
    </section>
  </section>

  <section id="C5S38">
    <title>TAGDEC_PROPS</title>

    <emphasis role="bold">Number of encoding bits</emphasis>: 0<sbr/>
    <emphasis role="bold">Is coding extendable</emphasis>: no<sbr/>
    <emphasis role="bold">Unit identification</emphasis>: tagdec

    <section id="C5S38.1">
      <title>make_tagdecs</title>

      <emphasis role="bold">Encoding number</emphasis>: 0

      <programlisting language="TDF">
      no_labels:       TDFINT
      tds:             SLIST(TAGDEC)
                 -&gt; TAGDEC_PROPS</programlisting>

      <para>
        <emphasis>no_labels</emphasis> is the number of local
        <code>LABEL</code>s used in <emphasis>tds</emphasis>.
        <emphasis>tds</emphasis> is a list of <code>TAGDEC</code>s which declare
        the <code>SHAPE</code>s associated with <code>TAG</code>s.
      </para>
    </section>
  </section>

  <section id="C5S39">
    <title>TAGDEF</title>

    <emphasis role="bold">Number of encoding bits</emphasis>: 2<sbr/>
    <emphasis role="bold">Is coding extendable</emphasis>: yes<sbr/>

    <para>
      A value of <code>SORT TAGDEF</code> gives the definition of a
      <code>TAG</code> for incorporation into a <code>TAGDEF_PROPS</code>.
    </para>

    <section id="C5S39.1">
      <title>make_id_tagdef</title>

      <emphasis role="bold">Encoding number</emphasis>: 1

      <programlisting language="TDF">
      t:               TDFINT
      signature:       OPTION(STRING)
      e:               EXP x
                 -&gt; TAGDEF</programlisting>

      <para>
        <emphasis>make_id_tagdef</emphasis> produces a <code>TAGDEF</code>
        defining the <code>TAG</code> <emphasis>x</emphasis> constructed from
        the <code>TDFINT</code>, <emphasis>t</emphasis>. This <code>TAG</code>
        is defined to stand for the value delivered by <emphasis>e</emphasis>.
      </para>

      <para>
        <emphasis>e</emphasis> will be a constant which can be evaluated at
        load_time or <emphasis>e</emphasis> will be some
        <emphasis>initial_value</emphasis>(E) (see <!-- TODO link to 5.16.48.
        initial_value -->section 5.16.48<!-- end link -->).
      </para>

      <para>
        <emphasis>t</emphasis> will be declared in the <code>CAPSULE</code>
        using <emphasis>make_id_tagdec</emphasis>.  If both the
        <emphasis>make_id_tagdec</emphasis> and
        <emphasis>make_id_tagdef</emphasis> have <emphasis>signatures</emphasis>
        present, the strings will be identical.
      </para>

      <para>
        If <emphasis>x</emphasis> is <code>PROC</code> and the <code>TAG</code>
        represented by <emphasis>t</emphasis> is named externally via a
        <code>CAPSULE_LINK</code>, e will be some <emphasis>make_proc</emphasis>
        or <emphasis>make_general_proc</emphasis>.
      </para>

      <para>
        There will not be more than one <code>TAGDEF</code> defining
        <emphasis>t</emphasis> in a <code>CAPSULE</code>.
      </para>
    </section>

    <section id="C5S39.2">
      <title>make_var_tagdef</title>

      <emphasis role="bold">Encoding number</emphasis>: 2

      <programlisting language="TDF">
      t:               TDFINT
      opt_access:      OPTION(ACCESS)
      signature:       OPTION(STRING)
      e:               EXP x
                 -&gt; TAGDEF</programlisting>

      <para>
        <emphasis>make_var_tagdef</emphasis> produces a <code>TAGDEF</code>
        defining the <code>TAG POINTER</code>(<emphasis>alignment(x)</emphasis>)
        constructed from the <code>TDFINT</code>, <emphasis>t</emphasis>. This
        <code>TAG</code> stands for a variable which is initialised with the
        value delivered by <emphasis>e</emphasis>.  The <code>TAG</code> is
        bound to an original pointer which has the evaluation of the program as
        its lifetime.
      </para>

      <para>
        If <emphasis>opt_access</emphasis> contains
        <emphasis>visible</emphasis>, the meaning is that the variable may be
        used by agents external to the capsule, and so it must not be optimised
        away. If it contains constant, the initialising value will remain in it
        throughout the program.
      </para>

      <para>
        <emphasis>e</emphasis> will be a constant which can be evaluated at
        load_time or <emphasis>e</emphasis> will be some
        <emphasis>initial_value</emphasis>(<emphasis>e1</emphasis>) (see <!--
        TODO link to 5.16.48. initial_value -->section 5.16.48<!-- link end
        -->).
      </para>

      <para>
        <emphasis>t</emphasis> will be declared in the <code>CAPSULE</code>
        using <emphasis>make_var_tagdec</emphasis>.  If both the
        <emphasis>make_var_tagdec</emphasis> and
        <emphasis>make_var_tagdef</emphasis> have
        <emphasis>signatures</emphasis> present, the strings will be identical.
      </para>

      <para>
        There will not be more than one <code>TAGDEF</code> defining
        <emphasis>t</emphasis> in a <code>CAPSULE</code>.
      </para>
    </section>

    <section id="C5S39.3">
      <title>common_tagdef</title>

      <emphasis role="bold">Encoding number</emphasis>: 3

      <programlisting language="TDF">
      t:               TDFINT
      opt_access:      OPTION(ACCESS)
      signature:       OPTION(STRING)
      e:               EXP x
                 -&gt; TAGDEF</programlisting>

      <para>
        <emphasis>common_tagdef</emphasis> produces a <code>TAGDEF</code>
        defining the <code>TAG</code>
        <code>POINTER</code>(<emphasis>alignment(x)</emphasis>) constructed from
        the <code>TDFINT</code>, <emphasis>t</emphasis>. This <code>TAG</code>
        stands for a variable which is initialised with the value delivered by
        <emphasis>e</emphasis>. The <code>TAG</code> is bound to an original
        pointer which has the evaluation of the program as its lifetime.
      </para>

      <para>
        If <emphasis>opt_access</emphasis> contains
        <emphasis>visible</emphasis>, the meaning is that the variable may be
        used by agents external to the capsule, and so it must not be optimised
        away. If it contains constant, the initialising value will remain in it
        throughout the program.
      </para>

      <para>
        <emphasis>e</emphasis> will be a constant evaluable at load_time or
        <emphasis>e</emphasis> will be some
        <emphasis>initial_value</emphasis>(E) (see <!-- TODO link to 5.16.48.
        initial_value -->section 5.16.48 <!-- end link -->).
      </para>

      <para>
        <emphasis>t</emphasis> will be declared in the <code>CAPSULE</code>
        using <emphasis>common_tagdec</emphasis>.If both the
        <emphasis>common_tagdec</emphasis> and
        <emphasis>common_tagdef</emphasis> have <emphasis>signatures</emphasis>
        present, the strings will be identical. Let the maximum
        <code>SHAPE</code> of these (see <!-- TODO link to 5.37.3. common_tagdec
        -->common_tagdec<!-- link end -->) be <emphasis>s</emphasis>.
      </para>

      <para>
        There may be any number of <emphasis>common_tagdef</emphasis>
        definitions for <emphasis>t</emphasis> in a <code>CAPSULE</code>. Of the
        <emphasis>e</emphasis> parameters of these, one will be a maximum.  This
        maximum definition is chosen as the definition of
        <emphasis>t</emphasis>. Its value of <emphasis>e</emphasis> will have
        <code>SHAPE</code> <emphasis>s</emphasis>.
      </para>

      <para>
        The maximum of two <emphasis>common_tagdef</emphasis> <code>EXP</code>s,
        <emphasis>a</emphasis> and <emphasis>b</emphasis>, is defined as
        follows:
      </para>

      <itemizedlist>
        <listitem>
          <para>
            If <emphasis>a</emphasis> has the form
            <emphasis>make_value</emphasis>(<emphasis>s</emphasis>),
            <emphasis>b</emphasis> is the maximum.
          </para>
        </listitem>

        <listitem>
          <para>
            If <emphasis>b</emphasis> has the form
            <emphasis>make_value</emphasis>(<emphasis>s</emphasis>),
            <emphasis>a</emphasis> is the maximum.
          </para>
        </listitem>

        <listitem>
          <para>
            If <emphasis>a</emphasis> and <emphasis>b</emphasis> have
            <code>SHAPE COMPOUND</code>(<emphasis>x</emphasis>) and
            <code>COMPOUND</code>(<emphasis>y</emphasis>) respectively and the
            value produced by <emphasis>a</emphasis> is an initial segment of
            the value produced by <emphasis>b</emphasis>, then
            <emphasis>b</emphasis> is the maximum. Similarly if
            <emphasis>b</emphasis> is an initial segment of
            <emphasis>a</emphasis> then <emphasis>a</emphasis> is the maximum.
          </para>
        </listitem>

        <listitem>
          <para>
            If <emphasis>a</emphasis> and <emphasis>b</emphasis> have
            <code>SHAPE NOF</code>(<emphasis>n</emphasis>,
            <emphasis>x</emphasis>) and <code>NOF</code>(<emphasis>m</emphasis>,
            <emphasis>x</emphasis>) respectively and the value produced by
            <emphasis>a</emphasis> is an initial segment of the value produced
            by <emphasis>b</emphasis>, then <emphasis>b</emphasis> is the
            maximum. Similarly if <emphasis>b</emphasis> is an initial segment
            of <emphasis>a</emphasis> then <emphasis>a</emphasis> is the
            maximum.
          </para>
        </listitem>

        <listitem>
          <para>
            If the value produced by <emphasis>a</emphasis> is equal to the
            value produced by <emphasis>b</emphasis> the maximum is
            <emphasis>a</emphasis>.
          </para>
        </listitem>

        <listitem>
          <para>
            Otherwise <emphasis>a</emphasis> and <emphasis>b</emphasis> have no
            maximum.
          </para>
        </listitem>
      </itemizedlist>
    </section>
  </section>

  <section id="C5S40">
    <title>TAGDEF_PROPS</title>

    <emphasis role="bold">Number of encoding bits</emphasis>: 0<sbr/>
    <emphasis role="bold">Is coding extendable</emphasis>: no<sbr/>
    <emphasis role="bold">Unit identification</emphasis>: tagdef

    <section id="C5S40.1">
      <title>make_tagdefs</title>

      <emphasis role="bold">Encoding number</emphasis>: 0

      <programlisting language="TDF">
      no_labels:       TDFINT
      tds:             SLIST(TAGDEF)
                 -&gt; TAGDEF_PROPS</programlisting>

      <para>
        <emphasis>no_labels</emphasis> is the number of local
        <code>LABEL</code>s used in <emphasis>tds</emphasis>.
        <emphasis>tds</emphasis> is a list of <code>TAGDEF</code>s which give
        the <code>EXP</code>s which are the definitions of values associated
        with <code>TAG</code>s.
      </para>
    </section>
  </section>

  <section id="C5S41">
    <title>TAGSHACC</title>

    <emphasis role="bold">Number of encoding bits</emphasis>: 0<sbr/>
    <emphasis role="bold">Is coding extendable</emphasis>: no<sbr/>

    <section id="C5S41.1">
      <title>make_tagshacc</title>

      <emphasis role="bold">Encoding number</emphasis>: 0

      <programlisting language="TDF">
      sha:             SHAPE
      opt_access:      OPTION(ACCESS)
      tg_intro:        TAG
                 -&gt; TAGSHACC</programlisting>

      <para>
        This is an auxiliary construction to make the elements of
        <emphasis>params_intro</emphasis> in <emphasis>make_proc</emphasis>.
      </para>
    </section>
  </section>

  <section id="C5S42">
    <title>TDFBOOL</title>

    <para>
      A <code>TDFBOOL</code> is the TDF encoding of a boolean. See <!-- TODO
      link to 8.2. Fundamental encodings -->Fundamental encoding<!-- link end
      -->.
    </para>
  </section>

  <section id="C5S43">
    <title>TDFIDENT</title>

    <para>
      A <code>TDFIDENT</code>(<emphasis>k</emphasis>, <emphasis>n</emphasis>)
      encodes a sequence of <emphasis>n</emphasis> unsigned integers of size
      <emphasis>k</emphasis> bits. <emphasis>k</emphasis> will be a multiple of
      8. See <!-- TODO link to 8.2. Fundamental encodings -->Fundamental
      encoding<!-- end link -->.
    </para>

    <para>
      This construction will not be used inside a <code>BITSTREAM</code>.
    </para>
  </section>

  <section id="C5S44">
    <title>TDFINT</title>

    <para>
      A <code>TDFINT</code> is the TDF encoding of an unbounded unsigned integer
      constant. See <!-- TODO link to 8.2. Fundamental encodings -->Fundamental
      encoding<!-- end link -->.
    </para>
  </section>

  <section id="C5S45">
    <title>TDFSTRING</title>

    <para>
      A <code>TDFSTRING</code>(<emphasis>k</emphasis>, <emphasis>n</emphasis>)
      encodes a sequence of <emphasis>n</emphasis> unsigned integers of size
      <emphasis>k</emphasis> bits. See <!-- TODO link to 8.2. Fundamental
      encodings -->Fundamental encoding<!-- end link -->.
    </para>
  </section>

  <section id="C5S46">
    <title>TOKDEC</title>

    <emphasis role="bold">Number of encoding bits</emphasis>: 1<sbr/>
    <emphasis role="bold">Is coding extendable</emphasis>: yes<sbr/>

    <para>
      A <code>TOKDEC</code> declares a <code>TOKEN</code> for incorporation into
      a <code>UNIT</code>.
    </para>

    <section id="C5S46.1">
      <title>make_tokdec</title>

      <emphasis role="bold">Encoding number</emphasis>: 1

      <programlisting language="TDF">
      tok:             TDFINT
      signature:       OPTION(STRING)
      s:               SORTNAME
                 -&gt; TOKDEC</programlisting>

      <para>
        The sort of the token <emphasis>tok</emphasis> is declared to be
        <emphasis>s</emphasis>. Note that <emphasis>s</emphasis> will always be
        a token <code>SORT</code>, with a list of parameter <code>SORT</code>s
        (possible empty) and a result <code>SORT</code>.
      </para>

      <para>
        If <emphasis>signature</emphasis> is present, it will be produced by
        <emphasis>make_string</emphasis>.
      </para>

      <para>
        If two <emphasis>make_tokdecs</emphasis> specify the same token and both
        have <emphasis>signatures</emphasis> present, the strings will be
        identical. Possible uses of this signature argument are outlined in <!--
        TODO link to 7.28. Tag and Token signatures -->section 7.28<!-- link end
        -->.
      </para>
    </section>
  </section>

  <section id="C5S47">
    <title>TOKDEC_PROPS</title>

    <emphasis role="bold">Number of encoding bits</emphasis>: 0<sbr/>
    <emphasis role="bold">Is coding extendable</emphasis>: no<sbr/>
    <emphasis role="bold">Unit identification</emphasis>: tokdec<sbr/>

    <section id="C5S47.1">
      <title>make_tokdecs</title>

      <emphasis role="bold">Encoding number</emphasis>: 0

      <programlisting language="TDF">
      tds:             SLIST(TOKDEC)
                 -&gt; TOKDEC_PROPS</programlisting>

      <para>
        <emphasis>tds</emphasis> is a list of <code>TOKDEC</code>s which gives
        the sorts associated with <code>TOKEN</code>s.
      </para>
    </section>
  </section>

  <section id="C5S48">
    <title>TOKDEF</title>

    <emphasis role="bold">Number of encoding bits</emphasis>: 1<sbr/>
    <emphasis role="bold">Is coding extendable</emphasis>: yes<sbr/>

    <para>
      <emphasis>tds</emphasis> is a list of <code>TOKDEC</code>s which gives the
      sorts associated with <code>TOKEN</code>s.
    </para>

    <section id="C5S48.1">
      <title>make_tokdef</title>

      <emphasis role="bold">Encoding number</emphasis>: 1

      <programlisting language="TDF">
      tok:             TDFINT
      signature:       OPTION(STRING)
      def:             BITSTREAM TOKEN_DEFN
                 -&gt; TOKDEF</programlisting>

      <para>
        A <code>TOKDEF</code> is constructed which defines the
        <code>TOKEN</code> <emphasis>tok</emphasis> to stand for the fragment of
        TDF, <emphasis>body</emphasis>, which may be of any <code>SORT</code>
        with a <code>SORTNAME</code>, except for <emphasis>token</emphasis>. The
        <code>SORT</code> of the result, <emphasis>result_sort</emphasis>, is
        given by the first component of the <code>BITSTREAM</code>. See <!--
        TODO link to 5.51.1.  token_definition -->token_definition<!-- end link
        -->.
      </para>

      <para>
        If <emphasis>signature</emphasis> is present, it will be produced by
        <emphasis>make_string</emphasis>.
      </para>

      <para>
        <emphasis>tok</emphasis> may have been introduced by a
        <emphasis>make_tokdec</emphasis>. If both the
        <emphasis>make_tokdec</emphasis> and <emphasis>make_tokdef</emphasis>
        have <emphasis>signatures</emphasis> present, the strings will be
        identical.
      </para>

      <para>
        At the application of this <code>TOKEN</code> actual pieces of TDF
        having <code>SORT</code> <emphasis>sn</emphasis>[<emphasis>i</emphasis>]
        are supplied to correspond to the
        <emphasis>tk</emphasis>[<emphasis>i</emphasis>]. The application denotes
        the piece of TDF obtained by substituting these actual parameters for
        the corresponding <code>TOKEN</code>s within <emphasis>body</emphasis>.
      </para>
    </section>
  </section>

  <section id="C5S49">
    <title>TOKDEF_PROPS</title>

    <emphasis role="bold">Number of encoding bits</emphasis>: 0<sbr/>
    <emphasis role="bold">Is coding extendable</emphasis>: no<sbr/>
    <emphasis role="bold">Unit identification</emphasis>: tokdef<sbr/>

    <section id="C5S49.1">
      <title>make_tokdefs</title>

      <emphasis role="bold">Encoding number</emphasis>: 0

      <programlisting language="TDF">
      no_labels:       TDFINT
      tds:             SLIST(TOKDEF)
                 -&gt; TOKDEF_PROPS</programlisting>

      <para>
        <emphasis>no_labels</emphasis> is the number of local
        <code>LABEL</code>s used in <emphasis>tds</emphasis>.
        <emphasis>tds</emphasis> is a list of <code>TOKDEF</code>s which gives
        the definitions associated with <code>TOKEN</code>s.
      </para>
    </section>
  </section>

  <section id="C5S50">
    <title>TOKEN</title>

    <emphasis role="bold">Number of encoding bits</emphasis>: 2<sbr/>
    <emphasis role="bold">Is coding extendable</emphasis>: yes<sbr/>
    <emphasis role="bold">Linkable entity identificaiton</emphasis>:
    token<sbr/>

    <para>
      These are used to stand for functions evaluated at installation time.
      They are represented by <code>TDFINT</code>s.
    </para>

    <section id="C5S50.1">
      <title>token_apply_token</title>

      <emphasis role="bold">Encoding number</emphasis>: 1

      <programlisting language="TDF">
      token_value:     TOKEN
      token_args:      BITSTREAM param_sorts(token_value)
                 -&gt; TOKEN</programlisting>

      <para>
        The token is applied to the arguments to give a <code>TOKEN</code>.
      </para>

      <para>
        If there is a definition for <emphasis>token_value</emphasis> in the
        <code>CAPSULE</code> then <emphasis>token_args</emphasis> is a
        <code>BITSTREAM</code> encoding of the <code>SORT</code>s of its
        parameters, in the order specified.
      </para>
    </section>

    <section id="C5S50.2">
      <title>make_tok</title>

      <emphasis role="bold">Encoding number</emphasis>: 2

      <programlisting language="TDF">
      tokno:           TDFINT
                 -&gt; TOKEN</programlisting>

      <para>
        <emphasis>make_tok</emphasis> constructs a <code>TOKEN</code> identified
        by <emphasis>tokno</emphasis>.
      </para>
    </section>

    <section id="C5S50.3">
      <title>use_tokdef</title>

      <emphasis role="bold">Encoding number</emphasis>: 3

      <programlisting language="TDF">
      tdef:            BITSTREAM TOKEN_DEFN
                 -&gt; TOKEN</programlisting>

      <para>
        <emphasis>tdef</emphasis> is used to supply the definition, as in
        <emphasis>make_tokdef</emphasis>. Note that <code>TOKEN</code>s are only
        used in <emphasis>x_apply_token</emphasis> constructions.
      </para>
    </section>
  </section>

  <section id="C5S51">
    <title>TOKEN_DEFN</title>

    <emphasis role="bold">Number of encoding bits</emphasis>: 1<sbr/>
    <emphasis role="bold">Is coding extendable</emphasis>: yes<sbr/>

    <para>
      An auxiliary <code>SORT</code> used in <emphasis>make_tokdef</emphasis>
      and <emphasis>use_tokdef</emphasis>.
    </para>

    <section id="C5S51.1">
      <title>token_definition</title>

      <emphasis role="bold">Encoding number</emphasis>: 1

      <programlisting language="TDF">
      result_sort:     SORTNAME
      tok_params:      LIST(TOKFORMALS)
      body:            result_sort
                 -&gt; TOKEN_DEFN</programlisting>

      <para>
        Makes a token definition. <emphasis>result_sort</emphasis> is the
        <code>SORT</code> of body. <emphasis>tok_params</emphasis> is a list of
        formal <code>TOKEN</code>s and their <code>SORT</code>s.
        <emphasis>body</emphasis> is the definition, which can use the formal
        <code>TOKEN</code>s defined in <emphasis>tok_params</emphasis>.
      </para>

      <para>
        The effect of applying the definition of a <code>TOKEN</code> is as if
        the following sequence was obeyed.
      </para>

      <para>
        First, the actual parameters (if any) are expanded to produce
        expressions of the appropriate <code>SORT</code>s. During this expansion
        all token applications in the actual parameters are expanded.
      </para>

      <para>
        Second, the definition is copied, making fresh <code>TAG</code>s and
        <code>LABEL</code>s where these are introduced in
        <emphasis>identify</emphasis>, <emphasis>variable</emphasis>,
        <emphasis>labelled</emphasis>, <emphasis>conditional</emphasis>,
        <emphasis>make_proc, make_general_proc</emphasis> and
        <emphasis>repeat</emphasis> constructions. Any other <code>TAG</code>s
        or <code>LABEL</code>s used in <emphasis>body</emphasis> will be
        provided by the context (see below) of the <code>TOKEN_DEFN</code> or by
        the expansions of the actual parameters.
      </para>

      <para>
        Third, the actual parameter expressions are substituted for the formal
        parameter tokens in <emphasis>tok_params</emphasis> to give the final
        result.
      </para>

      <para>
        The context of a <code>TOKEN_DEFN</code> is the set of names
        (<code>TOKEN</code>s, <code>TAG</code>s, <code>LABEL</code>s,
        <code>AL_TAG</code>s etc.) <quote>in scope</quote> at the site of the
        <code>TOKEN_DEFN</code>.
      </para>

      <para>
        Thus, in a <emphasis>make_tokdef</emphasis>, the context consists of the
        set of <code>TOKEN</code>s defined in its tokdef <code>UNIT</code>,
        together with the set of linkable entities defined by the
        <emphasis>make_links</emphasis> of that <code>UNIT</code>. Note that
        this does not include <code>LABEL</code>s and the only <code>TAG</code>s
        included are <quote>global</quote> ones.
      </para>

      <para>
        In a <emphasis>use_tokdef</emphasis>, the context may be wider, since
        the site of the <code>TOKEN_DEFN</code> need not be in a tokdef
        <code>UNIT</code>; it may be an actual parameter of a token application.
        If this happens to be within an EXP, there may be <code>TAG</code>s or
        <code>LABEL</code>s locally within scope; these will be in the context
        of the <code>TOKEN_DEFN</code>, together with the global names of the
        enclosing UNIT as before.
      </para>

      <para>
        <emphasis>Previous versions of the specification limited token
        definitions to be non-recursive. There is no intrinsic reason for the
        limitation on recursive <code>TOKEN</code>s. Since the UNIT structure
        implies different namespaces, there is very little implementation
        advantage to be gained from retaining the limitation.</emphasis>
      </para>
    </section>
  </section>

  <section id="C5S52">
    <title>TOKFORMALS</title>

    <emphasis role="bold">Number of encoding bits</emphasis>: 0<sbr/>
    <emphasis role="bold">Is coding extendable</emphasis>: no<sbr/>

    <section id="C5S52.1">
      <title>make_tokformals</title>

      <emphasis role="bold">Encoding number</emphasis>: 0

      <programlisting language="TDF">
      sn:              SORTNAME
      tk:              TDFINT
                 -&gt; TOKFORMALS</programlisting>

      <para>
        An auxiliary construction to make up the elements of the lists in
        <emphasis>token_definition</emphasis>.
      </para>
    </section>
  </section>

  <section id="C5S53">
    <title>TRANSFER_MODE</title>

    <emphasis role="bold">Number of encoding bits</emphasis>: 3<sbr/>
    <emphasis role="bold">Is coding extendable</emphasis>: yes<sbr/>

    <para>
      A <code>TRANSFER_MODE</code> controls the operation of
      <emphasis>assign_with_mode</emphasis>,
      <emphasis>contents_with_mode</emphasis> and
      <emphasis>move_some</emphasis>.
    </para>

    <para>
      A <code>TRANSFER_MODE</code> acts like a set of the values
      <emphasis>overlap, trap_on_nil, complete</emphasis> and
      <emphasis>volatile</emphasis>. The <code>TRANSFER_MODE</code>
      <emphasis>standard_transfer_mode</emphasis> acts like the empty set.
      <emphasis>add_modes</emphasis> acts like set union.
    </para>

    <section id="C5S53.1">
      <title>transfer_mode_apply_token</title>

      <emphasis role="bold">Encoding number</emphasis>: 1

      <programlisting language="TDF">
      token_value:     TOKEN
      token_args:      BITSTREAM param_sorts(token_value)
                 -&gt; TRANSFER_MODE</programlisting>

      <para>
        The token is applied to the arguments encoded in the
        <code>BITSTREAM</code> <emphasis>token_args</emphasis> to give a
        <code>TRANSFER_MODE</code>.
      </para>

      <para>
        The notation <emphasis>param_sorts(token_value)</emphasis> is intended
        to mean the following. The token definition or token declaration for
        <emphasis>token_value</emphasis> gives the <code>SORT</code>s of its
        arguments in the <code>SORTNAME</code> component. The
        <code>BITSTREAM</code> in <emphasis>token_args</emphasis> consists of
        these <code>SORT</code>s in the given order. If no token declaration or
        definition exists in the <code>CAPSULE</code>, the
        <code>BITSTREAM</code> cannot be read.
      </para>
    </section>

    <section id="C5S53.2">
      <title>transfer_mode_cond</title>

      <emphasis role="bold">Encoding number</emphasis>: 2

      <programlisting language="TDF">
      control: EXP INTEGER(v)
      e1:              BITSTREAM TRANSFER_MODE
      e2:              BITSTREAM TRANSFER_MODE
                 -&gt; TRANSFER_MODE</programlisting>

      <para>
        <emphasis>control</emphasis> is evaluated. It will be a constant at
        install time under the constant evaluation rules. If it is non-zero,
        <emphasis>e1</emphasis> is installed at this point and
        <emphasis>e2</emphasis> is ignored and never processed.  If
        <emphasis>control</emphasis> is zero then <emphasis>e2</emphasis> is
        installed at this point and <emphasis>e1</emphasis> is ignored and never
        processed.
      </para>
    </section>

    <section id="C5S53.3">
      <title>add_modes</title>

      <emphasis role="bold">Encoding number</emphasis>: 3

      <programlisting language="TDF">
      md1:             TRANSFER_MODE
      md2:             TRANSFER_MODE
                 -&gt; TRANSFER_MODE</programlisting>

      <para>
        A construction qualified by <emphasis>add_modes</emphasis> has both
        <code>TRANSFER_MODES</code> <emphasis>md1</emphasis> and
        <emphasis>md2</emphasis>. If <emphasis>md1</emphasis> is
        <emphasis>standard_transfer_mode</emphasis> then the result is
        <emphasis>md2</emphasis> and symmetrically.  This operation is
        associative and commutative.
      </para>
    </section>

    <section id="C5S53.4">
      <title>overlap</title>

      <emphasis role="bold">Encoding number</emphasis>: 4

      <programlisting language="TDF">
                 -&gt; TRANSFER_MODE</programlisting>

      <para>
        If <emphasis>overlap</emphasis> is used to qualify a
        <emphasis>move_some</emphasis> or an
        <emphasis>assign_with_mode</emphasis> for which
        <emphasis>arg2</emphasis> is a <emphasis>contents</emphasis> or
        <emphasis>contents_with_mode</emphasis>, then the source and destination
        might overlap.  The transfer shall be made as if the data were copied
        from the source to an independent place and thence to the destination.
      </para>

      <para>
        See <!-- TODO link to 7.16. Overlapping -->Overlapping<!-- end link -->.
      </para>
    </section>

    <section id="C5S53.5">
      <title>standard_transfer_mode</title>

      <emphasis role="bold">Encoding number</emphasis>: 5

      <programlisting language="TDF">
                 -&gt; TRANSFER_MODE</programlisting>

      <para>
        This <code>TRANSFER_MODE</code> implies no special properties.
      </para>
    </section>

    <section id="C5S53.6">
      <title>trap_on_nil</title>

      <emphasis role="bold">Encoding number</emphasis>: 6

      <programlisting language="TDF">
                 -&gt; TRANSFER_MODE</programlisting>

      <para>
        If <emphasis>trap_on_nil</emphasis> is used to qualify a
        <emphasis>contents_with_mode</emphasis> operation with a nil pointer
        argument, or an <emphasis>assign_with_mode</emphasis> whose arg1 is a
        nil pointer, or a <emphasis>move_some</emphasis> with either argument a
        nil pointer, the TDF exception <emphasis>nil_access</emphasis> is
        raised.
      </para>
    </section>

    <section id="C5S53.7">
      <title>volatile</title>

      <emphasis role="bold">Encoding number</emphasis>: 7

      <programlisting language="TDF">
                 -&gt; TRANSFER_MODE</programlisting>

      <para>
        If <emphasis>volatile</emphasis> is used to qualify a construction it
        shall not be optimised away.
      </para>

      <para>
        <emphasis>This is intended to implement ANSI C's volatile construction.
        In this use, any volatile identifier should be declared as a
        <code>TAG</code> with used_as_volatile <code>ACCESS</code>.</emphasis>
      </para>
    </section>

    <section id="C5S53.8">
      <title>complete</title>

      <emphasis role="bold">Encoding number</emphasis>: 8

      <programlisting language="TDF">
                 -&gt; TRANSFER_MODE</programlisting>

      <para>
        A transfer qualified with complete shall leave the destination unchanged
        if the evaluation of the value transferred is left with a jump.
      </para>
    </section>
  </section>

  <section id="C5S54">
    <title>UNIQUE</title>

    <emphasis role="bold">Number of encoding bits</emphasis>: 0<sbr/>
    <emphasis role="bold">Is coding extendable</emphasis>: no<sbr/>

    <para>
      These are used to provide world-wide unique names for <code>TOKEN</code>s
      and <code>TAG</code>s.
    </para>

    <para>
      This implies a registry for allocating <code>UNIQUE</code> values.
    </para>

    <section id="C5S54.1">
      <title>make_unique</title>

      <emphasis role="bold">Encoding number</emphasis>: 0

      <programlisting language="TDF">
      text:            SLIST(TDFIDENT)
                 -&gt; UNIQUE</programlisting>

      <para>
        Two <code>UNIQUE</code> values are equal if and only if they were
        constructed with equal arguments.
      </para>
    </section>
  </section>

  <section id="C5S55">
    <title>UNIT</title>

    <emphasis role="bold">Number of encoding bits</emphasis>: 0<sbr/>
    <emphasis role="bold">Is coding extendable</emphasis>: no<sbr/>

    <para>
      A <code>UNIT</code> gathers together a <code>PROPS</code> and
      <code>LINK</code>s which relate the names by which objects are known
      inside the <code>PROPS</code> and names by which they are to be known
      across the whole of the enclosing <code>CAPSULE</code>.
    </para>

    <section id="C5S55.1">
      <title>make_unit</title>

      <emphasis role="bold">Encoding number</emphasis>: 0

      <programlisting language="TDF">
      local_vars:      SLIST(TDFINT)
      lks:             SLIST(LINKS)
      properties:      BYTESTREAM PROPS
                 -&gt; UNIT</programlisting>

      <para>
        <emphasis>local_vars</emphasis> gives the number of linkable entities of
        each kind. These numbers correspond (in the same order) to the variable
        sorts in <emphasis>cap_linking</emphasis> in
        <emphasis>make_capsule</emphasis>. The linkable entities will be
        represented by <code>TDFINT</code>s in the range 0 to the corresponding
        <emphasis>nl</emphasis>-1.
      </para>

      <para>
        <emphasis>lks</emphasis> gives the <code>LINK</code>s for each kind of
        entity in the same order as in <emphasis>local_vars</emphasis>.
      </para>

      <para>
        The <emphasis>properties</emphasis> will be a <code>PROPS</code> of a
        form dictated by the unit identification, see <!-- TODO link to 5.11.1.
        make_capsule -->make_capsule<!-- end link -->.
      </para>

      <para>
        The length of <emphasis>lks</emphasis> will be either 0 or equal to the
        length of <emphasis>cap_linking</emphasis> in
        <emphasis>make_capsule</emphasis>.
      </para>
    </section>
  </section>

  <section id="C5S56">
    <title>VARIETY</title>

    <emphasis role="bold">Number of encoding bits</emphasis>: 2<sbr/>
    <emphasis role="bold">Is coding extendable</emphasis>: yes<sbr/>

    <para>
      These describe the different kinds of integer which can occur at run time.
      The fundamental construction consists of a <code>SIGNED_NAT</code> for the
      lower bound of the range of possible values, and a <code>SIGNED_NAT</code>
      for the upper bound (inclusive at both ends).
    </para>

    <para>
      There is no limitation on the magnitude of these bounds in TDF, but an
      installer may specify limits. See <!-- TODO link to 7.18. Representing
      integers -->Representing integers<!-- link end -->.
    </para>

    <section id="C5S56.1">
      <title>var_apply_token</title>

      <emphasis role="bold">Encoding number</emphasis>: 1

      <programlisting language="TDF">
      token_value:     TOKEN
      token_args:      BITSTREAM param_sorts(token_value)
                 -&gt; VARIETY</programlisting>

      <para>
        The token is applied to the arguments to give a <code>VARIETY</code>.
      </para>

      <para>
        If there is a definition for <emphasis>token_value</emphasis> in the
        <code>CAPSULE</code> then <emphasis>token_args</emphasis> is a
        <code>BITSTREAM</code> encoding of the <code>SORT</code>s of its
        parameters, in the order specified.
      </para>
    </section>

    <section id="C5S56.2">
      <title>var_cond</title>

      <emphasis role="bold">Encoding number</emphasis>: 2

      <programlisting language="TDF">
      control: EXP INTEGER(v)
      e1:              BITSTREAM VARIETY
      e2:              BITSTREAM VARIETY
                 -&gt; VARIETY</programlisting>

      <para>
        The <emphasis>control</emphasis> is evaluated. It will be a constant at
        install time under the constant evaluation rules. If it is non-zero,
        <emphasis>e1</emphasis> is installed at this point and
        <emphasis>e2</emphasis> is ignored and never processed.  If
        <emphasis>control</emphasis> is zero then <emphasis>e2</emphasis> is
        installed at this point and <emphasis>e1</emphasis> is ignored and never
        processed.
      </para>
    </section>

    <section id="C5S56.3">
      <title>var_limits</title>

      <emphasis role="bold">Encoding number</emphasis>: 3

      <programlisting language="TDF">
      lower_bound:     SIGNED_NAT
      upper_bound:     SIGNED_NAT
                 -&gt; VARIETY</programlisting>

      <para>
        <emphasis>lower_bound</emphasis> is the lower limit (inclusive) of the
        range of values which shall be representable in the resulting
        <code>VARIETY</code>, and <emphasis>upper_bound</emphasis> is the upper
        limit (inclusive).
      </para>
    </section>

    <section id="C5S56.4">
      <title>var_width</title>

      <emphasis role="bold">Encoding number</emphasis>: 4

      <programlisting language="TDF">
      signed_width:    BOOL
      width:           NAT
                 -&gt; VARIETY</programlisting>

      <para>
        If <emphasis>signed_width</emphasis> is <emphasis>true</emphasis> then
        this construction is equivalent to
        <emphasis>var_limits</emphasis>(-2<superscript><emphasis>width</emphasis>-1</superscript>,
        2<superscript><emphasis>width</emphasis>-1</superscript>-1).  If
        <emphasis>signed_width</emphasis> is <emphasis>false</emphasis> then
        this construction is <emphasis>var_limits </emphasis>(0,
        2<superscript><emphasis>width</emphasis></superscript>-1).
      </para>
    </section>
  </section>

  <section id="C5S57">
    <title>VERSION_PROPS</title>

    <emphasis role="bold">Number of encoding bits</emphasis>: 0<sbr/>
    <emphasis role="bold">Is coding extendable</emphasis>: no<sbr/>
    <emphasis role="bold">Unit identification</emphasis>: versions<sbr/>

    <para>
      This <code>UNIT</code> gives information about version numbers and user
      information.
    </para>

    <section id="C5S57.1">
      <title>make_versions</title>

      <emphasis role="bold">Encoding number</emphasis>: 0

      <programlisting language="TDF">
      version_info:    SLIST(VERSION)
                 -&gt; VERSION_PROPS</programlisting>

      <para>
        Contains version information.
      </para>
    </section>
  </section>

  <section id="C5S58">
    <title>VERSION</title>

    <emphasis role="bold">Number of encoding bits</emphasis>: 1<sbr/>
    <emphasis role="bold">Is coding extendable</emphasis>: yes<sbr/>

    <section id="C5S58.1">
      <title>make_version</title>

      <emphasis role="bold">Encoding number</emphasis>: 1

      <programlisting language="TDF">
      major_version:   TDFINT
      minor_version:   TDFINT
                 -&gt; VERSION</programlisting>

      <para>
        The major and minor version numbers of the TDF used. An increase in
        minor version number means an extension of facilities, an increase in
        major version number means an incompatible change. TDF with the same
        major number but a lower minor number than the installer shall install
        correctly.
      </para>

      <para>
        For TDF conforming to this specification the major number will be 4 and
        the minor number will be 0.
      </para>

      <para>
        Every <code>CAPSULE</code> will contain at least one
        <emphasis>make_version</emphasis> construct.
      </para>
    </section>

    <section id="C5S58.2">
      <title>user_info</title>

      <emphasis role="bold">Encoding number</emphasis>: 2

      <programlisting language="TDF">
      information:     STRING(k, n)
                 -&gt; VERSION</programlisting>

      <para>
        This is (usually character) information included in the TDF for
        labelling purposes.
      </para>

      <para>
        <emphasis>information</emphasis> will be produced by
        <emphasis>make_string</emphasis>.
      </para>
    </section>
  </section>
</chapter>
