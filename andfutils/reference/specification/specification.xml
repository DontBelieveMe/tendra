<?xml version="1.0" standalone="no"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
  "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">

<!--
  $Id$
-->

<book>
  <bookinfo>
    <title>TDF Specification, Issue 4.0</title>

    <othercredit class="copyeditor">
      <firstname>Matthew</firstname>
      <surname>Haub</surname>
      <affiliation><orgname>The TenDRA Project</orgname></affiliation>
    </othercredit>

    <corpauthor>DERA</corpauthor>
    <pubdate>2005</pubdate>

    <copyright>
      <year>2004</year>
      <year>2005</year>
      <year>2007</year>

      <holder>The TenDRA Project</holder>
    </copyright>

    <copyright>
      <year>1998</year>

      <holder>DERA</holder>
    </copyright>
  </bookinfo>

  <preface>
    <title>Preface</title>

    <para>
      This is Issue 4.0 of the TDF Specification. TDF version 4.0 is not
      bitwise compatible with earlier versions.
    </para>

    <section>
      <title>Major changes from issue 3.1</title>

      <para>
        A new <code>SORT</code> for <code>STRING</code> is introduced having
        the same relationship to <code>TDFSTRING</code> as <code>BOOL</code>
        has to <code>TDFBOOL</code>. This is used in place of
        <code>TDFSTRING</code> in various 3.1 constructions.
      </para>

      <para>
        They are also used in modified tag and token definitions and
        declarations to provide extra consistency checks in the use of these
        tags or tokens, and also may be used as names external to the TDF
        system. For example, the signature of
        <emphasis>make_id_tagdec</emphasis> is now:

        <programlisting>
t_intro:        TDFINT
acc:            OPTION(ACCESS)
signature:      OPTION(STRING)
x:              SHAPE
            -> TAGDEC</programlisting>
      </para>

      <para>
        A new <code>EXP</code> constructor, <emphasis>initial_value</emphasis>,
        is introduced to allow dynamic initialisation of global tags.
      </para>

      <para>
        These changes arise mainly from requirements of C++, but are clearly
        applicable elsewhere.
      </para>

      <para>
        Magic numbers are introduced at the start of files containing TDF
        bitstream information.
      </para>

      <para>
        The version 3.1 constructor <emphasis>set_stack_limit</emphasis> has had
        to be modified in the light of experience with platforms with ABIs which
        require upward-growing stacks or use disjoint frame stacks and alloca
        stacks.
      </para>

      <para>
        Various other minor changes have been made to elucidate some rather
        pathological cases, e.g. <emphasis>make_nof</emphasis> must have at
        least one element. Also there are some cosmetic changes to improve
        consistency, e.g. the order of the arguments of
        <emphasis>token</emphasis> are now consistent with
        <emphasis>token_definition</emphasis>.
      </para>
    </section>

    <section>
      <title>Notes on revision 1</title>
      <para>
        This Revision 1 of Issue 4.0 incorporates a number of corrections
        which have arisen where inconsistency or impracticability became evident
        when validating the OSF Research Institute's AVS (ANDF Validation
        Suite). Apart from minor textual corrections, the changes are:

        <itemizedlist>
          <listitem>
            <para>
              Use of installer-defined <code>TOKEN</code>s for accessing
              variable parameter lists - see the companion document <!-- TODO
              link to register document -->TDF Token Register
              (Revision 1)<!-- end link -->.
            </para>
          </listitem>

          <listitem>
            <para>
              Tolerance of overflow necessary to allow simple implementation
              of complex multiply and divide.
            </para>
          </listitem>

          <listitem>
            <para>
              Modified constraints on the arguments of
              <emphasis>shift_left</emphasis>,
              <emphasis>shift_right</emphasis>,
              <emphasis>rotate_left</emphasis>,
              <emphasis>rotate_right</emphasis>,
              <emphasis>make_dynamic_callees</emphasis>,
              <emphasis>make_var_tagdec</emphasis>,
              <emphasis>make_tokdec</emphasis>,
              <emphasis>make_tokdef</emphasis>, and
              <emphasis>user_info</emphasis>.
            </para>
          </listitem>

          <listitem>
            <para>
              Modified constant evaluation constraints with respect to
              <emphasis>env_size</emphasis> and <emphasis>env_offset</emphasis>.
            </para>
          </listitem>

          <listitem>
            <para>
              <emphasis>chain_extern</emphasis> no longer supported.
            </para>
          </listitem>
        </itemizedlist>

        <para>
          Changes under consideration but not included in Issue 4.0:
        </para>

        <itemizedlist>
          <listitem>
            <para>
              Tokenisation of the various LIST constructs.
            </para>
          </listitem>

          <listitem>
            <para>
              Inclusion of the specification of run-time diagnostic information
              in the main specification. This is currently given as an appendix,
              as it it is less mature than the main specification.
            </para>
          </listitem>
        </itemizedlist>
      </para>
    </section>
  </preface>

  <chapter id="introduction">
    <title>Introduction</title>

    <para>
      TDF is a porting technology and, as a result, it is a central part of a
      shrink-wrapping, distribution and installation technology. TDF has been
      chosen by the Open Software Foundation as the basis of its Architecture
      Neutral Distribution Format. It was developed by the United Kingdom's
      Defence Research Agency (DRA). TDF is not UNIX specific, although most of
      the implementation has been done on UNIX.
    </para>

    <para>
      Software vendors, when they port their programs to several platforms,
      usually wish to take advantage of the particular features of each
      platform. That is, they wish the versions of their programs on each
      platform to be functionally equivalent, but not necessarily
      algorithmically identical. TDF is intended for porting in this sense. It
      is designed so that a program in its TDF form can be systematically
      modified when it arrives at the target platform to achieve the intended
      functionality and to use the algorithms and data structures which are
      appropriate and efficient for the target machine. A fully efficient
      program, specialised to each target, is a necessity if independent
      software vendors are to take-up a porting technology.
    </para>

    <para>
      These modifications are systematic because, on the source machine,
      programmers work with generalised declarations of the APIs they are using.
      The declarations express the requirements of the APIs without giving their
      implementation. The declarations are specified in terms of TDF's
      <quote>tokens</quote>, and the TDF which is produced contains uses of
      these tokens. On each target machine the tokens are used as the basis for
      suitable substitutions and alterations.
    </para>

    <para>
      Using TDF for porting places extra requirements on software vendors and
      API designers. Software vendors must write their programs scrupulously in
      terms of APIs and nothing more. API designers need to produce an interface
      which can be specialised to efficient data structures and constructions on
      all relevant machines.
    </para>

    <para>
      TDF is neutral with respect to the set of languages which has been
      considered. The design of C, C++, Fortran and Pascal is quite
      conventional, in the sense that they are sufficiently similar for TDF
      constructions to be devised to represent them all. These TDF constructions
      can be chosen so that they are, in most cases, close to the language
      constructions. Other languages, such as Lisp, are likely to need a few
      extensions. To express novel language features TDF will probably have to
      be more seriously extended. But the time to do so is when the feature in
      question has achieved sufficient stability. Tokens can be used to express
      the constructs until the time is right. For example, there is a lack of
      consensus about the best constructions for parallel languages, so that at
      present TDF would either have to use low level constructions for
      parallelism or back what might turn out to be the wrong system.  In other
      words it is not yet the time to make generalisations for parallelism as an
      intrinsic part of TDF.
    </para>

    <para>
      TDF is neutral with respect to machine architectures. In designing TDF,
      the aim has been to retain the information which is needed to produce and
      optimise the machine code, while discarding identifier and syntactic
      information. So TDF has constructions which are closely related to typical
      language features and it has an abstract model of memory. We expect that
      programs expressed in the considered languages can be translated into code
      which is as efficient as that produced by native compilers for those
      languages.
    </para>

    <para>
      Because of these porting features TDF supports shrink-wrapping,
      distribution and installation. Installation does not have to be left to
      the end-user; the production of executables can be done anywhere in the
      chain from software vendor, through dealer and network manager to the
      end-user.
    </para>

    <para>
      This document provides English language specifications for each construct
      in the TDF format and some general notes on various aspects of TDF. It is
      intended for readers who are aware of the general background to TDF but
      require more detailed information.
    </para>
  </chapter>

  <chapter id="C2">
    <title>Structure of TDF</title>

    <para>
      Each piece of TDF program is classified as being of a particular
      <code>SORT</code>. Some pieces of TDF are <code>LABEL</code>s, some are
      <code>TAG</code>s, some are <code>ERROR_TREATMENT</code>s and so on (to
      list some of the more transparently named <code>SORT</code>s).  The
      <code>SORT</code>s of the arguments and result of each construct of the
      TDF format are specified. For instance, <emphasis>plus</emphasis> is
      defined to have three arguments - an <code>ERROR_TREATMENT</code> and two
      <code>EXP</code>s (short for <quote>expression</quote>) - and to produce
      an <code>EXP</code>; <emphasis>goto</emphasis> has a single
      <code>LABEL</code> argument and produces an <code>EXP</code>. The
      specification of the <code>SORT</code>s of the arguments and results of
      each construct constitutes the syntax of the TDF format. When TDF is
      represented as a parsed tree it is structured according to this syntax.
      When it is constructed and read it is in terms of this syntax.
    </para>

    <section id="S1">
      <title>The overall structure</title>
      <para>
        A separable piece of TDF is called a <code>CAPSULE</code>. A producer
        generates a <code>CAPSULE</code>; the TDF linker links
        <code>CAPSULE</code>s together to form a <code>CAPSULE</code>; and the
        final translation process turns a <code>CAPSULE</code> into an object
        file.
      </para>

      <para>
        The structure of capsules is designed so that the process of linking two
        or more capsules consists almost entirely of copying large byte-aligned
        sections of the source files into the destination file, without changing
        or even examining these sections. Only a small amount of interface
        information has to be modified and this is made easily accessible. The
        translation process only requires an extra indirection to account for
        this interface information, so it is also fast. The description of TDF
        at the capsule level is almost all about the organisation of the
        interface information.
      </para>

      <para>
        There are three major kinds of entity which are used inside a capsule
        to name its constituents. The first are called tags; they are used
        to name the procedures, functions, values and variables which are
        the components of the program. The second are called tokens; they
        identify pieces of TDF which can be used for substitution - a little
        like macros. The third are the alignment tags, used to name alignments
        so that circular types can be described. Because these internal names
        are used for linking pieces of TDF together, they are collectively
        called <emphasis>linkable entities</emphasis>. The interface information
        relates these linkable entities to each other and to the world outside
        the capsule.
      </para>

      <para>
        The most important part of a capsule, the part which contains the
        real information, consists of a sequence of groups of units. Each
        group contains units of the same kind, and all the units of the same
        kind are in the same group. The groups always occur in the same order,
        though it is not necessary for each kind to be present.

        <mediaobject>
          <imageobject>
            <imagedata fileref="capsule4.gif" format="GIF" align="center"/>
          </imageobject>
        </mediaobject>
      </para>

      <para>
        The order is as follows:

        <itemizedlist>
          <listitem>
            <para>
              <emphasis>tld</emphasis> unit. Every capsule has exactly one tld
              unit. It gives information to the TDF linker about those items in
              the capsule which are visible externally.
            </para>
          </listitem>

          <listitem>
            <para>
              <emphasis>versions</emphasis> unit. These units contain
              information about the versions of TDF used. Every capsule will
              have at least one such unit.
            </para>
          </listitem>

          <listitem>
            <para>
              <emphasis>tokdec</emphasis> units. These units contain
              declarations for tokens. They bear the same relationship to the
              following tokdef units that C declarations do to C definitions.
              However, they are not necessary for the translator, and the
              current ANSI C producer does not provide them by default.
            </para>
          </listitem>

          <listitem>
            <para>
              <emphasis>tokdef</emphasis> units. These units contain definitions
              of tokens.
            </para>
          </listitem>

          <listitem>
            <para>
              <emphasis>aldef</emphasis> units. These units give the definitions
              of alignment tags.
            </para>
          </listitem>

          <listitem>
            <para>
              <emphasis>diagtype</emphasis> units. These units give diagnostic
              information about types.
            </para>
          </listitem>

          <listitem>
            <para>
              <emphasis>tagdec</emphasis> units. These units contain
              declarations of tags, which identify values, procedures and
              run-time objects in the program. The declarations give information
              about the size, alignment and other properties of the values. They
              bear the same relationship to the following tagdef units that C
              declarations do to C definitions.
            </para>
          </listitem>

          <listitem>
            <para>
              <emphasis>diagdef</emphasis> units. These units give diagnostic
              information about the values and procedures defined in the
              capsule.
            </para>
          </listitem>

          <listitem>
            <para>
              <emphasis>tagdef</emphasis> units. These units contain the
              definitions of tags, and so describe the procedures and the values
              they manipulate.
            </para>
          </listitem>

          <listitem>
            <para>
              <emphasis>linkinfo</emphasis> units. These units give information
              about the linking of objects.
            </para>
          </listitem>
        </itemizedlist>

        This organisation is imposed to help installers, by ensuring that the
        information needed to process a unit has been provided before that unit
        arrives. For example, the token definitions occur before any tag
        definition, so that, during translation, the tokens may be expanded as
        the tag definitions are being read (in a capsule which is ready for
        translation all tokens used must be defined, but this need not apply to
        an arbitrary capsule).
      </para>

      <para>
        The tags and tokens in a capsule have to be related to the outside
        world. For example, there might be a tag standing for
        <emphasis>printf</emphasis>, used in the appropriate way inside the
        capsule. When an object file is produced from the capsule the identifier
        <emphasis>printf</emphasis> must occur in it, so that the system linker
        can associate it with the correct library procedure. In order to do
        this, the capsule has a table of tags at the capsule level, and a set of
        external links which provide external names for some of these tags.

        <mediaobject>
          <imageobject>
            <imagedata fileref="capsule1.gif" format="GIF" align="center"/>
          </imageobject>
        </mediaobject>
      </para>

      <para>
        In just the same way, there are tables of tokens and alignment tags
        at the capsule level, and external links for these as well.
      </para>

      <para>
        The tags used inside a unit have to be related to these capsule tags,
        so that they can be properly named. A similar mechanism is used, with
        a table of tags at the unit level, and links between these and the
        capsule level tags.

        <mediaobject>
          <imageobject>
            <imagedata fileref="capsule2.gif" format="GIF" align="center"/>
          </imageobject>
        </mediaobject>
      </para>

      <para>
        Again the same technique is used for tokens and alignment tags.
      </para>

      <para>
        It is also necessary for a tag used in one unit to refer to the same
        thing as a tag in another unit. To do this a tag at the capsule level
        is used, which may or may not have an external link.

        <mediaobject>
          <imageobject>
            <imagedata fileref="capsule3.gif" format="GIF" align="center"/>
          </imageobject>
        </mediaobject>
      </para>

      <para>
        The same technique is used for tokens and alignment tags.
      </para>

      <para>
        So when the TDF linker is joining two capsules, it has to perform
        the following tasks:

        <itemizedlist>
          <listitem>
            <para>
              It creates new sets of capsule level tags, tokens and alignment
              tags by identifying those which have the same external name, and
              otherwise creating different entries.
            </para>
          </listitem>

          <listitem>
            <para>
              It similarly joins the external links, suppressing any names which
              are no longer to be external.
            </para>
          </listitem>

          <listitem>
            <para>
              It produces new link tables for the units, so that the entities
              used inside the units are linked to the new positions in the
              capsule level tables.
            </para>
          </listitem>

          <listitem>
            <para>
              It re-organises the units so that the correct order is achieved.
            </para>
          </listitem>
        </itemizedlist>

        This can be done without looking into the interior of the units (except
        for the <emphasis>tld</emphasis> unit), simply copying the units into
        their new place.
      </para>

      <para>
        During the process of installation the values associated with the
        linkable entities can be accessed by indexing into an array followed
        by one indirection. These are the kinds of object which in a programming
        language are referred to by using identifiers, which involves using
        hash tables for access. This is an example of a general principle
        of the design of TDF; speed is required in the linking and installing
        processes, if necessary at the expense of time in the production of
        TDF.
      </para>
    </section>

    <section id="S2">
      <title>Tokens</title>

      <para>
        Tokens are used (applied) in the TDF at the point where substitutions
        are to be made. Token definitions provide the substitutions and usually
        reside on the target machine and are linked in there.
      </para>

      <para>
        A typical token definition has parameters from various
        <code>SORT</code>s and produces a result of a given <code>SORT</code>.
        As an example of a simple token definition, written here in a C-like
        notation, consider the following.

        <programlisting>
        EXP ptr_add (EXP par0, EXP par1, SHAPE par2)
        {
            add_to_ptr(
                par0,
                offset_mult(
                    offset_pad(
                        alignment(par2),
                        shape_offset(par2)),
                    par1))</programlisting>

        This defines the token, <emphasis>ptr_add</emphasis>, to produce
        something of <code>SORT</code> <code>EXP</code>. It has three
        parameters, of <code>SORT</code>s <code>EXP</code>, <code>EXP</code> and
        <code>SHAPE</code>. The <emphasis>add_to_ptr</emphasis>,
        <emphasis>offset_mult</emphasis>, <emphasis>offset_pad</emphasis>,
        <emphasis>alignment</emphasis> and <emphasis>shape_offset</emphasis>
        constructions are TDF constructions producing respectively an
        <code>EXP</code>, an <code>EXP</code>, an <code>EXP</code>, an
        <code>ALIGNMENT</code> and an <code>EXP</code>.
      </para>

      <para>
        A typical use of this token is:

        <programlisting>
        ptr_add(
            obtain_tag(tag41),
            contents(integer(~signed_int), obtain_tag(tag62)),
            integer(~char))</programlisting>

        The effect of this use is to produce the TDF of the definition with
        <emphasis>par0</emphasis>, <emphasis>par1</emphasis> and
        <emphasis>par2</emphasis> substituted by the actual parameters.
      </para>

      <para>
        There is no way of obtaining anything like a side-effect. A token
        without parameters is therefore just a constant.
      </para>

      <para>
        Tokens can be used for various purposes. They are used to make the TDF
        shorter by using tokens for commonly used constructions
        (<emphasis>ptr_add</emphasis> is an example of this use). They are used
        to make target dependent substitutions (<emphasis>~char</emphasis> in
        the use of <emphasis>ptr_add</emphasis> is an example of this, since
        <emphasis>~char</emphasis> may be signed or unsigned on the target).
      </para>

      <para>
        A particularly important use is to provide definitions appropriate
        to the translation of a particular language. Another is to abstract
        those features which differ from one ABI to another. This kind of
        use requires that sets of tokens should be standardised for these
        purposes, since otherwise there will be a proliferation of such
        definitions.
      </para>
    </section>

    <section id="S3">
      <title>Tags</title>
      <para>
        Tags are used to identify the actual program components. They can be
        declared or defined. A declaration gives the <code>SHAPE</code> of a tag
        (a <code>SHAPE</code> is the TDF analogue of a type). A definition gives
        an <code>EXP</code> for the tag (an <code>EXP</code> describes how the
        value is to be made up).
      </para>
    </section>

    <section id="S4">
      <title>Extending the format</title>
      <para>
        TDF can be extended for two major reasons.
      </para>

      <para>
        First, as part of the evolution of TDF, new features will from time
        to time be identified. It is highly desirable that these can be added
        without disturbing the current encoding, so that old TDF can still
        be installed by systems which recognise the new constructions. Such
        changes should only be made infrequently and with great care, for
        stability reasons, but nevertheless they must be allowed for in the
        design.
      </para>

      <para>
        Second, it may be required to add extra information to TDF to permit
        special processing. TDF is a way of describing programs and it clearly
        may be used for other reasons than portability and distribution. In
        these uses it may be necessary to add extra information which is closely
        integrated with the program. Diagnostics and profiling can serve as
        examples. In these cases the extra kinds of information may not have
        been allowed for in the TDF encoding.
      </para>

      <para>
        Some extension mechanisms are described below and related to these
        reasons:

        <itemizedlist>
          <listitem>
            <para>
              The encoding of every <code>SORT</code> in TDF can be extended
              indefinitely (except for certain auxiliary <code>SORT</code>s).
              This mechanism should only be used for extending standard TDF to
              the next standard, since otherwise extensions made by different
              groups of people might conflict with each other. See <!-- TODO
              link to 8.3.3 extendable integer encoding -->Extendable integer
              encoding<!-- end link -->.
            </para>
          </listitem>

          <listitem>
            <para>
              Basic TDF has three kinds of linkable entity and seven kinds of
              unit. It also contains a mechanism for extending these so that
              other information can be transmitted in a capsule and properly
              related to basic TDF. The rules for linking this extra information
              are also laid down. See <!-- TODO link to 5.11.1 make_capsule
              -->make_capsule<!-- end link -->.
            </para>
          </listitem>

          <listitem>
            <para>
              If a new kind of unit is added, it can contain any information,
              but if it is to refer to the tags and tokens of other units it
              must use the linkable entities. Since new kinds of unit might need
              extra kinds of linkable entity, a method for adding these is also
              provided.  All this works in a uniform way, with capsule level
              tables of the new entities, and external and internal links for
              them.
            </para>
          </listitem>

          <listitem>
            <para>
              If new kinds of unit are added, the order of groups must be the
              same in any capsules which are linked together. As an example of
              the use of this kind of extension, the diagnostic information is
              introduced in just this way. It uses two extra kinds of unit and
              one extra kind of linkable entity. The extra units need to refer
              to the tags in the other units, since these are the object of the
              diagnostic information.  This mechanism can be used for both
              purposes.
            </para>
          </listitem>

          <listitem>
            <para>
              The parameters of tokens are encoded in such a way that foreign
              information (that is, information which cannot be expressed in the
              TDF <code>SORT</code>s) can be supplied. This mechanism should
              only be used for the second purpose, though it could be used to
              experiment with extensions for future standards. See <!-- TODO
              link to 8.3 BITSTREAM --><code>BITSTREAM</code><!-- end link -->.
            </para>
          </listitem>
        </itemizedlist>
      </para>
    </section>
  </chapter>

  <chapter id="C3">
    <title>Describing the structure</title>

    <para>
      The following examples show how TDF constructs are described in this
      document. The first is the construct <!-- TODO link to 5.31.6 floating -->
      <emphasis>floating</emphasis><!-- end link -->:

      <programlisting>
        fv:              FLOATING_VARIETY
                    -&gt; SHAPE</programlisting>

      The constructs' arguments (one in this case) precede the
      <quote><emphasis>-&gt;</emphasis></quote> and the result follows it. Each
      argument is shown as follows:

      <programlisting>
        name:            SORT</programlisting>

      The name standing before the colon is for use in the accompanying
      English description within the specification. It has no other
      significance.
    </para>

    <para>
      The example given above indicates that <emphasis>floating</emphasis> takes
      one argument.  This argument, <emphasis>v</emphasis>, is of <code>SORT
        FLOATING_VARIETY</code>.  After the <quote><code>-&gt;</code></quote>
      comes the <code>SORT</code> of the result of
      <emphasis>floating</emphasis>. It is a <code>SHAPE</code>.
    </para>

    <para>
      In the case of <emphasis>floating</emphasis> the formal description
      supplies the syntax and the accompanying English text supplies the
      semantics. However, in the case of some constructs it is convenient to
      specify more information in the formal section. For example, the
      specification of the construct <!-- TODO link to 5.16.39 floating_negate
      --><emphasis>floating_negate</emphasis><!-- end link --> not only states
      that it has an <code>EXP</code> argument and an <code>EXP</code> result:

      <programlisting>
        flpt_err:         ERROR_TREATMENT
        arg1:            EXP FLOATING(f)
                   -&gt; EXP FLOATING(f)</programlisting>

      it also supplies additional information about those <code>EXP</code>s.  It
      specifies that these expressions will be floating point numbers of the
      same kind.
    </para>

    <para>
      Some construct's arguments are optional. This is denoted as follows (from
      <!-- TODO link to 5.16.6 apply_proc --><emphasis>apply_proc</emphasis><!--
      end link -->):

      <programlisting>
        result_shape:    SHAPE
        p:               EXP PROC
        params:          LIST(EXP)
        var_param:       OPTION(EXP)
                   -&gt; EXP result_shape</programlisting>
      <emphasis>var_param</emphasis> is an optional argument to the
      <emphasis>apply_proc</emphasis> construct shown above.
    </para>

    <para>
      Some constructs take a varying number of arguments.
      <emphasis>params</emphasis> in the above construct is an example. These
      are denoted by <code>LIST</code>. There is a similar construction,
      <code>SLIST</code>, which differs only in having a different encoding.
    </para>

    <para>
      Some constructs' results are governed by the values of their arguments.
      This is denoted by the <quote><code>?</code></quote> formation shown in
      the specification of the <!-- TODO link to 5.16.14 case
      --><emphasis>case</emphasis><!-- end link --> construct shown below:
      <programlisting>
        exhaustive:      BOOL
        control: EXP INTEGER(v)
        branches:        LIST(CASELIM)
                   -&gt; EXP (exhaustive ? BOTTOM : TOP)</programlisting>

      If <emphasis>exhaustive</emphasis> is true, the resulting <code>EXP</code>
      has the <code>SHAPE BOTTOM</code>: otherwise it is <code>TOP</code>.
    </para>

    <para>
      Depending on a TDF-processing tool's purpose, not all of some constructs'
      arguments need necessarily be processed. For instance, installers do not
      need to process one of the arguments of the <emphasis>x_cond</emphasis>
      constructs (where <emphasis>x</emphasis> stands for a <code>SORT</code>,
      e.g. <!-- TODO link to 5.16.2 exp_cond -->
      <emphasis>exp_cond</emphasis><!-- end link -->. Secondly, standard tools
      might want to ignore embedded fragments of TDF adhering to some private
      standard. In these cases it is desirable for tools to be able to skip the
      irrelevant pieces of TDF. <code>BITSTREAM</code>s and
      <code>BYTESTREAM</code>s are formations which permit this. In the encoding
      they are prefaced with information about their length.
    </para>

    <para>
      Some constructs' arguments are defined as being <code>BITSTREAM</code>s or
      <code>BYTESTREAM</code>s, even though the constructs specify them to be of
      a particular <code>SORT</code>. In these cases the argument's
      <code>SORT</code> is denoted as, for example, <code>BITSTREAM
       FLOATING_VARIETY </code>.  This construct must have a
      <code>FLOATING_VARIETY</code> argument, but certain TDF-processing tools
      may benefit from being able to skip past the argument (which might itself
      be a very large piece of TDF) without having to read its content.
    </para>

    <para>
      The nature of the <code>UNIT</code>s in a <code>GROUP</code> is determined
      by unit identifications. These occur in <emphasis>make_capsule</emphasis>.
      The values used for unit identifications are specified in the text as
      follows:

      <blockquote>
        <emphasis role="bold">Unit identification</emphasis>:
        <emphasis>some_name</emphasis>
      </blockquote>
      where <emphasis>some_name</emphasis> might be <emphasis>tokdec</emphasis>,
      <emphasis>tokdef</emphasis> etc.
    </para>

    <para>
      The kinds of linkable entity used are determined by linkable entity
      identifications. These occur in <emphasis>make_capsule</emphasis>. The
      values used for linkable entity identification are specified in the text
      as follows:

      <blockquote>
        <emphasis role="bold">Linkable entity identification</emphasis>:
        <emphasis>some_name</emphasis>
      </blockquote>
      where <emphasis>some_name</emphasis> might be <emphasis>tag</emphasis>,
      <emphasis>token</emphasis> etc.
    </para>

    <para>
      The bit encodings are also specified in this document. The details are
      given in <!-- TODO link to 8. The bit encoding of TDF -->The bit encoding
      of TDF<!-- end link -->. This section describes the encoding in terms of
      information given with the descriptions of the <code>SORT</code>s and
      constructs.
    </para>

    <para>
      With each <code>SORT</code> the number of bits used to encode the
      constructs is given in the following form:

      <blockquote>
        <emphasis role="bold">Number of encoding bits</emphasis>:
        <emphasis>n</emphasis>
      </blockquote>
      This number may be zero; if so the encoding is non-extendable. If
      it is non-zero the encoding may be extendable or non-extendable. This
      is specified in the following form:

      <blockquote>
        <emphasis role="bold">Is coding extendable</emphasis>: yes/no
      </blockquote>
      With each construct the number used to encode it is given in the
      following form:

      <blockquote>
        <emphasis role="bold">Encoding number</emphasis>: <emphasis>n</emphasis>
      </blockquote>
      If the number of encoding bits is zero, <emphasis>n</emphasis> will be zero.
    </para>

    <para>
      There may be a requirement that a component of a construct should start on
      a byte boundary in the encoding. This is denoted by inserting
      <code>BYTE_ALIGN</code> before the component <code>SORT</code>.
    </para>
  </chapter>

  <chapter id="C4">
    <title>Installer behavior</title>

    <section id="S5">
      <title>Definition of terms</title>

      In this document the behaviour of TDF installers is described in a
      precise manner. Certain words are used with very specific meanings.
      These are:

      <itemizedlist>
        <listitem>
          <para>
            <quote>undefined</quote>: means that installers can perform any
            action, including refusing to translate the program. It can produce
            code with any effect, meaningful or meaningless.
          </para>
        </listitem>

        <listitem>
          <para>
            <quote>shall</quote>: when the phrase <quote><emphasis>P</emphasis>
            shall be done</quote> (or similar phrases involving
            <quote>shall</quote>) is used, every installer must perform
            <emphasis>P</emphasis>.
          </para>
        </listitem>

        <listitem>
          <para>
            <quote>should</quote>: when the phrase <quote><emphasis>P</emphasis>
            should be done</quote> (or similar phrase involving
            <quote>should</quote>) is used, installers are advised to perform
            <emphasis>P</emphasis>, and producer writers may assume it will be
            done if possible. This usage generally relates to optimisations
            which are recommended.
          </para>
        </listitem>

        <listitem>
          <para>
            <quote>will</quote>: when the phrase <quote><emphasis>P</emphasis>
            will be true</quote> (or similar phrases involving
            <quote>will</quote>) is used to describe the composition of a TDF
            construct, the installer may assume that <emphasis>P</emphasis>
            holds without having to check it. If, in fact, a producer has
            produced TDF for which <emphasis>P</emphasis> does not hold, the
            effect is undefined.
          </para>
        </listitem>

        <listitem>
          <para>
            <quote>target-defined</quote>: means that behaviour will be defined,
            but that it varies from one target machine to another. Each target
            installer shall define everything which is said to be
            <quote>target-defined</quote>.
          </para>
        </listitem>
      </itemizedlist>
    </section>

    <section id="S6">
      <title>Properties of installers</title>

      <para>
        All installers must implement all of the constructions of TDF. There
        are some constructions where the installers may impose limits on the
        ranges of values which are implemented. In these cases the description
        of the installer must specify these limits.
      </para>

      <para>
        Installers are not expected to check that the TDF they are processing
        is well-formed, nor that undefined constructs are absent. If the TDF
        is not well-formed any effect is permitted.
      </para>

      <para>
        Installers shall only implement optimisations which are correct in
        all circumstances. This correctness can only be shown by demonstrating
        the equivalence of the transformed program, from equivalences deducible
        from this specification or from the ordinary laws of arithmetic. No
        statements are made in this specification of the form <quote>such and
        such an optimisation is permitted</quote>.
      </para>

      <para>
        <emphasis>Fortran90 has a notion of mathematical equivalence which is
        not the same as TDF equivalence. It can be applied to transform programs
        provided parentheses in the text are not crossed. TDF does not
        acknowledge this concept. Such transformations would have to be applied
        in a context where the permitted changes are known.</emphasis>
      </para>
    </section>
  </chapter>

  <chapter id="C5">
    <title>Specification of TDF constructs</title>

    <section id="S7">
      <title>Access</title>

      <emphasis role="bold">Number of encoding bits</emphasis>: 4<sbr/>
      <emphasis role="bold">Is coding extendable</emphasis>: yes

      <para>
        An <code>ACCESS</code> describes properties a variable or identity may
        have which may constrain or describe the ways in which the variable or
        identity is used.
      </para>

      <para>
        Each construction which needs an <code>ACCESS</code> uses it in the form
        <code>OPTION</code>(<code>ACCESS</code>). If the option is absent the
        variable or identity has no special properties.
      </para>

      <para>
        An <code>ACCESS</code> acts like a set of the values
        <emphasis>constant</emphasis>, <emphasis>long_jump_access</emphasis>,
        <emphasis>no_other_read</emphasis>, <emphasis>no_other_write</emphasis>,
        <emphasis>register</emphasis>, <emphasis>out_par</emphasis>,
        <emphasis>used_as_volatile</emphasis>, and <emphasis>visible</emphasis>.
        <emphasis>standard_access</emphasis> acts like the empty set.
        <emphasis>add_accesses</emphasis> is the set union operation.
      </para>

      <section id="S7S1">
        <title>access_apply_token</title>
        <emphasis role="bold">Encoding number</emphasis>: 1

        <para>
          <programlisting>
        token_value:     TOKEN
        token_args:      BITSTREAM param_sorts(token_value)
                   -&gt; ACCESS</programlisting>

          The token is applied to the arguments encoded in the
          <code>BITSTREAM</code>
          <emphasis>token_args</emphasis> to give an <code>ACCESS</code>.
        </para>

        <para>
          The notation <emphasis>param_sorts(token_value)</emphasis> is intended
          to mean the following. The token definition or token declaration for
          <emphasis>token_value</emphasis> gives the <code>SORT</code>s of its
          arguments in the <code>SORTNAME</code> component. The
          <code>BITSTREAM</code> in <emphasis>token_args</emphasis> consists of
          these <code>SORT</code>s in the given order. If no token declaration
          or definition exists in the <code>CAPSULE</code>, the
          <code>BITSTREAM</code> cannot be read.
        </para>
      </section>

      <section id="S7S2">
        <title>access_cond</title>

        <emphasis role="bold">Encoding Number</emphasis>: 2

        <programlisting>
        control: EXP INTEGER(v)
        e1:              BITSTREAM ACCESS
        e2:              BITSTREAM ACCESS
                   -&gt; ACCESS</programlisting>

        <emphasis>control</emphasis> is evaluated. It will be a constant at
        install time under the constant evaluation rules. If it is non-zero,
        <emphasis>e1</emphasis> is installed at this point and
        <emphasis>e2</emphasis> is ignored and never processed.  If
        <emphasis>control</emphasis> is zero then <emphasis>e2</emphasis> is
        installed at this point and <emphasis>e1</emphasis> is ignored and never
        processed.
      </section>

      <section id="S7S3">
        <title>add_access</title>

        <emphasis role="bold">Encoding number</emphasis>: 3

        <programlisting>
        a1:              ACCESS
        a2:              ACCESS
                   -&gt; ACCESS</programlisting>

        A construction qualified with <emphasis>add_accesses</emphasis> has both
        <code>ACCESS</code> properties <emphasis>a1</emphasis> and
        <emphasis>a2</emphasis>. This operation is associative and commutative.
      </section>

      <section id="S7S4">
        <title>constant</title>

        <emphasis role="bold">Encoding number</emphasis>: 4

        <programlisting>
                   -&gt; ACCESS</programlisting>

        Only a variable (not an identity) may be qualified with
        <emphasis>constant</emphasis>.  A variable qualified with
        <emphasis>constant</emphasis> will retain its initialising value
        unchanged throughout its lifetime.
      </section>

      <section id="S7S5">
        <title>long_jump_access</title>

        <emphasis role="bold">Encoding number</emphasis>: 5

        <programlisting>
                   -&gt; ACCESS</programlisting>

        An object must also have this property if it is to have a defined value
        when a <emphasis>long_jump</emphasis> returns to the procedure declaring
        the object.
      </section>

      <section id="S7S6">
        <title>no_other_read</title>

        <emphasis role="bold">Encoding number</emphasis>: 6

        <programlisting>
                   -&gt; ACCESS</programlisting>

        <para>
          This property refers to a <code>POINTER</code>, <emphasis>p</emphasis>.
          It says that, within the lifetime of the declaration being qualified,
          there are no <emphasis>contents</emphasis>,
          <emphasis>contents_with_mode</emphasis> or
          <emphasis>move_some</emphasis> source accesses to any pointer not
          derived from <emphasis>p</emphasis> which overlap with any of the
          <emphasis>contents</emphasis>, <emphasis>contents_with_mode</emphasis>,
          <emphasis>assign</emphasis>, <emphasis>assign_with_mode</emphasis> or
          <emphasis>move_some</emphasis> accesses to pointers derived from
          <emphasis>p</emphasis>.
        </para>

        <para>
          The <code>POINTER</code> being described is that obtained by applying
          <emphasis>obtain_tag</emphasis> to the <code>TAG</code> of the
          declaration. If the declaration is an <emphasis>identity</emphasis>,
          the <code>SHAPE</code> of the <code>TAG</code> will be a
          <code>POINTER</code>.
        </para>
      </section>

      <section id="S7S7">
        <title>no_other_write</title>

        <emphasis role="bold">Encoding number</emphasis>: 7

        <programlisting>
                   -&gt; ACCESS</programlisting>

        <para>
          This property refers to a <code>POINTER</code>,
          <emphasis>p</emphasis>. It says that, within the lifetime of the
          declaration being qualified, there are no <emphasis>assign</emphasis>,
          <emphasis>assign_with_mode</emphasis> or
          <emphasis>move_some</emphasis> destination accesses to any pointer not
          derived from <emphasis>p</emphasis> which overlap with any of the
          <emphasis>contents</emphasis>,
          <emphasis>contents_with_mode</emphasis>, <emphasis>assign</emphasis>,
          <emphasis>assign_with_mode</emphasis> or
          <emphasis>move_some</emphasis> accesses to pointers derived from
          <emphasis>p</emphasis>.
        </para>

        <para>
          The <code>POINTER</code> being described is that obtained by applying
          <emphasis>obtain_tag</emphasis> to the <code>TAG</code> of the
          declaration. If the declaration is an <emphasis>identity</emphasis>,
          the <code>SHAPE</code> of the <code>TAG</code> will be a
          <code>POINTER</code>.
        </para>
      </section>

      <section id="S7S8">
        <title>out_par</title>

        <emphasis role="bold">Encoding number</emphasis>: 8

        <programlisting>
                   -&gt; ACCESS</programlisting>

        An object qualified by <emphasis>out_par</emphasis> will be an output
        parameter in a <emphasis>make_general_proc</emphasis> construct. This
        will indicate that the final value of the parameter is required in
        <emphasis>postlude</emphasis> part of an
        <emphasis>apply_general_proc</emphasis> of this procedure.
      </section>

      <section id="S7S9">
        <title>preserve</title>

        <emphasis role="bold">Encoding number</emphasis>: 9

        <programlisting>
                   -&gt; ACCESS</programlisting>

        This property refers to a global object. It says that the object will be
        included in the final program, whether or not all possible accesses to
        that object are optimised away; for example by inlining all possible
        uses of procedure object.
      </section>

      <section id="S7S10">
        <title>register</title>

        <emphasis role="bold">Encoding number</emphasis>: 10

        <programlisting>
                   -&gt; ACCESS</programlisting>

        Indicates that an object with this property is frequently used. This can
        be taken as a recommendation to place it in a register.
      </section>

      <section id="S7S11">
        <title>standard_access</title>

        <emphasis role="bold">Encoding number</emphasis>: 11

        <programlisting>
                   -&gt; ACCESS</programlisting>

        An object qualified as having <emphasis>standard_access</emphasis> has
        normal (i.e.  no special) access properties.
      </section>

      <section id="S7S12">
        <title>used_as_volatile</title>

        <emphasis role="bold">Encoding number</emphasis>: 12

        <programlisting>
                   -&gt; ACCESS</programlisting>

        An object qualified as having <emphasis>used_as_volatile</emphasis> will
        be used in a <emphasis>move_some</emphasis>,
        <emphasis>contents_with_mode</emphasis> or an
        <emphasis>assign_with_mode</emphasis> construct with
        <code>TRANSFER_MODE</code> <emphasis>volatile</emphasis>.
      </section>

      <section id="S7S13">
        <title>visible</title>

        <emphasis role="bold">Encoding number</emphasis>: 13

        <programlisting>
                   -&gt; ACCESS</programlisting>

        An object qualified as <emphasis>visible</emphasis> may be accessed when
        the procedure in which it is declared is not the current procedure. A
        <code>TAG</code> must have this property if it is to be used by
        <emphasis>env_offset</emphasis>.
      </section>
    </section>

    <section id="S8">
      <title>AL_TAG</title>

      <emphasis role="bold">Number of encoding bits</emphasis>: 1<sbr/>
      <emphasis role="bold">Is coding extendable</emphasis>: yes<sbr/>
      <emphasis role="bold">Linkable entity identification</emphasis>:
      alignment

      <para>
        <code>AL_TAG</code>s name <code>ALIGNMENT</code>s. They are used so
        that circular definitions can be written in TDF. However, because of
        the definition of alignments, intrinsic circularities cannot occur.
      </para>

      <para>
        <emphasis>For example, the following equation has a circular form x =
        alignment(pointer(alignment(x))) and it or a similar equation might
        occur in TDF. But since alignment(pointer(x)) is {pointer}, this reduces
        to x = {pointer}.</emphasis>
      </para>

      <section id="S8S1">
        <title>al_tag_apply_token</title>

        <emphasis role="bold">Encoding number</emphasis>: 2

        <programlisting>
        token_value:     TOKEN
        token_args:      BITSTREAM param_sorts(token_value)
                   -&gt; AL_TAG</programlisting>

        The token is applied to the arguments encoded in the
        <code>BITSTREAM</code> <emphasis>token_args</emphasis> to give an
        <code>AL_TAG</code>.

        <para>
          If there is a definition for <emphasis>token_value</emphasis> in the
          <code>CAPSULE</code> then <emphasis>token_args</emphasis> is a
          <code>BITSTREAM</code> encoding of the <code>SORT</code>s of its
          parameters, in the order specified.
        </para>
      </section>

      <section id="S8S2">
        <title>make_al_tag</title>

        <emphasis role="bold">Encoding number</emphasis>: 1

        <programlisting>
        al_tagno:        TDFINT
                   -&gt; AL_TAG</programlisting>

        <emphasis>make_al_tag</emphasis> constructs an <code>AL_TAG</code>
        identified by <emphasis>al_tagno</emphasis>.
      </section>
    </section>

    <section id="S9">
      <title>AL_TAGDEF</title>

      <emphasis role="bold">Number of encoding bits</emphasis>: 1<sbr/>
      <emphasis role="bold">Is coding extendable</emphasis>: yes<sbr/>

      <para>
        An <code>AL_TAGDEF</code> gives the definition of an <code>AL_TAG</code>
        for incorporation into a <code>AL_TAGDEF_PROPS</code>.
      </para>

      <section id="S9S1">
        <title>make_al_tagdef</title>

        <emphasis role="bold">Encoding number</emphasis>: 1

        <programlisting>
        t:               TDFINT
        a:               ALIGNMENT
                   -&gt; AL_TAGDEF</programlisting>

        <para>
          The <code>AL_TAG</code> identified by <emphasis>t</emphasis> is
          defined to stand for the <code>ALIGNMENT</code>
          <emphasis>a</emphasis>. All the <code>AL_TAGDEF</code>s in a
          <code>CAPSULE</code> must be considered together as a set of
          simultaneous equations defining <code>ALIGNMENT</code> values for the
          <code>AL_TAG</code>s. No order is imposed on the definitions.
        </para>

        <para>
          In any particular <code>CAPSULE</code> the set of equations may be
          incomplete, but a <code>CAPSULE</code> which is being translated into
          code will have a set of equations which defines all the
          <code>AL_TAG</code>s which it uses.
        </para>

        <para>
          The result of the evaluation of the <emphasis>control</emphasis>
          argument of any <emphasis>x_cond</emphasis> construction (e.g
          <emphasis>alignment_cond</emphasis>) used in <emphasis>a</emphasis>
          shall be independent of any <code>AL_TAG</code>s used in the
          <emphasis>control</emphasis>.  Simultaneous equations defining
          <code>ALIGNMENT</code>s can then always be solved.
        </para>

        <para>
          See <!-- TODO link to 7.13.3 circular types in languages -->Circular
          types in languages<!-- end link -->.
        </para>
      </section>
    </section>

    <section id="S10">
      <title>AL_TAGDEF_PROPS</title>

      <emphasis role="bold">Number of encoding bits</emphasis>: 0<sbr/>
      <emphasis role="bold">Is coding extendable</emphasis>: no<sbr/>
      <emphasis role="bold">Unit identificaiton</emphasis>: aldef

      <section id="S10S1">
        <title>make_al_tagdefs</title>

        <emphasis role="bold">Encoding number</emphasis>: 0

        <programlisting>
        no_labels:       TDFINT
        tds:             SLIST(AL_TAGDEF)
                   -&gt; AL_TAGDEF_PROPS</programlisting>

        <para>
          <emphasis>no_labels</emphasis> is the number of local
          <code>LABEL</code>s used in <emphasis>tds</emphasis>.
          <emphasis>tds</emphasis> is a list of <code>AL_TAGDEF</code>s which
          define the bindings for <emphasis>al_tags</emphasis>.
        </para>
      </section>
    </section>

    <section id="S11">
      <title>ALIGNMENT</title>

      <emphasis role="bold">Number of encoding bits</emphasis>: 4<sbr/>
      <emphasis role="bold">Is coding extendable</emphasis>: yes<sbr/>

      <para>
        An <code>ALIGNMENT</code> gives information about the layout of data in
        memory and hence is a parameter for the <code>POINTER</code> and
        <code>OFFSET SHAPE</code>s (see <!-- TODO link to 7.13. Memory Model
        -->Memory Model<!-- end link -->). This information consists of a set
        of elements.
      </para>

      <para>
        The possible values of the elements in such a set are
        <emphasis>proc</emphasis>, <emphasis>code</emphasis>,
        <emphasis>pointer</emphasis>, <emphasis>offset</emphasis>, all
        <code>VARIETY</code>s, all <code>FLOATING_VARIETY</code>s and all
        <code>BITFIELD_VARIETY</code>s.  The sets are written here as, for
        example, {<emphasis>pointer</emphasis>, <emphasis>proc</emphasis>}
        meaning the set containing <emphasis>pointer</emphasis> and
        <emphasis>proc</emphasis>.
      </para>

      <para>
        In addition, there are <quote>special</quote> <code>ALIGNMENT</code>s
        <emphasis>alloca_alignment</emphasis>,
        <emphasis>callers_alignment</emphasis>,
        <emphasis>callees_alignment</emphasis>,
        <emphasis>locals_alignment</emphasis> and
        <emphasis>var_param_alignment</emphasis>. Each of these are considered
        to be sets which include all of the <quote>ordinary</quote>
        <code>ALIGNMENT</code>s above.
      </para>

      <para>
        There is a function, <emphasis>alignment</emphasis>, which can be
        applied to a <code>SHAPE</code> to give an <code>ALIGNMENT</code> (see
        the definition below). The interpretation of a <code>POINTER</code> to
        an <code>ALIGNMENT</code>, <emphasis>a</emphasis>, is that it can serve
        as a <code>POINTER</code> to any <code>SHAPE</code>,
        <emphasis>s</emphasis>, such that
        <emphasis>alignment</emphasis>(<emphasis>s</emphasis>) is a subset of
        the set <emphasis>a</emphasis>.
      </para>

      <para>
        So given a <code>POINTER</code>({<emphasis>proc</emphasis>,
        <emphasis>pointer</emphasis>}) it is permitted to assign a
        <code>PROC</code> or a <code>POINTER</code> to it, or indeed a compound
        containing only <code>PROC</code>s and <code>POINTER</code>s. This
        permission is valid only in respect of the space being of the right
        kind; it may or may not be big enough for the data.
      </para>

      <para>
        The most usual use for <code>ALIGNMENT</code> is to ensure that
        addresses of <emphasis>int</emphasis> values are aligned on 4-byte
        boundaries, <emphasis>float</emphasis> values are aligned on 4-byte
        boundaries, <emphasis>double</emphasis>s on 8-bit boundaries etc. and
        whatever may be implied by the definitions of the machines and languages
        involved.
      </para>

      <para>
        In the specification the phrase <quote><emphasis>a</emphasis> will
        include <emphasis>b</emphasis></quote> where <emphasis>a</emphasis> and
        <emphasis>b</emphasis> are <code>ALIGNMENT</code>s, means that the set
        <emphasis>b</emphasis> will be a subset of
        <emphasis>a</emphasis> (or equal to <emphasis>a</emphasis>).
      </para>

      <section id="S11S1">
        <title>alignment_apply_token</title>

        <emphasis role="bold">Encoding number</emphasis>: 1

        <programlisting>
        token_value:     TOKEN
        token_args:      BITSTREAM param_sorts(token_value)
                   -&gt; ALIGNMENT</programlisting>

        <para>
          The token is applied to the arguments encoded in the
          <code>BITSTREAM</code> <emphasis>token_args</emphasis> to give an
          <code>ALIGNMENT</code>.
        </para>

        <para>
          If there is a definition for <emphasis>token_value</emphasis> in the
          <code>CAPSULE</code> then <emphasis>token_args</emphasis> is a
          <code>BITSTREAM</code> encoding of the <code>SORT</code>s of its
          parameters, in the order specified.
        </para>
      </section>

      <section id="S11S2">
        <title>alignment_cond</title>

        <emphasis role="bold">Encoding number</emphasis>: 2

        <programlisting>
        control: EXP INTEGER(v)
        e1:              BITSTREAM ALIGNMENT
        e2:              BITSTREAM ALIGNMENT
                   -&gt; ALIGNMENT</programlisting>

        <para>
          <emphasis>control</emphasis> is evaluated. It will be a constant at
          install time under the constant evaluation rules. If it is non-zero,
          <emphasis>e1</emphasis> is installed at this point and
          <emphasis>e2</emphasis> is ignored and never processed.  If
          <emphasis>control</emphasis> is zero then <emphasis>e2</emphasis> is
          installed at this point and <emphasis>e1</emphasis> is ignored and
          never processed.
        </para>
      </section>

      <section id="S11S3">
        <title>alignment</title>

        <emphasis role="bold">Encoding number</emphasis>: 3

        <programlisting>
        sha:             SHAPE
                   -&gt; ALIGNMENT</programlisting>

        <para>
          The <emphasis>alignment</emphasis> construct is defined as follows:
        </para>

        <itemizedlist>
          <listitem>
            <para>
              If <emphasis>sha</emphasis> is <code>PROC</code> then the
              resulting <code>ALIGNMENT</code> is {<emphasis>proc</emphasis>}.
            </para>
          </listitem>

          <listitem>
            <para>
              If <emphasis>sha</emphasis> is
              <code>INTEGER</code>(<emphasis>v</emphasis>) then the resulting
              <code>ALIGNMENT</code> is {<emphasis>v</emphasis>}.
            </para>
          </listitem>

          <listitem>
            <para>
              If <emphasis>sha</emphasis> is
              <code>FLOATING</code>(<emphasis>v</emphasis>) then the resulting
              <code>ALIGNMENT</code> is {<emphasis>v</emphasis>}.
            </para>
          </listitem>

          <listitem>
            <para>
              If <emphasis>sha</emphasis> is
              <code>BITFIELD</code>(<emphasis>v</emphasis>) then the resulting
              <code>ALIGNMENT</code> is {<emphasis>v</emphasis>}.
            </para>
          </listitem>

          <listitem>
            <para>
              If <emphasis>sha</emphasis> is <code>TOP</code> the resulting
              <code>ALIGNMENT</code> is {} - the empty set.
            </para>
          </listitem>

          <listitem>
            <para>
              If <emphasis>sha</emphasis> is <code>BOTTOM</code> the resulting
              <code>ALIGNMENT</code> is undefined.
            </para>
          </listitem>

          <listitem>
            <para>
              If <emphasis>sha</emphasis> is
              <code>POINTER</code>(<emphasis>x</emphasis>) the resulting
              <code>ALIGNMENT</code> is {<emphasis>pointer</emphasis>}.
            </para>
          </listitem>

          <listitem>
            <para>
              If <emphasis>sha</emphasis> is
              <code>OFFSET</code>(<emphasis>x</emphasis>,
              <emphasis>y</emphasis>) the resulting <code>ALIGNMENT</code> is
              {<emphasis>offset</emphasis>}.
            </para>
          </listitem>

          <listitem>
            <para>
              If <emphasis>sha</emphasis> is
              <code>NOF</code>(<emphasis>n</emphasis>, <emphasis>s</emphasis>)
              the resulting <code>ALIGNMENT</code> is
              <emphasis>alignment</emphasis>(<emphasis>s</emphasis>).
            </para>
          </listitem>

          <listitem>
            <para>
              If <emphasis>sha</emphasis> is <code>COMPOUND</code>(<code>EXP
              OFFSET</code>(<emphasis>x</emphasis>, <emphasis>y</emphasis>))
              then the resulting <code>ALIGNMENT</code> is
              <emphasis>x</emphasis>.
            </para>
          </listitem>
        </itemizedlist>
      </section>

      <section id="S11S4">
        <title>alloca_allignment</title>

        <emphasis role="bold">Encoding number</emphasis>: 4

        <programlisting>
                   -&gt; ALIGNMENT</programlisting>

        <para>
          Delivers the <code>ALIGNMENT</code> of <code>POINTER</code>s produced
          from <emphasis>local_alloc</emphasis>.
        </para>
      </section>

      <section id="S11S5">
        <title>callees_alignment</title>

        <emphasis role="bold">Encoding number</emphasis>: 5

        <programlisting>
        var:             BOOL
                   -&gt; ALIGNMENT</programlisting>

        <para>
          If <emphasis>var</emphasis> is <emphasis>true</emphasis> the
          <code>ALIGNMENT</code> is that of callee parameters qualified by the
          <code>PROCPROPS</code> <emphasis>var_callees</emphasis>.  If
          <emphasis>var</emphasis> is <emphasis>false</emphasis>, the
          <code>ALIGNMENT</code> is that of callee parameters not qualified by
          <code>PROCPROPS</code> <emphasis>var_callees</emphasis>.
        </para>

        <para>
          Delivers the <code>base ALIGNMENT</code> of <code>OFFSET</code>s from
          a frame-pointer to a <code>CALLEE</code> parameter. Values of such
          <code>OFFSET</code>s can only be produced by <emphasis>env_offset</emphasis> applied
          to <code>CALLEE</code> parameters, or offset arithmetic operations
          applied to existing <code>OFFSET</code>s.
        </para>
      </section>

      <section id="S11S6">
        <title>callers_alignment</title>

        <emphasis role="bold">Encoding number</emphasis>: 6

        <programlisting>
        var:             BOOL
                   -&gt; ALIGNMENT</programlisting>

        <para>
          If <emphasis>var</emphasis> is <emphasis>true</emphasis> the
          <code>ALIGNMENT</code> is that of caller parameters qualified by the
          <code>PROCPROPS</code> <emphasis>var_callers</emphasis>.  If
          <emphasis>var</emphasis> is <emphasis>false</emphasis>, the
          <code>ALIGNMENT</code> is that of caller parameters not qualified by
          <code>PROCPROPS</code> <emphasis>var_callers</emphasis>.
        </para>

        <para>
          Delivers the <code>base ALIGNMENT</code> of <code>OFFSET</code>s from
          a frame-pointer to a <code>CALLER</code> parameter. Values of such
          <code>OFFSET</code>s can only be produced by
          <emphasis>env_offset</emphasis> applied to <code>CALLER</code>
          parameters, or offset arithmetic operations applied to existing
          <code>OFFSET</code>s.
        </para>
      </section>

      <section id="S11S7">
        <title>code_alignment</title>

        <emphasis role="bold">Encoding number</emphasis>: 7

        <programlisting>
                   -&gt; ALIGNMENT</programlisting>

        <para>
          Delivers {<emphasis>code</emphasis>}, the <code>ALIGNMENT</code> of
          the <code>POINTER</code> produced by
          <emphasis>make_local_lv</emphasis>.
        </para>
      </section>

      <section id="S11S8">
        <title>locals_alignment</title>

        <emphasis role="bold">Encoding number</emphasis>: 8

        <programlisting>
                   -&gt; ALIGNMENT</programlisting>

        <para>
          Delivers the <code>base ALIGNMENT</code> of <code>OFFSET</code>s from
          a frame-pointer to a value defined by <emphasis>variable</emphasis> or
          <emphasis>identify</emphasis>. Values of such <code>OFFSET</code>s can
          only be produced by <emphasis>env_offset</emphasis> applied to
          <code>TAG</code>s so defined, or offset arithmetic operations applied
          to existing <code>OFFSET</code>s.
        </para>
      </section>

      <section id="S11S9">
        <title>obtain_al_tag</title>

        <emphasis role="bold">Encoding number</emphasis>: 9

        <programlisting>
        at:              AL_TAG
                   -&gt; ALIGNMENT</programlisting>

        <para>
          <emphasis>obtain_al_tag</emphasis> produces the <code>ALIGNMENT</code>
          with which the <code>AL_TAG</code> <emphasis>at</emphasis> is bound.
        </para>
      </section>

      <section id="S11S10">
        <title>parameter_alignment</title>

        <emphasis role="bold">Encoding number</emphasis>: 10

        <programlisting>
        sha:             SHAPE
                   -&gt; ALIGNMENT</programlisting>

        <para>
          Delivers the <code>ALIGNMENT</code> of a parameter of a procedure of
          <code>SHAPE</code> <emphasis>sha</emphasis>.
        </para>
      </section>

      <section id="S11S11">
        <title>unite_alignments</title>

        <emphasis role="bold">Encoding number</emphasis>: 11

        <programlisting>
        a1:              ALIGNMENT
        a2:              ALIGNMENT
                   -&gt; ALIGNMENT</programlisting>

        <para>
          <emphasis>unite_alignments</emphasis> produces the alignment at which
          all the members of the <code>ALIGNMENT</code> sets
          <emphasis>a1</emphasis> and <emphasis>a2</emphasis> can be placed - in
          other words the <code>ALIGNMENT</code> set which is the union of
          <emphasis>a1</emphasis> and <emphasis>a2</emphasis>.
        </para>
      </section>

      <section id="S11S12">
        <title>var_param_alignment</title>

        <emphasis role="bold">Encoding number</emphasis>: 12

        <programlisting>
                   -&gt; ALIGNMENT</programlisting>
        <para>
          Delivers the <code>ALIGNMENT</code> used in the
          <emphasis>var_param</emphasis> argument of
          <emphasis>make_proc</emphasis>.
        </para>
      </section>
    </section>

    <section id="S12">
      <title>BITFIELD_VARIETY</title>

      <emphasis role="bold">Number of encoding bits</emphasis>: 2<sbr/>
      <emphasis role="bold">Is coding extendable</emphasis>: yes<sbr/>

      <para>
        These describe runtime bitfield values. The intention is that these
        values are usually kept in memory locations which need not be aligned
        on addressing boundaries.
      </para>

      <para>
        There is no limit on the size of bitfield values in TDF, but an
        installer may specify limits. See <!-- TODO link to 7.24. Representing
        bitfields -->Representing bitfields<!-- end link --> and <!-- TODO link
        to 7.25. Permitted limits -->Permitted limits<!-- end link -->.
      </para>


      <section id="S12S1">
        <title>bfvar_apply_token</title>

        <emphasis role="bold">Encoding number</emphasis>: 1

        <programlisting>
        token_value:     TOKEN
        token_args:      BITSTREAM param_sorts(token_value)
                   -&gt; BITFIELD_VARIETY</programlisting>

        <para>
          The token is applied to the arguments encoded in the
          <code>BITSTREAM</code> <emphasis>token_args</emphasis> to give a
          <code>BITFIELD_VARIETY</code>.
        </para>

        <para>
          If there is a definition for <emphasis>token_value</emphasis> in the
          <code>CAPSULE</code> then <emphasis>token_args</emphasis> is a
          <code>BITSTREAM</code> encoding of the <code>SORT</code>s of its
          parameters, in the order specified.
        </para>
      </section>

      <section id="S12S2">
        <title>bfvar_cond</title>

        <emphasis role="bold">Encoding number</emphasis>: 2

        <programlisting>
        control: EXP INTEGER(v)
        e1:              BITSTREAM BITFIELD_VARIETY
        e2:              BITSTREAM BITFIELD_VARIETY
                   -&gt; BITFIELD_VARIETY</programlisting>

        <para>
          <emphasis>control</emphasis> is evaluated. It will be a constant at
          install time under the constant evaluation rules. If it is non-zero,
          <emphasis>e1</emphasis> is installed at this point and
          <emphasis>e2</emphasis> is ignored and never processed.  If
          <emphasis>control</emphasis> is zero then <emphasis>e2</emphasis> is
          installed at this point and <emphasis>e1</emphasis> is ignored and
          never processed.
        </para>
      </section>

      <section id="S12S3">
        <title>bfvar_bits</title>

        <emphasis role="bold">Encoding number</emphasis>: 3

        <programlisting>
        issigned:        BOOL
        bits:            NAT
                   -&gt; BITFIELD_VARIETY</programlisting>

        <para>
          <emphasis>bfvar_bits</emphasis> constructs a
          <code>BITFIELD_VARIETY</code> describing a pattern of
          <emphasis>bits</emphasis> bits. If <emphasis>issigned</emphasis> is
          <emphasis>true</emphasis>, the pattern is considered to be a
          twos-complement signed number: otherwise it is considered to be
          unsigned.
        </para>
      </section>
    </section>

    <section id="S13">
      <title>BITSTREAM</title>

      <para>
        A <code>BITSTREAM</code> consists of an encoding of any number of bits.
        This encoding is such that any program reading TDF can determine how to
        skip over it. To read it meaningfully extra knowledge of what it
        represents may be needed.
      </para>

      <para>
        A <code>BITSTREAM</code> is used, for example, to supply parameters in a
        <code>TOKEN</code> application. If there is a definition of this
        <code>TOKEN</code> available, this will provide the information needed
        to decode the bitstream.
      </para>

      <para>
        See <!-- TODO link to 8.4. The TDF encoding -->The TDF encoding<!-- end
        link -->.
      </para>
    </section>

    <section id="S14">
      <title>BOOL</title>

      <emphasis role="bold">Number of encoding bits</emphasis>: 3<sbr/>
      <emphasis role="bold">Is coding extendable</emphasis>: yes<sbr/>

      <para>
        A <code>BOOL</code> is a piece of TDF which can take two values,
        <emphasis>true</emphasis> or <emphasis>false</emphasis>.
      </para>

      <section id="S14S1">
        <title>bool_apply_token</title>

        <emphasis role="bold">Encoding number</emphasis>: 1

        <programlisting>
        token_value:     TOKEN
        token_args:      BITSTREAM param_sorts(token_value)
                   -&gt; BOOL</programlisting>

        <para>
          The token is applied to the arguments encoded in the
          <code>BITSTREAM</code> <emphasis>token_args</emphasis> to give a
          <code>BOOL</code>.
        </para>

        <para>
          If there is a definition for <emphasis>token_value</emphasis> in the
          <code>CAPSULE</code> then <emphasis>token_args</emphasis> is a
          <code>BITSTREAM</code> encoding of the <code>SORT</code>s of its
          parameters, in the order specified.
        </para>
      </section>

      <section id="S14S2">
        <title>bool_cond</title>

        <emphasis role="bold">Encoding number</emphasis>: 2

        <programlisting>
        control: EXP INTEGER(v)
        e1:              BITSTREAM BOOL
        e2:              BITSTREAM BOOL
                   -&gt; BOOL</programlisting>

        <para>
          <emphasis>control</emphasis> is evaluated. It will be a constant at
          install time under the constant evaluation rules. If it is non-zero,
          <emphasis>e1</emphasis> is installed at this point and
          <emphasis>e2</emphasis> is ignored and never processed.  If
          <emphasis>control</emphasis> is zero then <emphasis>e2</emphasis> is
          installed at this point and <emphasis>e1</emphasis> is ignored and
          never processed.
        </para>
      </section>

      <section id="S14S3">
        <title>false</title>

        <emphasis role="bold">Encoding number</emphasis>: 3

        <programlisting>
                   -&gt; BOOL</programlisting>

        <para>
          <emphasis>false</emphasis> produces a false <code>BOOL</code>.
        </para>
      </section>

      <section id="S14S4">
        <title>true</title>

        <emphasis role="bold">Encoding number</emphasis>: 4

        <programlisting>
                   -&gt; BOOL</programlisting>

        <para>
          <emphasis>true</emphasis> produces a true <code>BOOL</code>.
        </para>
      </section>
    </section>

    <section id="S15">
      <title>BYTESTREAM</title>

      <para>
        A <code>BYTESTREAM</code> is analogous to a <code>BITSTREAM</code>, but
        is encoded to permit fast copying.
      </para>

      <para>
        See <!-- TODO link to 8.4. The TDF encoding -->The TDF encoding<!-- end
        link -->.
      </para>
    </section>

    <section id="S16">
      <title>CALLEES</title>

      <emphasis role="bold">Number of encoding bits</emphasis>: 2<sbr/>
      <emphasis role="bold">Is coding extendable</emphasis>: yes

      <para>
        This is an auxilliary <code>SORT</code> used in calling procedures by
        <emphasis>apply_general_proc</emphasis> and
        <emphasis>tail_call</emphasis> to provide their actual callee
        parameters.
      </para>

      <section id="S16S1">
        <title>make_callee_list</title>

        <emphasis role="bold">Encoding number</emphasis>: 1

        <programlisting>
        args:            LIST(EXP)
                   -&gt; CALLEES</programlisting>

        <para>
          The list of <code>EXP</code>s <emphasis>args</emphasis> are evaluated
          in any interleaved order and the resulting list of values form the
          actual callee parameters of the call.
        </para>
      </section>

      <section id="S16S2">
        <title>make_dynamic_callees</title>

        <emphasis role="bold">Encoding number</emphasis>: 2

        <programlisting>
        ptr:             EXP POINTER(x)
        sze:             EXP OFFSET(x, y)
                   -&gt; CALLEES</programlisting>

        <para>
          The value of size <emphasis>sze</emphasis> pointed at by
          <emphasis>ptr</emphasis> forms the actual callee parameters of the
          call.
        </para>

        <para>
          The <code>CALLEES</code> value is intended to refer to a sequence of
          zero or more callee parameters. <emphasis>x</emphasis> will include
          <emphasis>parameter_alignment</emphasis>(<emphasis>s</emphasis>) for
          each <emphasis>s</emphasis> that is the <code>SHAPE</code> of an
          intended callee parameter. The value addressed by
          <emphasis>ptr</emphasis> may be produced in one of two ways.  It may
          be produced as a <code>COMPOUND SHAPE</code> value in the normal sense
          of a structure, whose successive elements will be used to generate the
          sequence of callee parameters. In this case, each element in the
          sequence of <code>SHAPE</code> <emphasis>s</emphasis> must
          additionally be padded to
          <emphasis>parameter_alignment</emphasis>(<emphasis>s</emphasis>).
          Alternatively, <emphasis>ptr</emphasis> may address the callee
          parameters of an already activated procedure, by referring to the
          first of the sequence.  <emphasis>sze</emphasis> will be equivalent to
          <emphasis>shape_offset</emphasis>(<emphasis>c</emphasis>) where
          <emphasis>c</emphasis> is the <code>COMPOUND SHAPE</code> just
          described.
        </para>

        <para>
          The call involved (i.e. <emphasis>apply_general_proc</emphasis> or
          <emphasis>tail_call</emphasis>) must have a
          <emphasis>var_callees</emphasis> <code>PROCPROPS</code>.
        </para>
      </section>

      <section id="S16S3">
        <title>same_callees</title>

        <emphasis role="bold">Encoding number</emphasis>: 3

        <programlisting>
                   -&gt; CALLEES</programlisting>

        <para>
          The callee parameters of the call are the same as those of the current
          procedure.
        </para>
      </section>
    </section>

    <section id="S17">
      <title>CAPSULE</title>

      <emphasis role="bold">Number of encoding bits</emphasis>: 0<sbr/>
      <emphasis role="bold">Is coding extendable</emphasis>: no<sbr/>

      <para>
        A <code>CAPSULE</code> is an independent piece of TDF. There is only one
        construction, <emphasis>make_capsule</emphasis>.
      </para>

      <section id="S17S1">
        <title>make_capsule</title>

        <emphasis role="bold">Encoding number</emphasis>: 0

        <programlisting>
        prop_names:      SLIST(TDFIDENT)
        cap_linking:     SLIST(CAPSULE_LINK)
        ext_linkage:     SLIST(EXTERN_LINK)
        groups:          SLIST(GROUP)
                   -&gt; CAPSULE</programlisting>

        <para>
          <emphasis>make_capsule</emphasis> brings together <code>UNIT</code>s
          and linking and naming information. See <!-- TODO link to 2.1. The
          Overall Structure -->The Overall Structure<!-- end link -->.
        </para>

        <para>
          The elements of the list, <emphasis>prop_names</emphasis>, correspond
          one-to-one with the elements of the list, <emphasis>groups</emphasis>.
          The element of <emphasis>prop_names</emphasis> is the unit
          identification of all the <code>UNIT</code>s in the corresponding
          <code>GROUP</code>. See <!-- TODO link to 5.29. PROPS
          --><code>PROPS</code><!-- link end -->.  A <code>CAPSULE</code> need
          not contain all the kinds of <code>UNIT</code>.
        </para>

        <para>
          It is intended that new kinds of <code>PROPS</code> with new unit
          identifications can be added to the standard in a purely additive
          fashion, either to form a new standard or for private purposes.
        </para>

        <para>
          The elements of the list, <emphasis>cap_linking</emphasis>, correspond
          one-to-one with the elements of the list,
          <emphasis>ext_linkage</emphasis>. The element of
          <emphasis>cap_linking</emphasis> gives the linkable entity
          identification for all the <code>LINKEXTERN</code>s in the element of
          <emphasis>ext_linkage</emphasis>.  It also gives the number of
          <code>CAPSULE</code> level linkable entities having that
          identification.
        </para>

        <para>
          The elements of the list, <emphasis>cap_linking</emphasis>, also
          correspond one-to-one with the elements of the lists called
          <emphasis>local_vars</emphasis> in each of the
          <emphasis>make_unit</emphasis> constructions for the
          <code>UNIT</code>s in <emphasis>groups</emphasis>. The element of
          <emphasis>local_vars</emphasis> gives the number of <code>UNIT</code>
          level linkable entities having the identification in the corresponding
          member of <emphasis>cap_linking</emphasis>.
        </para>

        <para>
          It is intended that new kinds of linkable entity can be added to the
          standard in a purely additive fashion, either to form a new standard
          or for private purposes.
        </para>

        <para>
          <emphasis>ext_linkage</emphasis> provides a list of lists of
          <code>LINKEXTERN</code>s. These <code>LINKEXTERN</code>s specify the
          associations between the names to be used outside the
          <code>CAPSULE</code> and the linkable entities by which the
          <code>UNIT</code>s make objects available within the
          <code>CAPSULE</code>.
        </para>

        <para>
          The list, <emphasis>groups</emphasis>, provides the non-linkage
          information of the <code>CAPSULE</code>.
        </para>
      </section>
    </section>

    <section id="S18">
      <title>CAPSULE_LINK</title>

      <emphasis role="bold">Number of encoding bits</emphasis>: 0<sbr/>
      <emphasis role="bold">Is coding extendable</emphasis>: no<sbr/>

      <para>
        An auxiliary <code>SORT</code> which gives the number of linkable
        entities of a given kind at <code>CAPSULE</code> level. It is used only
        in <emphasis>make_capsule</emphasis>.
      </para>

      <section id="S18S1">
        <title>make_capsule_link</title>

        <emphasis role="bold">Encoding number</emphasis>: 0

        <programlisting>
        sn:              TDFIDENT
        n:               TDFINT
                   -&gt; CAPSULE_LINK</programlisting>

        <para>
          <emphasis>n</emphasis> is the number of <code>CAPSULE</code> level
          linkable entities (numbered from 0 to <emphasis>n</emphasis>-1) of the
          kind given by <emphasis>sn</emphasis>.  <emphasis>sn</emphasis>
          corresponds to the linkable entity identification.
        </para>
      </section>
    </section>

    <section id="S19">
      <title>CASELIM</title>

      <emphasis role="bold">Number of encoding bits</emphasis>: 0<sbr/>
      <emphasis role="bold">Is coding extendable</emphasis>: no<sbr/>

      <para>
        An auxiliary <code>SORT</code> which provides lower and upper bounds and
        the <code>LABEL</code> destination for the <emphasis>case</emphasis>
        construction.
      </para>

      <section id="S19S1">
        <title>make_caselim</title>

        <emphasis role="bold">Encoding number</emphasis>: 0

        <programlisting>
        branch:          LABEL
        lower:           SIGNED_NAT
        upper:           SIGNED_NAT
                   -&gt; CASELIM</programlisting>

        <para>
          Makes a triple of destination and limits. The
          <emphasis>case</emphasis> construction uses a list of
          <code>CASELIM</code>s. If the control variable of the
          <emphasis>case</emphasis> lies between <emphasis>lower</emphasis> and
          <emphasis>upper</emphasis>, control passes to
          <emphasis>branch</emphasis>.
        </para>
      </section>
    </section>

    <section id="S20">
      <title>ERROR_code</title>

      <emphasis role="bold">Number of encoding bits</emphasis>: 2<sbr/>
      <emphasis role="bold">Is coding extendable</emphasis>: yes<sbr/>

      <section id="S20S1">
        <title>nil_access</title>

        <emphasis role="bold">Encoding number</emphasis>: 1

        <programlisting>
                   -&gt; ERROR_code</programlisting>

        <para>
          Delivers the <code>ERROR_code</code> arising from an attempt to access
          a nil pointer in an operation with <code>TRANSFER_MODE</code>
          <emphasis>trap_on_nil</emphasis>.
        </para>
      </section>

      <section id="S20S2">
        <title>overflow</title>

        <emphasis role="bold">Encoding number</emphasis>: 2

        <programlisting>
                   -&gt; ERROR_code</programlisting>

        <para>
          Delivers the <code>ERROR_code</code> arising from a numerical
          exceptional result in an operation with <code>ERROR_TREATMENT</code>
          <emphasis>trap</emphasis>(<emphasis>overflow</emphasis>).
        </para>
      </section>

      <section id="S20S3">
        <title>stack_overflow</title>

        <emphasis role="bold">Encoding number</emphasis>: 3

        <programlisting>
                   -&gt; ERROR_code</programlisting>

        <para>
          Delivers the <code>ERROR_code</code> arising from a stack overflow in
          the call of a procedure defined with <code>PROCPROPS</code>
          <emphasis>check_stack.</emphasis>
        </para>
      </section>
    </section>

    <section id="S21">
      <title>ERROR_TREATMENT</title>

      <emphasis role="bold">Number of encoding bits</emphasis>: 3<sbr/>
      <emphasis role="bold">Is coding extendable</emphasis>: yes<sbr/>

      <para>
        These values describe the way to handle various forms of error which
        can occur during the evaluation of operations.
      </para>

      <para>
        <emphasis>It is expected that additional <code>ERROR_TREATMENT</code>s
        will be needed.</emphasis>
      </para>

      <section id="S21S1">
        <title>errt_apply_token</title>

        <emphasis role="bold">Encoding number</emphasis>: 1

        <programlisting>
        token_value:     TOKEN
        token_args:      BITSTREAM param_sorts(token_value)
                   -&gt; ERROR_TREATMENT</programlisting>

        <para>
          The token is applied to the arguments encoded in the
          <code>BITSTREAM</code> <emphasis>token_args</emphasis> to give an
          <code>ERROR_TREATMENT</code>.
        </para>

        <para>
          If there is a definition for <emphasis>token_value</emphasis> in the
          <code>CAPSULE</code> then <emphasis>token_args</emphasis> is a
          <code>BITSTREAM</code> encoding of the <code>SORT</code>s of its
          parameters, in the order specified.
        </para>
      </section>

      <section id="S21S2">
        <title>errt_cond</title>

        <emphasis role="bold">Encoding number</emphasis>: 2

        <programlisting>
        control: EXP INTEGER(v)
        e1:              BITSTREAM ERROR_TREATMENT
        e2:              BITSTREAM ERROR_TREATMENT
                   -&gt; ERROR_TREATMENT</programlisting>

        <para>
          <emphasis>control</emphasis> is evaluated. It will be a constant at
          install time under the constant evaluation rules. If it is non-zero,
          <emphasis>e1</emphasis> is installed at this point and
          <emphasis>e2</emphasis> is ignored and never processed.  If
          <emphasis>control</emphasis> is zero then <emphasis>e2</emphasis> is
          installed at this point and <emphasis>e1</emphasis> is ignored and
          never processed.
        </para>
      </section>

      <section id="S21S3">
        <title>continue</title>

        <emphasis role="bold">Encoding number</emphasis>: 3

        <programlisting>
                   -&gt; ERROR_TREATMENT</programlisting>

        <para>
          If an operation with a <emphasis>continue</emphasis>
          <code>ERROR_TREATMENT</code> causes an error, some value of the
          correct <code>SHAPE</code> shall be delivered. This value shall have
          the same properties as is specified in
          <emphasis>make_value</emphasis>.
        </para>
      </section>

      <section id="S21S4">
        <title>error_jump</title>

        <emphasis role="bold">Encoding number</emphasis>: 4

        <programlisting>
        lab:             LABEL
                   -&gt; ERROR_TREATMENT</programlisting>

        <para>
          <emphasis>error_jump</emphasis> produces an
          <code>ERROR_TREATMENT</code> which requires that control be passed to
          <emphasis>lab</emphasis> if it is invoked. <emphasis>lab</emphasis>
          will be in scope.
        </para>

        <para>
          If a construction has an <emphasis>error_jump</emphasis>
          <code>ERROR_TREATMENT</code> and the jump is taken, the canonical
          order specifies only that the jump occurs after evaluating the
          construction. It is not specified how many further constructions are
          evaluated.
        </para>

        <para>
          <emphasis>This rule implies that a further construction is needed to
          guarantee that errors have been processed. This is not yet included.
          The effect of nearby procedure calls or exits also needs
          definition.</emphasis>
        </para>
      </section>

      <section id="S21S5">
        <title>trap</title>

        <emphasis role="bold">Encoding number</emphasis>: 5

        <programlisting>
        trap_list:       LIST(ERROR_code)
                   -&gt; ERROR_TREATMENT</programlisting>

        <para>
          The list of <code>ERROR_codeS</code> in <emphasis>trap_list</emphasis>
          specifies a set of possible exceptional behaviours. If any of these
          occur in an construction with <code>ERROR_TREATMENT</code>
          <emphasis>trap</emphasis>, the TDF exception handling is invoked (see
          <!-- TODO link to 7.8. Exceptions and jumps -->section 7.8<!-- link
          end -->).
        </para>

        <para>
          The observations on canonical ordering in
          <emphasis>error_jump</emphasis> apply equally here.
        </para>
      </section>

      <section id="S21S6">
        <title>wrap</title>

        <emphasis role="bold">Encoding number</emphasis>: 6

        <programlisting>
                   -&gt; ERROR_TREATMENT</programlisting>

        <para>
          <emphasis>wrap</emphasis> is an <code>ERROR_TREATMENT</code> which
          will only be used in constructions with integer operands and
          delivering <code>EXP</code>
          <code>INTEGER</code>(<emphasis>v</emphasis>) where either the lower
          bound of <emphasis>v</emphasis> is zero or the construction is not one
          of <emphasis>mult, power, div0, div1, div2, rem0, rem1,
          rem2</emphasis>. The result will be evaluated and any bits in the
          result lying outside the representing <code>VARIETY</code> will be
          discarded (see <!-- TODO link to 7.18. Representing integers
          -->Representing integers<!-- end link -->
        </para>
      </section>

      <section id="S21S7">
        <title>impossible</title>

        <emphasis role="bold">Encoding number</emphasis>: 7

        <programlisting>
                   -&gt; ERROR_TREATMENT</programlisting>

        <para>
          <emphasis>impossible</emphasis> is an <code>ERROR_TREATMENT</code>
          which means that this error will not occur in the construct concerned.
        </para>

        <para>
          <emphasis>impossible is possibly a misnomer. If an error occurs the
          result is undefined.</emphasis>
        </para>
      </section>
    </section>

    <section id="S22">
      <title>EXP</title>

      <emphasis role="bold">Number of encoding bits</emphasis>: 7<sbr/>
      <emphasis role="bold">Is coding extendable</emphasis>: yes<sbr/>

      <para>
        <code>EXP</code>s are pieces of TDF which are translated into program.
        <code>EXP</code> is by far the richest <code>SORT</code>. There are few
        primitive <code>EXP</code>s: most of the constructions take arguments
        which are a mixture of <code>EXP</code>s and other <code>SORT</code>s.
        There are constructs delivering <code>EXP</code>s that correspond to the
        declarations, program structure, procedure calls, assignments, pointer
        manipulation, arithmetic operations, tests etc. of programming
        languages.
      </para>

      <section id="S22S1">
        <title>exp_apply_token</title>

        <emphasis role="bold">Encoding number</emphasis>: 1

        <programlisting>
        token_value:     TOKEN
        token_args:      BITSTREAM param_sorts(token_value)
                   -&gt; EXP x</programlisting>

        <para>
          The token is applied to the arguments encoded in the
          <code>BITSTREAM</code> <emphasis>token_args</emphasis> to give an
          <code>EXP</code>.
        </para>

        <para>
          If there is a definition for <emphasis>token_value</emphasis> in the
          <code>CAPSULE</code> then <emphasis>token_args</emphasis> is a
          <code>BITSTREAM</code> encoding of the <code>SORT</code>s of its
          parameters, in the order specified.
        </para>
      </section>

      <section id="S22S2">
        <title>exp_cond</title>

        <emphasis role="bold">Encoding number</emphasis>: 2

        <programlisting>
        control: EXP INTEGER(v)
        e1:              BITSTREAM EXP x
        e2:              BITSTREAM EXP y
                   -&gt; EXP (control ? x : y)</programlisting>

        <para>
          <emphasis>control</emphasis> is evaluated. It will be a constant at
          install time under the constant evaluation rules. If it is non-zero,
          <emphasis>e1</emphasis> is installed at this point and
          <emphasis>e2</emphasis> is ignored and never processed.  If
          <emphasis>control</emphasis> is zero then <emphasis>e2</emphasis> is
          installed at this point and <emphasis>e1</emphasis> is ignored and
          never processed.
        </para>
      </section>

      <section id="S22S3">
        <title>abs</title>

        <emphasis role="bold">Encoding number</emphasis>: 3

        <programlisting>
        ov_err:          ERROR_TREATMENT
        arg1:            EXP INTEGER(v)
                   -&gt; EXP INTEGER(v)</programlisting>

        <para>
          The absolute value of the result produced by <emphasis>arg1</emphasis>
          is delivered.
        </para>

        <para>
          If the result cannot be expressed in the <code>VARIETY</code> being
          used to represent <emphasis>v</emphasis>, an overflow error is caused
          and is handled in the way specified by <emphasis>ov_err</emphasis>.
        </para>
      </section>

      <section id="S22S4">
        <title>add_to_ptr</title>

        <emphasis role="bold">Encoding number</emphasis>: 4

        <programlisting>
        arg1:            EXP POINTER(x)
        arg2:            EXP OFFSET(y, z)
                   -&gt; EXP POINTER(z)</programlisting>

        <para>
          <emphasis>arg1</emphasis> is evaluated, giving <emphasis>p</emphasis>,
          and <emphasis>arg2</emphasis> is evaluated and the results are added
          to produce the answer. The result is derived from the pointer
          delivered by <emphasis>arg1</emphasis>. The intention is to produce a
          <code>POINTER</code> displaced from the argument <code>POINTER</code>
          by the given amount.
        </para>

        <para>
          <emphasis>x</emphasis> will include <emphasis>y</emphasis>.
        </para>

        <para>
          <emphasis>arg1</emphasis> may deliver a null <code>POINTER</code>. In
          this case the result is derived from a null <code>POINTER</code> which
          counts as an original <code>POINTER</code>. Further
          <code>OFFSET</code>s may be added to the result, but the only other
          useful operation on the result of adding a number of
          <code>OFFSET</code>s to a null <code>POINTER </code> is to
          <emphasis>subtract_ptrs</emphasis> a null <code>POINTER</code> from
          it.
        </para>

        <para>
          The result will be less than or equal (in the sense of
          <emphasis>pointer_test</emphasis>) to the result of applying
          <emphasis>add_to_ptr</emphasis> to the original pointer from which
          <emphasis>p</emphasis> is derived and the size of the space allocated
          for the original pointer.
        </para>

        <para>
          <emphasis>In the simple representation of <code>POINTER</code>
          arithmetic (see <!-- TODO link to 7.13. Memory Model -->Memory
          Model<!-- end link -->) add_to_ptr is represented by addition. The
          constraint <quote>x includes y</quote> ensures that no padding has to
          be inserted in this case.</emphasis>
        </para>
      </section>

      <section id="S22S5">
        <title>and</title>

        <emphasis role="bold">Encoding number</emphasis>: 5

        <programlisting>
        arg1:            EXP INTEGER(v)
        arg2:            EXP INTEGER(v)
                   -&gt; EXP INTEGER(v)</programlisting>

        <para>
          The arguments are evaluated producing integer values of the same
          <code>VARIETY</code>, <emphasis>v</emphasis>. The result is the
          bitwise <emphasis>and</emphasis> of the two values in the representing
          <code>VARIETY</code>. The result is delivered with the same
          <code>SHAPE</code> as the arguments.
        </para>

        <para>
          See <!-- TODO link to 7.18. Representing integers -->Representing
          integers<!-- link end -->.
        </para>
      </section>

      <section id="S22S6">
        <title>apply_proc</title>

        <emphasis role="bold">Encoding number</emphasis>: 6

        <programlisting>
        result_shape:    SHAPE
        p:               EXP PROC
        params:          LIST(EXP)
        var_param:       OPTION(EXP)
                   -&gt; EXP result_shape</programlisting>

        <para>
          <emphasis>p, params</emphasis> and <emphasis>var_param</emphasis> (if
          present) are evaluated in any interleaved order. The procedure,
          <emphasis>p</emphasis>, is applied to the parameters. The result of
          the procedure call, which will have <emphasis>result_shape</emphasis>,
          is delivered as the result of the construction.
        </para>

        <para>
          The canonical order of evaluation is as if the definition were
          in-lined. That is, the actual parameters are evaluated interleaved in
          any order and used to initialise variables which are identified by the
          formal parameters during the evaluation of the procedure body. When
          this is complete the body is evaluated. So
          <emphasis>apply_proc</emphasis> is evaluated like a
          <emphasis>variable</emphasis> construction, and obeys similar rules
          for order of evaluation.
        </para>

        <para>
          If <emphasis>p</emphasis> delivers a null procedure the effect is
          undefined.
        </para>

        <para>
          <emphasis>var_param</emphasis> is intended to communicate parameters
          which vary in <code>SHAPE</code> from call to call. Access to these
          parameters during the procedure is performed by using
          <code>OFFSET</code> arithmetic.  Note that it is necessary to place
          these values on <emphasis>var_param_alignment</emphasis> because of
          the definition of <emphasis>make_proc</emphasis>.
        </para>

        <para>
          The optional <emphasis>var_param</emphasis> should not be confused
          with variable argument lists in the C
          (<emphasis>&lt;stdarg.h&gt;</emphasis> or
          <emphasis>&lt;varargs.h&gt;</emphasis>) sense, which are communicated
          by extending the <emphasis>params</emphasis> list.  This is discussed
          further in <!-- TODO link to 7.9. Procedures -->section 7.9<!-- end
          link -->. If the number of arguments in the
          <emphasis>params</emphasis> list differs from the number of elements
          in the <emphasis>params_intro</emphasis> of the corresponding
          <emphasis>make_proc</emphasis>, then <emphasis>var_param</emphasis>
          must not be present.
        </para>

        <para>
          All calls to the same procedure will yield results of the same
          <code>SHAPE</code>.
        </para>

        <para>
          For notes on the intended implementation of procedures see <!-- TODO
          link to 7.9. Procedures -->section 7.9<!-- end link -->.
        </para>
      </section>

      <section id="S22S7">
        <title>apply_general_proc</title>

        <emphasis role="bold">Encoding number</emphasis>: 7

        <programlisting>
        result_shape:    SHAPE
        prcprops:        OPTION(PROCPROPS)
        p:               EXP PROC
        callers_intro:   LIST(OTAGEXP)
        callee_pars:     CALLEES
        postlude:        EXP TOP
                   -&gt; EXP result_shape</programlisting>

        <para>
          <emphasis>p</emphasis>, <emphasis>callers_intro</emphasis> and
          <emphasis>callee_pars</emphasis> are evaluated in any order. The
          procedure, <emphasis>p</emphasis>, is applied to the parameters.  The
          result of the procedure call, which will have
          <emphasis>result_shape</emphasis>, is delivered as the result of the
          construction.
        </para>

        <para>
          If <emphasis>p</emphasis> delivers a null procedure the effect is
          undefined.
        </para>

        <para>
          Any <code>TAG</code> introduced by an <code>OTAGEXP</code> in
          <emphasis>callers_intro</emphasis> is available in
          <emphasis>postlude</emphasis> which will be evaluated after the
          application.
        </para>

        <para>
          <emphasis>postlude</emphasis> will not contain any
          <emphasis>local_allocs</emphasis> or calls of procedures with untidy
          returns. If <emphasis>prcprops</emphasis> include
          <emphasis>untidy</emphasis>, <emphasis>postlude</emphasis> will be
          <emphasis>make_top</emphasis>.
        </para>

        <para>
          The canonical order of evaluation is as if the definition of
          <emphasis>p</emphasis> were inlined in a manner dependent on
          <emphasis>prcprops</emphasis>.
        </para>

        <para>
          If none of the <code>PROCPROPS</code>
          <emphasis>var_callers</emphasis>, <emphasis>var_callees</emphasis> and
          <emphasis>check_stack</emphasis> are present the inlining is as
          follows, supposing that P is the body of the definition of
          <emphasis>p</emphasis>:
        </para>
        
        <para>
          Let R<emphasis>i</emphasis> be the value of the <code>EXP</code> of
          the i<emphasis>th</emphasis> <code>OTAGEXP</code> in
          <emphasis>callers_intro</emphasis> and T<emphasis>i</emphasis> be its
          <code>TAG</code> (if it is present). Let E<emphasis>i</emphasis> be
          the i<emphasis>th</emphasis> value in
          <emphasis>callee_pars</emphasis>.<sbr/> Let r<emphasis>i</emphasis> be
          the i<emphasis>th</emphasis> formal caller parameter <code>TAG</code>
          of <emphasis>p</emphasis>.<sbr/> Let e<emphasis>i</emphasis> be the
          i<emphasis>th</emphasis> formal callee parameter <code>TAG</code> of
          <emphasis>p</emphasis>.
        </para>

        <para>
          Each R<emphasis>i</emphasis> is used to initialise a variable which is
          identified by r<emphasis>i</emphasis>; there will be exactly as many
          R<emphasis>i</emphasis> as r<emphasis>i</emphasis>.The scope of these
          variable definitions is a sequence consisting of three components -
          the identification of a <code>TAG</code> <emphasis>res</emphasis> with
          the result of a binding of P, followed by a binding of
          <emphasis>postlude</emphasis>, followed by an
          <emphasis>obtain_tag</emphasis> of <emphasis>res</emphasis> giving the
          result of the inlined procedure call.
        </para>

        <para>
          The binding of P consists of using each E<emphasis>i</emphasis> to
          initialise a variable identified with e<emphasis>i</emphasis>; there
          will be exactly as many E<emphasis>i</emphasis> as
          e<emphasis>i</emphasis>. The scope of these variable definitions is P
          modified so that the first <emphasis>return</emphasis> or
          <emphasis>untidy_return</emphasis> encountered in P gives the result
          of the binding. If it ends with a <emphasis>return</emphasis>, any
          space generated by <emphasis>local_allocs</emphasis> within the
          binding is freed (in the sense of <emphasis>local_free</emphasis>) at
          this point. If it ends with <emphasis>untidy_return</emphasis>, no
          freeing will take place.
        </para>

        <para>
          The binding of <emphasis>postlude</emphasis> consists of identifying
          each T<emphasis>i</emphasis> (if present) with the contents of the
          variable identified by r<emphasis>i</emphasis>.  The scope of these
          identifications is <emphasis>postlude</emphasis>.
        </para>

        <para>
          If the <code>PROCPROPS</code> <emphasis>var_callers</emphasis> is
          present, the inlining process is modified by:<sbr/> A compound
          variable is constructed initialised to R<emphasis>i</emphasis> in
          order; the alignment and padding of each individual
          R<emphasis>i</emphasis> will be given by an exact application of
          <emphasis>parameter_alignment</emphasis> on the <code>SHAPE</code> of
          R<emphasis>i</emphasis>. Each r<emphasis>i</emphasis> is then
          identified with a pointer to the copy of R<emphasis>i</emphasis>
          within the compound variable; there will be at least as many
          R<emphasis>i</emphasis> as r<emphasis>i</emphasis>. The evaluation
          then continues as above with the scope of these identifications being
          the sequence.
        </para>

        <para>
          If the <code>PROCPROPS</code> <emphasis>var_callees</emphasis> is
          present, the inlining process is modified by:<sbr/> The binding of P
          is done by generating (as if by <emphasis>local_alloc</emphasis>) a
          pointer to space for a compound value constructed from each
          E<emphasis>i</emphasis> in order (just as for
          <emphasis>var_callers</emphasis>). Each e<emphasis>i</emphasis> is
          identified with a pointer to the copy of E<emphasis>i</emphasis>
          within the generated space; there will be at least as many
          e<emphasis>i</emphasis> as E<emphasis>i</emphasis>. P is evaluated
          within the scope of these identifications as before. Note that the
          generation of space for these callee parameters is a
          <emphasis>local_alloc</emphasis> with the binding of P, and hence will
          not be freed if P ends with an <emphasis>untidy_return</emphasis>.
        </para>
      </section>

      <section id="S22S8">
        <title>assign</title>

        <emphasis role="bold">Encoding number</emphasis>: 8

        <programlisting>
        arg1:            EXP POINTER(x)
        arg2:            EXP y
                   -&gt; EXP TOP</programlisting>

        <para>
          The value produced by <emphasis>arg2</emphasis> will be put in the
          space indicated by <emphasis>arg1</emphasis>.
        </para>

        <para>
          <emphasis>x</emphasis> will include
          <emphasis>alignment</emphasis>(<emphasis>y</emphasis>).
        </para>

        <para>
          <emphasis>y</emphasis> will not be a <code>BITFIELD</code>.
        </para>

        <para>
          If the space which the pointer indicates does not lie wholly within
          the space indicated by the original pointer from which it is derived,
          the effect is undefined.
        </para>

        <para>
          If the value delivered by <emphasis>arg1</emphasis> is a null pointer
          the effect is undefined.
        </para>

        <para>
          See <!-- TODO link to 7.16. Overlapping -->Overlapping<!-- link end
          --> and <!-- TODO link to 7.17. Incomplete assignment -->Incomplete
          assignment<!-- link end -->.
        </para>

        <para>
          <emphasis>The constraint <quote>x will include alignment(y)</quote>
          ensures in the simple memory model that no change is needed to the
          <code>POINTER</code>.</emphasis>
        </para>
      </section>

      <section id="S22S9">
        <title>assign_with_mode</title>

        <emphasis role="bold">Encoding number</emphasis>: 9

        <programlisting>
        md:              TRANSFER_MODE
        arg1:            EXP POINTER(x)
        arg2:            EXP y
                   -&gt; EXP TOP</programlisting>

        <para>
          The value produced by <emphasis>arg2</emphasis> will be put in the
          space indicated by <emphasis>arg1</emphasis>. The assignment will be
          carried out as specified by the <code>TRANSFER_MODE</code> (q.v.).
        </para>

        <para>
          If <emphasis>md</emphasis> consists of
          <emphasis>standard_transfer_mode</emphasis> only, then
          <emphasis>assign_with_mode</emphasis> is the same as
          <emphasis>assign</emphasis>.
        </para>

        <para>
          <emphasis>x</emphasis> will include
          <emphasis>alignment</emphasis>(<emphasis>y</emphasis>).
        </para>

        <para>
          <emphasis>y</emphasis> will not be a <code>BITFIELD</code>.
        </para>

        <para>
          If the space which the pointer indicates does not lie wholly within
          the space indicated by the original pointer from which it is derived,
          the effect is undefined.
        </para>

        <para>
          If the value delivered by <emphasis>arg1</emphasis> is a null pointer
          the effect is undefined.
        </para>

        <para>
          See <!-- TODO link to 7.16. Overlapping -->Overlapping<!-- end link
          --> and <!-- TODO link to 7.17. Incomplete assignment -->Incomplete
          assignment<!-- link end -->.
        </para>
      </section>

      <section id="S22S10">
        <title>bitfield_assign</title>

        <emphasis role="bold">Encoding number</emphasis>: 10

        <programlisting>
        arg1:            EXP POINTER(x)
        arg2:            EXP OFFSET(y, z)
        arg3:            EXP BITFIELD(v)
                   -&gt; EXP TOP</programlisting>

        <para>
          The value delivered by <emphasis>arg3</emphasis> is assigned at a
          displacement given by <emphasis>arg2</emphasis> from the pointer
          delivered by <emphasis>arg1</emphasis>.
        </para>

        <para>
          <emphasis>x</emphasis> will include <emphasis>y</emphasis> and
          <emphasis>z</emphasis> will include <emphasis>v</emphasis>.
        </para>

        <para>
          <emphasis>arg2</emphasis>,
          <code>BITFIELD</code>(<emphasis>v</emphasis>) will be
          <emphasis>variety-enclosed</emphasis> (see <!-- TODO link to 7.24.
          Representing bitfields -->section 7.24<!-- end link -->).
        </para>
      </section>

      <section id="S22S11">
        <title>bitfield_assign_with_mode</title>

        <emphasis role="bold">Encoding number</emphasis>: 11

        <programlisting>
        md:              TRANSFER_MODE
        arg1:            EXP POINTER(x)
        arg2:            EXP OFFSET(y, z)
        arg3:            EXP BITFIELD(v)
                   -&gt; EXP TOP</programlisting>

        <para>
          The value delivered by <emphasis>arg3</emphasis> is assigned at a
          displacement given by <emphasis>arg2</emphasis> from the pointer
          delivered by <emphasis>arg1</emphasis>.The assignment will be carried
          out as specified by the <code>TRANSFER_MODE</code> (q.v.).
        </para>

        <para>
          If <emphasis>md</emphasis> consists of
          <emphasis>standard_transfer_mode</emphasis> only, then
          <emphasis>bitfield_assign_with_mode</emphasis> is the same as
          <emphasis>bitfield_assign</emphasis>.
        </para>

        <para>
          <emphasis>arg2</emphasis>,
          <code>BITFIELD</code>(<emphasis>v</emphasis>) will be
          <emphasis>variety-enclosed</emphasis>.(see <!-- TODO link to
          7.24. Representing bitfields -->section 7.24<!-- link end -->).
        </para>
      </section>

      <section id="S22S12">
        <title>bitfield_contents</title>

        <emphasis role="bold">Encoding number</emphasis>: 12

        <programlisting>
        v:               BITFIELD_VARIETY
        arg1:            EXP POINTER(x)
        arg2:            EXP OFFSET(y, z)
                   -&gt; EXP BITFIELD(v)</programlisting>

        <para>
          The bitfield of <code>BITFIELD_VARIETY</code> <emphasis>v</emphasis>,
          located at the displacement delivered by <emphasis>arg2</emphasis>
          from the pointer delivered by <emphasis>arg1</emphasis> is extracted
          and delivered.
        </para>

        <para>
          <emphasis>x</emphasis> will include <emphasis>y</emphasis> and
          <emphasis>z</emphasis> will include <emphasis>v</emphasis>.
        </para>

        <para>
          <emphasis>arg2</emphasis>,
          <code>BITFIELD</code>(<emphasis>v</emphasis>) will be
          <emphasis>variety_enclosed</emphasis> (see <!-- TODO link to 7.24.
          Representing bitfields -->section 7.24<!-- end link -->).
        </para>
      </section>

      <section id="S22S13">
        <title>bitfield_contents_with_mode</title>

        <emphasis role="bold">Encoding number</emphasis>: 13

        <programlisting>
        md:              TRANSFER_MODE
        v:               BITFIELD_VARIETY
        arg1:            EXP POINTER(x)
        arg2:            EXP OFFSET(y, z)
                   -&gt; EXP BITFIELD(v)</programlisting>

        <para>
          The bitfield of <code>BITFIELD_VARIETY </code><emphasis>v</emphasis>,
          located at the displacement delivered by <emphasis>arg2</emphasis>
          from the pointer delivered by <emphasis>arg1</emphasis> is extracted
          and delivered.The operation will be carried out as specified by the
          <code>TRANSFER_MODE</code> (q.v.).
        </para>

        <para>
          If <emphasis>md</emphasis> consists of
          <emphasis>standard_transfer_mode</emphasis> only, then
          <emphasis>bitfield_contents_with_mode</emphasis> is the same as
          <emphasis>bitfield_contents</emphasis>.
        </para>

        <para>
          <emphasis>x</emphasis> will include <emphasis>y</emphasis> and
          <emphasis>z</emphasis> will include <emphasis>v</emphasis>.
        </para>

        <para>
          <emphasis>arg2</emphasis>,
          <code>BITFIELD</code>(<emphasis>v</emphasis>) will be
          <emphasis>variety_enclosed</emphasis> (see <!-- TODO link to 7.24.
          Representing bitfields -->section 7.24<!-- end link -->).
        </para>
      </section>

      <section id="S22S14">
        <title>case</title>

        <emphasis role="bold">Encoding number</emphasis>: 14

        <programlisting>
        exhaustive:      BOOL
        control: EXP INTEGER(v)
        branches:        LIST(CASELIM)
                   -&gt; EXP (exhaustive ? BOTTOM : TOP)</programlisting>

        <para>
          <emphasis>control</emphasis> is evaluated to produce an integer value,
          <emphasis>c</emphasis>.  Then <emphasis>c</emphasis> is tested to see
          if it lies inclusively between <emphasis>lower</emphasis> and
          <emphasis>upper</emphasis>, for each element of
          <emphasis>branches</emphasis>. If this tests succeeds, control passes
          to the label <emphasis>branch</emphasis> belonging to that
          <code>CASELIM</code> (see <!-- TODO link to 5.13. CASELIM -->section
          5.13<!-- end link -->). If <emphasis>c</emphasis> lies between no
          pair, the construct delivers a value of <code>SHAPE TOP</code>. The
          order in which the comparisons are made is undefined.
        </para>

        <para>
          The sets of <code>SIGNED_NAT</code>s in <emphasis>branches</emphasis>
          will be disjoint.
        </para>

        <para>
          If <emphasis>exhaustive</emphasis> is true the value delivered by
          <emphasis>control</emphasis> will lie between one of the
          <emphasis>lower</emphasis>/<emphasis>upper</emphasis> pairs.
        </para>
      </section>

      <section id="S22S15">
        <title>change_bitfield_to_int</title>

        <emphasis role="bold">Encoding number</emphasis>: 15

        <programlisting>
        v:               VARIETY
        arg1:            EXP BITFIELD(bv)
                   -&gt; EXP INTEGER(v)</programlisting>

        <para>
          <emphasis>arg1</emphasis> is evaluated and converted to a
          <code>INTEGER</code>(<emphasis>v</emphasis>).
        </para>

        <para>
          If <emphasis>arg1</emphasis> exceed the bounds of
          <emphasis>v</emphasis>, the effect is undefined.
        </para>
      </section>

      <section id="S22S16">
        <title>change_floating_variety</title>

        <emphasis role="bold">Encoding number</emphasis>: 16

        <programlisting>
        flpt_err:        ERROR_TREATMENT
        r:               FLOATING_VARIETY
        arg1:            EXP FLOATING(f)
                   -&gt; EXP FLOATING(r)</programlisting>

        <para>
          <emphasis>arg1</emphasis> is evaluated and will produce floating point
          value, <emphasis>fp</emphasis>.  The value <emphasis>fp</emphasis> is
          delivered, changed to the representation of the
          <code>FLOATING_VARIETY</code> <emphasis>r</emphasis>.
        </para>

        <para>
          Either <emphasis>r</emphasis> and <emphasis>f</emphasis> will both real or both complex.
        </para>

        <para>
          If there is a floating point error it is handled by
          <emphasis>flpt_err</emphasis>.
        </para>

        <para>
          See <!-- TODO link to 7.21. Floating point errors -->Floating point
          errors<!-- end link -->.
        </para>
      </section>

      <section id="S22S17">
        <title>change_variety</title>

        <emphasis role="bold">Encoding number</emphasis>: 17

        <programlisting>
        ov_err:          ERROR_TREATMENT
        r:               VARIETY
        arg1:            EXP INTEGER(v)
                   -&gt; EXP INTEGER(r)</programlisting>

        <para>
          <emphasis>arg1</emphasis> is evaluated and will produce an integer
          value, <emphasis>a</emphasis>.  The value <emphasis>a</emphasis> is
          delivered, changed to the representation of the <code>VARIETY</code>
          <emphasis>r</emphasis>.
        </para>

        <para>
          If <emphasis>a</emphasis> is not contained in the <code>VARIETY</code>
          being used to represent <emphasis>r</emphasis>, an overflow occurs and
          is handled according to <emphasis>ov_err</emphasis>.
        </para>
      </section>

      <section id="S22S18">
        <title>change_int_to_bitfield</title>

        <emphasis role="bold">Encoding number</emphasis>: 18

        <programlisting>
        bv:              BITFIELD_VARIETY
        arg1:            EXP INTEGER(v)
                   -&gt; EXP BITFIELD(bv)</programlisting>

        <para>
          <emphasis>arg1</emphasis> is evaluated and converted to a
          <code>BITFIELD</code>(<emphasis>bv</emphasis>).
        </para>

        <para>
          If <emphasis>arg1</emphasis> exceed the bounds of
          <emphasis>bv</emphasis>, the effect is undefined.
        </para>
      </section>

      <section id="S22S19">
        <title>complex_conjugate</title>

        <emphasis role="bold">Encoding number</emphasis>: 19

        <programlisting>
        c:               EXP FLOATING(cv)
                   -&gt; EXP FLOATING(cv)</programlisting>

        <para>
          Delivers the complex conjugate of <emphasis>c</emphasis>.
        </para>

        <para>
          <emphasis>cv</emphasis> will be a complex floating variety.
        </para>
      </section>

      <section id="S22S20">
        <title>component</title>

        <emphasis role="bold">Encoding number</emphasis>: 20

        <programlisting>
        sha:             SHAPE
        arg1:            EXP COMPOUND(EXP OFFSET(x, y))
        arg2:            EXP OFFSET(x, alignment(sha))
                   -&gt; EXP sha</programlisting>

        <para>
          <emphasis>arg1</emphasis> is evaluated to produce a
          <code>COMPOUND</code> value.  The component of this value at the
          <code>OFFSET</code> given by <emphasis>arg2</emphasis> is delivered.
          This will have <code>SHAPE</code> <emphasis>sha</emphasis>.
        </para>

        <para>
          <emphasis>arg2</emphasis> will be a constant and non-negative (see
          <!-- TODO link to 7.3. Constant evaluation -->Constant evaluation<!--
          end link -->).
        </para>

        <para>
          If <emphasis>sha</emphasis> is a <code>BITFIELD</code> then
          <emphasis>arg2</emphasis>, <emphasis>sha</emphasis> will be
          <emphasis>variety_enclosed</emphasis> (see <!-- TODO link to
          7.24. Representing bitfields -->section 7.24<!-- end link -->).
        </para>
      </section>

      <section id="S22S21">
        <title>concat_nof</title>

        <emphasis role="bold">Encoding number</emphasis>: 21

        <programlisting>
        arg1:            EXP NOF(n, s)
        arg2:            EXP NOF(m, s)
                   -&gt; EXP NOF(n+m, s)</programlisting>

        <para>
          <emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated
          and their results concatenated.  In the result the components derived
          from <emphasis>arg1</emphasis> will have lower indices than those
          derived from <emphasis>arg2</emphasis>.
        </para>
      </section>

      <section id="S22S22">
        <title>conditional</title>

        <emphasis role="bold">Encoding number</emphasis>: 22

        <programlisting>
        altlab_intro:    LABEL
        first:           EXP x
        alt:             EXP z
                   -&gt; EXP (x LUB z)</programlisting>

        <para>
          <emphasis>first</emphasis> is evaluated. If <emphasis>first</emphasis>
          produces a result, <emphasis>f</emphasis>, this value is delivered as
          the result of the whole construct, and <emphasis>alt</emphasis> is not
          evaluated.
        </para>

        <para>
          If <emphasis>goto</emphasis>(<emphasis>altlab_intro</emphasis>) or any
          other jump (including <emphasis>long_jump</emphasis>) to
          <emphasis>altlab_intro</emphasis> is obeyed during the evaluation of
          <emphasis>first</emphasis>, then the evaluation of
          <emphasis>first</emphasis> will stop, <emphasis>alt</emphasis> will be
          evaluated and its result delivered as the result of the construction.
        </para>

        <para>
          The lifetime of <emphasis>altlab_intro</emphasis> is the evaluation of
          <emphasis>first</emphasis>.  <emphasis>altlab_intro</emphasis> will
          not be used within <emphasis>alt</emphasis>.
        </para>

        <para>
          The actual order of evaluation of the constituents shall be
          indistinguishable in all observable effects (apart from time) from
          evaluating all the obeyed parts of <emphasis>first</emphasis> before
          any obeyed part of <emphasis>alt</emphasis>.  Note that this
          specifically includes any defined error handling.
        </para>

        <para>
          For LUB see <!-- TODO link to 7.26. Least Upper Bound -->Least Upper
          Bound<!-- link end -->.
        </para>
      </section>

      <section id="S22S23">
        <title>contents</title>

        <emphasis role="bold">Encoding number</emphasis>: 23

        <programlisting>
        s:               SHAPE
        arg1:            EXP POINTER(x)
                   -&gt; EXP s</programlisting>

        <para>
          A value of <code>SHAPE</code> <emphasis>s</emphasis> will be extracted
          from the start of the space indicated by the pointer, and this is
          delivered.
        </para>

        <para>
          <emphasis>x</emphasis> will include
          <emphasis>alignment</emphasis>(<emphasis>s</emphasis>).
        </para>

        <para>
          <emphasis>s</emphasis> will not be a <code>BITFIELD</code>.
        </para>

        <para>
          If the space which the pointer indicates does not lie wholly within
          the space indicated by the original pointer from which it is derived,
          the effect is undefined.
        </para>

        <para>
          If the value delivered by <emphasis>arg1</emphasis> is a null pointer
          the effect is undefined.
        </para>

        <para>
          <emphasis>The constraint <quote>x will include alignment(s)</quote>
          ensures in the simple memory model that no change is needed to the
          <code>POINTER</code>.
          </emphasis>
        </para>
      </section>

      <section id="S22S24">
        <title>contents_with_mode</title>

        <emphasis role="bold">Encoding number</emphasis>: 24

        <programlisting>
        md:              TRANSFER_MODE
        s:               SHAPE
        arg1:            EXP POINTER(x)
                   -&gt; EXP s</programlisting>

        <para>
          A value of <code>SHAPE</code> <emphasis>s</emphasis> will be extracted from the
          start of the space indicated by the pointer, and this is delivered.
          The operation will be carried out as specified by the
          <code>TRANSFER_MODE</code> (q.v.).
        </para>

        <para>
          If <emphasis>md</emphasis> consists of
          <emphasis>standard_transfer_mode</emphasis> only, then
          <emphasis>contents_with_mode</emphasis> is the same as
          <emphasis>contents</emphasis>.
        </para>

        <para>
          <emphasis>x</emphasis> will include
          <emphasis>alignment</emphasis>(<emphasis>s</emphasis>).
        </para>

        <para>
          <emphasis>s</emphasis> will not be a <code>BITFIELD</code>.
        </para>

        <para>
          If the space which the pointer indicates does not lie wholly within
          the space indicated by the original pointer from which it is derived,
          the effect is undefined.
        </para>

        <para>
          If the value delivered by <emphasis>arg1</emphasis> is a null pointer
          the effect is undefined.
        </para>
      </section>

      <section id="S22S25">
        <title>current_env</title>

        <emphasis role="bold">Encoding number</emphasis>: 25

        <programlisting>
                   -&gt; EXP POINTER(fa)</programlisting>

        <para>
          A value of <code>SHAPE POINTER</code>(<emphasis>fa</emphasis>) is
          created and delivered.  It gives access to the variables, identities
          and parameters in the current procedure activation which are declared
          as having <code>ACCESS</code> <emphasis>visible</emphasis>.
        </para>

        <para>
          If the immediately enclosing procedure is defined by
          <emphasis>make_general_proc</emphasis>, then <emphasis>fa</emphasis>
          is the set union of <emphasis>local_alignment</emphasis> and the
          alignments of the kinds of parameters defined. That is to say, if
          there are caller parameters, then the alignment includes
          <emphasis>callers_alignment</emphasis>(<emphasis>x</emphasis>) where
          <emphasis>x</emphasis> is true if and only if the
          <code>PROCPROPS</code> <emphasis>var_callers</emphasis> is present; if
          there are callee parameters, the alignment includes
          <emphasis>callees_alignment</emphasis>(<emphasis>x</emphasis>) where
          <emphasis>x</emphasis> is true if and only if the
          <code>PROCPROPS</code> <emphasis>var_callees</emphasis> is present.
        </para>

        <para>
          If the immediately enclosing procedure is defined by
          <emphasis>make_proc</emphasis>, then <emphasis>fa</emphasis> = {
          <emphasis>locals_alignment</emphasis>,
          <emphasis>callers_alignment</emphasis>(<emphasis>false</emphasis>) }.
        </para>

        <para>
          If an <code>OFFSET</code> produced by <emphasis>env_offset</emphasis>
          is added to a <code>POINTER</code> produced by
          <emphasis>current_env</emphasis> from an activation of the procedure
          which contains the declaration of the <code>TAG</code> used by
          <emphasis>env_offset</emphasis>, then the result is an original
          <code>POINTER</code>, notwithstanding the normal rules for
          <emphasis>add_to_ptr</emphasis> (see <!-- TODO link to 7.15. Original
          pointers -->Original pointers<!-- link end -->).
        </para>

        <para>
          If an <code>OFFSET</code> produced by env_offset is added to
          such a pointer from an inappropriate procedure the effect is
          undefined.
        </para>
      </section>

      <section id="S22S26">
        <title>div0</title>

        <emphasis role="bold">Encoding number</emphasis>: 26

        <programlisting>
        div_by_0_err:    ERROR_TREATMENT
        ov_err:          ERROR_TREATMENT
        arg1:            EXP INTEGER(v)
        arg2:            EXP INTEGER(v)
                   -&gt; EXP INTEGER(v)</programlisting>

        <para>
          <emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated
          and will produce integer values, <emphasis>a</emphasis> and
          <emphasis>b</emphasis>, of the same <code>VARIETY</code>,
          <emphasis>v</emphasis>.  Either the value <emphasis>a</emphasis> D1
          <emphasis>b</emphasis> or the value <emphasis>a</emphasis> D2
          <emphasis>b</emphasis> is delivered as the result of the construct,
          with the same <code>SHAPE</code> as the arguments. Different
          occurrences of <emphasis>div0</emphasis> in the same capsule can use
          D1 or D2 independently.
        </para>

        <para>
          If <emphasis>b</emphasis> is zero a div_by_zero error occurs and is
          handled by <emphasis>div_by_0_err</emphasis>.
        </para>

        <para>
          If <emphasis>b</emphasis> is not zero and the result cannot be
          expressed in the <code>VARIETY</code> being used to represent
          <emphasis>v</emphasis> an overflow occurs and is handled by
          <emphasis>ov_err</emphasis>.
        </para>

        <para>
          Producers may assume that shifting and <emphasis>div0</emphasis> by a
          constant which is a power of two yield equally good code.
        </para>

        <para>
          See <!-- TODO link to 7.4. Division and modulus -->Division and
          modulus<!-- end link --> for the definitions of D1, D2, M1 and M2.
        </para>
      </section>

      <section id="S22S27">
        <title>div1</title>

        <emphasis role="bold">Encoding number</emphasis>: 27

        <programlisting>
        div_by_0_err:    ERROR_TREATMENT
        ov_err:          ERROR_TREATMENT
        arg1:            EXP INTEGER(v)
        arg2:            EXP INTEGER(v)
                   -&gt; EXP INTEGER(v)</programlisting>

        <para>
          <emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated
          and will produce integer values, <emphasis>a</emphasis> and
          <emphasis>b</emphasis>, of the same <code>VARIETY</code>,
          <emphasis>v</emphasis>.  The value <emphasis>a</emphasis> D1
          <emphasis>b</emphasis> is delivered as the result of the construct,
          with the same <code>SHAPE</code> as the arguments.
        </para>

        <para>
          If <emphasis>b</emphasis> is zero a div_by_zero error occurs and is
          handled by <emphasis>div_by_0_err</emphasis>.
        </para>

        <para>
          If <emphasis>b</emphasis> is not zero and the result cannot be
          expressed in the <code>VARIETY</code> being used to represent
          <emphasis>v</emphasis> an overflow occurs and is handled by
          <emphasis>ov_err</emphasis>.
        </para>

        <para>
          Producers may assume that shifting and <emphasis>div1</emphasis> by a
          constant which is a power of two yield equally good code.
        </para>

        <para>
          See <!-- TODO link to 7.4. Division and modulus -->Division and
          modulus<!-- end link --> for the definitions of D1, D2, M1 and M2.
        </para>
      </section>

      <section id="S22S28">
        <title>div2</title>

        <emphasis role="bold">Encoding number</emphasis>: 28

        <programlisting>
        div_by_0_err:    ERROR_TREATMENT
        ov_err:          ERROR_TREATMENT
        arg1:            EXP INTEGER(v)
        arg2:            EXP INTEGER(v)
                   -&gt; EXP INTEGER(v)</programlisting>

        <para>
          <emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated
          and will produce integer values, <emphasis>a</emphasis> and
          <emphasis>b</emphasis>, of the same <code>VARIETY</code>,
          <emphasis>v</emphasis>.  The value <emphasis>a</emphasis> D2
          <emphasis>b</emphasis> is delivered as the result of the construct,
          with the same <code>SHAPE</code> as the arguments.
        </para>

        <para>
          If <emphasis>b</emphasis> is zero a div_by_zero error occurs and is
          handled by <emphasis>div_by_0_err</emphasis>.
        </para>

        <para>
          If <emphasis>b</emphasis> is not zero and the result cannot be
          expressed in the <code>VARIETY</code> being used to represent
          <emphasis>v</emphasis> an overflow occurs and is handled by
          <emphasis>ov_err</emphasis>.
        </para>

        <para>
          Producers may assume that shifting and <emphasis>div2</emphasis> by a
          constant which is a power of two yield equally good code if the lower
          bound of <emphasis>v</emphasis> is zero.
        </para>

        <para>
          See <!-- TODO link to 7.4. Division and modulus -->Division and
          modulus<!-- end link --> for the definitions of D1, D2, M1 and M2.
        </para>
      </section>

      <section id="S22S29">
        <title>env_offset</title>

        <emphasis role="bold">Encoding number</emphasis>: 29

        <programlisting>
        fa:              ALIGNMENT
        y:               ALIGNMENT
        t:               TAG x
                   -&gt; EXP OFFSET(fa, y)</programlisting>

        <para>
          <emphasis>t</emphasis> will be the tag of a
          <emphasis>variable</emphasis>, <emphasis>identify</emphasis> or
          procedure parameter with the <emphasis>visible</emphasis> property
          within a procedure defined by <emphasis>make_general_proc</emphasis>
          or <emphasis>make_proc</emphasis>.
        </para>
        
        <para>
          If it is defined in a make_general_proc, let P be its associated
          <code>PROCPROPS</code>; otherwise let P be the <code>PROCPROPS</code>
          {<emphasis>locals_alignment</emphasis>,
          <emphasis>caller_alignment</emphasis>(<emphasis>false</emphasis>)}.
        </para>

        <para>
          If <emphasis>t</emphasis> is the <code>TAG</code> of a
          <emphasis>variable</emphasis> or <emphasis>identify, fa</emphasis>
          will contain <emphasis>locals_alignment</emphasis>; if it is a caller
          parameter <emphasis>fa</emphasis> will contain a
          <emphasis>caller_alignment</emphasis>(<emphasis>b</emphasis>) where
          <emphasis>b </emphasis>is true if and only if P contains
          <emphasis>var_callers</emphasis> ; if it is a callee parameter
          <emphasis>fa</emphasis> will contain a
          <emphasis>callee_alignment</emphasis>(<emphasis>b</emphasis>) where
          <emphasis>b</emphasis> is true if and only if P contains
          <emphasis>var_callees</emphasis>.
        </para>

        <para>
          If t is the <code>TAG</code> of a <emphasis>variable</emphasis> or
          parameter, the result is the <code>OFFSET</code> of its position,
          within any procedure environment which derives from the procedure
          containing the declaration of the variable or parameter, relative to
          its environment pointer. In this case <emphasis>x</emphasis> will be
          <code>POINTER</code>(<emphasis>y).</emphasis>
        </para>

        <para>
          If t is the <code>TAG</code> of an <emphasis>identify</emphasis>, the
          result will be an <code>OFFSET</code> of space which holds the value.
          This pointer will not be used to alter the value. In this case
          <emphasis>y</emphasis> will be
          <emphasis>alignment</emphasis>(<emphasis>x</emphasis>).
        </para>

        <para>
          See <!-- TODO link to 7.10. Frames -->section 7.10<!-- link end -->.
        </para>
      </section>

      <section id="S22S30">
        <title>env_size</title>

        <emphasis role="bold">Encoding number</emphasis>: 30

        <programlisting>
        proctag: TAG PROC
                   -&gt; EXP OFFSET(locals_alignment, {})</programlisting>

        <para>
          Delivers an <code>OFFSET</code> of a space sufficient to contain all
          the variables and identifications, explicit or implicit in the
          procedure identified by <emphasis>proctag</emphasis>. This will not
          include the space required for any <emphasis>local_allocs</emphasis>
          or procedure calls within the procedure.
        </para>

        <para>
          <emphasis>proctag</emphasis> will be defined in the current
          <code>CAPSULE</code> by a <code>TAGDEF</code> identification of a
          <emphasis>make_proc</emphasis> or a
          <emphasis>make_general_proc</emphasis>.
        </para>
      </section>

      <section id="S22S31">
        <title>fail_installer</title>

        <emphasis role="bold">Encoding number</emphasis>: 31

        <programlisting>
        message: STRING(k, n)
                   -&gt; EXP BOTTOM</programlisting>

        <para>
          Any attempt to use this operation to produce code will result in a
          failure of the installation process. <emphasis>message</emphasis> will
          give information about the reason for this failure which should be
          passed to the installation manager.
        </para>
      </section>

      <section id="S22S32">
        <title>float_int</title>

        <emphasis role="bold">Encoding number</emphasis>: 32

        <programlisting>
        flpt_err:        ERROR_TREATMENT
        f:               FLOATING_VARIETY
        arg1:            EXP INTEGER(v)
                   -&gt; EXP FLOATING(f)</programlisting>

        <para>
          <emphasis>arg1</emphasis> is evaluated to produce an integer value,
          which is converted to the representation of <emphasis>f</emphasis> and
          delivered.
        </para>

        <para>
          If <emphasis>f</emphasis> is complex the real part of the result will
          be derived from <emphasis>arg1</emphasis> and the imaginary part will
          be zero.
        </para>

        <para>
          If there is a floating point error it is handled by
          <emphasis>flpt_err</emphasis>.  See <!-- TODO link to 7.21. Floating
          point errors -->Floating point errors<!-- link end -->.
        </para>
      </section>

      <section id="S22S33">
        <title>floating_abs</title>

        <emphasis role="bold">Encoding number</emphasis>: 33

        <programlisting>
        flpt_err:        ERROR_TREATMENT
        arg1:            EXP FLOATING(f)
                   -&gt; EXP FLOATING(f)</programlisting>

        <para>
          <emphasis>arg1</emphasis> is evaluated and will produce a floating
          point value, <emphasis>a</emphasis>, of the
          <code>FLOATING_VARIETY</code>, <emphasis>f</emphasis>. The absolute
          value of <emphasis>a</emphasis> is delivered as the result of the
          construct, with the same <code>SHAPE</code> as the argument.
        </para>

        <para>
          Though <emphasis>floating_abs</emphasis> cannot produce an overflow it
          can give an invalid operand exception which is handled by
          <emphasis>flpt_err</emphasis>.
        </para>

        <para>
          <emphasis>f</emphasis> will not be complex.
        </para>

        <para>
          See also <!-- TODO link to 7.23. Floating point accuracy -->Floating
          point accuracy<!-- link end -->.
        </para>
      </section>

      <section id="S22S34">
        <title>floating_div</title>

        <emphasis role="bold">Encoding number</emphasis>: 34

        <programlisting>
        flpt_err:        ERROR_TREATMENT
        arg1:            EXP FLOATING(f)
        arg2:            EXP FLOATING(f)
                   -&gt; EXP FLOATING(f)</programlisting>

        <para>
          <emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated
          and will produce floating point values, <emphasis>a</emphasis> and
          <emphasis>b</emphasis>, of the same <code>FLOATING_VARIETY</code>,
          <emphasis>f</emphasis>. The value
          <emphasis>a</emphasis>/<emphasis>b</emphasis> is delivered as the
          result of the construct, with the same <code>SHAPE</code> as the
          arguments.
        </para>

        <para>
          If there is a floating point error it is handled by
          <emphasis>flpt_err</emphasis>. See <!-- TODO link to 7.21. Floating
          point errors -->Floating point errors<!-- end link -->.
        </para>

        <para>
          See also <!-- TODO link to 7.23. Floating point accuracy -->Floating
          point accuracy<!-- end link -->.
        </para>
      </section>

      <section id="S22S35">
        <title>floating_minus</title>

        <emphasis role="bold">Encoding number</emphasis>: 35

        <programlisting>
        flpt_err:        ERROR_TREATMENT
        arg1:            EXP FLOATING(f)
        arg2:            EXP FLOATING(f)
                   -&gt; EXP FLOATING(f)</programlisting>

        <para>
          <emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated
          and will produce floating point values, <emphasis>a</emphasis> and
          <emphasis>b</emphasis>, of the same <code>FLOATING_VARIETY</code>,
          <emphasis>f</emphasis>. The value
          <emphasis>a</emphasis>-<emphasis>b</emphasis> is delivered as the
          result of the construct, with the same <code>SHAPE</code> as the
          arguments.
        </para>

        <para>
          If there is a floating point error it is handled by
          <emphasis>flpt_err</emphasis>. See <!-- TODO link to 7.21. Floating
          point errors -->Floating point errors<!-- end link -->.
        </para>

        <para>
          See also <!-- TODO link to 7.23. Floating point accuracy -->Floating
          point accuracy<!-- end link -->.
        </para>
      </section>

      <section id="S22S36">
        <title>floating_maximum</title>

        <emphasis role="bold">Encoding number</emphasis>: 36

        <programlisting>
        flpt_err:        ERROR_TREATMENT
        arg1:            EXP FLOATING(f)
        arg2:            EXP FLOATING(f)
                   -&gt; EXP FLOATING(f)</programlisting>

        <para>
          The maximum of the values delivered by <emphasis>arg1</emphasis> and
          <emphasis>arg2</emphasis> is the result. <emphasis>f</emphasis> will
          not be complex.
        </para>

        <para>
          If <emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are
          incomparable, <emphasis>flpt_err</emphasis> will be invoked.
        </para>

        <para>
          See also <!-- TODO link to 7.23. Floating point accuracy -->Floating
          point accuracy<!-- end link -->.
        </para>
      </section>

      <section id="S22S37">
        <title>floating_minimum</title>

        <emphasis role="bold">Encoding number</emphasis>: 37

        <programlisting>
        flpt_err:        ERROR_TREATMENT
        arg1:            EXP FLOATING(f)
        arg2:            EXP FLOATING(f)
                   -&gt; EXP FLOATING(f)</programlisting>

        <para>
          The minimum of the values delivered by <emphasis>arg1</emphasis> and
          <emphasis>arg2</emphasis> is the result. <emphasis>f</emphasis> will
          not be complex.
        </para>

        <para>
          If <emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are
          incomparable, <emphasis>flpt_err</emphasis> will be invoked.
        </para>

        <para>
          See also <!-- TODO link to 7.23. Floating point accuracy -->Floating
          point accuracy<!-- end link -->.
        </para>
      </section>

      <section id="S22S38">
        <title>floating_mult</title>

        <emphasis role="bold">Encoding number</emphasis>: 38

        <programlisting>
        flpt_err:        ERROR_TREATMENT
        arg1:            LIST(EXP)
                   -&gt; EXP FLOATING(f)</programlisting>

        <para>
          The arguments, <emphasis>arg1</emphasis>, are evaluated producing
          floating point values all of the same <code>FLOATING_VARIETY</code>,
          <emphasis>f</emphasis>. These values are multiplied in any order and
          the result of this multiplication is delivered as the result of the
          construct, with the same <code>SHAPE</code> as the arguments.
        </para>

        <para>
          If there is a floating point error it is handled by
          <emphasis>flpt_err</emphasis>. See <!-- TODO link to 7.21. Floating
          point errors -->Floating point errors<!-- link end -->.
        </para>

        <para>
          <emphasis>Note that separate floating_mult operations cannot in
          general be combined, because rounding errors need to be controlled.
          The reason for allowing floating_mult to take a variable number of
          arguments is to make it possible to specify that a number of
          multiplications can be re-ordered.</emphasis>
        </para>

        <para>
          If <emphasis>arg1</emphasis> contains one element the result is the
          value of that element. There will be at least one element in
          <emphasis>arg1</emphasis>.
        </para>

        <para>
          See also <!-- TODO link to 7.23. Floating point accuracy -->Floating
          point accuracy<!-- end link -->.
        </para>
      </section>

      <section id="S22S39">
        <title>floating_negate</title>

        <emphasis role="bold">Encoding number</emphasis>: 39

        <programlisting>
        flpt_err:        ERROR_TREATMENT
        arg1:            EXP FLOATING(f)
                   -&gt; EXP FLOATING(f)</programlisting>

        <para>
          <emphasis>arg1</emphasis> is evaluated and will produce a floating
          point value, <emphasis>a</emphasis>, of the
          <code>FLOATING_VARIETY</code>, <emphasis>f</emphasis>. The value
          -<emphasis>a</emphasis> is delivered as the result of the construct,
          with the same <code>SHAPE</code> as the argument.
        </para>

        <para>
          Though <emphasis>floating_negate</emphasis> cannot produce an overflow
          it can give an invalid operand exception which is handled by
          <emphasis>flpt_err</emphasis>.
        </para>

        <para>
          See also <!-- TODO link to 7.23. Floating point accuracy -->Floating
          point accuracy<!-- end link -->.
        </para>
      </section>

      <section id="S22S40">
        <title>floating_plus</title>

        <emphasis role="bold">Encoding number</emphasis>: 40

        <programlisting>
        flpt_err:        ERROR_TREATMENT
        arg1:            LIST(EXP)
                   -&gt; EXP FLOATING(f)</programlisting>

        <para>
          The arguments, <emphasis>arg1</emphasis>, are evaluated producing
          floating point values, all of the same <code>FLOATING_VARIETY</code>,
          <emphasis>f</emphasis>. These values are added in any order and the
          result of this addition is delivered as the result of the construct,
          with the same <code>SHAPE</code> as the arguments.
        </para>

        <para>
          If there is a floating point error it is handled by
          <emphasis>flpt_err</emphasis>.  See <!-- TODO link to 7.21. Floating
          point errors -->Floating point errors<!-- link end -->.
        </para>

        <para>
          <emphasis>Note that separate floating_plus operations cannot in
          general be combined, because rounding errors need to be controlled.
          The reason for allowing floating_plus to take a variable number of
          arguments is to make it possible to specify that a number of
          multiplications can be re-ordered.</emphasis>
        </para>

        <para>
          If <emphasis>arg1</emphasis> contains one element the result is the
          value of that element. There will be at least one element in
          <emphasis>arg1</emphasis>.
        </para>

        <para>
          See also <!-- TODO link to 7.23. Floating point accuracy -->Floating
          point accuracy<!-- end link -->.
        </para>
      </section>

      <section id="S22S41">
        <title>floating_power</title>

        <emphasis role="bold">Encoding number</emphasis>: 41

        <programlisting>
        flpt_err:        ERROR_TREATMENT
        arg1:            EXP FLOATING(f)
        arg2:            EXP INTEGER(v)
                   -&gt; EXP FLOATING(f)</programlisting>

        <para>
          The result of <emphasis>arg1</emphasis> is raised to the power given
          by <emphasis>arg2</emphasis>.
        </para>

        <para>
          If there is a floating point error it is handled by
          <emphasis>flpt_err</emphasis>.  See <!-- TODO link to 7.21. Floating
          point errors -->Floating point errors<!-- link end -->.
        </para>

        <para>
          See also <!-- TODO link to 7.23. Floating point accuracy -->Floating
          point accuracy<!-- end link -->.
        </para>
      </section>

      <section id="S22S42">
        <title>floating_test</title>

        <emphasis role="bold">Encoding number</emphasis>: 42

        <programlisting>
        prob:            OPTION(NAT)
        flpt_err:        ERROR_TREATMENT
        nt:              NTEST
        dest:            LABEL
        arg1:            EXP FLOATING(f)
        arg2:            EXP FLOATING(f)
                   -&gt; EXP TOP</programlisting>

        <para>
          <emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated
          and will produce floating point values, <emphasis>a</emphasis> and
          <emphasis>b</emphasis>, of the same <code>FLOATING_VARIETY</code>,
          <emphasis>f</emphasis>. These values are compared using
          <emphasis>nt</emphasis>.
        </para>

        <para>
          If <emphasis>f</emphasis> is complex then <emphasis>nt</emphasis> will
          be <emphasis>equal</emphasis> or <emphasis>not_equal</emphasis>.
        </para>

        <para>
          If <emphasis>a nt b</emphasis>, this construction yields
          <code>TOP</code>. Otherwise control passes to
          <emphasis>dest</emphasis>.
        </para>

        <para>
          If <emphasis>prob</emphasis> is present<emphasis>, prob</emphasis>/100
          gives the probability that control will continue to the next construct
          (ie. not pass to <emphasis>dest</emphasis>).  If
          <emphasis>prob</emphasis> is absent this probability is unknown.
        </para>

        <para>
          If there is a floating point error it is handled by
          <emphasis>flpt_err</emphasis>.  See <!-- TODO link to 7.21. Floating
          point errors -->Floating point errors<!-- link end -->.
        </para>

        <para>
          See also <!-- TODO link to 7.23. Floating point accuracy -->Floating
          point accuracy<!-- end link -->.
        </para>
      </section>

      <section id="S22S43">
        <title>goto</title>

        <emphasis role="bold">Encoding number</emphasis>: 43

        <programlisting>
        dest:            LABEL
                   -&gt; EXP BOTTOM</programlisting>

        <para>
          Control passes to the <code>EXP</code> labelled
          <emphasis>dest</emphasis>. This construct will only be used where
          <emphasis>dest</emphasis> is in scope.
        </para>
      </section>

      <section id="S22S44">
        <title>goto_local_lv</title>

        <emphasis role="bold">Encoding number</emphasis>: 44

        <programlisting>
        arg1:            EXP POINTER({code})
                   -&gt; EXP BOTTOM</programlisting>

        <para>
          <emphasis>arg1</emphasis> is evaluated. The label from which the value
          delivered by <emphasis>arg1</emphasis> was created will be within its
          lifetime and this construction will be obeyed in the same activation
          of the same procedure as the creation of the
          <code>POINTER(</code><emphasis>{code</emphasis><code>})</code> by
          <emphasis>make_local_lv</emphasis>. Control passes to this activation
          of this <code>LABEL</code>.
        </para>

        <para>
          If <emphasis>arg1</emphasis> delivers a null <code>POINTER</code> the
          effect is undefined.
        </para>
      </section>

      <section id="S22S45">
        <title>identify</title>

        <emphasis role="bold">Encoding number</emphasis>: 45

        <programlisting>
        opt_access:      OPTION(ACCESS)
        name_intro:      TAG x
        definition:      EXP x
        body:            EXP y
                   -&gt; EXP y</programlisting>

        <para>
          <emphasis>definition</emphasis> is evaluated to produce a value,
          <emphasis>v</emphasis>. Then <emphasis>body</emphasis> is evaluated.
          During this evaluation, <emphasis>v</emphasis> is bound to
          <emphasis>name_intro</emphasis>. This means that inside
          <emphasis>body</emphasis> an evaluation of
          <emphasis>obtain_tag</emphasis>(<emphasis>name_intro</emphasis>) will
          produce the value, <emphasis>v</emphasis>.
        </para>

        <para>
          The value delivered by <emphasis>identify</emphasis> is that produced
          by <emphasis>body</emphasis>.
        </para>

        <para>
          The <code>TAG</code> given for <emphasis>name_intro</emphasis> will
          not be reused within the current <code>UNIT</code>. No rules for the
          hiding of one <code>TAG</code> by another are given: this will not
          happen. The lifetime of <emphasis>name_intro</emphasis> is the
          evaluation of <emphasis>body</emphasis>.
        </para>

        <para>
          If <emphasis>opt_access</emphasis> contains
          <emphasis>visible</emphasis>, it means that the value must not be
          aliased while the procedure containing this declaration is not the
          current procedure. Hence if there are any copies of this value they
          will need to be refreshed when the procedure is returned to. The
          easiest implementation when <emphasis>opt_access</emphasis> is
          <emphasis>visible</emphasis> may be to keep the value in memory, but
          this is not a necessary requirement.
        </para>

        <para>
          The order in which the constituents of <emphasis>definition</emphasis>
          and <emphasis>body</emphasis> are evaluated shall be indistinguishable
          in all observable effects (apart from time) from completely evaluating
          <emphasis>definition</emphasis> before starting
          <emphasis>body</emphasis>. See the note about order in <!-- TODO link
          to 5.16.107. sequence -->sequence<!-- end link -->.
        </para>
      </section>

      <section id="S22S46">
        <title>ignorable</title>

        <emphasis role="bold">Encoding number</emphasis>: 46

        <programlisting>
        arg1:            EXP x
                   -&gt; EXP x</programlisting>

        <para>
          If the result of this construction is discarded,
          <emphasis>arg1</emphasis> need not be evaluated, though evaluation is
          permitted. If the result is used it is the result of
          <emphasis>arg1</emphasis>.
        </para>
      </section>

      <section id="S22S47">
        <title>imaginary_part</title>

        <emphasis role="bold">Encoding number</emphasis>: 47

        <programlisting>
        arg1:            EXP c
                   -&gt; EXP FLOATING (float_of_complex(c))</programlisting>

        <para>
          <emphasis>c</emphasis> will be complex. Delivers the imaginary part of
          the value produced by <emphasis>arg1</emphasis>.
        </para>
      </section>

      <section id="S22S48">
        <title>initial_value</title>

        <emphasis role="bold">Encoding number</emphasis>: 48

        <programlisting>
        init:            EXP s
                   -&gt; EXP s</programlisting>

        <para>
          Any tag used as an argument of an <emphasis>obtain_tag</emphasis> in
          <emphasis>init</emphasis> will be global or defined within
          <emphasis>init</emphasis>.
        </para>

        <para>
          All labels used in <emphasis>init</emphasis> will be defined within
          <emphasis>init</emphasis>.
        </para>

        <para>
          <emphasis>init</emphasis> will be evaluated once only before any
          procedure application, other than those involved in this or other
          <emphasis>initial_value</emphasis> constructions, but after all
          load-time constant initialisations of TAGDEFs. The result of this
          evaluation is the value of the construction.
        </para>

        <para>
          The order of evaluation of the different
          <emphasis>initial_values</emphasis> in a program is undefined.
        </para>

        <para>
          See <!-- TODO link to 7.29. Dynamic initialisation -->section 7.29<!--
          end link -->.
        </para>
      </section>

      <section id="S22S49">
        <title>integer_test</title>

        <emphasis role="bold">Encoding number</emphasis>: 49

        <programlisting>
        prob:            OPTION(NAT)
        nt:              NTEST
        dest:            LABEL
        arg1:            EXP INTEGER(v)
        arg2:            EXP INTEGER(v)
                   -&gt; EXP TOP</programlisting>

        <para>
          <emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated
          and will produce integer values, <emphasis>a</emphasis> and
          <emphasis>b</emphasis>, of the same <code>VARIETY</code>,
          <emphasis>v</emphasis>.  These values are compared using
          <emphasis>nt</emphasis>.
        </para>

        <para>
          If <emphasis>a nt b</emphasis>, this construction yields
          <code>TOP</code>. Otherwise control passes to
          <emphasis>dest</emphasis>.
        </para>

        <para>
          If <emphasis>prob</emphasis> is present, <emphasis>prob</emphasis>/100
          gives the probability that control will continue to the next construct
          (ie. not pass to <emphasis>dest</emphasis>).  If
          <emphasis>prob</emphasis> is absent this probability is unknown.
        </para>
      </section>

      <section id="S22S50">
        <title>labelled</title>

        <emphasis role="bold">Encoding number</emphasis>: 50

        <programlisting>
        labs_intro:      LIST(LABEL)
        starter: EXP x
        places:          LIST(EXP)
                   -&gt; EXP w</programlisting>

        <para>
          The lists <emphasis>labs_intro</emphasis> and
          <emphasis>places</emphasis> shall have the same number of elements.
        </para>

        <para>
          To evaluate the construction <emphasis>starter</emphasis> is
          evaluated. If its evaluation runs to completion producing a value,
          then this is delivered as the result of the whole construction. If a
          <emphasis>goto</emphasis> one of the <code>LABEL</code>s in
          <emphasis>labs_intro</emphasis> or any other jump to one of these
          <code>LABEL</code>s is evaluated, then the evaluation of
          <emphasis>starter</emphasis> stops and the corresponding element of
          <emphasis>places</emphasis> is evaluated.  In the canonical ordering
          all the operations which are evaluated from
          <emphasis>starter</emphasis> are completed before any from an element
          of <emphasis>places</emphasis> is started. If the evaluation of the
          member of <emphasis>places</emphasis> produces a result this is the
          result of the construction.
        </para>

        <para>
          If a jump to any of the <emphasis>labs_intro</emphasis> is obeyed then
          evaluation continues similarly. Such jumping may continue
          indefinitely, but if any <emphasis>places</emphasis> terminates, then
          the value it produces is the value delivered by the construction.
        </para>

        <para>
          The <code>SHAPE</code> <emphasis>w</emphasis> is the LUB of
          <emphasis>x</emphasis> and all the <emphasis>places</emphasis>. See
          <!-- TODO link to 7.26. Least Upper Bound -->Least Upper Bound<!-- end
          link -->.
        </para>

        <para>
          The actual order of evaluation of the constituents shall be
          indistinguishable in all observable effects (apart from time) from
          that described above.  Note that this specifically includes any
          defined error handling.
        </para>

        <para>
          The lifetime of each of the <code>LABEL</code>s in
          <emphasis>labs_intro</emphasis>, is the evaluation of
          <emphasis>starter</emphasis> and all the elements of
          <emphasis>places</emphasis>.
        </para>
      </section>

      <section id="S22S51">
        <title>last_local</title>

        <emphasis role="bold">Encoding number</emphasis>: 51

        <programlisting>
        x:               EXP OFFSET(y, z)
                   -&gt; EXP POINTER(alloca_alignment)</programlisting>

        <para>
          If the last use of <emphasis>local_alloc</emphasis> in the current
          activation of the current procedure was after the last use of
          <emphasis>local_free</emphasis> or
          <emphasis>local_free_all</emphasis>, then the value returned is the
          last <code>POINTER</code> allocated with
          <emphasis>local_alloc</emphasis>.
        </para>

        <para>
          If the last use of <emphasis>local_free</emphasis> in the current
          activation of the current procedure was after the last use of
          <emphasis>local_alloc</emphasis>, then the result is the
          <code>POINTER</code> last allocated which is still active.
        </para>

        <para>
          The <code>ALIGNMENT</code>, <emphasis>alloca_alignment</emphasis>,
          includes the set union of all the <code>ALIGNMENT</code>s which can be
          produced by <emphasis>alignment</emphasis> from any
          <code>SHAPE</code>. See <!-- TODO link to 7.13.4. Special alignments
          -->Special alignments<!-- end link -->.
        </para>
      </section>

      <section id="S22S52">
        <title>local_alloc</title>

        <emphasis role="bold">Encoding number</emphasis>: 52

        <programlisting>
        arg1:            EXP OFFSET(x, y)
                   -&gt; EXP POINTER(alloca_alignment)</programlisting>

        <para>
          The <emphasis>arg1</emphasis> expression is evaluated and space is
          allocated sufficient to hold a value of the given size. The result is
          an original pointer to this space.
        </para>

        <para>
          <emphasis>x</emphasis> will not consist entirely of bitfield
          alignments.
        </para>

        <para>
          The initial contents of the space are not specified.
        </para>

        <para>
          This allocation is as if on the stack of the current procedure, and
          the lifetime of the pointer ends when the current activation of the
          current procedure ends with a <emphasis>return</emphasis>,
          <emphasis>return_to_label</emphasis> or <emphasis>tail_call</emphasis>
          or if there is a long jump out of the activation.  Any use of the
          pointer thereafter is undefined. Note the specific exclusion of the
          procedure ending with <emphasis>untidy_return</emphasis>; in this case
          the calling procedure becomes the current activation.
        </para>

        <para>
          The uses of <emphasis>local_alloc</emphasis> within the procedure are
          ordered dynamically as they occur, and this order affects the meaning
          of <emphasis>local_free</emphasis> and
          <emphasis>last_local</emphasis>.
        </para>

        <para>
          <emphasis>arg1</emphasis> may be a zero <code>OFFSET</code>. In this
          case suppose the result is <emphasis>p</emphasis>. Then a subsequent
          use, in the same activation of the procedure, of
        </para>

        <para>
          <emphasis>local_free</emphasis>(<emphasis>offset_zero</emphasis>(<emphasis>alloca_alignment</emphasis>),
          <emphasis>p</emphasis>)
        </para>

        <para>
          will return the <emphasis>alloca</emphasis> stack to the state it was
          in immediately before the use of <emphasis>local_alloc</emphasis>.
        </para>

        <para>
          Note that if a procedure which uses <emphasis>local_alloc</emphasis>
          is inlined, it may be necessary to use <emphasis>local_free</emphasis>
          to get the correct semantics.
        </para>

        <para>
          See also <!-- TODO link to 7.12. Alloca -->section 7.12<!-- end link
          -->.
        </para>
      </section>

      <section id="S22S53">
        <title>local_alloc_check</title>

        <emphasis role="bold">Encoding number</emphasis>: 53

        <programlisting>
        arg1:            EXP OFFSET(x, y)
                   -&gt; EXP POINTER(alloca_alignment)</programlisting>

        <para>
          If the <code>OFFSET</code> <emphasis>arg1</emphasis> can be
          accomodated within the limit of the local_alloc stack (see <!-- TODO
          link to 5.16.108. set_stack_limit -->section 5.16.108<!-- end link
          -->), the action is precisely the same as
          <emphasis>local_alloc</emphasis>.
        </para>

        <para>
          If not, normal action is stopped and a TDF exception is raised with
          ERROR_code <emphasis>stack_overflow</emphasis>.
        </para>
      </section>

      <section id="S22S54">
        <title>local_free</title>

        <emphasis role="bold">Encoding number</emphasis>: 54

        <programlisting>
        a:               EXP OFFSET(x, y)
        p:               EXP POINTER(alloca_alignment)
                   -&gt; EXP TOP</programlisting>

        <para>
          The <code>POINTER</code>, <emphasis>p</emphasis>, will be an original
          pointer to space allocated by <emphasis>local_alloc</emphasis> within
          the current call of the current procedure. It and all spaces allocated
          after it by <emphasis>local_alloc</emphasis> will no longer be used.
          This <code>POINTER</code> will have been created by
          <emphasis>local_alloc</emphasis> with the value of its
          <emphasis>arg1</emphasis> equal to the value of
          <emphasis>a</emphasis>.
        </para>

        <para>
          Any subsequent use of pointers to the spaces no longer used will be
          undefined.
        </para>
      </section>

      <section id="S22S55">
        <title>local_free_all</title>

        <emphasis role="bold">Encoding number</emphasis>: 55

        <programlisting>
                   -&gt; EXP TOP</programlisting>

        <para>
          Every space allocated by <emphasis>local_alloc</emphasis> within the
          current call of the current procedure will no longer be used.
        </para>

        <para>
          Any use of a pointer to space allocated before this operation within
          the current call of the current procedure is undefined.
        </para>

        <para>
          Note that if a procedure which uses
          <emphasis>local_free_all</emphasis> is inlined, it may be necessary to
          use <emphasis>local_free</emphasis> to get the correct semantics.
        </para>
      </section>

      <section id="S22S56">
        <title>long_jump</title>

        <emphasis role="bold">Encoding number</emphasis>: 56

        <programlisting>
        arg1:            EXP POINTER(fa)
        arg2:            EXP POINTER({code})
                   -&gt; EXP BOTTOM</programlisting>

        <para>
          <emphasis>arg1</emphasis> will be a pointer produced by an application of
          <emphasis>curent_env</emphasis> in a currently active procedure.
        </para>

        <para>
          The frame produced by <emphasis>arg1</emphasis> is reinstated as the
          current procedure. This frame will still be active. Evaluation
          recommences at the label given by <emphasis>arg2</emphasis>. This
          operation will only be used during the lifetime of that label.
        </para>

        <para>
          Only <code>TAG</code>s declared to have <emphasis>long_jump_access</emphasis> will
          be defined at the re-entry.
        </para>

        <para>
          If <emphasis>arg2</emphasis> delivers a null
          <code>POINTER(</code>{<emphasis>code</emphasis><code>})</code> the
          effect is undefined.
        </para>
      </section>

      <section id="S22S57">
        <title>make_complex</title>

        <emphasis role="bold">Encoding number</emphasis>: 57

        <programlisting>
        c:               FLOATING_VARIETY
        arg1:            EXP FLOATING(f)
        arg2:            EXP FLOATING(f)
                   -&gt; EXP FLOATING(c)</programlisting>

        <para>
          <emphasis>c</emphasis> will be complex and derived from the same
          parameters as <emphasis>f</emphasis>.
        </para>

        <para>
          Delivers a complex number with <emphasis>arg1</emphasis> delivering
          the real part and <emphasis>arg2</emphasis> the imaginary.
        </para>
      </section>

      <section id="S22S58">
        <title>make_compound</title>

        <emphasis role="bold">Encoding number</emphasis>: 58

        <programlisting>
        arg1:            EXP OFFSET(base, y)
        arg2:            LIST(EXP)
                   -&gt; EXP COMPOUND(arg1)</programlisting>

        <para>
          Let the <emphasis>i</emphasis>th component (<emphasis>i</emphasis>
          starts at one) of <emphasis>arg2</emphasis> be
          <emphasis>x</emphasis>[<emphasis>i</emphasis>]. The list may be empty.
        </para>

        <para>
          The components <emphasis>x</emphasis>[2 * <emphasis>k</emphasis>] are
          values which are to be placed at <code>OFFSET</code>s given by
          <emphasis>x</emphasis>[2 * <emphasis>k</emphasis> - 1]. These
          <code>OFFSET</code>s will be constants and non-negative.
        </para>

        <para>
          The <code>OFFSET</code> <emphasis>x</emphasis>[2 *
          <emphasis>k</emphasis> - 1] will have the <code>SHAPE</code>
          <code>OFFSET</code>(<emphasis>z</emphasis><emphasis>k</emphasis>,
          <emphasis>alignment</emphasis>(<emphasis>shape</emphasis>(<emphasis>x</emphasis>[2
          * <emphasis>k</emphasis>]))), where
          <emphasis>shape</emphasis> gives the <code>SHAPE</code> of the
          component and <emphasis>base</emphasis> includes
          <emphasis>z</emphasis><emphasis>k</emphasis>.
        </para>

        <para>
          <emphasis>arg1</emphasis> will be a constant non-negative
          <code>OFFSET</code>, see <!-- TODO link to 5.16.87. offset_pad
          -->offset_pad<!-- link end -->.
        </para>

        <para>
          The values <emphasis>x</emphasis>[2 * <emphasis>k</emphasis> - 1] will
          be such that the components when in place either do not overlap or
          exactly coincide, in the sense that the <code>OFFSET</code>s are equal
          and the values have the same <code>SHAPE</code>. If they coincide the
          corresponding values <emphasis>x</emphasis>[2
          * <emphasis>k</emphasis>] will have <code>VARIETY SHAPE</code>s and
          * will be <emphasis>ored</emphasis>
          together.
        </para>

        <para>
          The <code>SHAPE</code> of a <emphasis>x</emphasis>[2 *
          <emphasis>k</emphasis>] component can be <code>TOP</code>. In this
          case the component is evaluated, but no value is placed at the
          corresponding <code>OFFSET</code>.
        </para>

        <para>
          If <emphasis>x[2 * k]</emphasis> is a <code>BITFIELD</code> then
          <emphasis>x[2 * k - 1]</emphasis>, <emphasis>shape(x[2 *
          k])</emphasis> will be <emphasis>variety-enclosed</emphasis> (see <!--
          TODO link to 7.24. Representing bitfields -->section 7.24<!-- link end
          -->).
        </para>
      </section>

      <section id="S22S59">
        <title>make_floating</title>

        <emphasis role="bold">Encoding number</emphasis>: 59

        <programlisting>
        f:               FLOATING_VARIETY
        rm:              ROUNDING_MODE
        negative:        BOOL
        mantissa:        STRING(k, n)
        base:            NAT
        exponent:        SIGNED_NAT
                   -&gt; EXP FLOATING(f)</programlisting>

        <para>
          <emphasis>f</emphasis> will not be complex.
        </para>

        <para>
          <emphasis>mantissa</emphasis> will be a <code>STRING</code> of 8-bit
          integers, each of which is either  46 or is greater than or equal to
          48. Those values, <emphasis>c</emphasis>, which lie between 48 and 63
          will represent the digit <emphasis>c</emphasis>-48.  A decimal point
          is represented by 46.
        </para>

        <para>
          The <code>BOOL</code> <emphasis>negative</emphasis> determines the
          sign of the result, if true the result will be negative, if false,
          positive.
        </para>

        <para>
          A floating point number, <emphasis>mantissa</emphasis>*(<emphasis>
          base</emphasis><superscript><emphasis>exponent</emphasis>
          </superscript>) is created and rounded to the representation of
          <emphasis>f</emphasis> as specified by <emphasis>rm</emphasis>.
          <emphasis>rm</emphasis> will not be
          <emphasis>round_as_state</emphasis>. <emphasis>mantissa</emphasis> is
          read as a sequence of digits to base <emphasis>base</emphasis> and may
          contain one point symbol.
        </para>

        <para>
          <emphasis>base</emphasis> will be one of the numbers 2, 4, 8, 10, 16.
          Note that in base 16 the digit 10 is represented by the character
          number 58 etc.
        </para>

        <para>
          The result will lie in <emphasis>f</emphasis>.
        </para>
      </section>

      <section id="S2260">
        <title>make_general_proc</title>

        <emphasis role="bold">Encoding number</emphasis>: 60

        <programlisting>
        result_shape:    SHAPE
        prcprops:        OPTION(PROCPROPS)
        caller_intro:    LIST(TAGSHACC)
        callee_intro:    LIST(TAGSHACC)
        body:            EXP BOTTOM
                   -&gt; EXP PROC</programlisting>

        <para>
          Evaluation of <emphasis>make_general_proc</emphasis> delivers a
          <code>PROC</code>.  When this procedure is applied to parameters using
          <emphasis>apply_general_proc</emphasis>, space is allocated to hold
          the actual values of the parameters <emphasis>caller_intro </emphasis>
          and <emphasis>callee_intro</emphasis>. The values produced by the
          actual parameters are used to initialise these spaces. Then
          <emphasis>body</emphasis> is evaluated. During this evaluation the
          <code>TAG</code>s in <emphasis>caller_intro</emphasis> and
          <emphasis>callee_intro</emphasis> are bound to original
          <code>POINTER</code>s to these spaces. The lifetime of these
          <code>TAG</code>s is the evaluation of <emphasis>body</emphasis>.
        </para>

        <para>
          The <code>SHAPE</code> of <emphasis>body</emphasis> will be
          <code>BOTTOM</code>.  <emphasis>caller_intro</emphasis> and
          <emphasis>callee_intro</emphasis> may be empty.
        </para>

        <para>
          The <code>TAG</code>s introduced in the parameters will not be reused
          within the current <code>UNIT</code>.
        </para>

        <para>
          The <code>SHAPE</code>s in the parameters specify the
          <code>SHAPE</code> of the corresponding <code>TAG</code>s.
        </para>

        <para>
          The <code>OPTION(ACCESS)</code> (in <emphasis>params_intro</emphasis>)
          specifies the <code>ACCESS</code> properties of the corresponding
          parameter, just as for a variable declaration.
        </para>

        <para>
          In <emphasis>body</emphasis> the only <code>TAG</code>s which may be
          used as an argument of <emphasis>obtain_tag</emphasis> are those which
          are declared by <emphasis>identify</emphasis> or
          <emphasis>variable</emphasis> constructions in
          <emphasis>body</emphasis> and which are in scope, or <code>TAG</code>s
          which are declared by <emphasis>make_id_tagdef</emphasis>,
          <emphasis>make_var_tagdef</emphasis> or
          <emphasis>common_tagdef</emphasis> or are in
          <emphasis>caller_intro</emphasis> or
          <emphasis>callee_intro</emphasis>. If a <emphasis>make_proc</emphasis>
          occurs in <emphasis>body</emphasis> its <code>TAG</code>s are not in
          scope.
        </para>

        <para>
          The argument of every <emphasis>return</emphasis> or
          <emphasis>untidy_return</emphasis> construction in
          <emphasis>body</emphasis> will have <code>SHAPE</code>
          <emphasis>result_shape</emphasis>. Every
          <emphasis>apply_general_proc</emphasis> using the procedure will
          specify the <code>SHAPE</code> of its result to be
          <emphasis>result_shape</emphasis>.
        </para>

        <para>
          The presence or absence of each of the <code>PROCPROPS</code>
          <emphasis>var_callers</emphasis>, <emphasis>var_callees,
          check_stack</emphasis> and <emphasis>untidy</emphasis> in
          <emphasis>prcprops</emphasis> will be reflected in every
          <emphasis>apply_general_proc</emphasis> or
          <emphasis>tail_call</emphasis> on this procedure.
        </para>

        <para>
          The definition of the canonical ordering of the evaluation of
          <emphasis>apply_general_proc</emphasis> gives the definition of these
          <code>PROCPROPS</code>.
        </para>

        <para>
          If <emphasis>prcprocs</emphasis> contains
          <emphasis>check_stack</emphasis>, a TDF exception will be raised if
          the static space required for the procedure call (in the sense of
          <emphasis>env_size</emphasis>) would exceed the limit given by
          <emphasis>set_stack_limit</emphasis>.
        </para>

        <para>
          If <emphasis>prcprops</emphasis> contains
          <emphasis>no_long_jump_dest</emphasis>, the body of the procedure will
          never contain the destination label of a
          <emphasis>long_jump</emphasis>.
        </para>

        <para>
          For notes on the intended implementation of procedures see
          <!-- TODO link to 7.9. Procedures -->section 7.9<!-- end link -->.
        </para>
      </section>

      <section id="S22S61">
        <title>make_int</title>

        <emphasis role="bold">Encoding number</emphasis>: 61

        <programlisting>
        v:               VARIETY
        value:           SIGNED_NAT
                   -&gt; EXP INTEGER(v)</programlisting>

        <para>
          An integer value is delivered of which the value is given by
          <emphasis>value</emphasis>, and the <code>VARIETY</code> by
          <emphasis>v</emphasis>. The <code>SIGNED_NAT</code>
          <emphasis>value</emphasis> will lie between the bounds of
          <emphasis>v</emphasis>.
        </para>
      </section>

      <section id="S22S62">
        <title>make_local_lv</title>

        <emphasis role="bold">Encoding number</emphasis>: 62

        <programlisting>
        lab:             LABEL
                   -&gt; EXP POINTER({code})</programlisting>

        <para>
          A <code>POINTER(</code><emphasis>{code</emphasis><code>})</code>
          <emphasis>lv</emphasis> is created and delivered. It can be used as an
          argument to <emphasis>goto_local_lv</emphasis> or
          <emphasis>long_jump</emphasis>. If and when one of these is evaluated
          with <emphasis>lv</emphasis> as an argument, control will pass to
          <emphasis>lab</emphasis>.
        </para>
      </section>

      <section id="S22S63">
        <title>make_nof</title>

        <emphasis role="bold">Encoding number</emphasis>: 63

        <programlisting>
        arg1:            LIST(EXP)
                   -&gt; EXP NOF(n, s)</programlisting>

        <para>
          Creates an array of <emphasis>n</emphasis> values of
          <code>SHAPE</code> <emphasis>s</emphasis>, containing the given values
          produced by evaluating the members of <emphasis>arg1</emphasis> in the
          same order as they occur in the list.
        </para>

        <para>
          <emphasis>n</emphasis> will not be zero.
        </para>
      </section>

      <section id="S22S64">
        <title>make_nof_int</title>

        <emphasis role="bold">Encoding number</emphasis>: 64

        <programlisting>
        v:               VARIETY
        str:             STRING(k, n)
                   -&gt; EXP NOF(n, INTEGER(v))</programlisting>

        <para>
          An <code>NOF INTEGER</code> is delivered. The conversions are carried
          out as if the elements of <emphasis>str</emphasis> were
          <code>INTEGER</code>(<emphasis>var_limits</emphasis>(0,
          2<superscript><emphasis>k</emphasis></superscript>-1)).
          <emphasis>n</emphasis> may be zero.
        </para>
      </section>

      <section id="S22S65">
        <title>make_null_local_lv</title>

        <emphasis role="bold">Encoding number</emphasis>: 65

        <programlisting>
                   -&gt; EXP POINTER({code})</programlisting>

        <para>
          Makes a null <code>POINTER</code>({<emphasis>code</emphasis>}) which
          can be detected by <emphasis>pointer_test</emphasis>. The effect of
          <emphasis>goto_local_lv</emphasis> or <emphasis>long_jump</emphasis>
          applied to this value is undefined.
        </para>

        <para>
          All null <code>POINTER</code>({<emphasis>code</emphasis>}) are equal
          to each other and unequal to any other <code>POINTER</code>s.
        </para>
      </section>

      <section id="S22S66">
        <title>make_null_proc</title>

        <emphasis role="bold">Encoding number</emphasis>: 66

        <programlisting>
                   -&gt; EXP PROC</programlisting>

        <para>
          A null <code>PROC</code> is created and delivered. The null
          <code>PROC</code> may be tested for by using
          <emphasis>proc_test</emphasis>. The effect of using it as the first
          argument of <emphasis>apply_proc</emphasis> is undefined.
        </para>

        <para>
          All null <code>PROC</code> are equal to each other and unequal to any
          other <code>PROC</code>.
        </para>
      </section>

      <section id="S22S67">
        <title>make_null_ptr</title>

        <emphasis role="bold">Encoding number</emphasis>: 67

        <programlisting>
        a:               ALIGNMENT
                   -&gt; EXP POINTER(a)</programlisting>

        <para>
          A null <code>POINTER</code>(<emphasis>a</emphasis>) is created and
          delivered. The null <code>POINTER</code> may be tested for by
          <emphasis>pointer_test</emphasis>.
        </para>

        <para>
          <emphasis>a</emphasis> will not include <emphasis>code</emphasis>.
        </para>

        <para>
          All null <code>POINTER</code>(<emphasis>x</emphasis>) are equal to
          each other and unequal to any other
          <code>POINTER</code>(<emphasis>x</emphasis>).
        </para>
      </section>

      <section id="S22S68">
        <title>make_proc</title>

        <emphasis role="bold">Encoding number</emphasis>: 68

        <programlisting>
        result_shape:    SHAPE
        params_intro:    LIST(TAGSHACC)
        var_intro:       OPTION(TAGACC)
        body:            EXP BOTTOM
                   -&gt; EXP PROC</programlisting>

        <para>
          Evaluation of <emphasis>make_proc</emphasis> delivers a
          <code>PROC</code>. When this procedure is applied to parameters using
          <emphasis>apply_proc</emphasis>, space is allocated to hold the actual
          values of the parameters <emphasis>params_intro</emphasis> and
          <emphasis>var_intro</emphasis> (if present). The values produced by
          the actual parameters are used to initialise these spaces. Then
          <emphasis>body</emphasis> is evaluated. During this evaluation the
          <code>TAG</code>s in <emphasis>params_intro</emphasis> and
          <emphasis>var_intro</emphasis> are bound to original
          <code>POINTER</code>s to these spaces. The lifetime of these
          <code>TAG</code>s is the evaluation of <emphasis>body</emphasis>.
        </para>

        <para>
          If <emphasis>var_intro</emphasis> is present, it may be used for one
          of two purposes, with different consequences for corresponding uses of
          <emphasis>apply_proc</emphasis>. See <!-- TODO link to 7.9. Procedures
          -->section 7.9<!-- end link -->. The <code>ALIGNMENT</code>,
          <emphasis>var_param_alignment</emphasis>, includes the set union of
          all the <code>ALIGNMENT</code>s which can be produced by
          <emphasis>alignment</emphasis> from any <code>SHAPE</code>. Note that
          <emphasis>var_intro</emphasis> does not contain an <code>ACCESS</code>
          component and so cannot be marked <emphasis>visible</emphasis>. Hence
          it is not a possible argument of <emphasis>env_offset</emphasis>.  If
          present, <emphasis>var_intro</emphasis> is an original
          pointer.
        </para>

        <para>
          The <code>SHAPE</code> of <emphasis>body</emphasis> will be
          <code>BOTTOM</code>. <emphasis>params_intro</emphasis> may be empty.
        </para>

        <para>
          The <code>TAG</code>s introduced in the parameters will not be reused
          within the current <code>UNIT</code>.
        </para>

        <para>
          The <code>SHAPE</code>s in the parameters specify the
          <code>SHAPE</code> of the corresponding <code>TAG</code>s.
        </para>

        <para>
          The <code>OPTION(ACCESS</code>) (in <emphasis>params_intro</emphasis>)
          specifies the <code>ACCESS</code> properties of the corresponding
          parameter, just as for a variable declaration.
        </para>

        <para>
          In <emphasis>body</emphasis> the only <code>TAG</code>s which may be
          used as an argument of <emphasis>obtain_tag</emphasis> are those which
          are declared by <emphasis>identify</emphasis> or
          <emphasis>variable</emphasis> constructions in
          <emphasis>body</emphasis> and which are in scope, or <code>TAG</code>s
          which are declared by <emphasis>make_id_tagdef</emphasis>,
          <emphasis>make_var_tagdef</emphasis> or
          <emphasis>common_tagdef</emphasis> or are in
          <emphasis>params_intro</emphasis> or <emphasis>var_intro</emphasis>.
          If a <emphasis>make_proc</emphasis> occurs in
          <emphasis>body</emphasis> its <code>TAG</code>s are not in scope.
        </para>

        <para>
          The argument of every <emphasis>return</emphasis> construction in
          <emphasis>body</emphasis> will have <code>SHAPE</code>
          <emphasis>result_shape</emphasis>. Every
          <emphasis>apply_proc</emphasis> using the procedure will specify the
          <code>SHAPE</code> of it result to be
          <emphasis>result_shape</emphasis>.
        </para>

        <para>
          For notes on the intended implementation of procedures see
          <!-- TODO link to 7.9 Procedures -->section 7.9<!-- end link -->.
        </para>
      </section>

      <section id="S22S69">
        <title>make_stack_limit</title>

        <emphasis role="bold">Encoding number</emphasis>: 116

        <programlisting>
        stack_base:      EXP POINTER(fa)
        frame_size:      EXP OFFSET(locals_alignment, x)
        alloc_size:      EXP OFFSET(alloca_alignment, y)
                   -&gt; EXP POINTER(fb)</programlisting>

        <para>
          This creates a POINTER suitable for use with
          <emphasis>set_stack_limit</emphasis>.
        </para>

        <para>
          <emphasis>fa</emphasis> and <emphasis>fb</emphasis> will include
          <emphasis>locals_alignment</emphasis> and, if
          <emphasis>alloc_size</emphasis> is not the zero offset, will also
          contain <emphasis>alloca_alignment</emphasis>.
        </para>

        <para>
          The result will be the same as if given by:<sbr/> Assume
          <emphasis>stack_base</emphasis> is the current frame-pointer as given
          by <emphasis>current_env</emphasis> in a hypothetical procedure P with
          <emphasis>env_size</emphasis> equal to <emphasis>frame_size</emphasis>
          and which has generated <emphasis>alloc_size</emphasis> by a
          <emphasis>local_alloc</emphasis>. If P then calls Q, the result will
          be the same as that of a <emphasis>current_env</emphasis> performed
          immediately in the body of Q.<sbr/> If the following construction is
          performed:<sbr/> set_stack_limit(make_stack_limit(current_env, F,
          A))<sbr/> the frame space and local_alloc space that would be
          available for use by this supposed call of Q will not be reused by
          procedure calls with <emphasis>check_stack</emphasis> or uses of
          <emphasis>local_alloc_check</emphasis> after the
          <emphasis>set_stack_limit</emphasis>. Any attempt to do so will raise
          a TDF exception, <emphasis>stack_overflow</emphasis>.
        </para>
      </section>

      <section id="S22S70">
        <title>make_top</title>

        <emphasis role="bold">Encoding number</emphasis>: 69

        <programlisting>
                   -&gt; EXP TOP</programlisting>

        <para>
          <emphasis>make_top</emphasis> delivers a value of <code>SHAPE
          TOP</code> (i.e. <emphasis>void</emphasis>).
        </para>
      </section>

      <section id="S22S71">
        <title>make_value</title>

        <emphasis role="bold">Encoding number</emphasis>: 70

        <programlisting>
        s:               SHAPE
                   -&gt; EXP s</programlisting>

        <para>
          This <code>EXP</code> creates some value with the representation of
          the <code>SHAPE</code> <emphasis>s</emphasis>. This value will have
          the correct size, but its representation is not specified. It can be
          assigned, be the result of a <emphasis>contents</emphasis>, a
          parameter or result of a procedure, or the result of any construction
          (like <emphasis>sequence</emphasis>) which delivers the value
          delivered by an internal <code>EXP</code>. But if it is used for
          arithmetic or as a <code>POINTER</code> for taking
          <emphasis>contents</emphasis> or <emphasis>add_to_ptr</emphasis> etc.
          the effect is undefined.
        </para>

        <para>
          Installers will usually be able to implement this operation by
          producing no code.
        </para>

        <para>
          <emphasis>Note that a floating point NaN is a possible value for this
          purpose.</emphasis>
        </para>

        <para>
          The <code>SHAPE</code> <emphasis>s</emphasis> will not be
          <code>BOTTOM</code>.
        </para>
      </section>

      <section id="S22S72">
        <title>maximum</title>

        <emphasis role="bold">Encoding number</emphasis>: 71

        <programlisting>
        arg1:            EXP INTEGER(v)
        arg2:            EXP INTEGER(v)
                   -&gt; EXP INTEGER(v)</programlisting>

        <para>
          The arguments will be evaluated and the maximum of the values
          delivered is the result.
        </para>
      </section>

      <section id="S2273">
        <title>minimum</title>

        <emphasis role="bold">Encoding number</emphasis>: 72

        <programlisting>
        arg1:            EXP INTEGER(v)
        arg2:            EXP INTEGER(v)
                   -&gt; EXP INTEGER(v)</programlisting>

        <para>
          The arguments will be evaluated and the minimum of the values
          delivered is the result.
        </para>
      </section>

      <section id="S22S74">
        <title>minus</title>

        <emphasis role="bold">Encoding number</emphasis>: 73

        <programlisting>
        ov_err:          ERROR_TREATMENT
        arg1:            EXP INTEGER(v)
        arg2:            EXP INTEGER(v)
                   -&gt; EXP INTEGER(v)</programlisting>

        <para>
          <emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated
          and will produce integer values, <emphasis>a</emphasis> and
          <emphasis>b</emphasis>, of the same <code>VARIETY</code>,
          <emphasis>v</emphasis>. The difference
          <emphasis>a</emphasis>-<emphasis>b</emphasis> is delivered as the
          result of the construct, with the same <code>SHAPE</code> as the
          arguments.
        </para>

        <para>
          If the result cannot be expressed in the <code>VARIETY</code> being
          used to represent <emphasis>v</emphasis>, an overflow error is caused
          and is handled in the way specified by <emphasis>ov_err</emphasis>.
        </para>
      </section>

      <section id="S22S75">
        <title>move_some</title>

        <emphasis role="bold">Encoding number</emphasis>: 74

        <programlisting>
        md:              TRANSFER_MODE
        arg1:            EXP POINTER(x)
        arg2:            EXP POINTER(y)
        arg3:            EXP OFFSET(z, t)
                   -&gt; EXP TOP</programlisting>

        <para>
          The arguments are evaluated to produce <emphasis>p1</emphasis>,
          <emphasis>p2</emphasis>, and <emphasis>sz</emphasis> respectively. A
          quantity of data measured by <emphasis>sz</emphasis> in the space
          indicated by <emphasis>p1</emphasis> is moved to the space indicated
          by <emphasis>p2</emphasis>.  The operation will be carried out as
          specified by the <code>TRANSFER_MODE</code> (q.v.).
        </para>

        <para>
          <emphasis>x</emphasis> will include <emphasis>z</emphasis> and
          <emphasis>y</emphasis> will include <emphasis>z</emphasis>.
        </para>

        <para>
          <emphasis>sz</emphasis> will be a non-negative <code>OFFSET</code>,
          see <!-- TODO link to 5.16.87. offset_pad -->offset_pad<!-- end link
          -->.
        </para>

        <para>
          If the spaces of size <emphasis>sz</emphasis> to which
          <emphasis>p1</emphasis> and <emphasis>p2</emphasis> point do not lie
          entirely within the spaces indicated by the original pointers from
          which they are derived, the effect of the operation is undefined.
        </para>

        <para>
          If the value delivered by <emphasis>arg1</emphasis> or
          <emphasis>arg2</emphasis> is a null pointer the effect is undefined.
        </para>

        <para>
          See <!-- TODO link to 7.16. Overlapping -->Overlapping<!-- end link
          -->.
        </para>
      </section>

      <section id="S22S76">
        <title>mult</title>

        <emphasis role="bold">Encoding number</emphasis>: 75

        <programlisting>
        ov_err:          ERROR_TREATMENT
        arg1:            EXP INTEGER(v)
        arg2:            EXP INTEGER(v)
                   -&gt; EXP INTEGER(v)</programlisting>

        <para>
          <emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated
          and will produce integer values, <emphasis>a</emphasis> and
          <emphasis>b</emphasis>, of the same <code>VARIETY</code>,
          <emphasis>v</emphasis>.  The product
          <emphasis>a</emphasis>*<emphasis>b</emphasis> is delivered as the
          result of the construct, with the same <code>SHAPE</code> as the
          arguments.
        </para>

        <para>
          If the result cannot be expressed in the <code>VARIETY</code> being
          used to represent <emphasis>v</emphasis>, an overflow error is caused
          and is handled in the way specified by <emphasis>ov_err</emphasis>.
        </para>
      </section>

      <section id="S22S77">
        <title>n_copies</title>

        <emphasis role="bold">Encoding number</emphasis>: 76

        <programlisting>
        n:               NAT
        arg1:            EXP x
                   -&gt; EXP NOF(n, x)</programlisting>

        <para>
          <emphasis>arg1</emphasis> is evaluated and an <code>NOF</code> value
          is delivered which contains <emphasis>n</emphasis> copies of this
          value. <emphasis>n</emphasis> can be zero or one or greater.
        </para>

        <para>
          Producers are encouraged to use <emphasis>n_copies</emphasis> to
          initialise arrays of known size.
        </para>
      </section>

      <section id="S22S78">
        <title>negate</title>

        <emphasis role="bold">Encoding number</emphasis>: 78

        <programlisting>
        ov_err:          ERROR_TREATMENT
        arg1:            EXP INTEGER(v)
                   -&gt; EXP INTEGER(v)</programlisting>

        <para>
          <emphasis>arg1</emphasis> is evaluated and will produce an integer
          value, <emphasis>a</emphasis>.  The value -<emphasis>a</emphasis> is
          delivered as the result of the construct, with the same
          <code>SHAPE</code> as the argument.
        </para>

        <para>
          If the result cannot be expressed in the <code>VARIETY</code> being
          used to represent <emphasis>v</emphasis>, an overflow error is caused
          and is handled in the way specified by <emphasis>ov_err</emphasis>.
        </para>
      </section>

      <section id="S22S79">
        <title>not</title>

        <emphasis role="bold">Encoding number</emphasis>: 78

        <programlisting>
        arg1:            EXP INTEGER(v)
                   -&gt; EXP INTEGER(v)</programlisting>

        <para>
          The argument is evaluated producing an integer value, of
          <code>VARIETY</code>, <emphasis>v</emphasis>. The result is the
          bitwise <emphasis>not</emphasis> of this value in the representing
          <code>VARIETY</code>. The result is delivered as the result of the
          construct, with the same <code>SHAPE</code> as the arguments.
        </para>

        <para>
          See <!-- TODO link to 7.18. Representing integers -->Representing
          integers<!-- end link -->.
        </para>
      </section>

      <section id="S22S80">
        <title>obtain_tag</title>

        <emphasis role="bold">Encoding number</emphasis>: 79

        <programlisting>
        t:               TAG x
                   -&gt; EXP x</programlisting>

        <para>
          The value with which the <code>TAG</code> <emphasis>t</emphasis> is
          bound is delivered.  The <code>SHAPE</code> of the result is the
          <code>SHAPE</code> of the value with which the <code>TAG</code> is
          bound.
        </para>
      </section>

      <section id="S22S81">
        <title>offset_add</title>

        <emphasis role="bold">Encoding number</emphasis>: 80

        <programlisting>
        arg1:            EXP OFFSET(x, y)
        arg2:            EXP OFFSET(z, t)
                   -&gt; EXP OFFSET(x, t)</programlisting>

        <para>
          The two arguments deliver <code>OFFSET</code>s. The result is the
          sum of these <code>OFFSET</code>s, as an <code>OFFSET</code>.
        </para>

        <para>
          <emphasis>y</emphasis> will include <emphasis>z</emphasis>.
        </para>

        <para>
          <emphasis>The effect of the constraint <quote>y will include z</quote>
          is that, in the simple representation of pointer arithmetic, this
          operation can be represented by addition. offset_add can lose
          information, so that offset_subtract does not have the usual relation
          with it.</emphasis>
        </para>
      </section>

      <section id="S22S82">
        <title>offset_div</title>

        <emphasis role="bold">Encoding number</emphasis>: 81

        <programlisting>
        v:               VARIETY
        arg1:            EXP OFFSET(x, x)
        arg2:            EXP OFFSET(x, x)
                   -&gt; EXP INTEGER(v)</programlisting>

        <para>
          The two arguments deliver <code>OFFSET</code>s, <emphasis>a</emphasis>
          and <emphasis>b</emphasis>.  The result is <emphasis>a/b</emphasis>,
          as an <code>INTEGER</code> of <code>VARIETY</code>,
          <emphasis>v</emphasis>. Division is interpreted in the same sense
          (with respect to remainder) as in <emphasis>div0</emphasis>.
        </para>

        <para>
          The value produced by <emphasis>arg2</emphasis> will be non-zero.
        </para>
      </section>

      <section id="S22S83">
        <title>offset_div_by_int</title>

        <emphasis role="bold">Encoding number</emphasis>: 82

        <programlisting>
        arg1:            EXP OFFSET(x, x)
        arg2:            EXP INTEGER(v)
                   -&gt; EXP OFFSET(x, x)</programlisting>

        <para>
          The result is the <code>OFFSET</code> produced by
          <emphasis>arg1</emphasis> divided by <emphasis>arg2</emphasis>, as an
          <code>OFFSET</code>(<emphasis>x</emphasis>, <emphasis>x</emphasis>).
        </para>

        <para>
          The value produced by <emphasis>arg2</emphasis> will be greater than
          zero.
        </para>

        <para>
          The following identity will apply for all A and n:
        </para>

        <para>
          <emphasis>offset_mult</emphasis>(<emphasis>offset_div_by_int</emphasis>(A,
          n), n) = A
        </para>
      </section>

      <section id="S22S84">
        <title>offset_max</title>

        <emphasis role="bold">Encoding number</emphasis>: 83

        <programlisting>
        arg1:            EXP OFFSET(x, y)
        arg2:            EXP OFFSET(z, y)
                   -&gt; EXP OFFSET(unite_alignments(x, z), y)</programlisting>

        <para>
          The two arguments deliver <code>OFFSET</code>s. The result is the
          maximum of these <code>OFFSET</code>s, as an <code>OFFSET</code>.
        </para>

        <para>
          See <!-- TODO link to 7.13.2. Comparison of pointers and offsets
          -->Comparison of pointers and offsets<!-- link end -->.
        </para>

        <para>
          <emphasis>In the simple memory model this operation is represented by
          maximum. The constraint that the second <code>ALIGNMENT</code>
          parameters are both y is to permit the representation of
          <code>OFFSET</code>s in installers by a simple
          homomorphism.</emphasis>
        </para>
      </section>

      <section id="S22S85">
        <title>offset_mult</title>

        <emphasis role="bold">Encoding number</emphasis>: 84

        <programlisting>
        arg1:            EXP OFFSET(x, x)
        arg2:            EXP INTEGER(v)
                   -&gt; EXP OFFSET(x, x)</programlisting>

        <para>
          The first argument gives an <code>OFFSET</code>,
          <emphasis>off</emphasis>, and the second an integer,
          <emphasis>n</emphasis>. The result is the product of these, as an
          offset.
        </para>

        <para>
          The result shall be equal to <emphasis>offset_adding off n</emphasis>
          times to <emphasis>offset_zero</emphasis>(<emphasis>x</emphasis>).
        </para>
      </section>

      <section id="S22S86">
        <title>offset_negate</title>

        <emphasis role="bold">Encoding number</emphasis>: 85

        <programlisting>
        arg1:            EXP OFFSET(x, x)
                   -&gt; EXP OFFSET(x, x)</programlisting>

        <para>
          The inverse of the argument is delivered.
        </para>

        <para>
          <emphasis>In the simple memory model this can be represented by negate.</emphasis>
        </para>
      </section>

      <section id="S22S87">
        <title>offset_pad</title>

        <emphasis role="bold">Encoding number</emphasis>: 86

        <programlisting>
        a:               ALIGNMENT
        arg1:            EXP OFFSET(z, t)
                   -&gt; EXP OFFSET(unite_alignments(z, a), a)</programlisting>

        <para>
          <emphasis>arg1</emphasis> is evaluated giving
          <emphasis>off</emphasis>. The next greater or equal
          <code>OFFSET</code> at which a value of <code>ALIGNMENT</code>
          <emphasis>a</emphasis> can be placed is delivered. That is, there
          shall not exist an <code>OFFSET</code> of the same <code>SHAPE</code>
          as the result which is greater than or equal to
          <emphasis>off</emphasis> and less than the result, in the sense of
          <emphasis>offset_test</emphasis>.
        </para>

        <para>
          <emphasis>off</emphasis> will be a non-negative <code>OFFSET</code>,
          that is it will be greater than or equal to a zero <code>OFFSET</code>
          of the same <code>SHAPE</code> in the sense of
          <emphasis>offset_test</emphasis>.
        </para>

        <para>
          <emphasis>In the simple memory model this operation can be represented
          by ((off + a - 1) / a) * a. In the simple model this is the only
          operation which is not represented by a simple corresponding integer
          operation.</emphasis>
        </para>
      </section>

      <section id="S22S88">
        <title>offset_subtract</title>

        <emphasis role="bold">Encoding number</emphasis>: 87

        <programlisting>
        arg1:            EXP OFFSET(x, y)
        arg2:            EXP OFFSET(x, z)
                   -&gt; EXP OFFSET(z, y)
        </programlisting>

        <para>
          The two arguments deliver offsets, <emphasis>p</emphasis> and
          <emphasis>q</emphasis>. The result is
          <emphasis>p</emphasis>-<emphasis>q</emphasis>, as an offset.
        </para>

        <para>
          Note that <emphasis>x</emphasis> will include <emphasis>y</emphasis>,
          <emphasis>x</emphasis> will include <emphasis>z</emphasis> and
          <emphasis>z</emphasis> will include <emphasis>y</emphasis>, by the
          constraints on <code>OFFSET</code>s.
        </para>

        <para>
          <emphasis>offset_subtract and offset_add do not have the conventional
          relationship because offset_add can lose information, which cannot be
          regenerated by offset_subtract.</emphasis>
        </para>
      </section>

      <section id="S22S89">
        <title>offset_test</title>

        <emphasis role="bold">Encoding number</emphasis>: 88

        <programlisting>
        prob:            OPTION(NAT)
        nt:              NTEST
        dest:            LABEL
        arg1:            EXP OFFSET(x, y)
        arg2:            EXP OFFSET(x, y)
                   -&gt; EXP TOP</programlisting>

        <para>
          <emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated
          and will produce offset values, <emphasis>a</emphasis> and
          <emphasis>b</emphasis>. These values are compared using
          <emphasis>nt</emphasis>.
        </para>

        <para>
          If <emphasis>a nt b</emphasis>, this construction yields
          <code>TOP</code>. Otherwise control passes to
          <emphasis>dest</emphasis>.
        </para>

        <para>
          If <emphasis>prob</emphasis> is present, <emphasis>prob</emphasis>/100
          gives the probability that control will continue to the next construct
          (ie. not pass to <emphasis>dest</emphasis>).  If
          <emphasis>prob</emphasis> is absent this probability is unknown.
        </para>

        <para>
          <emphasis>a greater_than_or_equal b</emphasis> is equivalent to
          <emphasis>offset_max</emphasis>(<emphasis>a</emphasis>,
          <emphasis>b</emphasis>) = <emphasis>a</emphasis>, and similarly for
          the other comparisons.
        </para>

        <para>
          <emphasis>In the simple memory model this can be represented by
          integer_test.</emphasis>
        </para>
      </section>

      <section id="S22S90">
        <title>offset_zero</title>

        <emphasis role="bold">Encoding number</emphasis>: 89

        <programlisting>
        a:               ALIGNMENT
                   -&gt; EXP OFFSET(a, a)</programlisting>

        <para>
          A zero offset of <code>SHAPE OFFSET</code>(<emphasis>a</emphasis>,
          <emphasis>a</emphasis>).
        </para>

        <para>
          <emphasis>offset_pad</emphasis>(<emphasis>b</emphasis>,
          <emphasis>offset_zero</emphasis>(<emphasis>a</emphasis>)) is a zero
          offset of <code>SHAPE
          OFFSET</code>(<emphasis>unite_alignments</emphasis>(<emphasis>a</emphasis>,
          <emphasis>b</emphasis>), <emphasis>b</emphasis>).
        </para>
      </section>

      <section id="S22S91">
        <title>or</title>

        <emphasis role="bold">Encoding number</emphasis>: 90

        <programlisting>
        arg1:            EXP INTEGER(v)
        arg2:            EXP INTEGER(v)
                   -&gt; EXP INTEGER(v)</programlisting>

        <para>
          The arguments are evaluated producing integer values of the same
          <code>VARIETY</code>, <emphasis>v</emphasis>. The result is the
          bitwise <emphasis>or</emphasis> of these two integers in the
          representing <code>VARIETY</code>. The result is delivered as the
          result of the construct, with the same <code>SHAPE</code> as the
          arguments.
        </para>

        <para>
          See <!-- TODO link to 7.18. Representing integers -->Representing
          integers<!-- end link -->.
        </para>
      </section>

      <section id="S22S92">
        <title>plus</title>

        <emphasis role="bold">Encoding number</emphasis>: 91

        <programlisting>
        ov_err:          ERROR_TREATMENT
        arg1:            EXP INTEGER(v)
        arg2:            EXP INTEGER(v)
                   -&gt; EXP INTEGER(v)</programlisting>

        <para>
          <emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated
          and will produce integer values, <emphasis>a</emphasis> and
          <emphasis>b</emphasis>, of the same <code>VARIETY</code>,
          <emphasis>v</emphasis>.  The sum
          <emphasis>a</emphasis>+<emphasis>b</emphasis> is delivered as the
          result of the construct, with the same <code>SHAPE</code> as the
          arguments.
        </para>

        <para>
          If the result cannot be expressed in the <code>VARIETY</code> being
          used to represent <emphasis>v</emphasis>, an overflow error is caused
          and is handled in the way specified by <emphasis>ov_err</emphasis>.
        </para>
      </section>

      <section id="S22S93">
        <title>pointer_test</title>

        <emphasis role="bold">Encoding number</emphasis>: 92

        <programlisting>
        prob:            OPTION(NAT)
        nt:              NTEST
        dest:            LABEL
        arg1:            EXP POINTER(x)
        arg2:            EXP POINTER(x)
                   -&gt; EXP TOP</programlisting>

        <para>
          <emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated
          and will produce pointer values, <emphasis>a</emphasis> and
          <emphasis>b</emphasis>, which will be derived from the same original
          pointer. These values are compared using <emphasis>nt</emphasis>.
        </para>

        <para>
          If <emphasis>a nt b</emphasis>, this construction yields
          <code>TOP</code>. Otherwise control passes to
          <emphasis>dest</emphasis>.
        </para>

        <para>
          If <emphasis>prob</emphasis> is present, <emphasis>prob</emphasis>/100
          gives the probability that control will continue to the next construct
          (ie. not pass to <emphasis>dest</emphasis>).  If
          <emphasis>prob</emphasis> is absent this probability is unknown.
        </para>

        <para>
          The effect of this construction is the same as:
        </para>

        <para>
          <emphasis>offset_test</emphasis>(<emphasis>prob, nt</emphasis>,
          <emphasis>dest</emphasis>,
          <emphasis>subtract_ptrs</emphasis>(<emphasis>arg1 </emphasis>,
          <emphasis>arg2</emphasis>),
          <emphasis>offset_zero</emphasis>(<emphasis>x</emphasis>))
        </para>

        <para>
          <emphasis>In the simple memory model this construction can be
          represented by integer_test.</emphasis>
        </para>
      </section>

      <section id="S22S94">
        <title>power</title>

        <emphasis role="bold">Encoding number</emphasis>: 93

        <programlisting>
        ov_err:          ERROR_TREATMENT
        arg1:            EXP INTEGER(v)
        arg2:            EXP INTEGER(w)
                   -&gt; EXP INTEGER(v)</programlisting>

        <para>
          <emphasis>arg2</emphasis> will be non-negative. The result is the
          result of <emphasis>arg1</emphasis> raised to the power given by
          <emphasis>arg2</emphasis>.
        </para>

        <para>
          If the result cannot be expressed in the <code>VARIETY</code> being
          used to represent <emphasis>v</emphasis>, an overflow error is caused
          and is handled in the way specified by <emphasis>ov_err</emphasis>.
        </para>
      </section>

      <section id="S22S95">
        <title>proc_test</title>

        <emphasis role="bold">Encoding number</emphasis>: 94

        <programlisting>
        prob:            OPTION(NAT)
        nt:              NTEST
        dest:            LABEL
        arg1:            EXP PROC
        arg2:            EXP PROC
                   -&gt; EXP TOP</programlisting>

        <para>
          <emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated
          and will produce <code>PROC</code> values, <emphasis>a</emphasis> and
          <emphasis>b</emphasis>. These values are compared using
          <emphasis>nt</emphasis>.  The only permitted values of
          <emphasis>nt</emphasis> are <emphasis>equal</emphasis> and
          <emphasis>not_equal</emphasis>.
        </para>

        <para>
          If <emphasis>a nt b</emphasis>, this construction yields
          <code>TOP</code>. Otherwise control passes to
          <emphasis>dest</emphasis>.
        </para>

        <para>
          If <emphasis>prob</emphasis> is present, <emphasis>prob</emphasis>/100
          gives the probability that control will continue to the next construct
          (ie. not pass to <emphasis>dest</emphasis>).  If
          <emphasis>prob</emphasis> is absent this probability is unknown.
        </para>

        <para>
          Two <code>PROC</code>s are equal if they were produced by the same
          instantiation of <emphasis>make_proc</emphasis> or if they were both
          made with <emphasis>make_null_proc</emphasis>. Otherwise they are
          unequal.
        </para>
      </section>

      <section id="S22S96">
        <title>profile</title>

        <emphasis role="bold">Encoding number</emphasis>: 95

        <programlisting>
        uses:            NAT
                   -&gt; EXP TOP</programlisting>

        <para>
          The integer <emphasis>uses</emphasis> gives the number of times which
          this construct is expected to be evaluated.
        </para>

        <para>
          All uses of <emphasis>profile</emphasis> in the same capsule are to
          the same scale.  They will be mutually consistent.
        </para>
      </section>

      <section id="S22S97">
        <title>real_part</title>

        <emphasis role="bold">Encoding number</emphasis>: 96

        <programlisting>
        arg1:            EXP c
                   -&gt; EXP FLOATING (float_of_complex(c))</programlisting>

        <para>
          <emphasis>c</emphasis> will be complex. Delivers the real part of the
          value produced by <emphasis>arg1</emphasis>.
        </para>
      </section>

      <section id="S22S98">
        <title>rem0</title>

        <emphasis role="bold">Encoding number</emphasis>: 97

        <programlisting>
        div_by_0_err:    ERROR_TREATMENT
        ov_err:          ERROR_TREATMENT
        arg1:            EXP INTEGER(v)
        arg2:            EXP INTEGER(v)
                   -&gt; EXP INTEGER(v)</programlisting>

        <para>
          <emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated
          and will produce integer values, <emphasis>a</emphasis> and
          <emphasis>b</emphasis>, of the same <code>VARIETY</code>,
          <emphasis>v</emphasis>. The value <emphasis>a</emphasis> M1
          <emphasis>b</emphasis> or the value <emphasis>a</emphasis> M2
          <emphasis>b</emphasis> is delivered as the result of the construct,
          with the same <code>SHAPE</code> as the arguments. Different
          occurrences of <emphasis>rem0</emphasis> in the same capsule can use
          M1 or M2 independently.
        </para>

        <para>
          The following equivalence shall hold:
        </para>

        <programlisting>
        x = plus(mult(div0(x, y), y), rem0(x, y))
        </programlisting>

        <para>
          if all the <code>ERROR_TREATMENT</code>s are
          <emphasis>impossible</emphasis>, and <emphasis>x</emphasis> and
          <emphasis>y</emphasis> have no side effects.
        </para>

        <para>
          If <emphasis>b</emphasis> is zero a div_by_zero error occurs and is
          handled by <emphasis>div_by_0_err</emphasis>.
        </para>

        <para>
          If <emphasis>b</emphasis> is not zero and
          <emphasis>div0</emphasis>(<emphasis>a</emphasis>,
          <emphasis>b</emphasis>) cannot be expressed in the
          <code>VARIETY</code> being used to represent <emphasis>v</emphasis> an
          overflow may occur in which case it is handled by
          <emphasis>ov_err</emphasis>.
        </para>

        <para>
          Producers may assume that suitable masking and
          <emphasis>rem0</emphasis> by a power of two yield equally good code.
        </para>

        <para>
          See <!-- TODO link to 7.4. Division and modulus -->Division and
          modulus<!-- end link --> for the definitions of D1, D2, M1 and M2.
        </para>
      </section>

      <section id="S22S99">
        <title>rem1</title>

        <emphasis role="bold">Encoding number</emphasis>: 98

        <programlisting>
        div_by_0_err:    ERROR_TREATMENT
        ov_err:          ERROR_TREATMENT
        arg1:            EXP INTEGER(v)
        arg2:            EXP INTEGER(v)
                   -&gt; EXP INTEGER(v)</programlisting>

        <para>
          <emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated
          and will produce integer values, <emphasis>a</emphasis> and
          <emphasis>b</emphasis>, of the same <code>VARIETY</code>,
          <emphasis>v</emphasis>. The value <emphasis>a</emphasis> M1
          <emphasis>b</emphasis> is delivered as the result of the construct,
          with the same <code>SHAPE</code> as the arguments.
        </para>

        <para>
          If <emphasis>b</emphasis> is zero a div_by_zero error occurs and is
          handled by <emphasis>div_by_0_err</emphasis>.
        </para>

        <para>
          If <emphasis>b</emphasis> is not zero and
          <emphasis>div1</emphasis>(<emphasis>a</emphasis>,
          <emphasis>b</emphasis>) cannot be expressed in the
          <code>VARIETY</code> being used to represent <emphasis>v</emphasis> an
          overflow may occur, in which case it is handled by
          <emphasis>ov_err</emphasis>.
        </para>

        <para>
          Producers may assume that suitable masking and
          <emphasis>rem1</emphasis> by a power of two yield equally good code.
        </para>

        <para>
          See <!-- TODO link to 7.4. Division and modulus -->Division and
          modulus<!-- end link --> for the definitions of D1, D2, M1 and M2.
        </para>
      </section>

      <section id="S22S100">
        <title>rem2</title>

        <emphasis role="bold">Encoding number</emphasis>: 99

        <programlisting>
        div_by_0_err:    ERROR_TREATMENT
        ov_err:          ERROR_TREATMENT
        arg1:            EXP INTEGER(v)
        arg2:            EXP INTEGER(v)
                   -&gt; EXP INTEGER(v)</programlisting>

        <para>
          <emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated
          and will produce integer values, <emphasis>a</emphasis> and
          <emphasis>b</emphasis>, of the same <code>VARIETY</code>,
          <emphasis>v</emphasis>. The value <emphasis>a</emphasis> M2
          <emphasis>b</emphasis> is delivered as the result of the construct,
          with the same <code>SHAPE</code> as the arguments.
        </para>

        <para>
          If <emphasis>b</emphasis> is zero a div_by_zero error occurs and is
          handled by
        </para>

        <para>
          If <emphasis>b</emphasis> is not zero and
          <emphasis>div2</emphasis>(<emphasis>a</emphasis>,
          <emphasis>b</emphasis>) cannot be expressed in the
          <code>VARIETY</code> being used to represent <emphasis>v</emphasis> an
          overflow may occur, in which case it is handled by
          <emphasis>ov_err</emphasis>.
        </para>

        <para>
          Producers may assume that suitable masking and
          <emphasis>rem2</emphasis> by a power of two yield equally good code if
          the lower bound of <emphasis>v</emphasis> is zero.
        </para>

        <para>
          See <!-- TODO link to 7.4. Division and modulus -->Division and
          modulus<!-- end link --> for the definitions of D1, D2, M1 and M2.
        </para>
      </section>

      <section id="S22S101">
        <title>repeat</title>

        <emphasis role="bold">Encoding number</emphasis>: 100

        <programlisting>
        replab_intro:    LABEL
        start:           EXP TOP
        body:            EXP y
                   -&gt; EXP y</programlisting>

        <para>
          <emphasis>start</emphasis> is evaluated. Then
          <emphasis>body</emphasis> is evaluated.
        </para>

        <para>
          If <emphasis>body</emphasis> produces a result, this is the result of
          the whole construction. However if <emphasis>goto</emphasis> or any
          other jump to <emphasis>replab_intro</emphasis> is encountered during
          the evaluation then the current evaluation stops and
          <emphasis>body</emphasis> is evaluated again. In the canonical order
          all evaluated components are completely evaluated before any of the
          next iteration of <emphasis>body</emphasis>. The lifetime of
          <emphasis>replab_intro</emphasis> is the evaluation of
          <emphasis>body</emphasis>.
        </para>

        <para>
          The actual order of evaluation of the constituents shall be
          indistinguishable in all observable effects (apart from time) from
          that described above. Note that this specifically includes any defined
          error handling.
        </para>
      </section>

      <section id="S22S102">
        <title>return</title>

        <emphasis role="bold">Encoding number</emphasis>: 101

        <programlisting>
        arg1:            EXP x
                   -&gt; EXP BOTTOM</programlisting>

        <para>
          <emphasis>arg1</emphasis> is evaluated to produce a value,
          <emphasis>v</emphasis>. The evaluation of the immediately enclosing
          procedure ceases and <emphasis>v</emphasis> is delivered as the result
          of the procedure.
        </para>

        <para>
          Since the <emphasis>return</emphasis> construct can never produce a
          value, the <code>SHAPE</code> of its result is <code>BOTTOM</code>.
        </para>

        <para>
          All uses of <emphasis>return</emphasis> in the
          <emphasis>body</emphasis> of a <emphasis>make_proc</emphasis> or
          <emphasis>make_general_proc</emphasis> will have
          <emphasis>arg1</emphasis> with the same <code>SHAPE</code>.
        </para>
      </section>

      <section id="S22S103">
        <title>return_to_label</title>

        <emphasis role="bold">Encoding number</emphasis>: 102

        <programlisting>
        lab_val: EXP POINTER code_alignment
                   -&gt; EXP BOTTOM</programlisting>

        <para>
          <emphasis>lab_val</emphasis> will be a label value in the calling
          procedure.
        </para>

        <para>
          The evaluation of the immediately enclosing procedure ceases and
          control is passed to the calling procedure at the label given by
          <emphasis>lab_val</emphasis>.
        </para>
      </section>

      <section id="S22S104">
        <title>round_with_mode</title>

        <emphasis role="bold">Encoding number</emphasis>: 103

        <programlisting>
        flpt_err:        ERROR_TREATMENT
        mode:            ROUNDING_MODE
        r:               VARIETY
        arg1:            EXP FLOATING(f)
                   -&gt; EXP INTEGER(r)</programlisting>

        <para>
          <emphasis>arg</emphasis> is evaluated to produce a floating point
          value, <emphasis>v</emphasis>.  This is rounded to an integer of
          <code>VARIETY</code>, <emphasis>r</emphasis>, using the
          <code>ROUNDING_MODE</code>, <emphasis>mode</emphasis>. This is the
          result of the construction.
        </para>

        <para>
          If <emphasis>f</emphasis> is complex the result is derived from the
          real part of <emphasis>arg1</emphasis>.
        </para>

        <para>
          If there is a floating point error it is handled by
          <emphasis>flpt_err</emphasis>.  See <!-- TODO link to 7.21. Floating
          point errors -->Floating point errors<!-- link end -->.
        </para>
      </section>

      <section id="S22S105">
        <title>rotate_left</title>

        <emphasis role="bold">Encoding number</emphasis>: 104

        <programlisting>
        arg1:            EXP INTEGER(v)
        arg2:            EXP INTEGER(w)
                   -&gt; EXP INTEGER(v)</programlisting>

        <para>
          The value delivered by <emphasis>arg1</emphasis> is rotated left
          <emphasis>arg2</emphasis> places.
        </para>

        <para>
          <emphasis>arg2</emphasis> will be non-negative and will be strictly
          less than the number of bits needed to represent
          <emphasis>v</emphasis>.
        </para>

        <para>
          The use of this construct assumes knowledge of the representational
          variety of <emphasis>v</emphasis>.
        </para>
      </section>

      <section id="S22S106">
        <title>rotate_right</title>

        <emphasis role="bold">Encoding number</emphasis>: 105

        <programlisting>
        arg1:            EXP INTEGER(v)
        arg2:            EXP INTEGER(w)
                   -&gt; EXP INTEGER(v)</programlisting>

        <para>
          The value delivered by <emphasis>arg1</emphasis> is rotated right
          <emphasis>arg2</emphasis> places.
        </para>

        <para>
          <emphasis>arg2</emphasis> will be non-negative and will be strictly
          less than the number of bits needed to represent
          <emphasis>v</emphasis>.
        </para>

        <para>
          The use of this construct assumes knowledge of the representational
          variety of <emphasis>v</emphasis>.
        </para>
      </section>

      <section id="S22S107">
        <title>sequence</title>

        <emphasis role="bold">Encoding number</emphasis>: 106

        <programlisting>
        statements:      LIST(EXP)
        result:          EXP x
                   -&gt; EXP x</programlisting>

        <para>
          The statements are evaluated in the same order as the list,
          <emphasis>statements</emphasis>, and their results are discarded. Then
          <emphasis>result</emphasis> is evaluated and its result forms the
          result of the construction.
        </para>

        <para>
          A canonical order is one in which all the components of each statement
          are completely evaluated before any component of the next statement is
          started. A similar constraint applies between the last statement and
          the <emphasis>result</emphasis>. The actual order in which the
          statements and their components are evaluated shall be
          indistinguishable in all observable effects (apart from time) from a
          canonical order.
        </para>

        <para>
          Note that this specifically includes any defined error handling.
          However, if in any canonical order the effect of the program is
          undefined, the actual effect of the sequence is undefined.
        </para>

        <para>
          Hence constructions with <emphasis>impossible</emphasis> error
          handlers may be performed before or after those with specified error
          handlers, if the resulting order is otherwise acceptable.
        </para>
      </section>

      <section id="S22S108">
        <title>set_stack_limit</title>

        <emphasis role="bold">Encoding number</emphasis>: 107

        <programlisting>
        lim:             EXP POINTER({locals_alignment, alloca_alignment})
                   -&gt; EXP TOP</programlisting>

        <para>
          <emphasis>set_stack_limit</emphasis> sets the limits of remaining free
          stack space to <emphasis>lim</emphasis>. This include both the frame
          stack limit and the local_alloc stack. Note that, in implementations
          where the frame stack and local_alloc stack are distinct, this pointer
          will have a special representation, appropriate to its frame
          alignment. Thus the pointer should always be generated using
          <emphasis>make_stack_limit</emphasis> or its equivalent formation.
        </para>

        <para>
          Any later <emphasis>apply_general_proc</emphasis> with
          <code>PROCPROPS</code> including <emphasis>check_stack</emphasis> up
          to the dynamically next <emphasis>set_stack_limit</emphasis> will
          check that the frame required for the procedure will be within the
          frame stack limit. If it is not, normal execution is stopped and a TDF
          exception with ERROR_code <emphasis>stack_overflow</emphasis> is
          raised.
        </para>

        <para>
          Any later <emphasis>local_alloc_check</emphasis> will check that the
          locally allocated space required is within the local_alloc stack
          limit. If it is not, normal execution is stopped and a TDF exception
          with ERROR_code <emphasis>stack_overflow</emphasis> is raised.
        </para>
      </section>

      <section id="S22S109">
        <title>shape_offset</title>

        <emphasis role="bold">Encoding number</emphasis>: 108

        <programlisting>
        s:               SHAPE
                   -&gt; EXP OFFSET(alignment(s), {})</programlisting>

        <para>
          This construction delivers the <quote>size</quote> of a value of the
          given <code>SHAPE</code>.
        </para>

        <para>
          Suppose that a value of <code>SHAPE</code>, <emphasis>s</emphasis>, is
          placed in a space indicated by a
          <code>POINTER</code>(<emphasis>x</emphasis>), <emphasis>p</emphasis>,
          where <emphasis>x</emphasis> includes
          <emphasis>alignment(s</emphasis>). Suppose that a value of
          <code>SHAPE</code>, <emphasis>t</emphasis>, where
          <emphasis>a</emphasis> is
          <emphasis>alignment</emphasis>(<emphasis>t</emphasis>) and
          <emphasis>x</emphasis> includes <emphasis>a</emphasis>, is placed
          at
        </para>

        <para>
          <emphasis>add_to_ptr</emphasis>(<emphasis>p</emphasis>, <emphasis>offset_pad(a,
            shape_offset</emphasis>(<emphasis>s</emphasis>)))
        </para>

        <para>
          Then the values shall not overlap. This shall be true for all legal
          <emphasis>s</emphasis>, <emphasis>x</emphasis> and
          <emphasis>t</emphasis>.
        </para>
      </section>

      <section id="S22S110">
        <title>shift_left</title>

        <emphasis role="bold">Encoding number</emphasis>: 109

        <programlisting>
        ov_err:          ERROR_TREATMENT
        arg1:            EXP INTEGER(v)
        arg2:            EXP INTEGER(w)
                   -&gt; EXP INTEGER(v)</programlisting>

        <para>
          <emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated
          and will produce integer values, <emphasis>a</emphasis> and
          <emphasis>b</emphasis>. The value <emphasis>a</emphasis> shifted left
          <emphasis>b</emphasis> places is delivered as the result of the
          construct, with the same <code>SHAPE</code> as <emphasis>a</emphasis>.
        </para>

        <para>
          <emphasis>b</emphasis> will be non-negative and will be strictly less
          than the number of bits needed to represent <emphasis>v</emphasis>.
        </para>

        <para>
          If the result cannot be expressed in the <code>VARIETY</code> being
          used to represent <emphasis>v</emphasis>, an overflow error is caused
          and is handled in the way specified by <emphasis>ov_err</emphasis>.
        </para>

        <para>
          Producers may assume that <emphasis>shift_left</emphasis> and
          multiplication by a power of two yield equally efficient code.
        </para>
      </section>

      <section id="S22S111">
        <title>shift_right</title>

        <emphasis role="bold">Encoding number</emphasis>: 110

        <programlisting>
        arg1:            EXP INTEGER(v)
        arg2:            EXP INTEGER(w)
                   -&gt; EXP INTEGER(v)</programlisting>

        <para>
          <emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated
          and will produce integer values, <emphasis>a</emphasis> and
          <emphasis>b</emphasis>. The value <emphasis>a</emphasis> shifted right
          <emphasis>b</emphasis> places is delivered as the result of the
          construct, with the same <code>SHAPE</code> as
          <emphasis>arg1</emphasis>.
        </para>

        <para>
          <emphasis>b</emphasis> will be non-negative and will be strictly less
          than the number of bits needed to represent <emphasis>v</emphasis>.
        </para>

        <para>
          If the lower bound of <emphasis>v</emphasis> is negative, the sign
          will be propagated.
        </para>
      </section>

      <section id="S22S112">
        <title>subtract_ptrs</title>

        <emphasis role="bold">Encoding number</emphasis>: 111

        <programlisting>
        arg1:            EXP POINTER(y)
        arg2:            EXP POINTER(x)
                   -&gt; EXP OFFSET(x, y)</programlisting>

        <para>
          <emphasis>arg1</emphasis> and <emphasis>arg2</emphasis> are evaluated
          to produce pointers <emphasis>p1</emphasis> and
          <emphasis>p2</emphasis>, which will be derived from the same original
          pointer.  The result, <emphasis>r</emphasis>, is the
          <code>OFFSET</code> from <emphasis>p2</emphasis> to
          <emphasis>p1</emphasis>. Both arguments will be derived from the same
          original pointer.
        </para>

        <para>
          Note that <emphasis>add_to_ptr</emphasis>(<emphasis>p2</emphasis>,
          <emphasis>r</emphasis>) = <emphasis>p1</emphasis>.
        </para>
      </section>

      <section id="S22S113">
        <title>tail_call</title>

        <emphasis role="bold">Encoding number</emphasis>: 112

        <programlisting>
        prcprops:        OPTION(PROCPROPS)
        p:               EXP PROC
        callee_pars:     CALLEES
                   -&gt; EXP BOTTOM</programlisting>

        <para>
          <emphasis>p</emphasis> is called in the sense of
          <emphasis>apply_general_proc</emphasis> with the caller parameters of
          the immediately enclosing proc and <code>CALLEES</code> given by
          <emphasis>callee_pars</emphasis> and <code>PROCPROPS</code>
          <emphasis>prcprops</emphasis>.
        </para>

        <para>
          The result of the call is delivered as the result of the immediately
          enclosing proc in the sense of <emphasis>return</emphasis>. The
          <code>SHAPE</code> of the result of <emphasis>p</emphasis> will be
          identical to the <code>SHAPE</code> specified as the result of
          immediately enclosing procedure.
        </para>

        <para>
          The presence or absence of each of the <code>PROCPROPS</code>
          <emphasis>check_stack</emphasis> and <emphasis>untidy</emphasis>, in
          <emphasis>prcprops</emphasis> will be reflected in the
          <code>PROCPROPS</code> of the immediately enclosing procedure.
        </para>
      </section>

      <section id="S22S114">
        <title>untidy_return</title>

        <emphasis role="bold">Encoding number</emphasis>: 113

        <programlisting>
        arg1:            EXP x
                   -&gt; EXP BOTTOM</programlisting>

        <para>
          <emphasis>arg1</emphasis> is evaluated to produce a value,
          <emphasis>v</emphasis>. The evaluation of the immediately enclosing
          procedure ceases and <emphasis>v</emphasis> is delivered as the result
          of the procedure, in such a manner as that pointers to any callee
          parameters or local allocations are valid in the calling procedure.
        </para>

        <para>
          <emphasis>untidy_return</emphasis> can only occur in a procedure
          defined by <emphasis>make_general_proc</emphasis> with
          <code>PROCPROPS</code> including <emphasis>untidy</emphasis>.
        </para>
      </section>

      <section id="S22S115">
        <title>variable</title>

        <emphasis role="bold">Encoding number</emphasis>: 114

        <programlisting>
        opt_access:      OPTION(ACCESS)
        name_intro:      TAG POINTER(alignment(x))
        init:            EXP x
        body:            EXP y
                   -&gt; EXP y</programlisting>

        <para>
          <emphasis>init</emphasis> is evaluated to produce a value,
          <emphasis>v</emphasis>. Space is allocated to hold a value of
          <code>SHAPE</code> <emphasis>x</emphasis> and this is initialised with
          <emphasis>v</emphasis>. Then <emphasis>body</emphasis> is evaluated.
          During this evaluation, an original <code>POINTER</code> pointing to
          the allocated space is bound to <emphasis>name_intro</emphasis>. This
          means that inside <emphasis>body</emphasis> an evaluation of
          <emphasis>obtain_tag</emphasis>(<emphasis>name_intro</emphasis>) will
          produce a <code>POINTER</code> to this space. The lifetime of
          <emphasis>name_intro</emphasis> is the evaluation of
          <emphasis>body</emphasis>.
        </para>

        <para>
          The value delivered by <emphasis>variable</emphasis> is that produced
          by <emphasis>body</emphasis>.
        </para>

        <para>
          If <emphasis>opt_access</emphasis> contains
          <emphasis>visible</emphasis>, it means that the contents of the space
          may be altered while the procedure containing this declaration is not
          the current procedure. Hence if there are any copies of this value
          they will need to be refreshed from the variable when the procedure is
          returned to. The easiest implementation when
          <emphasis>opt_access</emphasis> is <emphasis>visible</emphasis> may be
          to keep the value in memory, but this is not a necessary requirement.
        </para>

        <para>
          The <code>TAG</code> given for <emphasis>name_intro</emphasis> will
          not be reused within the current <code>UNIT</code>. No rules for the
          hiding of one <code>TAG</code> by another are given: this will not
          happen.
        </para>

        <para>
          The order in which the constituents of <emphasis>init</emphasis> and
          <emphasis>body</emphasis> are evaluated shall be indistinguishable in
          all observable effects (apart from time) from completely evaluating
          <emphasis>init</emphasis> before starting <emphasis>body</emphasis>.
          See the note about order in <!-- TODO link to 5.16.107. sequence
          -->sequence<!-- end link -->.
        </para>

        <para>
          When compiling languages which permit uninitialised variable
          declarations, <emphasis>make_value</emphasis> may be used to provide
          an initialisation.
        </para>
      </section>

      <section id="S22S116">
        <title>xor</title>

        <emphasis role="bold">Encoding number</emphasis>: 115

        <programlisting>
        arg1:            EXP INTEGER(v)
        arg2:            EXP INTEGER(v)
                   -&gt; EXP INTEGER(v)</programlisting>

        <para>
          The arguments are evaluated producing integer values of the same
          <code>VARIETY</code>, <emphasis>v</emphasis>. The result is the
          bitwise <emphasis>xor</emphasis> of these two integers in the
          representing <code>VARIETY</code>. The result is delivered as the
          result of the construct, with the same <code>SHAPE</code> as the
          arguments.
        </para>

        <para>
          See <!-- TODO link to 7.18. Representing integers -->Representing
          integers<!-- end link -->.
        </para>
      </section>
    </section>

    <section id="S23">
      <title>EXTERNAL</title>

      <emphasis role="bold">Number of encoding bits</emphasis>: 2<sbr/>
      <emphasis role="bold">Is coding extendable</emphasis>: yes<sbr/>

      <para>
        An <code>EXTERNAL</code> defines the classes of external name available
        for connecting the internal names inside a <code>CAPSULE</code> to the
        world outside the <code>CAPSULE</code>.
      </para>

      <section id="S23S1">
        <title>string_extern</title>

        <emphasis role="bold">Encoding number</emphasis>: 1

        <programlisting>
        s:               BYTE_ALIGN TDFIDENT(n)
                   -&gt; EXTERNAL</programlisting>

        <para>
          <emphasis>string_extern</emphasis> produces an <code>EXTERNAL</code>
          identified by the <code>TDFIDENT</code> <emphasis>s</emphasis>.
        </para>
      </section>

      <section id="S23S2">
        <title>unique_extern</title>

        <emphasis role="bold">Encoding number</emphasis>: 2

        <programlisting>
        u:               BYTE_ALIGN UNIQUE
                   -&gt; EXTERNAL</programlisting>

        <para>
          <emphasis>unique_extern</emphasis> produces an <code>EXTERNAL</code>
          identified by the <code>UNIQUE</code> <emphasis>u</emphasis>.
        </para>
      </section>

      <section id="S23S3">
        <title>chain_extern</title>

        <emphasis role="bold">Encoding number</emphasis>: 3

        <programlisting>
        s:               BYTE_ALIGN TDFIDENT
        prev:            TDFINT
                   -&gt; EXTERNAL</programlisting>

        <para>
          This construct is redundant and should not be used.
        </para>
      </section>
    </section>

    <section id="S24">
      <title>EXTERN_LINK</title>

      <emphasis role="bold">Number of encoding bits</emphasis>: 0<sbr/>
      <emphasis role="bold">Is coding extendable</emphasis>: no<sbr/>

      <para>
        An auxiliary <code>SORT</code> providing a list of
        <code>LINKEXTERN</code>.
      </para>

      <section id="S24S1">
        <title>make_extern_link</title>

        <emphasis role="bold">Encoding number</emphasis>: 0

        <programlisting>
        el:              SLIST(LINKEXTERN)
                   -&gt; EXTERN_LINK</programlisting>

        <para>
          <emphasis>make_capsule</emphasis> requires a
          <code>SLIST</code>(<code>EXTERN_LINK</code>) to express the links
          between the linkable entities and the named (by
          <code>EXTERNAL</code>s) values outside the <code>CAPSULE</code>.
        </para>
      </section>
    </section>

    <section id="S25">
      <title>FLOATING_VARIETY</title>

      <emphasis role="bold">Number of encoding bits</emphasis>: 3<sbr/>
      <emphasis role="bold">Is coding extendable</emphasis>: yes<sbr/>

      <para>
        These describe kinds of floating point number.
      </para>

      <section id="S25S1">
        <title>flvar_apply_token</title>

        <emphasis role="bold">Encoding number</emphasis>: 1

        <programlisting>
        token_value:     TOKEN
        token_args:      BITSTREAM param_sorts(token_value)
                   -&gt; FLOATING_VARIETY</programlisting>

        <para>
          The token is applied to the arguments to give a
          <code>FLOATING_VARIETY</code>
        </para>

        <para>
          If there is a definition for <emphasis>token_value</emphasis> in the
          <code>CAPSULE</code> then <emphasis>token_args</emphasis> is a
          <code>BITSTREAM</code> encoding of the <code>SORT</code>s of its
          parameters, in the order specified.
        </para>
      </section>

      <section id="S25S2">
        <title>flvar_cond</title>

        <emphasis role="bold">Encoding number</emphasis>: 2

        <programlisting>
        control: EXP INTEGER(v)
        e1:              BITSTREAM FLOATING_VARIETY
        e2:              BITSTREAM FLOATING_VARIETY
                   -&gt; FLOATING_VARIETY</programlisting>

        <para>
          The <emphasis>control</emphasis> is evaluated. It will be a constant
          at install time under the constant evaluation rules. If it is
          non-zero, <emphasis>e1</emphasis> is installed at this point and
          <emphasis>e2</emphasis> is ignored and never processed.  If
          <emphasis>control</emphasis> is zero then <emphasis>e2</emphasis> is
          installed at this point and <emphasis>e1</emphasis> is ignored and
          never processed.
        </para>
      </section>

      <section id="S25S3">
        <title>flvar_parms</title>

        <emphasis role="bold">Encoding number</emphasis>: 3

        <programlisting>
        base:            NAT
        mantissa_digs:   NAT
        min_exponent:    NAT
        max_exponent:    NAT
                   -&gt; FLOATING_VARIETY</programlisting>

        <para>
          <emphasis>base</emphasis> is the base with respect to which the
          remaining numbers refer. <emphasis>base</emphasis> will be a power of
          2.
        </para>

        <para>
          <emphasis>mantissa_digs</emphasis> is the required number of
          <emphasis>base</emphasis> digits, <emphasis>q</emphasis>, such that
          any number with <emphasis>q</emphasis> digits can be rounded to a
          floating point number of the variety and back again without any change
          to the <emphasis>q</emphasis> digits.
        </para>

        <para>
          <emphasis>min_exponent</emphasis> is the negative of the required
          minimum integer such that <emphasis>base</emphasis> raised to that
          power can be represented as a non-zero floating point number in the
          <code>FLOATING_VARIETY</code>.
        </para>

        <para>
          <emphasis>max_exponent</emphasis> is the required maximum integer such
          that <emphasis>base</emphasis> raised to that power can be represented
          in the <code>FLOATING_VARIETY</code>.
        </para>

        <para>
          A TDF translator is required to make available a representing
          <code>FLOATING_VARIETY</code> such that, if only values within the
          given requirements are produced, no overflow error will occur. Where
          several such representative <code>FLOATING_VARIETY</code>s exist, the
          translator will choose one to minimise space requirements or maximise
          the speed of operations.
        </para>

        <para>
          All numbers of the form xb1  M*<emphasis>base N+1-q</emphasis> are
          required to be represented exactly where M and N are integers such
          that<sbr/> <emphasis>base</emphasis><emphasis>q-1</emphasis>  M &lt;
          <emphasis>base</emphasis><emphasis>q</emphasis><sbr/>
          -<emphasis>min_exponent</emphasis>  N
          <emphasis>max_exponent</emphasis>
        </para>

        <para>
          Zero will also be represented exactly in any
          <code>FLOATING_VARIETY</code>.
        </para>
      </section>

      <section id="S25S4">
        <title>complex_parms</title>

        <emphasis role="bold">Encoding number</emphasis>: 4

        <programlisting>
        base:            NAT
        mantissa_digs:   NAT
        min_exponent:    NAT
        max_exponent:    NAT
                   -&gt; FLOATING_VARIETY</programlisting>

        <para>
          A <code>FLOATING_VARIETY</code> described by
          <emphasis>complex_parms</emphasis> holds a complex number which is
          likely to be represented by its real and imaginary parts, each of
          which is as if defined by <emphasis>flvar_parms</emphasis> with the
          same arguments.
        </para>
      </section>

      <section id="S25S5">
        <title>float_of_complex</title>

        <emphasis role="bold">Encoding number</emphasis>: 5

        <programlisting>
        csh:             SHAPE
                   -&gt; FLOATING_VARIETY</programlisting>

        <para>
          <emphasis>csh</emphasis> will be a complex <code>SHAPE</code>.
        </para>

        <para>
          Delivers the <code>FLOATING_VARIETY</code> required for the real (or
          imaginary) part of a complex <code>SHAPE</code>
          <emphasis>csh</emphasis>.
        </para>
      </section>

      <section id="S25S6">
        <title>complex_of_float</title>

        <emphasis role="bold">Encoding number</emphasis>: 6

        <programlisting>
        fsh:             SHAPE
                   -&gt; FLOATING_VARIETY</programlisting>

        <para>
          <emphasis>fsh</emphasis> will be a floating <code>SHAPE</code>.
        </para>

        <para>
          Delivers <code>FLOATING_VARIETY</code> required for a complex number
          whose real (and imaginary) parts have <code>SHAPE</code>
          <emphasis>fsh</emphasis>.
        </para>
      </section>
    </section>

    <section id="S26">
      <title>GROUP</title>

      <emphasis role="bold">Number of encoding bits</emphasis>: 0<sbr/>
      <emphasis role="bold">Is coding extendable</emphasis>: no<sbr/>

      <para>
        A <code>GROUP</code> is a list of <code>UNIT</code>s with the same
        unit identification.
      </para>

      <section id="S26S1">
        <title>make_group</title>

        <emphasis role="bold">Encoding number</emphasis>: 0

        <programlisting>
        us:              SLIST(UNIT)
                   -&gt; GROUP</programlisting>

        <para>
          <emphasis>make_capsule</emphasis> contains a list of
          <code>GROUPS</code>. Each member of this list has a different unit
          identification deduced from the <emphasis>prop_name</emphasis>
          argument of <emphasis>make_capsule</emphasis>.
        </para>
      </section>
    </section>

    <section id="S27">
      <title>LABEL</title>

      <emphasis role="bold">Number of encoding bits</emphasis>: 1<sbr/>
      <emphasis role="bold">Is coding extendable</emphasis>: yes<sbr/>

      <para>
        A <code>LABEL</code> marks an <code>EXP</code> in certain constructions,
        and is used in jump-like constructions to change the control to the
        labelled construction.
      </para>

      <section id="S27S1">
        <title>label_apply_token</title>

        <emphasis role="bold">Encoding number</emphasis>: 2

        <programlisting>
        token_value:     TOKEN
        token_args:      BITSTREAM param_sorts(token_value)
                   -&gt; LABEL x</programlisting>

        <para>
          The token is applied to the arguments to give a <code>LABEL</code>.
        </para>

        <para>
          If there is a definition for <emphasis>token_value</emphasis> in the
          <code>CAPSULE</code> then <emphasis>token_args</emphasis> is a
          <code>BITSTREAM</code> encoding of the <code>SORT</code>s of its
          parameters, in the order specified.
        </para>
      </section>

      <section id="S27S2">
        <title>make_label</title>

        <emphasis role="bold">Encoding number</emphasis>: 1

        <programlisting>
        labelno: TDFINT
                   -&gt; LABEL</programlisting>

        <para>
          Labels are represented in TDF by integers, but they are not linkable.
          Hence the definition and all uses of a <code>LABEL</code> occur in the
          same <code>UNIT</code>.
        </para>
      </section>
    </section>

    <section id="S28">
      <title>LINK</title>

      <emphasis role="bold">Number of encoding bits</emphasis>: 0<sbr/>
      <emphasis role="bold">Is coding extendable</emphasis>: no<sbr/>

      <para>
        A <code>LINK</code> expresses the connection between two variables of
        the same <code>SORT</code>.
      </para>

      <section id="S28S1">
        <title>make_link</title>

        <emphasis role="bold">Encoding number</emphasis>: 0

        <programlisting>
        unit_name:       TDFINT
        capsule_name:    TDFINT
                   -&gt; LINK</programlisting>

        <para>
          A <code>LINK</code> defines a linkable entity declared inside a
          <code>UNIT</code> as <emphasis>unit_name</emphasis> to correspond to a
          <code>CAPSULE</code> linkable entity having the same linkable entity
          identification. The <code>CAPSULE</code> linkable entity is
          <emphasis>capsule_name</emphasis>.
        </para>

        <para>
          A <code>LINK</code> is normally constructed by the TDF builder in the
          course of resolving sharing and name clashes when constructing a
          composite <code>CAPSULE</code>.
        </para>
      </section>
    </section>

    <section id="S29">
      <title>LINKEXTERN</title>

      <emphasis role="bold">Number of encoding bits</emphasis>: 0<sbr/>
      <emphasis role="bold">Is coding extendable</emphasis>: no<sbr/>

      <para>
        A value of <code>SORT LINKEXTERN</code> expresses the connection between
        the name by which an object is known inside a <code>CAPSULE</code> and a
        name by which it is known outside.
      </para>

      <section id="S29S1">
        <title>make_linkextern</title>

        <emphasis role="bold">Encoding number</emphasis>: 0

        <programlisting>
        internal:        TDFINT
        ext:             EXTERNAL
                   -&gt; LINKEXTERN</programlisting>

        <para>
          <emphasis>make_linkextern</emphasis> produces a
          <code>LINKEXTERN</code> connecting an object identified within a
          <code>CAPSULE</code> by a <code>TAG</code>, <code>TOKEN</code>,
          <code>AL_TAG</code> or any linkable entity constructed from
          <emphasis>internal</emphasis>, with an <code>EXTERNAL</code>,
          <emphasis>ext</emphasis>. The <code>EXTERNAL</code> is an identifier
          which linkers and similar programs can use.
        </para>
      </section>
    </section>

    <section id="S30">
      <title>LINKS</title>

      <emphasis role="bold">Number of encoding bits</emphasis>: 0<sbr/>
      <emphasis role="bold">Is coding extendable</emphasis>: no<sbr/>

      <section id="S30S1">
        <title>make_links</title>

        <emphasis role="bold">Encoding number</emphasis>: 0

        <programlisting>
        ls:              SLIST(LINK)
                   -&gt; LINKS</programlisting>

        <para>
          <emphasis>make_unit</emphasis> uses a
          <code>SLIST</code>(<code>LINKS</code>) to define which linkable
          entities within a <code>UNIT</code> correspond to the
          <code>CAPSULE</code> linkable entities. Each <code>LINK</code> in a
          <code>LINKS</code> has the same linkable entity identification.
        </para>
      </section>
    </section>

    <section id="S31">
      <title>NAT</title>

      <emphasis role="bold">Number of encoding bits</emphasis>: 3<sbr/>
      <emphasis role="bold">Is coding extendable</emphasis>: yes<sbr/>

      <para>
        These are non-negative integers of unlimited size.
      </para>

      <section id="S31S1">
        <title>nat_apply_token</title>

        <emphasis role="bold">Encoding number</emphasis>: 1

        <programlisting>
        token_value:     TOKEN
        token_args:      BITSTREAM param_sorts(token_value)
                   -&gt; NAT</programlisting>

        <para>
          The token is applied to the arguments to give a <code>NAT</code>.
        </para>

        <para>
          If there is a definition for <emphasis>token_value</emphasis> in the
          <code>CAPSULE</code> then <emphasis>token_args</emphasis> is a
          <code>BITSTREAM</code> encoding of the <code>SORT</code>s of its
          parameters, in the order specified.
        </para>
      </section>

      <section id="S31S2">
        <title>nat_cond</title>

        <emphasis role="bold">Encoding number</emphasis>: 2

        <programlisting>
        control: EXP INTEGER(v)
        e1:              BITSTREAM NAT
        e2:              BITSTREAM NAT
                   -&gt; NAT</programlisting>

        <para>
          The <emphasis>control</emphasis> is evaluated. It will be a constant
          at install time under the constant evaluation rules. If it is
          non-zero, <emphasis>e1</emphasis> is installed at this point and
          <emphasis>e2</emphasis> is ignored and never processed.  If
          <emphasis>control</emphasis> is zero then <emphasis>e2</emphasis> is
          installed at this point and <emphasis>e1</emphasis> is ignored and
          never processed.
        </para>
      </section>

      <section id="S31S3">
        <title>computed_nat</title>

        <emphasis role="bold">Encoding number</emphasis>: 3

        <programlisting>
        arg:             EXP INTEGER(v)
                   -&gt; NAT</programlisting>

        <para>
          <emphasis>arg</emphasis> will be an install-time non-negative
          constant. The result is that constant.
        </para>
      </section>

      <section id="S31S4">
        <title>error_val</title>

        <emphasis role="bold">Encoding number</emphasis>: 4

        <programlisting>
        err:             ERROR_code
                   -&gt; NAT</programlisting>

        <para>
          Gives the <code>NAT</code> corresponding to the
          <code>ERROR_code</code> <emphasis>err</emphasis>. Each distinct
          <code>ERROR_code</code> will give a different <code>NAT</code>.
        </para>
      </section>

      <section id="S31S5">
        <title>make_nat</title>

        <emphasis role="bold">Encoding number</emphasis>: 5

        <programlisting>
        n:               TDFINT
                   -&gt; NAT</programlisting>

        <para>
          <emphasis>n</emphasis> is a non-negative integer of unbounded
          magnitude.
        </para>
      </section>
    </section>

    <section id="S32">
      <title>NTEST</title>

      <emphasis role="bold">Number of encoding bits</emphasis>: 4<sbr/>
      <emphasis role="bold">Is coding extendable</emphasis>: yes<sbr/>

      <para>
        These describe the comparisons which are possible in the various
        <emphasis>test</emphasis> constructions. Note that
        <emphasis>greater_than</emphasis> is not necessarily the same as
        <emphasis>not_less_than_or_equal</emphasis>, since the result need not
        be defined (e.g. in IEEE floating point).
      </para>

      <section id="S32S1">
        <title>ntest_apply</title>

        <emphasis role="bold">Encoding number</emphasis>: 1

        <programlisting>
        token_value:     TOKEN
        token_args:      BITSTREAM param_sorts(token_value)
                   -&gt; NTEST</programlisting>

        <para>
          The token is applied to the arguments to give a <code>NTEST</code>.
        </para>

        <para>
          If there is a definition for <emphasis>token_value</emphasis> in the
          <code>CAPSULE</code> then <emphasis>token_args</emphasis> is a
          <code>BITSTREAM</code> encoding of the <code>SORT</code>s of its
          parameters, in the order specified.
        </para>
      </section>

      <section id="S32S2">
        <title>ntest_cond</title>

        <emphasis role="bold">Encoding number</emphasis>: 2

        <programlisting>
        control: EXP INTEGER(v)
        e1:              BITSTREAM NTEST
        e2:              BITSTREAM NTEST
                   -&gt; NTEST</programlisting>

        <para>
          The <emphasis>control</emphasis> is evaluated. It will be a constant
          at install time under the constant evaluation rules. If it is
          non-zero, <emphasis>e1</emphasis> is installed at this point and
          <emphasis>e2</emphasis> is ignored and never processed.  If
          <emphasis>control</emphasis> is zero then <emphasis>e2</emphasis> is
          installed at this point and <emphasis>e1</emphasis> is ignored and
          never processed.
        </para>
      </section>

      <section id="S32S3">
        <title>equal</title>

        <emphasis role="bold">Encoding number</emphasis>: 3

        <programlisting>
                   -&gt; NTEST</programlisting>

        <para>
          Signifies <quote>equal</quote> test.
        </para>
      </section>

      <section id="S32S4">
        <title>greater_than</title>

        <emphasis role="bold">Encoding number</emphasis>: 4

        <programlisting>
                   -&gt; NTEST</programlisting>

        <para>
          Signifies <quote>greater than</quote> test.
        </para>
      </section>

      <section id="S32S5">
        <title>greater_than_or_equal</title>

        <emphasis role="bold">Encoding number</emphasis>: 5

        <programlisting>
                   -&gt; NTEST</programlisting>

        <para>
          Signifies <quote>greater than or equal</quote> test.
        </para>
      </section>

      <section id="S32S6">
        <title>less_than</title>

        <emphasis role="bold">Encoding number</emphasis>: 6

        <programlisting>
                   -&gt; NTEST</programlisting>

        <para>
          Signifies <quote>less than</quote> test.
        </para>
      </section>

      <section id="S32S7">
        <title>less_than_or_equal</title>

        <emphasis role="bold">Encoding number</emphasis>: 7

        <programlisting>
                   -&gt; NTEST</programlisting>

        <para>
          Signifies <quote>less than or equal</quote> test.
        </para>
      </section>

      <section id="S32S8">
        <title>not_equal</title>

        <emphasis role="bold">Encoding number</emphasis>: 8

        <programlisting>
                   -&gt; NTEST</programlisting>

        <para>
          Signifies <quote>not equal</quote> test.
        </para>
      </section>

      <section id="S32S9">
        <title>not_greater_than</title>

        <emphasis role="bold">Encoding number</emphasis>: 9

        <programlisting>
                   -&gt; NTEST</programlisting>

        <para>
          Signifies <quote>not greater than</quote> test.
        </para>
      </section>

      <section id="S32S10">
        <title>not_greater_than_or_equal</title>

        <emphasis role="bold">Encoding number</emphasis>: 10

        <programlisting>
                   -&gt; NTEST</programlisting>

        <para>
          Signifies <quote>not (greater than or equal)</quote> test.
        </para>
      </section>

      <section id="S32S11">
        <title>not_less_than</title>

        <emphasis role="bold">Encoding number</emphasis>: 11

        <programlisting>
                   -&gt; NTEST</programlisting>

        <para>
          Signifies <quote>not less than</quote> test.
        </para>
      </section>

      <section id="S32S12">
        <title>not_less_than_or_equal</title>

        <emphasis role="bold">Encoding number</emphasis>: 12

        <programlisting>
                   -&gt; NTEST</programlisting>

        <para>
          Signifies <quote>not (less than or equal)</quote> test.
        </para>
      </section>

      <section id="S32S13">
        <title>less_than_or_greater_than</title>

        <emphasis role="bold">Encoding number</emphasis>: 13

        <programlisting>
                   -&gt; NTEST</programlisting>

        <para>
          Signifies <quote>less than or greater than</quote> test.
        </para>
      </section>

      <section id="S32S14">
        <title>not_less_than_and_not_greater_than</title>

        <emphasis role="bold">Encoding number</emphasis>: 14

        <programlisting>
                   -&gt; NTEST</programlisting>

        <para>
          Signifies <quote>not less than and not greater than</quote> test.
        </para>
      </section>

      <section id="S32S15">
        <title>comparable</title>

        <emphasis role="bold">Encoding number</emphasis>: 15

        <programlisting>
                   -&gt; NTEST</programlisting>

        <para>
          Signifies <quote>comparable</quote> test.
        </para>

        <para>
          With all operands <code>SHAPE</code>s except <code>FLOATING</code>,
          this comparison is always true.
        </para>
      </section>

      <section id="S32S16">
        <title>not_comparable</title>

        <emphasis role="bold">Encoding number</emphasis>: 16

        <programlisting>
                   -&gt; NTEST</programlisting>

        <para>
          Signifies <quote>not comparable</quote> test.
        </para>

        <para>
          With all operands <code>SHAPE</code>s except <code>FLOATING</code>,
          this comparison is always false.
        </para>
      </section>
    </section>

    <section id="S33">
      <title>OTAGEXP</title>

      <emphasis role="bold">Number of encoding bits</emphasis>: 0<sbr/>
      <emphasis role="bold">Is coding extendable</emphasis>: no<sbr/>

      <para>
        This is a auxilliary <code>SORT</code> used in
        <emphasis>apply_general_proc</emphasis>.
      </para>

      <section id="S33S1">
        <title>make_otagexp</title>

        <emphasis role="bold">Encoding number</emphasis>: 0

        <programlisting>
        tgopt:           OPTION(TAG x)
        e:               EXP x
                   -&gt; OTAGEXP</programlisting>

        <para>
          <emphasis>e</emphasis> is evaluated and its value is the actual caller
          parameter. If <emphasis>tgopt</emphasis> is present, the
          <code>TAG</code> will be bound to the final value of caller parameter
          in the <emphasis>postlude</emphasis> part of the
          <emphasis>apply_general_proc</emphasis>.
        </para>
      </section>
    </section>

    <section id="S34">
      <title>PROCPROPS</title>

      <emphasis role="bold">Number of encoding bits</emphasis>: 4<sbr/>
      <emphasis role="bold">Is coding extendable</emphasis>: yes<sbr/>

      <para>
        <code>PROCPROPS</code> is a set of properties ascribed to procedure
        definitions and calls.
      </para>

      <section id="S34S1">
        <title>procprops_apply_token</title>

        <emphasis role="bold">Encoding number</emphasis>: 1

        <programlisting>
        token_value:     TOKEN
        token_args:      BITSTREAM param_sorts(token_value)
                   -&gt; PROCPROPS</programlisting>

        <para>
          The token is applied to the arguments to give a
          <code>PROCPROPS</code>.
        </para>

        <para>
          If there is a definition for <emphasis>token_value</emphasis> in the
          <code>CAPSULE</code> then <emphasis>token_args</emphasis> is a
          <code>BITSTREAM</code> encoding of the <code>SORT</code>s of its
          parameters in the order specified.
        </para>
      </section>

      <section id="S34S2">
        <title>procprops_cond</title>

        <emphasis role="bold">Encoding number</emphasis>: 2

        <programlisting>
        control: EXP INTEGER(v)
        e1:              BITSTREAM PROCPROPS
        e2:              BITSTREAM PROCPROPS
                   -&gt; PROCPROPS</programlisting>

        <para>
          The <emphasis>control</emphasis> is evaluated. It will be a constant
          at install time under the constant evaluation rules. If it is
          non-zero, <emphasis>e1</emphasis> is installed at this point and
          <emphasis>e2</emphasis> is ignored and never processed.  If
          <emphasis>control</emphasis> is zero then <emphasis>e2</emphasis> is
          installed at this point and <emphasis>e1</emphasis> is ignored and
          never processed.
        </para>
      </section>

      <section id="S34S3">
        <title>add_procprops</title>

        <emphasis role="bold">Encoding number</emphasis>: 3

        <programlisting>
        arg1:            PROCPROPS
        arg2:            PROCPROPS
                   -&gt; PROCPROPS</programlisting>

        <para>
          Delivers the join of <emphasis>arg1</emphasis> and <emphasis>arg2</emphasis>.
        </para>
      </section>

      <section id="S34S4">
        <title>check_stack</title>

        <emphasis role="bold">Encoding number</emphasis>: 4

        <programlisting>
                   -&gt; PROCPROPS</programlisting>

        <para>
          The procedure body is required to check for stack overflow.
        </para>
      </section>

      <section id="S34S5">
        <title>inline</title>

        <emphasis role="bold">Encoding number</emphasis>: 5

        <programlisting>
                   -&gt; PROCPROPS</programlisting>

        <para>
          The procedure body is a good candidate for inlining at its
          application.
        </para>
      </section>

      <section id="S34S6">
        <title>no_long_jump_dest</title>

        <emphasis role="bold">Encoding number</emphasis>: 6

        <programlisting>
                   -&gt; PROCPROPS</programlisting>

        <para>
          The procedure body will contain no label which is the destination
          of a long_jump.
        </para>
      </section>

      <section id="S34S7">
        <title>untidy</title>

        <emphasis role="bold">Encoding number</emphasis>: 7

        <programlisting>
                   -&gt; PROCPROPS</programlisting>

        <para>
          The procedure body may be exited using an
          <emphasis>untidy_return</emphasis>.
        </para>
      </section>

      <section id="S34S8">
        <title>var_callees</title>

        <emphasis role="bold">Encoding number</emphasis>: 8

        <programlisting>
                   -&gt; PROCPROPS</programlisting>

        <para>
          Applications of the procedure may have different numbers of actual
          callee parameters.
        </para>
      </section>

      <section id="S34S9">
        <title>var_callers</title>

        <emphasis role="bold">Encoding number</emphasis>: 9

        <programlisting>
                   -&gt; PROCPROPS</programlisting>

        <para>
          Applications of the procedure may have different numbers of actual
          caller parameters.
        </para>
      </section>
    </section>

    <section id="S35">
      <title>PROPS</title>

      <para>
        A <code>PROPS</code> is an assemblage of program information. This
        standard offers various ways of constructing a <code>PROPS</code>
        - i.e. it defines kinds of information which it is useful to express.
        These are:
      </para>

      <itemizedlist>
        <listitem>
          <para>
            definitions of <code>AL_TAG</code>s standing for
            <code>ALIGNMENT</code>s;
          </para>
        </listitem>

        <listitem>
          <para>
            declarations of <code>TAG</code>s standing for <code>EXP</code>s;
          </para>
        </listitem>

        <listitem>
          <para>
            definitions of the <code>EXP</code>s for which <code>TAG</code>s
            stand;
          </para>
        </listitem>

        <listitem>
          <para>
            declarations of <code>TOKEN</code>s standing for pieces of TDF
            program;
          </para>
        </listitem>

        <listitem>
          <para>
            definitions of the pieces of TDF program for which
            <code>TOKEN</code>s stand;
          </para>
        </listitem>

        <listitem>
          <para>
            linkage and naming information;
          </para>
        </listitem>

        <listitem>
          <para>
            version information
          </para>
        </listitem>
      </itemizedlist>

      <para>
        <code>PROPS</code> giving diagnostic information are described in
        a separate document.
      </para>

      <para>
        The standard can be extended by the definition of new kinds of
        <code>PROPS</code> information and new <code>PROPS</code> constructs for
        expressing them; and private standards can define new kinds of
        information and corresponding constructs without disruption to adherents
        to the present standard.
      </para>

      <para>
        Each <code>GROUP</code> of <code>UNIT</code>s is identified by a unit
        identification - a <code>TDFIDENT</code>. All the <code>UNIT</code>s in
        that <code>GROUP</code> are of the same kind.
      </para>

      <para>
        In addition there is a <emphasis>tld</emphasis> <code>UNIT</code>, see
        <!-- TODO link to 8.4. The TDF encoding -->The TDF encoding<!-- link end
        -->.
      </para>
    </section>

    <section id="S36">
      <title>ROUNDING_MODE</title>

      <emphasis role="bold">Number of encoding bits</emphasis>: 3<sbr/>
      <emphasis role="bold">Is coding extendable</emphasis>: yes<sbr/>

      <para>
        <code>ROUNDING_MODE</code> specifies the way rounding is to be performed
        in floating point arithmetic.
      </para>

      <section id="S36S1">
        <title>rounding_mode_apply_token</title>

        <emphasis role="bold">Encoding number</emphasis>: 1

        <programlisting>
        token_value:     TOKEN
        token_args:      BITSTREAM param_sorts(token_value)
                   -&gt; ROUNDING_MODE</programlisting>

        <para>
          The token is applied to the arguments to give a
          <code>ROUNDING_MODE</code>.
        </para>

        <para>
          If there is a definition for <emphasis>token_value</emphasis> in the
          <code>CAPSULE</code> then <emphasis>token_args</emphasis> is a
          <code>BITSTREAM</code> encoding of the <code>SORT</code>s of its
          parameters, in the order specified.
        </para>
      </section>

      <section id="S36S2">
        <title>rounding_mode_cond</title>

        <emphasis role="bold">Encoding number</emphasis>: 2

        <programlisting>
        control: EXP INTEGER(v)
        e1:              BITSTREAM ROUNDING_MODE
        e2:              BITSTREAM ROUNDING_MODE
                   -&gt; ROUNDING_MODE</programlisting>

        <para>
          The <emphasis>control</emphasis> is evaluated. It will be a constant
          at install time under the constant evaluation rules. If it is
          non-zero, <emphasis>e1</emphasis> is installed at this point and
          <emphasis>e2</emphasis> is ignored and never processed.  If
          <emphasis>control</emphasis> is zero then <emphasis>e2</emphasis> is
          installed at this point and <emphasis>e1</emphasis> is ignored and
          never processed.
        </para>
      </section>

      <section id="S36S3">
        <title>round_as_state</title>

        <emphasis role="bold">Encoding number</emphasis>: 3

        <programlisting>
                   -&gt; ROUNDING_MODE</programlisting>

        <para>
          Round as specified by the current state of the machine.
        </para>
      </section>

      <section id="S36S4">
        <title>to_nearest</title>

        <emphasis role="bold">Encoding number</emphasis>: 4

        <programlisting>
                   -&gt; ROUNDING_MODE</programlisting>

        <para>
          Signifies rounding to nearest. The effect when the number lies
          half-way is not specified.
        </para>
      </section>

      <section id="S36S5">
        <title>toward_larger</title>

        <emphasis role="bold">Encoding number</emphasis>: 5

        <programlisting>
                   -&gt; ROUNDING_MODE</programlisting>

        <para>
          Signifies rounding toward next largest.
        </para>
      </section>

      <section id="S36S6">
        <title>toward_smaller</title>

        <emphasis role="bold">Encoding number</emphasis>: 6

        <programlisting>
                   -&gt; ROUNDING_MODE</programlisting>

        <para>
          Signifies rounding toward next smallest.
        </para>
      </section>

      <section id="S36S7">
        <title>toward_zero</title>

        <emphasis role="bold">Encoding number</emphasis>: 7

        <programlisting>
                   -&gt; ROUNDING_MODE</programlisting>

        <para>
          Signifies rounding toward zero.
        </para>
      </section>
    </section>

    <section id="S37">
      <title>SHAPE</title>

      <emphasis role="bold">Number of encoding bits</emphasis>: 4<sbr/>
      <emphasis role="bold">Is coding extendable</emphasis>: yes<sbr/>

      <para>
        <code>SHAPE</code>s express symbolic size and representation information
        about run time values.
      </para>

      <para>
        <code>SHAPE</code>s are constructed from primitive <code>SHAPE</code>s
        which describe values such as procedures and integers, and recursively
        from compound construction in terms of other <code>SHAPE</code>s.
      </para>

      <section id="S37S1">
        <title>shape_apply_token</title>

        <emphasis role="bold">Encoding number</emphasis>: 1

        <programlisting>
        token_value:     TOKEN
        token_args:      BITSTREAM param_sorts(token_value)
                   -&gt; SHAPE</programlisting>

        <para>
          The token is applied to the arguments to give a <code>SHAPE</code>.
        </para>

        <para>
          If there is a definition for <emphasis>token_value</emphasis> in the
          <code>CAPSULE</code> then <emphasis>token_args</emphasis> is a
          <code>BITSTREAM</code> encoding of the <code>SORT</code>s of its
          parameters, in the order specified.
        </para>
      </section>

      <section id="S37S2">
        <title>shape_cond</title>

        <emphasis role="bold">Encoding number</emphasis>: 2

        <programlisting>
        control: EXP INTEGER(v)
        e1:              BITSTREAM SHAPE
        e2:              BITSTREAM SHAPE
                   -&gt; SHAPE</programlisting>

        <para>
          The <emphasis>control</emphasis> is evaluated. It will be a constant
          at install time under the constant evaluation rules. If it is
          non-zero, <emphasis>e1</emphasis> is installed at this point and
          <emphasis>e2</emphasis> is ignored and never processed.  If
          <emphasis>control</emphasis> is zero then <emphasis>e2</emphasis> is
          installed at this point and <emphasis>e1</emphasis> is ignored and
          never processed.
        </para>
      </section>

      <section id="S37S3">
        <title>bitfield</title>

        <emphasis role="bold">Encoding number</emphasis>: 3

        <programlisting>
        bf_var:          BITFIELD_VARIETY
                   -&gt; SHAPE</programlisting>

        <para>
          A <code>BITFIELD</code> is used to represent a pattern of bits which
          will be packed, provided that the
          <emphasis>variety_enclosed</emphasis> constraints are not violated.
          (see See <!-- TODO link to 7.24. Representing bitfields -->section
          7.24<!-- link end -->)
        </para>

        <para>
          A <code>BITFIELD_VARIETY</code> specifies the number of bits and
          whether they are considered to be signed.
        </para>

        <para>
          There are very few operations on <code>BITFIELD</code>s, which have to
          be converted to <code>INTEGER</code>s before arithmetic can be
          performed on them.
        </para>

        <para>
          An installer may place a limit on the number of bits it implements.
          See <!-- TODO link to 7.25. Permitted limits -->Permitted limits<!--
          link end -->.
        </para>
      </section>

      <section id="S37S4">
        <title>bottom</title>

        <emphasis role="bold">Encoding number</emphasis>: 4

        <programlisting>
                   -&gt; SHAPE</programlisting>

        <para>
          <code>BOTTOM</code> is the <code>SHAPE</code> which describes a piece
          of program which does not evaluate to any result. Examples include
          <emphasis>goto</emphasis> and <emphasis>return</emphasis>.
        </para>

        <para>
          If <code>BOTTOM</code> is a parameter to any other <code>SHAPE</code>
          constructor, the result is <code>BOTTOM</code>.
        </para>
      </section>

      <section id="S37S5">
        <title>compound</title>

        <emphasis role="bold">Encoding number</emphasis>: 5

        <programlisting>
        sz:              EXP OFFSET(x, y)
                   -&gt; SHAPE</programlisting>

        <para>
          The <code>SHAPE</code> constructor <code>COMPOUND</code> describes
          cartesian products and unions.
        </para>

        <para>
          The alignments <emphasis>x</emphasis> and <emphasis>y</emphasis> will
          be <emphasis>alignment</emphasis>(<emphasis>sx</emphasis>) and
          <emphasis>alignment</emphasis>(<emphasis>sy</emphasis>) for some
          <code>SHAPE</code>s <emphasis>sx</emphasis> and
          <emphasis>sy</emphasis>.
        </para>

        <para>
          <emphasis>sz</emphasis> will evaluate to a constant, non-negative
          <code>OFFSET</code>
          (see <!-- TODO link to 5.16.87. offset_pad -->offset_pad<!-- end link
          -->). The resulting <code>SHAPE</code> describes a value whose size is
          given by <emphasis>sz</emphasis>.
        </para>
      </section>

      <section id="S37S6">
        <title>floating</title>

        <emphasis role="bold">Encoding number</emphasis>: 6

        <programlisting>
        fv:              FLOATING_VARIETY
                   -&gt; SHAPE</programlisting>

        <para>
          Most of the floating point arithmetic operations,
          <emphasis>floating_plus</emphasis>,
          <emphasis>floating_minus</emphasis> etc., are defined to work in the
          same way on different kinds of floating point number. If these
          operations have more than one argument the arguments have to be of the
          same kind, and the result is of the same kind.
        </para>

        <para>
          See <!-- TODO link to 7.20. Representing floating point
          -->Representing floating point<!-- link end -->.
        </para>

        <para>
          An installer may limit the <code>FLOATING_VARIETY</code>s it can
          represent. A statement of any such limits shall be part of the
          specification of an installer. See <!-- TODO link to 7.20.
          Representing floating point -->Representing floating point<!-- link
          end -->.
        </para>
      </section>

      <section id="S37S7">
        <title>integer</title>

        <emphasis role="bold">Encoding number</emphasis>: 7

        <programlisting>
        var:             VARIETY
                   -&gt; SHAPE</programlisting>

        <para>
          The different kinds of <code>INTEGER</code> are distinguished by
          having different <code>VARIETY</code>s. A fundamental
          <code>VARIETY</code> (not a <code>TOKEN</code> or conditional) is
          represented by two <code>SIGNED_NAT</code>s, respectively the lower
          and upper bounds (inclusive) of the set of values belonging to the
          <code>VARIETY</code>.
        </para>

        <para>
          Most architectures require that dyadic integer arithmetic operations
          take arguments of the same size, and so TDF does likewise. Because TDF
          is completely architecture neutral and makes no assumptions about word
          length, this means that the <code>VARIETY</code>s of the two arguments
          must be identical. An example illustrates this. A piece of TDF which
          attempted to add two values whose <code>SHAPE</code>s were:
        </para>

        <para>
                  INTEGER(0, 60000)  <emphasis>and</emphasis>  INTEGER(0, 30000)
        </para>

        <para>
          would be undefined. The reason is that without knowledge of the target
          architecture's word length, it is impossible to guarantee that the two
          values are going to be represented in the same number of bytes.  On a
          16-bit machine they probably would, but not on a 15-bit machine.  The
          only way to ensure that two <code>INTEGER</code>s are going to be
          represented in the same way in all machines is to stipulate that their
          <code>VARIETY</code>s are exactly the same.
        </para>

        <para>
          When any construct delivering an <code>INTEGER</code> of a given
          <code>VARIETY</code> produces a result which is not representable in
          the space which an installer has chosen to represent that
          <code>VARIETY</code>, an integer overflow occurs. Whether it occurs in
          a particular case depends on the target, because the installers'
          decisions on representation are inherently target-defined.
        </para>

        <para>
          A particular installer may limit the ranges of integers that it
          implements. See <!-- TODO link to 7.18. Representing integers
          -->Representing integers<!-- end link -->.
        </para>
      </section>

      <section id="S37S8">
        <title>nof</title>

        <emphasis role="bold">Encoding number</emphasis>: 8

        <programlisting>
        n:               NAT
        s:               SHAPE
                   -&gt; SHAPE</programlisting>

        <para>
          The <code>NOF</code> constructor describes the <code>SHAPE</code> of a
          value consisting of an array of <emphasis>n</emphasis> values of the
          same <code>SHAPE</code>, <emphasis>s</emphasis>.
        </para>
      </section>

      <section id="S37S9">
        <title>offset</title>

        <emphasis role="bold">Encoding number</emphasis>: 9

        <programlisting>
        arg1:            ALIGNMENT
        arg2:            ALIGNMENT
                   -&gt; SHAPE</programlisting>

        <para>
          The <code>SHAPE</code> constructor <code>OFFSET</code> describes
          values which represent the differences between <code>POINTER</code>s,
          that is they measure offsets in memory. It should be emphasised that
          these are in general run-time values.
        </para>

        <para>
          An <code>OFFSET</code> measures the displacement from the value
          indicated by a <code>POINTER</code>(<emphasis>arg1</emphasis>) to the
          value indicated by a <code>POINTER</code>(<emphasis>arg2</emphasis>).
          Such an offset is only defined if the <code>POINTER</code>s are
          derived from the same original <code>POINTER</code>.
        </para>

        <para>
          An <code>OFFSET</code> may also measure the displacement from a
          <code>POINTER</code> to the start of a <code>BITFIELD_VARIETY</code>,
          or from the start of one <code>BITFIELD_VARIETY</code> to the start of
          another. Hence, unlike the argument of <emphasis>pointer</emphasis>,
          <emphasis>arg1</emphasis> or <emphasis>arg2</emphasis> may consist
          entirely of <code>BITFIELD_VARIETY</code>s.
        </para>

        <para>
          The set <emphasis>arg1</emphasis> will include the set
          <emphasis>arg2</emphasis>.
        </para>

        <para>
          See <!-- TODO link to 7.13. Memory Model -->Memory Model<!-- link end
          -->.
        </para>
      </section>

      <section id="S37S10">
        <title>pointer</title>

        <emphasis role="bold">Encoding number</emphasis>: 10

        <programlisting>
        arg:             ALIGNMENT
                   -&gt; SHAPE</programlisting>

        <para>
          A <code>POINTER</code> is a value which points to space allocated in a
          computer's memory. The <code>POINTER</code> constructor takes an
          <code>ALIGNMENT</code> argument. This argument will not consist
          entirely of <code>BITFIELD_VARIETY</code>s. See <!-- TODO link to
          7.13. Memory Model -->Memory Model<!-- end link -->.
        </para>
      </section>

      <section id="S37S11">
        <title></title>

        <emphasis role="bold">Encoding number</emphasis>: 11

        <programlisting>
                   -&gt; SHAPE</programlisting>

        <para>
          <code>PROC</code> is the <code>SHAPE</code> which describes pieces
          of program.
        </para>
      </section>

      <section id="S37S12">
        <title>top</title>

        <emphasis role="bold">Encoding number</emphasis>: 12

        <programlisting>
                   -&gt; SHAPE</programlisting>

        <para>
          <code>TOP</code> is the <code>SHAPE</code> which describes pieces
          of program which return no useful value. assign is an example:
          it performs an assignment, but does not deliver any useful value.
        </para>
      </section>
    </section>

    <section id="S38">
      <title>SIGNED_NAT</title>

      <emphasis role="bold">Number of encoding bits</emphasis>: 3<sbr/>
      <emphasis role="bold">Is coding extendable</emphasis>: yes<sbr/>

      <para>
        These are positive or negative integers of unbounded size.
      </para>

      <section id="S38S1">
        <title>signed_nat_apply_token</title>

        <emphasis role="bold">Encoding number</emphasis>: 1

        <programlisting>
        token_value:     TOKEN
        token_args:      BITSTREAM param_sorts(token_value)
                   -&gt; SIGNED_NAT</programlisting>

        <para>
          The token is applied to the arguments to give a
          <code>SIGNED_NAT</code>.
        </para>

        <para>
          If there is a definition for <emphasis>token_value</emphasis> in the
          <code>CAPSULE</code> then <emphasis>token_args</emphasis> is a
          <code>BITSTREAM</code> encoding of the <code>SORT</code>s of its
          parameters, in the order specified.
        </para>
      </section>

      <section id="S38S2">
        <title>signed_nat_cond</title>

        <emphasis role="bold">Encoding number</emphasis>: 2

        <programlisting>
        control: EXP INTEGER(v)
        e1:              BITSTREAM SIGNED_NAT
        e2:              BITSTREAM SIGNED_NAT
                   -&gt; SIGNED_NAT</programlisting>

        <para>
          The <emphasis>control</emphasis> is evaluated. It will be a constant
          at install time under the constant evaluation rules. If it is
          non-zero, <emphasis>e1</emphasis> is installed at this point and
          <emphasis>e2</emphasis> is ignored and never processed.  If
          <emphasis>control</emphasis> is zero then <emphasis>e2</emphasis> is
          installed at this point and <emphasis>e1</emphasis> is ignored and
          never processed.
        </para>
      </section>

      <section id="S38S3">
        <title>computed_signed_nat</title>

        <emphasis role="bold">Encoding number</emphasis>: 3

        <programlisting>
        arg:             EXP INTEGER(v)
                   -&gt; SIGNED_NAT</programlisting>

        <para>
          <emphasis>arg</emphasis> will be an install-time constant. The result
          is that constant.
        </para>
      </section>

      <section id="S38S4">
        <title>make_signed_nat</title>

        <emphasis role="bold">Encoding number</emphasis>: 4

        <programlisting>
        neg:             TDFBOOL
        n:               TDFINT
                   -&gt; SIGNED_NAT</programlisting>

        <para>
          <emphasis>n</emphasis> is a non-negative integer of unbounded
          magnitude. The result is negative if and only if
          <emphasis>neg</emphasis> is true.
        </para>
      </section>

      <section id="S38S5">
        <title>snat_from_nat</title>

        <emphasis role="bold">Encoding number</emphasis>: 5

        <programlisting>
        neg:             BOOL
        n:               NAT
                   -&gt; SIGNED_NAT</programlisting>

        <para>
          The result is negated if and only if <emphasis>neg</emphasis> is true.
        </para>
      </section>
    </section>

    <section id="S39">
      <title>SORTNAME</title>

      <emphasis role="bold">Number of encoding bits</emphasis>: 5<sbr/>
      <emphasis role="bold">Is coding extendable</emphasis>: yes<sbr/>

      <para>
        These are the names of the <code>SORT</code>s which can be parameters of
        <code>TOKEN</code> definitions.
      </para>

      <section id="S39S1">
        <title>access</title>

        <emphasis role="bold">Encoding number</emphasis>: 1

        <programlisting>
                   -&gt; SORTNAME</programlisting>
      </section>

      <section id="S39S2">
        <title>al_tag</title>

        <emphasis role="bold">Encoding number</emphasis>: 2

        <programlisting>
                   -&gt; SORTNAME</programlisting>
      </section>

      <section id="S39S3">
        <title>alignment_sort</title>

        <emphasis role="bold">Encoding number</emphasis>: 3

        <programlisting>
                   -&gt; SORTNAME</programlisting>
      </section>

      <section id="S39S4">
        <title>bitfield_variety</title>

        <emphasis role="bold">Encoding number</emphasis>: 4

        <programlisting>
                   -&gt; SORTNAME</programlisting>
      </section>

      <section id="S39S5">
        <title>bool</title>

        <emphasis role="bold">Encoding number</emphasis>: 5

        <programlisting>
                   -&gt; SORTNAME</programlisting>
      </section>

      <section id="S39S6">
        <title>error_treatment</title>

        <emphasis role="bold">Encoding number</emphasis>: 6

        <programlisting>
                   -&gt; SORTNAME</programlisting>
      </section>

      <section id="S39S7">
        <title>exp</title>

        <emphasis role="bold">Encoding number</emphasis>: 7

        <programlisting>
                   -&gt; SORTNAME</programlisting>
      </section>

      <section id="S39S8">
        <title>floating_variety</title>

        <emphasis role="bold">Encoding number</emphasis>: 8

        <programlisting>
                   -&gt; SORTNAME</programlisting>
      </section>

      <section id="S39S9">
        <title>foreign_sort</title>

        <emphasis role="bold">Encoding number</emphasis>: 9

        <programlisting>
        foreign_name:    STRING(k, n)
                   -&gt; SORTNAME</programlisting>

        <para>
          This <code>SORT</code> enables unanticipated kinds of information to
          be placed in TDF.
        </para>
      </section>

      <section id="S39S10">
        <title>label</title>

        <emphasis role="bold">Encoding number</emphasis>: 10

        <programlisting>
                   -&gt; SORTNAME</programlisting>
      </section>

      <section id="S39S11">
        <title>nat</title>

        <emphasis role="bold">Encoding number</emphasis>: 11

        <programlisting>
                   -&gt; SORTNAME</programlisting>
      </section>

      <section id="S39S12">
        <title>ntest</title>

        <emphasis role="bold">Encoding number</emphasis>: 12

        <programlisting>
                   -&gt; SORTNAME</programlisting>
      </section>

      <section id="S39S13">
        <title>procprops</title>

        <emphasis role="bold">Encoding number</emphasis>: 13

        <programlisting>
                   -&gt; SORTNAME</programlisting>
      </section>

      <section id="S39S14">
        <title>rounding_mode</title>

        <emphasis role="bold">Encoding number</emphasis>: 14

        <programlisting>
                   -&gt; SORTNAME</programlisting>
      </section>

      <section id="S39S15">
        <title>shape</title>

        <emphasis role="bold">Encoding number</emphasis>: 15

        <programlisting>
                   -&gt; SORTNAME</programlisting>
      </section>

      <section id="S39S16">
        <title>signed_nat</title>

        <emphasis role="bold">Encoding number</emphasis>: 16

        <programlisting>
                   -&gt; SORTNAME</programlisting>
      </section>

      <section id="S39S17">
        <title>string</title>

        <emphasis role="bold">Encoding number</emphasis>: 17

        <programlisting>
                   -&gt; SORTNAME</programlisting>
      </section>

      <section id="S39S18">
        <title>tag</title>

        <emphasis role="bold">Encoding number</emphasis>: 18

        <programlisting>
                   -&gt; SORTNAME</programlisting>

        <para>
          The <code>SORT</code> of <code>TAG</code>.
        </para>
      </section>

      <section id="S39S19">
        <title>transfer_mode</title>

        <emphasis role="bold">Encoding number</emphasis>: 19

        <programlisting>
                   -&gt; SORTNAME</programlisting>
      </section>

      <section id="S39S20">
        <title>token</title>

        <emphasis role="bold">Encoding number</emphasis>: 20

        <programlisting>
        result:          SORTNAME
        params:          LIST(SORTNAME)
                   -&gt; SORTNAME
        </programlisting>

        <para>
          The <code>SORTNAME</code> of a <code>TOKEN</code>. Note that it can
          have tokens as parameters, but not as result.
        </para>
      </section>

      <section id="S39S21">
        <title>variety</title>

        <emphasis role="bold">Encoding number</emphasis>: 21

        <programlisting>
                   -&gt; SORTNAME
        </programlisting>
      </section>
    </section>

    <section id="S40">
      <title>STRING</title>

      <emphasis role="bold">Number of encoding bits</emphasis>: 3<sbr/>
      <emphasis role="bold">Is coding extendable</emphasis>: yes<sbr/>


      <section id="S40S1">
        <title>string_apply_token</title>

        <emphasis role="bold">Encoding number</emphasis>: 1

        <programlisting>
        token_value:     TOKEN
        token_args:      BITSTREAM param_sorts(token_value)
                   -&gt; STRING(k, n)</programlisting>

        <para>
          The token is applied to the arguments to give a <code>STRING</code>
        </para>

        <para>
          If there is a definition for <emphasis>token_value</emphasis> in the
          <code>CAPSULE</code> then <emphasis>token_args</emphasis> is a
          <code>BITSTREAM</code> encoding of the <code>SORT</code>s of its
          parameters, in the order specified.
        </para>
      </section>

      <section id="S40S2">
        <title>string_cond</title>

        <emphasis role="bold">Encoding number</emphasis>: 2

        <programlisting>
        control: EXP INTEGER(v)
        e1:              BITSTREAM STRING
        e2:              BITSTREAM STRING
                   -&gt; STRING(k, n)</programlisting>

        <para>
          The <emphasis>control</emphasis> is evaluated. It will be a constant
          at install time under the constant evaluation rules. If it is
          non-zero, <emphasis>e1</emphasis> is installed at this point and
          <emphasis>e2</emphasis> is ignored and never processed.  If
          <emphasis>control</emphasis> is zero then <emphasis>e2</emphasis> is
          installed at this point and <emphasis>e1</emphasis> is ignored and
          never processed.
        </para>
      </section>

      <section id="S40S3">
        <title>concat_string</title>

        <emphasis role="bold">Encoding number</emphasis>: 3

        <programlisting>
        arg1:            STRING(k, n)
        arg2:            STRING(k, m)
                   -&gt; STRING(k, n+m)</programlisting>

        <para>
          Gives a <code>STRING</code> which is the concatenation of
          <emphasis>arg1</emphasis> with <emphasis>arg2</emphasis>.
        </para>
      </section>

      <section id="S40S4">
        <title>make_string</title>

        <emphasis role="bold">Encoding number</emphasis>: 4

        <programlisting>
        arg:             TDFSTRING(k, n)
                   -&gt; STRING(k, n)</programlisting>

        <para>
          Delivers the <code>STRING</code> identical to the
          <emphasis>arg</emphasis>.
        </para>
      </section>
    </section>

    <section id="S41">
      <title></title>

      <emphasis role="bold">Number of encoding bits</emphasis>: 1
      <emphasis role="bold">Is coding extendable</emphasis>: yes<sbr/>
      <emphasis role="bold">Linkable entity identification</emphasis>: tag<sbr/>

      <para>
        These are used to name values and variables in the run time program.
      </para>

      <section id="S41S1">
        <title>tag_apply_token</title>

        <emphasis role="bold">Encoding number</emphasis>: 2

        <programlisting>
        token_value:     TOKEN
        token_args:      BITSTREAM param_sorts(token_value)
                   -&gt; TAG x</programlisting>

        <para>
          The token is applied to the arguments to give a <code>TAG</code>.
        </para>

        <para>
          If there is a definition for <emphasis>token_value</emphasis> in the
          <code>CAPSULE</code> then <emphasis>token_args</emphasis> is a
          <code>BITSTREAM</code> encoding of the <code>SORT</code>s of its
          parameters, in the order specified.
        </para>
      </section>

      <section id="S41S2">
        <title>make_tag</title>

        <emphasis role="bold">Encoding number</emphasis>: 1

        <programlisting>
        tagno:           TDFINT
                   -&gt; TAG x</programlisting>

        <para>
          <emphasis>make_tag</emphasis> produces a <code>TAG</code> identified
          by <emphasis>tagno</emphasis>.
        </para>
      </section>
    </section>

    <section id="S42">
      <title>TAGACC</title>

      <emphasis role="bold">Number of encoding bits</emphasis>: 0<sbr/>
      <emphasis role="bold">Is coding extendable</emphasis>: no<sbr/>

      <para>
        Constructs a pair of a <code>TAG</code> and an
        <code>OPTION(ACCESS)</code> for use in <emphasis>make_proc</emphasis>.
      </para>

      <section id="S42S1">
        <title>make_tagacc</title>

        <emphasis role="bold">Encoding number</emphasis>: 0

        <programlisting>
        tg:              TAG POINTER var_param_alignment
        acc:             OPTION(ACCESS)
                   -&gt; TAGACC</programlisting>

        <para>
          Constructs the pair for <emphasis>make_proc</emphasis>.
        </para>
      </section>
    </section>

    <section id="S43">
      <title>TAGDEC</title>

      <emphasis role="bold">Number of encoding bits</emphasis>: 2<sbr/>
      <emphasis role="bold">Is coding extendable</emphasis>: yes<sbr/>

      <para>
        A <code>TAGDEC</code> declares a <code>TAG</code> for incorporation
        into a <code>TAGDEC_PROPS.</code>
      </para>

      <section id="S43S1">
        <title>make_id_tagdec</title>

        <emphasis role="bold">Encoding number</emphasis>: 1

        <programlisting>
        t_intro: TDFINT
        acc:             OPTION(ACCESS)
        signature:       OPTION(STRING)
        x:               SHAPE
                   -&gt; TAGDEC</programlisting>

        <para>
          A <code>TAGDEC</code> announcing that the <code>TAG</code>
          <emphasis>t_intro</emphasis> identifies an <code>EXP</code> of
          <code>SHAPE</code> <emphasis>x</emphasis> is constructed.
        </para>

        <para>
          <emphasis>acc</emphasis> specifies the <code>ACCESS</code> properties
          of the <code>TAG</code>.
        </para>

        <para>
          If there is a <emphasis>make_id_tagdec</emphasis> for a
          <code>TAG</code> then all other <emphasis>make_id_tagdec</emphasis>
          for the same <code>TAG</code> will specify the same <code>SHAPE</code>
          and there will be no <emphasis>make_var_tagdec</emphasis> or
          <emphasis>common_tagdec</emphasis> for the <code>TAG</code>.
        </para>

        <para>
          If two <emphasis>make_id_tagdecs</emphasis> specify the same tag and
          both have <emphasis>signatures</emphasis> present, the strings will be
          identical. Possible uses of this signature argument are outlined in
          <!-- TODO link to 7.28. Tag and Token signatures -->section 7.28<!--
          end link -->.
        </para>
      </section>

      <section id="S43S2">
        <title>make_var_tagdec</title>

        <emphasis role="bold">Encoding number</emphasis>: 2

        <programlisting>
        t_intro: TDFINT
        acc:             OPTION(ACCESS)
        signature:       OPTION(STRING)
        x:               SHAPE
                   -&gt; TAGDEC</programlisting>

        <para>
          A <code>TAGDEC</code> announcing that the <code>TAG</code>
          <emphasis>t_intro</emphasis> identifies an <code>EXP</code> of
          <code>SHAPE POINTER</code>(<emphasis>alignment
          </emphasis>(<emphasis>x</emphasis>)) is constructed.
        </para>

        <para>
          <emphasis>acc</emphasis> specifies the <code>ACCESS</code> properties
          of the <code>TAG</code>.
        </para>

        <para>
          If there is a <emphasis>make_var_tagdec</emphasis> for a
          <code>TAG</code> then all other <emphasis>make_var_tagdec</emphasis>s
          for the same <code>TAG</code> will specify <code>SHAPE</code>s with
          identical <code>ALIGNMENT</code> and there will be no
          <emphasis>make_id_tagdec</emphasis> or
          <emphasis>common_tagdec</emphasis> for the <code>TAG</code>.
        </para>

        <para>
          If two <emphasis>make_var_tagdec</emphasis>s specify the same tag and
          both have <emphasis>signature</emphasis> present, the strings will be
          identical. Possible uses of this signature argument are outlined in
          <!-- TODO link to 7.28. Tag and Token signatures -->section 7.28<!--
          link end -->.
        </para>
      </section>

      <section id="S43S3">
        <title>common_tagdec</title>

        <emphasis role="bold">Encoding number</emphasis>: 3

        <programlisting>
        t_intro: TDFINT
        acc:             OPTION(ACCESS)
        signature:       OPTION(STRING)
        x:               SHAPE
                   -&gt; TAGDEC</programlisting>

        <para>
          A <code>TAGDEC</code> announcing that the <code>TAG</code>
          <emphasis>t_intro</emphasis> identifies an <code>EXP</code> of
          <code>SHAPE POINTER</code>(<emphasis>alignment
          </emphasis>(<emphasis>x</emphasis>)) is constructed.
        </para>

        <para>
          <emphasis>acc</emphasis> specifies the <code>ACCESS</code> properties
          of the <code>TAG</code>.
        </para>

        <para>
          If there is a <emphasis>common_tagdec</emphasis> for a
          <code>TAG</code> then there will be no
          <emphasis>make_id_tagdec</emphasis> or
          <emphasis>make_var_tagdec</emphasis> for that <code>TAG</code>. If
          there is more than one <emphasis>common_tagdec</emphasis> for a
          <code>TAG</code> the one having the maximum <code>SHAPE</code> shall
          be taken to apply for the <code>CAPSULE</code>. Each pair of such
          <code>SHAPE</code>s will have a maximum. The maximum of two
          <code>SHAPE</code>s, <emphasis>a</emphasis> and
          <emphasis>b</emphasis>, is defined as follows:
        </para>

        <itemizedlist>
          <listitem>
            <para>
              If the <emphasis>a</emphasis> is equal to <emphasis>b</emphasis>
              the maximum is <emphasis>a</emphasis>.
            </para>
          </listitem>

          <listitem>
            <para>
              If <emphasis>a</emphasis> and <emphasis>b</emphasis> are
              <code>COMPOUND</code>(<emphasis>x</emphasis>) and
              <code>COMPOUND</code>(<emphasis>y</emphasis>) respectively and
              <emphasis>a</emphasis> is an initial segment of
              <emphasis>b</emphasis>, then <emphasis>b</emphasis> is the
              maximum. Similarly if <emphasis>b</emphasis> is an initial segment
              of <emphasis>a</emphasis> then <emphasis>a</emphasis> is the
              maximum.
            </para>
          </listitem>

          <listitem>
            <para>
              If <emphasis>a</emphasis> and <emphasis>b</emphasis> are
              <code>NOF</code>(<emphasis>n</emphasis>, <emphasis>x</emphasis>)
              and <code>NOF</code>(<emphasis>m</emphasis>,
              <emphasis>x</emphasis>) respectively and <emphasis>n</emphasis> is
              less than or equal to <emphasis>m</emphasis>, then
              <emphasis>b</emphasis> is the maximum.  Similarly if
              <emphasis>m</emphasis> is less than or equal to
              <emphasis>n</emphasis> then <emphasis>a</emphasis> is the maximum.
            </para>
          </listitem>

          <listitem>
            <para>
              Otherwise <emphasis>a</emphasis> and <emphasis>b</emphasis> have
              no maximum.
            </para>
          </listitem>
        </itemizedlist>

        <para>
          If two <emphasis>common_tagdecs</emphasis> specify the same tag and
          both have <emphasis>signatures</emphasis> present, the strings will be
          identical. Possible uses of this signature argument are outlined in
          <!-- TODO link to 7.28. Tag and Token signatures -->section 7.28<!--
          link end -->.
        </para>
      </section>
    </section>

    <section id="S44">
      <title>TAGDEC_PROPS</title>

      <emphasis role="bold">Number of encoding bits</emphasis>: 0<sbr/>
      <emphasis role="bold">Is coding extendable</emphasis>: no<sbr/>
      <emphasis role="bold">Unit identification</emphasis>: tagdec

      <section id="S44S1">
        <title>make_tagdecs</title>

        <emphasis role="bold">Encoding number</emphasis>: 0

        <programlisting>
        no_labels:       TDFINT
        tds:             SLIST(TAGDEC)
                   -&gt; TAGDEC_PROPS</programlisting>

        <para>
          <emphasis>no_labels</emphasis> is the number of local
          <code>LABEL</code>s used in <emphasis>tds</emphasis>.
          <emphasis>tds</emphasis> is a list of <code>TAGDEC</code>s which
          declare the <code>SHAPE</code>s associated with <code>TAG</code>s.
        </para>
      </section>
    </section>

    <section id="S45">
      <title>TAGDEF</title>

      <emphasis role="bold">Number of encoding bits</emphasis>: 2<sbr/>
      <emphasis role="bold">Is coding extendable</emphasis>: yes<sbr/>

      <para>
        A value of <code>SORT TAGDEF</code> gives the definition of a
        <code>TAG</code> for incorporation into a <code>TAGDEF_PROPS</code>.
      </para>

      <section id="S45S1">
        <title>make_id_tagdef</title>

        <emphasis role="bold">Encoding number</emphasis>: 1

        <programlisting>
        t:               TDFINT
        signature:       OPTION(STRING)
        e:               EXP x
                   -&gt; TAGDEF</programlisting>

        <para>
          <emphasis>make_id_tagdef</emphasis> produces a <code>TAGDEF</code>
          defining the <code>TAG</code> <emphasis>x</emphasis> constructed from
          the <code>TDFINT</code>, <emphasis>t</emphasis>. This <code>TAG</code>
          is defined to stand for the value delivered by <emphasis>e</emphasis>.
        </para>

        <para>
          <emphasis>e</emphasis> will be a constant which can be evaluated at
          load_time or <emphasis>e</emphasis> will be some
          <emphasis>initial_value</emphasis>(E) (see <!-- TODO link to 5.16.48.
          initial_value -->section 5.16.48<!-- end link -->).
        </para>

        <para>
          <emphasis>t</emphasis> will be declared in the <code>CAPSULE</code>
          using <emphasis>make_id_tagdec</emphasis>.  If both the
          <emphasis>make_id_tagdec</emphasis> and
          <emphasis>make_id_tagdef</emphasis> have
          <emphasis>signatures</emphasis> present, the strings will be
          identical.
        </para>

        <para>
          If <emphasis>x</emphasis> is <code>PROC</code> and the
          <code>TAG</code> represented by <emphasis>t</emphasis> is named
          externally via a <code>CAPSULE_LINK</code>, e will be some
          <emphasis>make_proc</emphasis> or
          <emphasis>make_general_proc</emphasis>.
        </para>

        <para>
          There will not be more than one <code>TAGDEF</code> defining
          <emphasis>t</emphasis> in a <code>CAPSULE</code>.
        </para>
      </section>

      <section id="S45S2">
        <title>make_var_tagdef</title>

        <emphasis role="bold">Encoding number</emphasis>: 2

        <programlisting>
        t:               TDFINT
        opt_access:      OPTION(ACCESS)
        signature:       OPTION(STRING)
        e:               EXP x
                   -&gt; TAGDEF</programlisting>

        <para>
          <emphasis>make_var_tagdef</emphasis> produces a <code>TAGDEF</code>
          defining the <code>TAG
          POINTER</code>(<emphasis>alignment(x)</emphasis>) constructed from
          the <code>TDFINT</code>, <emphasis>t</emphasis>. This <code>TAG</code>
          stands for a variable which is initialised with the value delivered by
          <emphasis>e</emphasis>.  The <code>TAG</code> is bound to an original
          pointer which has the evaluation of the program as its lifetime.
        </para>

        <para>
          If <emphasis>opt_access</emphasis> contains
          <emphasis>visible</emphasis>, the meaning is that the variable may be
          used by agents external to the capsule, and so it must not be
          optimised away. If it contains constant, the initialising value will
          remain in it throughout the program.
        </para>

        <para>
          <emphasis>e</emphasis> will be a constant which can be evaluated at
          load_time or <emphasis>e</emphasis> will be some
          <emphasis>initial_value</emphasis>(<emphasis>e1</emphasis>) (see <!--
          TODO link to 5.16.48. initial_value -->section 5.16.48<!-- link end
          -->).
        </para>

        <para>
          <emphasis>t</emphasis> will be declared in the <code>CAPSULE</code>
          using <emphasis>make_var_tagdec</emphasis>.  If both the
          <emphasis>make_var_tagdec</emphasis> and
          <emphasis>make_var_tagdef</emphasis> have
          <emphasis>signatures</emphasis> present, the strings will be
          identical.
        </para>

        <para>
          There will not be more than one <code>TAGDEF</code> defining
          <emphasis>t</emphasis> in a <code>CAPSULE</code>.
        </para>
      </section>

      <section id="S45S3">
        <title>common_tagdef</title>

        <emphasis role="bold">Encoding number</emphasis>: 3

        <programlisting>
        t:               TDFINT
        opt_access:      OPTION(ACCESS)
        signature:       OPTION(STRING)
        e:               EXP x
                   -&gt; TAGDEF</programlisting>

        <para>
          <emphasis>common_tagdef</emphasis> produces a <code>TAGDEF</code>
          defining the <code>TAG</code>
          <code>POINTER</code>(<emphasis>alignment(x)</emphasis>) constructed
          from the <code>TDFINT</code>, <emphasis>t</emphasis>. This
          <code>TAG</code> stands for a variable which is initialised with the
          value delivered by <emphasis>e</emphasis>.  The <code>TAG</code> is
          bound to an original pointer which has the evaluation of the program
          as its lifetime.
        </para>

        <para>
          If <emphasis>opt_access</emphasis> contains
          <emphasis>visible</emphasis>, the meaning is that the variable may be
          used by agents external to the capsule, and so it must not be
          optimised away. If it contains constant, the initialising value will
          remain in it throughout the program.
        </para>

        <para>
          <emphasis>e</emphasis> will be a constant evaluable at load_time or
          <emphasis>e</emphasis> will be some
          <emphasis>initial_value</emphasis>(E) (see <!-- TODO link to 5.16.48.
          initial_value -->section 5.16.48 <!-- end link -->).
        </para>

        <para>
          <emphasis>t</emphasis> will be declared in the <code>CAPSULE</code>
          using <emphasis>common_tagdec</emphasis>.If both the
          <emphasis>common_tagdec</emphasis> and
          <emphasis>common_tagdef</emphasis> have
          <emphasis>signatures</emphasis> present, the strings will be
          identical. Let the maximum <code>SHAPE</code> of these (see
          <!-- TODO link to 5.37.3. common_tagdec -->common_tagdec<!-- link end
          -->) be <emphasis>s</emphasis>.
        </para>

        <para>
          There may be any number of <emphasis>common_tagdef</emphasis>
          definitions for <emphasis>t</emphasis> in a <code>CAPSULE</code>. Of
          the <emphasis>e</emphasis> parameters of these, one will be a maximum.
          This maximum definition is chosen as the definition of
          <emphasis>t</emphasis>. Its value of <emphasis>e</emphasis> will have
          <code>SHAPE</code> <emphasis>s</emphasis>.
        </para>

        <para>
          The maximum of two <emphasis>common_tagdef</emphasis>
          <code>EXP</code>s, <emphasis>a</emphasis> and <emphasis>b</emphasis>,
          is defined as follows:
        </para>

        <itemizedlist>
          <listitem>
            <para>
              If <emphasis>a</emphasis> has the form
              <emphasis>make_value</emphasis>(<emphasis>s</emphasis>),
              <emphasis>b</emphasis> is the maximum.
            </para>
          </listitem>

          <listitem>
            <para>
              If <emphasis>b</emphasis> has the form
              <emphasis>make_value</emphasis>(<emphasis>s</emphasis>),
              <emphasis>a</emphasis> is the maximum.
            </para>
          </listitem>

          <listitem>
            <para>
              If <emphasis>a</emphasis> and <emphasis>b</emphasis> have
              <code>SHAPE COMPOUND</code>(<emphasis>x</emphasis>) and
              <code>COMPOUND</code>(<emphasis>y</emphasis>) respectively and the
              value produced by <emphasis>a</emphasis> is an initial segment of
              the value produced by <emphasis>b</emphasis>, then
              <emphasis>b</emphasis> is the maximum. Similarly if
              <emphasis>b</emphasis> is an initial segment of
              <emphasis>a</emphasis> then <emphasis>a</emphasis> is the maximum.
            </para>
          </listitem>

          <listitem>
            <para>
              If <emphasis>a</emphasis> and <emphasis>b</emphasis> have
              <code>SHAPE NOF</code>(<emphasis>n</emphasis>,
              <emphasis>x</emphasis>) and
              <code>NOF</code>(<emphasis>m</emphasis>, <emphasis>x</emphasis>)
              respectively and the value produced by <emphasis>a</emphasis> is
              an initial segment of the value produced by
              <emphasis>b</emphasis>, then <emphasis>b</emphasis> is the
              maximum. Similarly if <emphasis>b</emphasis> is an initial segment
              of <emphasis>a</emphasis> then <emphasis>a</emphasis> is the
              maximum.
            </para>
          </listitem>

          <listitem>
            <para>
              If the value produced by <emphasis>a</emphasis> is equal to the
              value produced by <emphasis>b</emphasis> the maximum is
              <emphasis>a</emphasis>.
            </para>
          </listitem>

          <listitem>
            <para>
              Otherwise <emphasis>a</emphasis> and <emphasis>b</emphasis> have
              no maximum.
            </para>
          </listitem>
        </itemizedlist>
      </section>
    </section>

    <section id="S46">
      <title>TAGDEF_PROPS</title>

      <emphasis role="bold">Number of encoding bits</emphasis>: 0<sbr/>
      <emphasis role="bold">Is coding extendable</emphasis>: no<sbr/>
      <emphasis role="bold">Unit identification</emphasis>: tagdef

      <section id="S46S1">
        <title>make_tagdefs</title>

        <emphasis role="bold">Encoding number</emphasis>: 0

        <programlisting>
        no_labels:       TDFINT
        tds:             SLIST(TAGDEF)
                   -&gt; TAGDEF_PROPS</programlisting>

        <para>
          <emphasis>no_labels</emphasis> is the number of local
          <code>LABEL</code>s used in <emphasis>tds</emphasis>.
          <emphasis>tds</emphasis> is a list of <code>TAGDEF</code>s which give
          the <code>EXP</code>s which are the definitions of values associated
          with <code>TAG</code>s.
        </para>
      </section>
    </section>

    <section id="S47">
      <title>TAGSHACC</title>

      <emphasis role="bold">Number of encoding bits</emphasis>: 0<sbr/>
      <emphasis role="bold">Is coding extendable</emphasis>: no<sbr/>

      <section id="S47S1">
        <title>make_tagshacc</title>

        <emphasis role="bold">Encoding number</emphasis>: 0

        <programlisting>
        sha:             SHAPE
        opt_access:      OPTION(ACCESS)
        tg_intro:        TAG
                   -&gt; TAGSHACC</programlisting>

        <para>
          This is an auxiliary construction to make the elements of
          <emphasis>params_intro</emphasis> in <emphasis>make_proc</emphasis>.
        </para>
      </section>
    </section>

    <section id="S48">
      <title>TDFBOOL</title>

      <para>
        A <code>TDFBOOL</code> is the TDF encoding of a boolean. See <!-- TODO
        link to 8.2. Fundamental encodings -->Fundamental encoding<!-- link end
        -->.
      </para>
    </section>

    <section id="S49">
      <title>TDFIDENT</title>

      <para>
        A <code>TDFIDENT</code>(<emphasis>k</emphasis>, <emphasis>n</emphasis>)
        encodes a sequence of <emphasis>n</emphasis> unsigned integers of size
        <emphasis>k</emphasis> bits. <emphasis>k</emphasis> will be a multiple
        of 8. See <!-- TODO link to 8.2. Fundamental encodings -->Fundamental
        encoding<!-- end link -->.
      </para>

      <para>
        This construction will not be used inside a <code>BITSTREAM</code>.
      </para>
    </section>

    <section id="S50">
      <title>TDFINT</title>

      <para>
        A <code>TDFINT</code> is the TDF encoding of an unbounded unsigned
        integer constant. See <!-- TODO link to 8.2. Fundamental encodings
        -->Fundamental encoding<!-- end link -->.
      </para>
    </section>

    <section id="S51">
      <title>TDFSTRING</title>

      <para>
        A <code>TDFSTRING</code>(<emphasis>k</emphasis>, <emphasis>n</emphasis>)
        encodes a sequence of <emphasis>n</emphasis> unsigned integers of size
        <emphasis>k</emphasis> bits. See <!-- TODO link to 8.2. Fundamental
        encodings -->Fundamental encoding<!-- end link -->.
      </para>
    </section>

    <section id="S52">
      <title>TOKDEC</title>

      <emphasis role="bold">Number of encoding bits</emphasis>: 1<sbr/>
      <emphasis role="bold">Is coding extendable</emphasis>: yes<sbr/>

      <para>
        A <code>TOKDEC</code> declares a <code>TOKEN</code> for incorporation
        into a <code>UNIT</code>.
      </para>

      <section id="S52S1">
        <title>make_tokdec</title>

        <emphasis role="bold">Encoding number</emphasis>: 1

        <programlisting>
        tok:             TDFINT
        signature:       OPTION(STRING)
        s:               SORTNAME
                   -&gt; TOKDEC</programlisting>

        <para>
          The sort of the token <emphasis>tok</emphasis> is declared to be
          <emphasis>s</emphasis>. Note that <emphasis>s</emphasis> will always
          be a token <code>SORT</code>, with a list of parameter
          <code>SORT</code>s (possible empty) and a result <code>SORT</code>.
        </para>

        <para>
          If <emphasis>signature</emphasis> is present, it will be produced by
          <emphasis>make_string</emphasis>.
        </para>

        <para>
          If two <emphasis>make_tokdecs</emphasis> specify the same token and
          both have <emphasis>signatures</emphasis> present, the strings will be
          identical. Possible uses of this signature argument are outlined in
          <!-- TODO link to 7.28. Tag and Token signatures -->section 7.28<!--
          link end -->.
        </para>
      </section>
    </section>

    <section id="S53">
      <title>TOKDEC_PROPS</title>

      <emphasis role="bold">Number of encoding bits</emphasis>: 0<sbr/>
      <emphasis role="bold">Is coding extendable</emphasis>: no<sbr/>
      <emphasis role="bold">Unit identification</emphasis>: tokdec<sbr/>

      <section id="S53S1">
        <title>make_tokdecs</title>

        <emphasis role="bold">Encoding number</emphasis>: 0

        <programlisting>
        tds:             SLIST(TOKDEC)
                   -&gt; TOKDEC_PROPS</programlisting>

        <para>
          <emphasis>tds</emphasis> is a list of <code>TOKDEC</code>s which gives
          the sorts associated with <code>TOKEN</code>s.
        </para>
      </section>
    </section>

    <section id="S54">
      <title>TOKDEF</title>

      <emphasis role="bold">Number of encoding bits</emphasis>: 1<sbr/>
      <emphasis role="bold">Is coding extendable</emphasis>: yes<sbr/>

      <para>
        <emphasis>tds</emphasis> is a list of <code>TOKDEC</code>s which gives
        the sorts associated with <code>TOKEN</code>s.
      </para>

      <section id="S54S1">
        <title>make_tokdef</title>

        <emphasis role="bold">Encoding number</emphasis>: 1

        <programlisting>
        tok:             TDFINT
        signature:       OPTION(STRING)
        def:             BITSTREAM TOKEN_DEFN
                   -&gt; TOKDEF</programlisting>

        <para>
          A <code>TOKDEF</code> is constructed which defines the
          <code>TOKEN</code> <emphasis>tok</emphasis> to stand for the fragment
          of TDF, <emphasis>body</emphasis>, which may be of any
          <code>SORT</code> with a <code>SORTNAME</code>, except for
          <emphasis>token</emphasis>. The <code>SORT</code> of the result,
          <emphasis>result_sort</emphasis>, is given by the first component of
          the <code>BITSTREAM</code>. See <!-- TODO link to 5.51.1.
          token_definition -->token_definition<!-- end link -->.
        </para>

        <para>
          If <emphasis>signature</emphasis> is present, it will be produced by
          <emphasis>make_string</emphasis>.
        </para>

        <para>
          <emphasis>tok</emphasis> may have been introduced by a
          <emphasis>make_tokdec</emphasis>. If both the
          <emphasis>make_tokdec</emphasis> and <emphasis>make_tokdef</emphasis>
          have <emphasis>signatures</emphasis> present, the strings will be
          identical.
        </para>

        <para>
          At the application of this <code>TOKEN</code> actual pieces of TDF
          having <code>SORT</code>
          <emphasis>sn</emphasis>[<emphasis>i</emphasis>] are supplied to
          correspond to the <emphasis>tk</emphasis>[<emphasis>i</emphasis>]. The
          application denotes the piece of TDF obtained by substituting these
          actual parameters for the corresponding <code>TOKEN</code>s within
          <emphasis>body</emphasis>.
        </para>
      </section>
    </section>

    <section id="S55">
      <title>TOKDEF_PROPS</title>

      <emphasis role="bold">Number of encoding bits</emphasis>: 0<sbr/>
      <emphasis role="bold">Is coding extendable</emphasis>: no<sbr/>
      <emphasis role="bold">Unit identification</emphasis>: tokdef<sbr/>

      <section id="S55S1">
        <title>make_tokdefs</title>

        <emphasis role="bold">Encoding number</emphasis>: 0

        <programlisting>
        no_labels:       TDFINT
        tds:             SLIST(TOKDEF)
                   -&gt; TOKDEF_PROPS</programlisting>

        <para>
          <emphasis>no_labels</emphasis> is the number of local
          <code>LABEL</code>s used in <emphasis>tds</emphasis>.
          <emphasis>tds</emphasis> is a list of <code>TOKDEF</code>s which gives
          the definitions associated with <code>TOKEN</code>s.
        </para>
      </section>
    </section>

    <section id="S56">
      <title>TOKEN</title>

      <emphasis role="bold">Number of encoding bits</emphasis>: 2<sbr/>
      <emphasis role="bold">Is coding extendable</emphasis>: yes<sbr/>
      <emphasis role="bold">Linkable entity identificaiton</emphasis>:
      token<sbr/>

      <para>
        These are used to stand for functions evaluated at installation time.
        They are represented by <code>TDFINT</code>s.
      </para>

      <section id="S56S1">
        <title>token_apply_token</title>

        <emphasis role="bold">Encoding number</emphasis>: 1

        <programlisting>
        token_value:     TOKEN
        token_args:      BITSTREAM param_sorts(token_value)
                   -&gt; TOKEN</programlisting>

        <para>
          The token is applied to the arguments to give a <code>TOKEN</code>.
        </para>

        <para>
          If there is a definition for <emphasis>token_value</emphasis> in the
          <code>CAPSULE</code> then <emphasis>token_args</emphasis> is a
          <code>BITSTREAM</code> encoding of the <code>SORT</code>s of its
          parameters, in the order specified.
        </para>
      </section>

      <section id="S56S2">
        <title>make_tok</title>

        <emphasis role="bold">Encoding number</emphasis>: 2

        <programlisting>
        tokno:           TDFINT
                   -&gt; TOKEN</programlisting>

        <para>
          <emphasis>make_tok</emphasis> constructs a <code>TOKEN</code>
          identified by <emphasis>tokno</emphasis>.
        </para>
      </section>

      <section id="S56S3">
        <title>use_tokdef</title>

        <emphasis role="bold">Encoding number</emphasis>: 3

        <programlisting>
        tdef:            BITSTREAM TOKEN_DEFN
                   -&gt; TOKEN</programlisting>

        <para>
          <emphasis>tdef</emphasis> is used to supply the definition, as in
          <emphasis>make_tokdef</emphasis>. Note that <code>TOKEN</code>s are
          only used in <emphasis>x_apply_token</emphasis> constructions.
        </para>
      </section>
    </section>

    <section id="S57">
      <title>TOKEN_DEFN</title>

      <emphasis role="bold">Number of encoding bits</emphasis>: 1<sbr/>
      <emphasis role="bold">Is coding extendable</emphasis>: yes<sbr/>

      <para>
        An auxiliary <code>SORT</code> used in <emphasis>make_tokdef</emphasis>
        and <emphasis>use_tokdef</emphasis>.
      </para>

      <section id="S57S1">
        <title>token_definition</title>

        <emphasis role="bold">Encoding number</emphasis>: 1

        <programlisting>
        result_sort:     SORTNAME
        tok_params:      LIST(TOKFORMALS)
        body:            result_sort
                   -&gt; TOKEN_DEFN</programlisting>

        <para>
          Makes a token definition. <emphasis>result_sort</emphasis> is the
          <code>SORT</code> of body. <emphasis>tok_params</emphasis> is a list
          of formal <code>TOKEN</code>s and their <code>SORT</code>s.
          <emphasis>body</emphasis> is the definition, which can use the formal
          <code>TOKEN</code>s defined in <emphasis>tok_params</emphasis>.
        </para>

        <para>
          The effect of applying the definition of a <code>TOKEN</code> is as
          if the following sequence was obeyed.
        </para>

        <para>
          First, the actual parameters (if any) are expanded to produce
          expressions of the appropriate <code>SORT</code>s. During this
          expansion all token applications in the actual parameters are
          expanded.
        </para>

        <para>
          Second, the definition is copied, making fresh <code>TAG</code>s and
          <code>LABEL</code>s where these are introduced in
          <emphasis>identify</emphasis>, <emphasis>variable</emphasis>,
          <emphasis>labelled</emphasis>, <emphasis>conditional</emphasis>,
          <emphasis>make_proc, make_general_proc</emphasis> and
          <emphasis>repeat</emphasis> constructions. Any other <code>TAG</code>s
          or <code>LABEL</code>s used in <emphasis>body</emphasis> will be
          provided by the context (see below) of the <code>TOKEN_DEFN</code> or
          by the expansions of the actual parameters.
        </para>

        <para>
          Third, the actual parameter expressions are substituted for the formal
          parameter tokens in <emphasis>tok_params</emphasis> to give the final
          result.
        </para>

        <para>
          The context of a <code>TOKEN_DEFN</code> is the set of names
          (<code>TOKEN</code>s,
          <code>TAG</code>s, <code>LABEL</code>s,
          <code>AL_TAG</code>s etc.) <quote>in scope</quote> at the site of the
          <code>TOKEN_DEFN</code>.
        </para>

        <para>
          Thus, in a <emphasis>make_tokdef</emphasis>, the context consists of
          the set of <code>TOKEN</code>s defined in its tokdef
          <code>UNIT</code>, together with the set of linkable entities defined
          by the <emphasis>make_links</emphasis> of that <code>UNIT</code>. Note
          that this does not include <code>LABEL</code>s and the only
          <code>TAG</code>s included are <quote>global</quote> ones.
        </para>

        <para>
          In a <emphasis>use_tokdef</emphasis>, the context may be wider, since
          the site of the <code>TOKEN_DEFN</code> need not be in a tokdef
          <code>UNIT</code>; it may be an actual parameter of a token
          application. If this happens to be within an EXP, there may be
          <code>TAG</code>s or <code>LABEL</code>s locally within scope; these
          will be in the context of the <code>TOKEN_DEFN</code>, together with
          the global names of the enclosing UNIT as before.
        </para>

        <para>
          <emphasis>Previous versions of the specification limited token
          definitions to be non-recursive. There is no intrinsic reason for the
          limitation on recursive <code>TOKEN</code>s. Since the UNIT structure
          implies different namespaces, there is very little implementation
          advantage to be gained from retaining the limitation.</emphasis>
        </para>
      </section>
    </section>

    <section id="S58">
      <title>TOKFORMALS</title>

      <emphasis role="bold">Number of encoding bits</emphasis>: 0<sbr/>
      <emphasis role="bold">Is coding extendable</emphasis>: no<sbr/>

      <section id="S58S1">
        <title>make_tokformals</title>

        <emphasis role="bold">Encoding number</emphasis>: 0

        <programlisting>
        sn:              SORTNAME
        tk:              TDFINT
                   -&gt; TOKFORMALS</programlisting>

        <para>
          An auxiliary construction to make up the elements of the lists in
          <emphasis>token_definition</emphasis>.
        </para>
      </section>
    </section>

    <section id="S59">
      <title>TRANSFER_MODE</title>

      <emphasis role="bold">Number of encoding bits</emphasis>: 3<sbr/>
      <emphasis role="bold">Is coding extendable</emphasis>: yes<sbr/>

      <para>
        A <code>TRANSFER_MODE</code> controls the operation of
        <emphasis>assign_with_mode</emphasis>,
        <emphasis>contents_with_mode</emphasis> and
        <emphasis>move_some</emphasis>.
      </para>

      <para>
        A <code>TRANSFER_MODE</code> acts like a set of the values
        <emphasis>overlap, trap_on_nil, complete</emphasis> and
        <emphasis>volatile</emphasis>. The <code>TRANSFER_MODE</code>
        <emphasis>standard_transfer_mode</emphasis> acts like the empty set.
        <emphasis>add_modes</emphasis> acts like set union.
      </para>

      <section id="S59S1">
        <title>transfer_mode_apply_token</title>

        <emphasis role="bold">Encoding number</emphasis>: 1

        <programlisting>
        token_value:     TOKEN
        token_args:      BITSTREAM param_sorts(token_value)
                   -&gt; TRANSFER_MODE</programlisting>

        <para>
          The token is applied to the arguments encoded in the
          <code>BITSTREAM</code> <emphasis>token_args</emphasis> to give a
          <code>TRANSFER_MODE</code>.
        </para>

        <para>
          The notation <emphasis>param_sorts(token_value)</emphasis> is intended
          to mean the following. The token definition or token declaration for
          <emphasis>token_value</emphasis> gives the <code>SORT</code>s of its
          arguments in the <code>SORTNAME</code> component. The
          <code>BITSTREAM</code> in <emphasis>token_args</emphasis> consists of
          these <code>SORT</code>s in the given order. If no token declaration
          or definition exists in the <code>CAPSULE</code>, the
          <code>BITSTREAM</code> cannot be read.
        </para>
      </section>

      <section id="S59S2">
        <title>transfer_mode_cond</title>

        <emphasis role="bold">Encoding number</emphasis>: 2

        <programlisting>
        control: EXP INTEGER(v)
        e1:              BITSTREAM TRANSFER_MODE
        e2:              BITSTREAM TRANSFER_MODE
                   -&gt; TRANSFER_MODE</programlisting>

        <para>
          <emphasis>control</emphasis> is evaluated. It will be a constant at
          install time under the constant evaluation rules. If it is non-zero,
          <emphasis>e1</emphasis> is installed at this point and
          <emphasis>e2</emphasis> is ignored and never processed.  If
          <emphasis>control</emphasis> is zero then <emphasis>e2</emphasis> is
          installed at this point and <emphasis>e1</emphasis> is ignored and
          never processed.
        </para>
      </section>

      <section id="S59S3">
        <title>add_modes</title>

        <emphasis role="bold">Encoding number</emphasis>: 3

        <programlisting>
        md1:             TRANSFER_MODE
        md2:             TRANSFER_MODE
                   -&gt; TRANSFER_MODE</programlisting>

        <para>
          A construction qualified by <emphasis>add_modes</emphasis> has both
          <code>TRANSFER_MODES</code> <emphasis>md1</emphasis> and
          <emphasis>md2</emphasis>. If <emphasis>md1</emphasis> is
          <emphasis>standard_transfer_mode</emphasis> then the result is
          <emphasis>md2</emphasis> and symmetrically.  This operation is
          associative and commutative.
        </para>
      </section>

      <section id="S59S4">
        <title>overlap</title>

        <emphasis role="bold">Encoding number</emphasis>: 4

        <programlisting>
                   -&gt; TRANSFER_MODE</programlisting>

        <para>
          If <emphasis>overlap</emphasis> is used to qualify a
          <emphasis>move_some</emphasis> or an
          <emphasis>assign_with_mode</emphasis> for which
          <emphasis>arg2</emphasis> is a <emphasis>contents</emphasis> or
          <emphasis>contents_with_mode</emphasis>, then the source and
          destination might overlap.  The transfer shall be made as if the data
          were copied from the source to an independent place and thence to the
          destination.
        </para>

        <para>
          See <!-- TODO link to 7.16. Overlapping -->Overlapping<!-- end link
          -->.
        </para>
      </section>

      <section id="S59S5">
        <title>standard_transfer_mode</title>

        <emphasis role="bold">Encoding number</emphasis>: 5

        <programlisting>
                   -&gt; TRANSFER_MODE</programlisting>

        <para>
          This <code>TRANSFER_MODE</code> implies no special properties.
        </para>
      </section>

      <section id="S59S6">
        <title>trap_on_nil</title>

        <emphasis role="bold">Encoding number</emphasis>: 6

        <programlisting>
                   -&gt; TRANSFER_MODE</programlisting>

        <para>
          If <emphasis>trap_on_nil</emphasis> is used to qualify a
          <emphasis>contents_with_mode</emphasis> operation with a nil pointer
          argument, or an <emphasis>assign_with_mode</emphasis> whose arg1 is a
          nil pointer, or a <emphasis>move_some</emphasis> with either argument
          a nil pointer, the TDF exception <emphasis>nil_access</emphasis> is
          raised.
        </para>
      </section>

      <section id="S59S7">
        <title>volatile</title>

        <emphasis role="bold">Encoding number</emphasis>: 7

        <programlisting>
                   -&gt; TRANSFER_MODE</programlisting>

        <para>
          If <emphasis>volatile</emphasis> is used to qualify a construction it
          shall not be optimised away.
        </para>

        <para>
          <emphasis>This is intended to implement ANSI C's volatile
          construction. In this use, any volatile identifier should be declared
          as a <code>TAG</code> with used_as_volatile
          <code>ACCESS</code>.</emphasis>
        </para>
      </section>

      <section id="S59S8">
        <title>complete</title>

        <emphasis role="bold">Encoding number</emphasis>: 8

        <programlisting>
                   -&gt; TRANSFER_MODE</programlisting>

        <para>
          A transfer qualified with complete shall leave the destination
          unchanged if the evaluation of the value transferred is left with a
          jump.
        </para>
      </section>
    </section>

    <section id="S60">
      <title>UNIQUE</title>

      <emphasis role="bold">Number of encoding bits</emphasis>: 0<sbr/>
      <emphasis role="bold">Is coding extendable</emphasis>: no<sbr/>

      <para>
        These are used to provide world-wide unique names for
        <code>TOKEN</code>s and <code>TAG</code>s.
      </para>

      <para>
        This implies a registry for allocating <code>UNIQUE</code> values.
      </para>

      <section id="S60S1">
        <title>make_unique</title>

        <emphasis role="bold">Encoding number</emphasis>: 0

        <programlisting>
        text:            SLIST(TDFIDENT)
                   -&gt; UNIQUE</programlisting>

        <para>
          Two <code>UNIQUE</code> values are equal if and only if they were
          constructed with equal arguments.
        </para>
      </section>
    </section>

    <section id="S61">
      <title>UNIT</title>

      <emphasis role="bold">Number of encoding bits</emphasis>: 0<sbr/>
      <emphasis role="bold">Is coding extendable</emphasis>: no<sbr/>

      <para>
        A <code>UNIT</code> gathers together a <code>PROPS</code> and
        <code>LINK</code>s which relate the names by which objects are known
        inside the <code>PROPS</code> and names by which they are to be known
        across the whole of the enclosing <code>CAPSULE</code>.
      </para>

      <section id="S61S1">
        <title>make_unit</title>

        <emphasis role="bold">Encoding number</emphasis>: 0

        <programlisting>
        local_vars:      SLIST(TDFINT)
        lks:             SLIST(LINKS)
        properties:      BYTESTREAM PROPS
                   -&gt; UNIT</programlisting>

        <para>
          <emphasis>local_vars</emphasis> gives the number of linkable entities
          of each kind. These numbers correspond (in the same order) to the
          variable sorts in <emphasis>cap_linking</emphasis> in
          <emphasis>make_capsule</emphasis>. The linkable entities will be
          represented by <code>TDFINT</code>s in the range 0 to the
          corresponding <emphasis>nl</emphasis>-1.
        </para>

        <para>
          <emphasis>lks</emphasis> gives the <code>LINK</code>s for each kind of
          entity in the same order as in <emphasis>local_vars</emphasis>.
        </para>

        <para>
          The <emphasis>properties</emphasis> will be a <code>PROPS</code> of a
          form dictated by the unit identification, see <!-- TODO link to
          5.11.1. make_capsule -->make_capsule<!-- end link -->.
        </para>

        <para>
          The length of <emphasis>lks</emphasis> will be either 0 or equal to
          the length of <emphasis>cap_linking</emphasis> in
          <emphasis>make_capsule</emphasis>.
        </para>
      </section>
    </section>

    <section id="S62">
      <title>VARIETY</title>

      <emphasis role="bold">Number of encoding bits</emphasis>: 2<sbr/>
      <emphasis role="bold">Is coding extendable</emphasis>: yes<sbr/>

      <para>
        These describe the different kinds of integer which can occur at run
        time. The fundamental construction consists of a <code>SIGNED_NAT</code>
        for the lower bound of the range of possible values, and a
        <code>SIGNED_NAT</code> for the upper bound (inclusive at both ends).
      </para>

      <para>
        There is no limitation on the magnitude of these bounds in TDF, but an
        installer may specify limits. See <!-- TODO link to 7.18. Representing
        integers -->Representing integers<!-- link end -->.
      </para>

      <section id="S62S1">
        <title>var_apply_token</title>

        <emphasis role="bold">Encoding number</emphasis>: 1

        <programlisting>
        token_value:     TOKEN
        token_args:      BITSTREAM param_sorts(token_value)
                   -&gt; VARIETY</programlisting>

        <para>
          The token is applied to the arguments to give a <code>VARIETY</code>.
        </para>

        <para>
          If there is a definition for <emphasis>token_value</emphasis> in the
          <code>CAPSULE</code> then <emphasis>token_args</emphasis> is a
          <code>BITSTREAM</code> encoding of the <code>SORT</code>s of its
          parameters, in the order specified.
        </para>
      </section>

      <section id="S62S2">
        <title>var_cond</title>

        <emphasis role="bold">Encoding number</emphasis>: 2

        <programlisting>
        control: EXP INTEGER(v)
        e1:              BITSTREAM VARIETY
        e2:              BITSTREAM VARIETY
                   -&gt; VARIETY</programlisting>

        <para>
          The <emphasis>control</emphasis> is evaluated. It will be a constant
          at install time under the constant evaluation rules. If it is
          non-zero, <emphasis>e1</emphasis> is installed at this point and
          <emphasis>e2</emphasis> is ignored and never processed.  If
          <emphasis>control</emphasis> is zero then <emphasis>e2</emphasis> is
          installed at this point and <emphasis>e1</emphasis> is ignored and
          never processed.
        </para>
      </section>

      <section id="S62S3">
        <title>var_limits</title>

        <emphasis role="bold">Encoding number</emphasis>: 3

        <programlisting>
        lower_bound:     SIGNED_NAT
        upper_bound:     SIGNED_NAT
                   -&gt; VARIETY</programlisting>

        <para>
          <emphasis>lower_bound</emphasis> is the lower limit (inclusive) of the
          range of values which shall be representable in the resulting
          <code>VARIETY</code>, and <emphasis>upper_bound</emphasis> is the
          upper limit (inclusive).
        </para>
      </section>

      <section id="S62S4">
        <title>var_width</title>

        <emphasis role="bold">Encoding number</emphasis>: 4

        <programlisting>
        signed_width:    BOOL
        width:           NAT
                   -&gt; VARIETY</programlisting>

        <para>
          If <emphasis>signed_width</emphasis> is <emphasis>true</emphasis> then
          this construction is equivalent to
          <emphasis>var_limits</emphasis>(-2<superscript><emphasis>width</emphasis>-1</superscript>,
          2<superscript><emphasis>width</emphasis>-1</superscript>-1).  If
          <emphasis>signed_width</emphasis> is <emphasis>false</emphasis> then
          this construction is <emphasis>var_limits </emphasis>(0,
          2<superscript><emphasis>width</emphasis></superscript>-1).
        </para>
      </section>
    </section>

    <section id="S63">
      <title>VERSION_PROPS</title>

      <emphasis role="bold">Number of encoding bits</emphasis>: 0<sbr/>
      <emphasis role="bold">Is coding extendable</emphasis>: no<sbr/>
      <emphasis role="bold">Unit identification</emphasis>: versions<sbr/>

      <para>
        This <code>UNIT</code> gives information about version numbers and
        user information.
      </para>

      <section id="S63S1">
        <title>make_versions</title>

        <emphasis role="bold">Encoding number</emphasis>: 0

        <programlisting>
        version_info:    SLIST(VERSION)
                   -&gt; VERSION_PROPS</programlisting>

        <para>
          Contains version information.
        </para>
      </section>
    </section>

    <section id="S64">
      <title>VERSION</title>

      <emphasis role="bold">Number of encoding bits</emphasis>: 1<sbr/>
      <emphasis role="bold">Is coding extendable</emphasis>: yes<sbr/>

      <section id="S64S1">
        <title>make_version</title>

        <emphasis role="bold">Encoding number</emphasis>: 1

        <programlisting>
        major_version:   TDFINT
        minor_version:   TDFINT
                   -&gt; VERSION</programlisting>

        <para>
          The major and minor version numbers of the TDF used. An increase in
          minor version number means an extension of facilities, an increase in
          major version number means an incompatible change. TDF with the same
          major number but a lower minor number than the installer shall install
          correctly.
        </para>

        <para>
          For TDF conforming to this specification the major number will be 4
          and the minor number will be 0.
        </para>

        <para>
          Every <code>CAPSULE</code> will contain at least one
          <emphasis>make_version</emphasis> construct.
        </para>
      </section>

      <section id="S64S2">
        <title>user_info</title>

        <emphasis role="bold">Encoding number</emphasis>: 2

        <programlisting>
        information:     STRING(k, n)
                   -&gt; VERSION</programlisting>

        <para>
          This is (usually character) information included in the TDF for
          labelling purposes.
        </para>

        <para>
          <emphasis>information</emphasis> will be produced by
          <emphasis>make_string</emphasis>.
        </para>
      </section>
    </section>
  </chapter>
</book>
