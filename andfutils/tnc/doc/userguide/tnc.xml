<?xml version="1.0" standalone="no"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
	"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd" [
	<!ENTITY tdf "<acronym>TDF</acronym>">
]>

<article>
	<articleinfo>
		<title>&tdf; Notation Compiler</title>

		<othercredit class="copyeditor">
			<firstname>Katherine</firstname>
			<surname>Flavel</surname>
			<affiliation><orgname>The TenDRA Project</orgname></affiliation>
		</othercredit>
		<corpauthor>DERA</corpauthor>

		<pubdate>1998</pubdate>

		<copyright>
			<year>2007</year>

			<holder>The TenDRA Project</holder>
		</copyright>

		<copyright>
			<year>1998</year>

			<holder>DERA</holder>
		</copyright>
	</articleinfo>

	<chapter id="S1">
		<title>Introduction</title>

		<para>The &tdf; notation compiler, <code>tnc</code>, is a tool for translating
			&tdf; capsules to and from text. This paper gives a brief introduction
			to how to use this utility and the syntax of the textual form of &tdf;.
			The version here described is that supporting version 3.1 of the &tdf;
			specification.</para>

		<para><code>tnc</code> has four modes, two input modes and two output modes.
			These are as follows:</para>

		<itemizedlist>
			<listitem>
				<para><emphasis>decode</emphasis> - translate an input &tdf; capsule into the <code>tnc</code>
					internal representation,</para>
			</listitem>

			<listitem>
				<para><emphasis>read</emphasis> - translate an input text file into the internal representation,</para>
			</listitem>

			<listitem>
				<para><emphasis>encode</emphasis> - translate the internal representation into an
					output &tdf; capsule,</para>
			</listitem>

			<listitem>
				<para><emphasis>write</emphasis> - translate the internal representation into an output
					text file.</para>
			</listitem>
		</itemizedlist>

		<para>Due to the modular nature of the program it is possible to form versions
			of <code>tnc</code> in which not all the modes are available. Passing
			the <emphasis>-version</emphasis> flag to <code>tnc</code> causes it to report which
			modes it has implemented.</para>

		<para>Any application of <code>tnc</code> consists of the composite of an
			input mode and an output mode. The default action is <emphasis>read</emphasis>-<emphasis>encode</emphasis>,
			i.e. translate an input test file into an output &tdf; capsule. Other
			modes may be specified by passing the following command line options
			to <code>tnc</code>:</para>

		<itemizedlist>
			<listitem>
				<para><emphasis>-decode</emphasis> or <emphasis>-d</emphasis>,</para>
			</listitem>

			<listitem>
				<para><emphasis>-read</emphasis> or <emphasis>-r</emphasis>,</para>
			</listitem>

			<listitem>
				<para><emphasis>-encode</emphasis> or <emphasis>-e</emphasis>,</para>
			</listitem>

			<listitem>
				<para><emphasis>-write</emphasis> or <emphasis>-w</emphasis>.</para>
			</listitem>
		</itemizedlist>

		<para>The only other really useful action is <emphasis>decode</emphasis>-<emphasis>write</emphasis>,
			i.e. translate an input &tdf; capsule into an output text file. This
			may also be specified by the <emphasis>-print</emphasis> or <emphasis>-p</emphasis> option. The
			actions <emphasis>decode</emphasis>-<emphasis>encode</emphasis> and <emphasis>read</emphasis>-<emphasis>write</emphasis> are
			not precise identities, they do however give equivalent input and
			output files.</para>

		<para>In addition, the <emphasis>decode</emphasis> mode may be modified to accept a &tdf;
			library as input rather than a &tdf; capsule by passing the addition
			flag:</para>

		<itemizedlist>
			<listitem>
				<para><emphasis>-lib</emphasis> or <emphasis>-l</emphasis>,</para>
			</listitem>
		</itemizedlist>

		<para>to <code>tnc</code>.</para>

		<para>The overall syntax for <code>tnc</code> is as follows:

<programlisting>tnc [ options ... ] input_file [ output_file ]</programlisting>

			If the output file is not specified, the standard output is used.</para>
	</chapter>

	<chapter id="S2">
		<title>Input classes</title>

		<para>The rest of this paper is concerned with the form required of the
			input text file. The input can be divided into eight classes.</para>

		<!-- XXX variablelist instead -->
		<section id="S21">
			<title>Delimiters</title>

			<para>The characters <code>(</code> and <code>)</code> are used as delimiters
				to impose a syntactic structure on the input.</para>
		</section>

		<section id="S22">
			<title>White space</title>

			<para>White space comprises sequences of space, tab and newline characters,
				together with comments (see below). It is not significant to the output
				(&tdf; notation is completely free-form), and serves only to separate
				syntactic units. Every identifier, number etc. must be terminated
				by a white space or a delimiter.</para>
		</section>

		<section id="S23">
			<title>Comments</title>

			<para>Comments may be inserted in the input at any point. They begin with
				a <code>#</code> character and run to the end of the line.</para>
		</section>

		<section id="S24">
			<title>Identifiers</title>

			<para>An identifier consists of any sequence of characters drawn from the
				following set: upper case letters, lower case letters, decimal digits,
				underscore (<code>_</code>), dot (<code>.</code>), and tilde (<code>~</code>),
				which does not begin with a decimal digit. <code>tnc</code> generates
				names beginning with double tilde (<code>~~</code>) for unnamed objects
				when in <emphasis>decode</emphasis> mode, so the use of such identifiers is not
				recommended.</para>
		</section>

		<section id="S25">
			<title>Numbers</title>

			<para>Numbers can be given in octal (prefixed by <code>0</code>), decimal,
				or hexadecimal (prefixed by <code>0x</code> or <code>0X</code>). Both
				upper and lower case letters can be used for hex digits. A number
				can be preceded by any number of <code>+</code> or <code>-</code>
				signs.</para>
		</section>

		<section id="S26">
			<title>Strings</title>

			<para>A string consists of a sequence of characters enclosed in double quotes
				(<code>&quot;</code>). The following escape sequences are recognised:</para>

		<itemizedlist>
			<listitem>
				<para><code>\n</code> represents a newline character,</para>
			</listitem>

			<listitem>
				<para><code>\t</code> represents a tab character,</para>
			</listitem>

			<listitem>
				<para><code>\xxx</code>, where <code>xxx</code> consists of three octal
					digits, represents the character with ASCII code <code>xxx</code>.</para>
			</listitem>
		</itemizedlist>

			<para>Newlines are not allowed in strings unless they are escaped. For all
				other escaped characters, <code>\x</code> represents <code>x</code>.</para>
		</section>

		<section id="S27">
			<title>Blanks</title>

			<para>A single minus character (<code>-</code>) has a special meaning. It
				may be used to indicate the absence of an optional argument or optional
				group of arguments.</para>
		</section>

		<section id="S28">
			<title>Bars</title>

			<para>A single vertical bar (<code>|</code>) has a special meaning. It may
				be used to indicate the end of a sequence of repeated arguments.</para>
		</section>
	</chapter>

	<chapter id="S3">
		<title>Input syntax</title>

		<section id="S31">
			<title>Basic syntax</title>

			<para>The basic input syntax is very simple. A construct consists of an
				identifier followed by a list of arguments, all enclosed in brackets
				in a Lisp-like fashion. Each argument can be an identifier, a number,
				a string, a blank, a bar, or another construct. There are further
				restrictions on this basic syntax, described below.</para>

<programlisting language="BNF">
construct	: ( identifier arglist )

argument	: construct
		| identifier
		| number
		| string
		| blank
		| bar

arglist		: (empty)
		| argument arglist</programlisting>

			<para>The construct <code>( identifier )</code>, with an empty argument
				list, is equivalent to the identifier argument <code>identifier</code>.
				The two may be used interchangeably.</para>
		</section>

		<section id="S32">
			<title>Sorts</title>

			<para>Except at the outermost level, which forms a special case discussed
				below, every construct and argument has an associated sort. This is
				one of the basic &tdf; sorts: <code>access</code>, <code>al_tag</code>,
				<code>alignment</code>, <code>bitfield_variety</code>, <code>bool</code>,
				<code>callees</code>, <code>error_code</code>, <code>error_treatment</code>,
				<code>exp</code>, <code>floating_variety</code>, <code>label</code>,
				<code>nat</code>, <code>ntest</code>, <code>procprops</code>, <code>rounding_mode</code>,
				<code>shape</code>, <code>signed_nat</code>, <code>string</code>,
				<code>tag</code>, <code>transfer_mode</code>, <code>variety</code>,
				<code>tdfint</code> or <code>tdfstring</code>.</para>

			<para>Ignoring for the moment the shorthands discussed below, the ways of
				creating constructs of sort <code>exp</code> say, correspond to the
				&tdf; constructs delivering an <code>exp</code>. For example, <code>contents
				</code> takes a <code>shape</code> and an <code>exp</code> and delivers
				an <code>exp</code>. Thus:</para>

			<programlisting>( contents arg1 arg2 )</programlisting>

			<para>where <code>arg1</code> is an argument of sort <code>shape</code>
				and <code>arg2</code> is an argument of sort <code>exp</code>, is
				a sort-correct construct. Only constructs which are sort correct in
				this sense are allowed.</para>

			<para>As another example, because of the rule concerning constructs with
				no arguments, both</para>

			<programlisting>( true )</programlisting>

			<para>and</para>

			<programlisting>false</programlisting>

			<para>are valid constructs of sort <code>bool</code>.</para>

			<para>&tdf; constructs which take lists of arguments are easily dealt with.
				For example:</para>

			<programlisting>( make_nof arg1 ... argn )</programlisting>

			<para>where <code>arg1</code>, ..., <code>argn</code> are all arguments
				of sort <code>exp</code>, is valid. A vertical bar may be used to
				indicate the end of a sequence of repeated arguments.</para>

			<para>Optional arguments should be entered normally if they are present.
				Their absence may be indicated by means of a blank (minus sign), or
				by simply omitting the argument.</para>

			<para>The vertical bar and blank should be used whenever the input is potentially
				ambiguous. Particular care should be taken with <code>apply_proc</code>
				(which is genuinely ambiguous) and <code>labelled</code>.</para>

			<para>The &tdf; specification should be consulted for a full list of valid
				&tdf; constructs and their argument sorts. Alternatively the <code>tnc</code>
				help facility may be used. The command:</para>

			<programlisting>tnc -help cmd1 ... cmdn</programlisting>

			<para>prints sort information on the constructs or sorts <code>cmd1</code>,
				..., <code>cmdn</code>. Alternatively:</para>

			<programlisting>tnc -help</programlisting>

			<para>prints this information for all constructs. (To obtain help on the
				sort <code>alignment</code> as opposed to the construct <code>alignment</code>
				use <code>alignment_sort</code>. This confusion cannot occur elsewhere.)</para>
		</section>

		<section id="S33">
			<title>Numbers and strings</title>

			<para>Numbers can occur in two contexts, as the argument to the &tdf; constructs
				<code>make_nat</code> and <code>make_signed_nat</code>. In the former
				case the number must be positive. The following shorthands are understood
				by <code>tnc</code>:</para>

<programlisting>
number <emphasis>for</emphasis> ( make_nat number )
number <emphasis>for</emphasis> ( make_signed_nat number )
</programlisting>

			<para>depending on whether a construct of sort <code>nat</code> or
				<code>signed_nat</code> is expected.</para>

			<para>Strings are nominally of sort <code>tdfstring</code>. They are taken
				to be simple strings (8 bits per character). Multibyte strings (those
				with other than 8 bits per character) may be represented by means
				of the <code>multi_string</code> construct. This takes the form:</para>

			<programlisting>( multi_string b c1 ... cn )</programlisting>

			<para>where <code>b</code> is the number of bits per character and <code>c1</code>,
				...,<code>cn</code> are the codes of the characters comprising the
				string. These multibyte strings cannot be used as external names.</para>

			<para>In addition, a simple (8 bit) string can be used as a shorthand for
				a &tdf; construct of sort <code>string</code>, as follows:</para>

			<programlisting>string <emphasis>for</emphasis> ( make_string string )</programlisting>
		</section>

		<section id="S34">
			<title>Tokens, tags, alignment tags and labels</title>

			<para>In &tdf; simple tokens, tags, alignment tags and labels are represented
				by numbers which may, or may not, be associated with external names.
				In <code>tnc</code> however they are represented by identifiers. This
				brings the problem of scoping which does not occur in &tdf;. The rules
				are that all tokens, tags, alignment tags and labels must be declared
				before they are used. Externally defined objects have global scope,
				and the scope of a formal argument in a token definition is the definition
				body. For those constructs which introduce a local tag or label -
				for example, <code>identify</code>, <code>make_proc</code>,
				<code>make_general_proc</code> and <code>variable</code> for tags and <code>conditional</code>,
				<code>labelled</code> and <code>repeat</code> for labels - the scope
				of the object is as set out in the &tdf; specification.</para>

			<para>The following shorthands are understood by <code>tnc</code>, according
				to the argument sort expected:</para>

<programlisting>tag_id <emphasis>for</emphasis> ( make_tag tag_id )
al_tag_id <emphasis>for</emphasis> ( make_al_tag al_tag_id )
label_id <emphasis>for</emphasis> ( make_label label_id )</programlisting>

			<para>The syntax for token applications is as follows:</para>

<programlisting>( apply_construct ( token_id arg1 ... argn ) )</programlisting>

			<para>where <code>apply_construct</code> is the appropriate &tdf; token application
				construct, for example, <code>exp_apply_token</code> for tokens declared
				to deliver <code>exp</code>'s. The token arguments <code>arg1</code>,
				..., <code>argn</code> must be of the sorts indicated in the token
				declaration or definition. For tokens without any arguments the alternative
				form:</para>

			<programlisting>( apply_construct token_id )</programlisting>

			<para>is allowed.</para>

			<para>The token application above may be abbreviated to:</para>

			<programlisting>( token_id arg1 ... argn )</programlisting>

			<para>the result sort being known from the token declaration. This in turn
				may be abbreviated to:</para>

			<programlisting>token_id</programlisting>

			<para>when there are no token arguments.</para>

			<para>Care needs to be taken with these shorthands, as they can lead to
				confusion, particularly when, due to optional arguments or lists of
				arguments, <code>tnc</code> is not sure what sort is coming next.
				The five categories of objects represented by identifiers - &tdf; constructs,
				tokens, tags, alignment tags and labels - occupy separate name spaces,
				but it is a good idea to try to avoid duplication of names.</para>

			<para>By default all these shorthands are used by <code>tnc</code> in <emphasis>write</emphasis>
				mode. If this causes problems, the <emphasis>-V</emphasis> flag should be passed
				to <code>tnc</code>.</para>
		</section>
	</chapter>

	<chapter id="S35">
		<title>Outer level syntax</title>

		<para>At the outer level <code>tnc</code> is expecting a sequence of constructs
			of the following forms:</para>

		<itemizedlist>
			<listitem>
				<para>an included file,</para>
			</listitem>

			<listitem>
				<para>a token declaration,</para>
			</listitem>

			<listitem>
				<para>a token definition,</para>
			</listitem>

			<listitem>
				<para>an alignment tag declaration,</para>
			</listitem>

			<listitem>
				<para>an alignment tag definition,</para>
			</listitem>

			<listitem>
				<para>a tag declaration,</para>
			</listitem>

			<listitem>
				<para>a tag definition.</para>
			</listitem>
		</itemizedlist>

		<section id="S36">
			<title>Included files</title>

			<para>Included files may be of three types - text, &tdf; capsule or &tdf; library.
				For &tdf; capsules and libraries there are two include modes. The first
				just decodes the given capsule or set of capsules. The second scans
				through them to extract token declaration information. These declarations
				appear in the output file only if they are used elsewhere.</para>

			<para>The syntax for an included text file is:</para>

			<programlisting>( include string )</programlisting>

			<para>where <code>string</code> is a string giving the pathname of the file
				to be included. <code>tnc</code> applies <emphasis>read</emphasis> to this sub-file
				before continuing with the present file.</para>

			<para>Similarly, the syntaxes for included &tdf; capsules and libraries are:</para>

<programlisting>
( code string )
( lib string )</programlisting>

			<para>respectively. <code>tnc</code> applies <emphasis>decode</emphasis> to this capsule
				or set of capsules (provided this mode is available) before continuing
				with the present file.</para>

			<para>The syntaxes for extracting the token declaration information from
				a &tdf; capsule or library are:</para>

<programlisting>
( use_code string )
( use_lib string )</programlisting>

			<para>Again, these rely on the <emphasis>decode</emphasis> mode being available.</para>
		</section>

		<section id="S37">
			<title>Internal and external names</title>

			<para>All tokens, tags and alignment tags have an internal name, namely
				the associated identifier, but this name does not necessarily appear
				in the corresponding &tdf; capsule. There must firstly be an associated
				declaration or definition at the outer level - tags internal to a
				piece of &tdf; do not have external names. Even then we may not wish
				this name to appear at the outer level, because it is local to this
				file and is not required for linking purposes. Alternatively we may
				wish a different external name to be associated with it in the &tdf;
				capsule.</para>

			<para>As an example of how <code>tnc</code> allows for this, consider token
				declarations (although similar remarks apply to token definitions,
				alignment tag definitions etc.). The basic form of the token declaration
				is:</para>

			<programlisting>( make_tokdec token_id ... )</programlisting>

			<para>This creates a token with both internal and external names equal to
				<code>token_id</code>. Alternatively:</para>

			<programlisting>( local make_tokdec token_id ... )</programlisting>

			<para>creates a token with internal name <code>token_id</code> but no external
				name. This allows the creation of tokens local to the current file.
				Again:</para>

			<programlisting>( make_tokdec ( string_extern string ) token_id ... )</programlisting>

			<para>creates a token with internal name <code>token_id</code> and external
				name given by the string <code>string</code>. For example, to create
				a token whose external name is not a valid identifier, it would be
				necessary to use this construct. Finally:</para>

			<programlisting>( make_tokdec ( unique_extern string1 ... stringn ) token_id ... )</programlisting>

			<para>creates a token with internal name <code>token_id</code> and external
				name given by the unique name consisting of the strings <code>string1</code>,
				..., <code>stringn</code>.</para>

			<para>The <code>local</code> quantifier should be used consistently on all
				declarations and definitions of the token, tag or alignment tag. The
				alternative external name should only be given on the first occasion
				however. Thereafter the object is identified by its internal name.</para>
		</section>

		<section id="S38">
			<title>Token declarations</title>

			<para>The basic form of a token declaration is:</para>

			<programlisting>( make_tokdec token_id ( arg1 ... argn ) res )</programlisting>

			<para>where the token <code>token_id</code> is declared to take argument
				sorts <code>arg1</code>, ..., <code>argn</code> and deliver the result
				sort <code>res</code>. These sorts are given by their sort names,
				<code>al_tag</code>, <code>alignment</code>, <code>bitfield_variety</code>
				etc. For a token with no arguments the declaration may be given in
				the form:</para>

<programlisting>( make_tokdec token_id res )</programlisting>

			<para>A token may be declared any number of times, provided the declarations
				are consistent.</para>

			<para>This basic declaration may be modified in the ways outlined above
				to specify the external token name.</para>
		</section>

		<section id="S39">
			<title>Token definitions</title>

			<para>The basic form of a token definition is:</para>

			<programlisting>( make_tokdef token_id ( arg1 id1 ... argn idn ) res def )</programlisting>

			<para>where the token <code>token_id</code> is defined to take formal arguments
				<code>id1</code>, ..., <code>idn</code> of sorts <code>arg1</code>,
				..., <code>argn</code> respectively and have the value <code>def</code>,
				which is a construct of sort <code>res</code>. The scope of the tokens
				<code>id1</code>, ..., <code>idn</code> is <code>def</code>.</para>

			<para>For a token with no arguments the definition may be given in the form:</para>

			<programlisting>( make_tokdef token_id res def )</programlisting>

			<para>A token may be defined more than once. All definitions must be consistent
				with any previous declarations and definitions (the renaming of formal
				arguments is allowed however).</para>

			<para>This basic definition may be modified in the ways outlined above to
				specify the external token name.</para>
		</section>

		<section id="S310">
			<title>Alignment tag declarations</title>

			<para>The basic form of an alignment tag declaration is:</para>

			<programlisting>( make_al_tagdec al_tag_id )</programlisting>

			<para>where the alignment tag <code>al_tag_id</code> is declared to exist.</para>

			<para>This basic declaration may be modified in the ways outlined above
				to specify the external alignment tag name.</para>
		</section>

		<section id="S311">
			<title>Alignment tag definitions</title>

			<para>The basic form of an alignment tag definition is:</para>

			<programlisting>( make_al_tagdef al_tag_id def )</programlisting>

			<para>where the alignment tag <code>al_tag_id</code> is defined to be <code>def</code>,
				which is a construct of sort <code>alignment</code>. An alignment
				tag may be declared or defined more than once, provided the definitions
				are consistent.</para>

			<para>This basic definition may be modified in the ways outlined above to
				specify the external alignment tag name.</para>
		</section>

		<section id="S312">
			<title>Tag declarations</title>

			<para>The basic forms of a tag declaration are:</para>

<programlisting>
( make_id_tagdec tag_id info dec )
( make_var_tagdec tag_id info dec )
( common_tagdec tag_id info dec )</programlisting>

			<para>where the tag <code>tag_id</code> is declared to be an identity, variable
				or common tag with access information <code>info</code>, which is
				an optional construct of sort <code>access</code>, and shape <code>dec</code>,
				which is a construct of sort <code>shape</code>. A tag may be declared
				more than once, provided all declarations and definitions are consistent
				(including agreement of whether the tag is an identity, a variable
				or common).</para>

			<para>These basic declarations may be modified in the ways outlined above
				to specify the external tag name.</para>
		</section>

		<section id="S313">
			<title>Tag definitions</title>

			<para>The basic forms of a tag definition are:</para>

<programlisting>
( make_id_tagdef tag_id def )
( make_var_tagdef tag_id info def )
( common_tagdef tag_id info def )</programlisting>

			<para>where the tag <code>tag_id</code> is defined to be an identity, variable
				or common tag with value <code>def</code>, which is a construct of
				sort <code>exp</code>. Non-identity tag definitions also have an optional
				<code>access</code> construct, <code>info</code>. A tag must have
				been declared before it is defined, but may be defined any number
				of times. All declarations and definitions must be consistent (except
				that common tags may be defined inconsistently) and agree on whether
				the tag is an identity, a variable, or common.</para>

			<para>These basic definitions may be modified in the ways outlined above
				to specify the external tag name.</para>
		</section>
	</chapter>

	<chapter id="S4">
		<title>Shape checking</title>

		<para>The input in <emphasis>read</emphasis> (and to a lesser extent <emphasis>decode</emphasis>) mode
			is checked for shape correctness if the <emphasis>-check</emphasis> or <emphasis>-c</emphasis>
			flag is passed to <code>tnc</code>. This is not guaranteed to pick
			up all shape errors, but is better than nothing.</para>

		<para>When in <emphasis>write</emphasis> mode the results of the shape checking may be
			viewed by passing the <emphasis>-cv</emphasis> flag to <code>tnc</code>. Each expression
			is associated with its shape by means of the:</para>

<programlisting>( exp_with_shape exp shape ) -&gt; exp</programlisting>

		<para>pseudo-construct. Unknown shapes are indicated by <code>....</code></para>
	</chapter>

	<chapter id="S5">
		<title>Remarks</title>

		<para>The target independent &tdf; capsules produced by the C to &tdf; compiler,
			<code>tcc</code>, do not contain declarations or definitions for all
			the tokens they use. Thus <code>tnc</code> cannot fully decode them
			as they stand. However the necessary token declaration information
			may be made available to <code>tnc</code> by using the <emphasis>use_lib</emphasis>
			construct. The commands:</para>

<programlisting>
( use_lib library )
( code capsule )
</programlisting>

		<para>will decode the &tdf; capsule <code>capsule</code> which uses tokens
			defined in the &tdf; library <code>library</code>.</para>
	</chapter>

	<chapter id="S6">
		<title>Limitations</title>

		<para>The main limitations in the current version of <code>tnc</code> are
			as follows:</para>

		<itemizedlist>
			<listitem>
				<para>There is no error recovery,</para>
			</listitem>

			<listitem>
				<para>There is no support for foreign sorts,</para>
			</listitem>

			<listitem>
				<para>The support for tokenised tokens is limited and undocumented.</para>
			</listitem>
		</itemizedlist>

		<para>In addition, far more of the checks (scopes, shape checking, checking
			of consistency of declarations and definitions etc.) are implemented
			for <emphasis>read</emphasis> mode rather than <emphasis>decode</emphasis> mode. To shape check
			a &tdf; capsule, it will almost certainly be more effective to translate
			it into text and check that.</para>

		<para>Another limitation is that the scoping rules for local tags do not
			allow such tags to be accessed outside their scopes using <code>env_offset</code>.</para>
	</chapter>

	<!-- TODO we can put our andfutil manpages in (1andf)? -->
	<!-- TODO move to the manpage!
	<chapter id="S7>7. Manual Page for tnc</A></H2>
		<para>
Here is the manual page for tnc.
		<para>
<emphasis>NAME</emphasis>: <code>tnc</code> - &tdf; notation compiler
		<para>
<emphasis>SYNOPSIS</emphasis>: <code>tnc [ options ] input-file [ output-file ]</code>
		<para>
<emphasis>DESCRIPTION</emphasis>: <code>tnc</code> translates &tdf; capsules to and
from text. It has two input modes, <emphasis>read</emphasis> and <emphasis>decode</emphasis>.
In the first, which is default, <code>input-file</code> is a file
containing &tdf; text. In the second <code>input-file</code> is a &tdf;
capsule. There are also two output modes, <emphasis>encode</emphasis> and <emphasis>write</emphasis>.
In the first, which is default, a &tdf; capsule is written to <code>output-file
</code> (or the standard output if this argument is absent). In the
second, &tdf; text is written to <code>output-file</code>.
		<para>
Combination of these modes give four actions: text to &tdf; (which is
default), &tdf; to text, text to text and &tdf; to &tdf;. The last two actions
are not precise identities, but they do give equivalent files.
		<para>
The form of the &tdf; text format and more information about <code>tnc</code>
can be found in the document <emphasis>The &tdf; Notation Compiler</emphasis>.
		<para>
<emphasis>OPTIONS</emphasis>:
		<para>
<emphasis>-c</emphasis> or <emphasis>-cv</emphasis> or <emphasis>-check</emphasis>
Specifies that <code>tnc</code> should apply extra checks to <code>input-file
</code>. For example, simple shape checking is applied. These checks
are more efficient in <emphasis>read</emphasis> mode than in <emphasis>decode</emphasis> mode.
If the <emphasis>-cv</emphasis> option is used in <emphasis>write</emphasis> mode, all the information
gleaned from the shape checking appears in <code>output-file</code>.
		<para>
<emphasis>-d</emphasis> or <emphasis>-decode</emphasis>
Specifies that <code>tnc</code> should be in <emphasis>decode</emphasis> mode. That
is, that <code>input-file</code> is a &tdf; capsule.
		<para>
<emphasis>-e</emphasis> or <emphasis>-encode</emphasis>
Specifies that <code>tnc</code> should be in <emphasis>encode</emphasis> mode. That
is, that <code>output-file</code> is a &tdf; capsule.
		<para>
<emphasis>-help</emphasis> <code>subject</code> ... Makes <code>tnc</code> print
its help message on the given subject(s). If no subject is given,
all the help messages are printed.
		<para>
<emphasis>-I</emphasis><code>dir</code>
Adds the directory <code>dir</code> to the search path used by <code>tnc</code>
to find included files in <emphasis>read</emphasis> mode.
		<para>
<emphasis>-l</emphasis> or <emphasis>-lib</emphasis>
In <emphasis>decode</emphasis> mode, specifies that <code>input-file</code> is not
a &tdf; capsule, but a &tdf; library. All the capsules comprising the
library are decoded.
		<para>
<emphasis>-o</emphasis> <code>output-file</code>
Gives an alternative method of specifying the output file.
		<para>
<emphasis>-p</emphasis> or <emphasis>-print</emphasis>
Specifies that <code>tnc</code> should be in <emphasis>decode</emphasis> and <emphasis>write</emphasis>
modes. That is, that <code>input-file</code> is a &tdf; capsule and
<code>output-file</code> should consist of &tdf; text. This option makes
<code>tnc</code> into a &tdf; pretty-printer.
		<para>
<emphasis>-q</emphasis>
Specifies that <code>tnc</code> should not check duplicate tag declarations
etc for consistency, but should use the first declaration given.
		<para>
<emphasis>-r</emphasis> or <emphasis>-read</emphasis>
Specifies that <code>tnc</code> should be in <emphasis>read</emphasis> mode. That
is, that <code>input-file</code> should consist of &tdf; text.
		<para>
<emphasis>-V</emphasis>
In <emphasis>write</emphasis> mode, specifies that the output should be in the &quot;verbose&quot;
form, with no shorthand forms.
		<para>
<emphasis>-version</emphasis>
Makes <code>tnc</code> print its version number.
		<para>
<emphasis>-w</emphasis> or <emphasis>-write</emphasis>
Specifies that <code>tnc</code> should be in <emphasis>write</emphasis> mode. That
is, that <code>output-file</code> should consist of &tdf; text.
		<para>

<emphasis>SEE ALSO</emphasis>: <emphasis>tdf</emphasis>(1tdf).
	-->
</article>

