/*
    		 Crown Copyright (c) 1997, 1998
    
    This TenDRA(r) Computer Program is subject to Copyright
    owned by the United Kingdom Secretary of State for Defence
    acting through the Defence Evaluation and Research Agency
    (DERA).  It is made available to Recipients with a
    royalty-free licence for its use, reproduction, transfer
    to other parties and amendment for any purpose not excluding
    product development provided that any such use et cetera
    shall be deemed to be acceptance of the following conditions:-
    
        (1) Its Recipients shall ensure that this Notice is
        reproduced upon any copies or amended versions of it;
    
        (2) Any amended version of it shall be clearly marked to
        show both the nature of and the organisation responsible
        for the relevant amendment or amendments;
    
        (3) Its onward transfer from a recipient to another
        party shall be deemed to be that party's acceptance of
        these conditions;
    
        (4) DERA gives no warranty or assurance as to its
        quality or suitability for any purpose and DERA accepts
        no liability whatsoever in relation to any use to which
        it may be put.
*/


/*
    ERROR DATABASE

    This file describes the database of errors used within the C++ compiler.
    It starts with some standard header information.
*/

DATABASE_NAME:
    cpp

RIG:
    c_err

PREFIX:
    compiler_output -> ERR_
    from_compiler   -> OPT_
    from_database   -> ENO_


/*
    ERROR TYPES

    This section lists all the error parameter types recognised within the
    database.
*/

TYPES:
    ACCESS, BASE_TYPE, CLASS_TYPE, CV_SPEC, DECL_SPEC, FLOAT, HASHID,
    IDENTIFIER, LEX, LONG_ID, NAMESPACE, NAT, PPTOKEN_P, PTR_LOC,
    QUALIFIER, STRING, TYPE, cint, cstring, string, ucint, ulong,
    unsigned, plural


/*
    ERROR PROPERTIES

    This section lists the various categories of error.
*/

PROPERTIES:
    non_iso, compiler, pragma, printf, syntax, token, dummy


/*
    ERROR KEYS

    This section lists the various key properties associated with each
    error message.  These include a cross reference to the ISO standard
    (if appropriate), and the actual error message.
*/

KEYS:
    ISO, STD


/*
    ERROR USAGES

    This section lists the various error usages.  These correspond to
    the groups of errors described by the compiler options.  The default
    values for the options in C++ and C are given.
*/

USAGE:
    error, warning, none, whatever, new, wall,
    cpp_error = error | none,
    c_error = none | error,
    addr_register = none | error,
    anon_union = none | error,
    bitf_overflow = wall | error,
    bitf_type = none | error,
    bool_assign = wall,
    case_fall = wall,
    cast_explicit = none,
    class_scope = on | off,
    comma_extra = error,
    complete_struct = wall,
    concat_string = error,
    cond_default = off,
    cond_lvalue = none | error,
    const_cond = wall,
    const_internal = on | off,
    const_string = wall,
    conv = wall,
    conv_int_int = wall,
    conv_int_int_expl = none, conv_int_int_impl = wall,
    conv_int_enum = error | wall,
    conv_int_ptr = wall,
    conv_int_ptr_expl = wall, conv_int_ptr_impl = error,
    conv_ptr_ptr = wall,
    conv_ptr_ptr_expl = wall, conv_ptr_ptr_impl = error,
    conv_ptr_ptr_void = wall, conv_ptr_void_ptr = error | wall,
    conv_ptr_func = error,
    cpplus_comment = none | error,
    decl_cond = error,
    decl_empty = error,
    decl_hide = wall,
    decl_none = none | error,
    decl_struct_anon = error,
    decl_unify = off,
    decl_volatile = off,
    delete_over = none,
    digraph = wall,
    discard = wall,
    discard_exp = wall, discard_func = wall,
    discard_static = wall,
    discard_value = wall,
    dollar_ident = error,
    dspec_none = error,
    dspec_none_func = new | wall,
    ellipsis_extra = error,
    ellipsis_ident = error,
    empty_body = wall,
    enum_decl = error,
    enum_switch = wall,
    eof_nline = error,
    escape_overflow = error,
    escape_unknown = error,
    for_scope = on | off,
    func_block = error,
    func_impl = error | wall,
    func_incompat = error,
    func_linkage = error,
    func_proto = none,
    func_ret_void = error | wall,
    func_token_undef = wall,
    func_weak = none,
    gen_ptr_char = error,
    hash_ident = error,
    include_full = wall,
    include_verbose = off,
    infer_int = new | wall, infer_int_cv = new | wall,
    init_aggregate = wall,
    init_dynamic = none | error,
    init_struct = none | wall,
    inline_internal = off | on,
    int_operator = wall,
    int_overflow = wall,
    interf_incompat = error,
    iso_keyword = wall | error,
    link_incompat = error | wall,
    link_internal = on,
    link_resolve = error | wall,
    lint_comment = error,
    longlong = error,
    macro_arg_dir = wall,
    macro_nest = error,
    macro_redef = error, macro_weak = error,
    member_incompat = error,
    name_limit = off,
    nest_comment = wall,
    new_array = on,
    overload_ambig = error,
    overload_dep = wall,
    overload_expl = off,
    overload_res = none,
    overload_strict = on,
    param_impl = error | wall,
    paren = wall,
    ppdir_id = error,
    ppdir_null = none,
    ppdir_text = error,
    ppdir_unknown = error,
    ppdir_assert = error, ppdir_assert_ignore = off,
    ppdir_file = error, ppdir_file_ignore = off,
    ppdir_ident = error, ppdir_ident_ignore = off,
    ppdir_import = error, ppdir_import_ignore = off,
    ppdir_indent = none,
    ppdir_indent_dir = none,
    ppdir_unassert = error, ppdir_unassert_ignore = off,
    ppdir_warning = error, ppdir_warning_ignore = off,
    ppdir_weak = error, ppdir_weak_ignore = off,
    pragma_unknown = wall,
    preproc_old = off,
    printf_string = warning,
    proto_scope = off | on,
    ptr_operator = wall,
    ptr_void = error,
    reached = wall,
    semicolon_extra = error,
    templ_export = off,
    templ_undecl = new,
    this_lvalue = error,
    throw_bad = wall | none,
    token_const = error | wall,
    token_redef = wall,
    token_undef = error,
    trigraph = wall,
    type_obj_incompl = none | error,
    type_qual_incompat = error,
    type_redef = none | error,
    type_tag_ignore = error,
    unmatched = error,
    variable = wall,
    weak = off | wall


/*
    ERROR LISTING

    The remainder of this file lists the various error messages comprising
    the database.
*/

ENTRIES:


/*
    ISO C++ STANDARD (DECEMBER 1996 DRAFT)

    The first section of error messages are derived from the ISO C++
    standard.  They are categorised according to the various sections of
    the standard.  Note how these errors give traceability between the
    compiler and the language it implements.  The alternate values
    (following the '|') give the corresponding ISO C settings.

    To reduce the size of the catalogue there are a couple of conventions
    for default values.  If no 'KEY (ISO)' entry is given then the ISO
    section numbers is the same as that of the previous error.  The usages
    have been chosen so that 'error' has value 0.  Thus if no usage is
    given, a usage of 'error' may be inferred.  Rather than an 'iso'
    property which most errors would have, a 'non_iso' property is used.
*/

fail_input ( string: s )
{
    PROPERTIES: non_iso, compiler
    KEY (ISO)	/* empty */
    KEY (STD)	"Can't open input file, '"s"'"
}

fail_output ( string: s )
{
    PROPERTIES: non_iso, compiler
    KEY (STD)	"Can't open output file, '"s"'"
}

fail_dump ( string: s )
{
    PROPERTIES: non_iso, compiler
    KEY (STD)	"Can't open output dump file, '"s"'"
}

fail_spec ( string: s )
{
    PROPERTIES: non_iso, compiler
    KEY (STD)	"Can't open output spec file, '"s"'"
}

fail_spec_bad ( string: s, string: m )
{
    PROPERTIES: non_iso, compiler
    KEY (STD)	"Ill-formed spec file, '"s"': "m
}

fail_port ( string: s )
{
    PROPERTIES: non_iso, compiler
    KEY (STD)	"Can't open portability table, '"s"'"
}

fail_too_many ( ulong: n )
{
    PROPERTIES: non_iso, compiler
    KEY (STD)	"Too many errors ("n") - aborting"
}

fail_error ( cstring: s )
{
    PROPERTIES: non_iso, compiler
    KEY (STD)	s
}

fail_warning ( cstring: s )
{
    USAGE:	warning
    PROPERTIES: non_iso, compiler
    KEY (STD)	s
}

fail_list_item ( unsigned: n, LONG_ID: id, PTR_LOC: loc )
{
    USAGE:	whatever
    PROPERTIES:	non_iso, dummy
    KEY (STD)	"\t"n". '"id"' ("loc")"
}

fail_list_end ( unsigned: n )
{
    USAGE:	none
    PROPERTIES:	non_iso, dummy
    KEY (STD)	" (total "n")"
}


/*  --------------------------------------------------------------------
    1		General
		[intro]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    1.1		Scope
		[intro.scope]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    1.2		Normative references
		[intro.refs]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    1.3		Implementation compliance
		[intro.compliance]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    1.4		Definitions
		[intro.defs]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    1.5		Syntax notation
		[syntax]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    1.6		The C++ memory model
		[intro.memory]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    1.7		The C++ object model
		[intro.object]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    1.8		Program execution
		[intro.execution]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    2		Lexical conventions
		[lex]
    --------------------------------------------------------------------  */

lex_parse ( PPTOKEN_P: pptok )
{
    PROPERTIES:	non_iso, syntax
    KEY (ISO)	/* none */
    KEY (STD)	"Parse error before '"pptok"'"
}

lex_expect ( LEX: lex )
{
    PROPERTIES:	non_iso, syntax
    KEY (STD)	"Syntax error, '"lex"' expected"
}

lex_extra_comma ()
{
    USAGE:	comma_extra
    PROPERTIES:	non_iso, syntax
    KEY (STD)	"Extra comma at end of list"
}

lex_abort ()
{
    PROPERTIES:	non_iso, syntax
    KEY (STD)	"Can't recover from this error"
}


/*  --------------------------------------------------------------------
    2.1		Phases of translation
		[lex.phases]
    --------------------------------------------------------------------  */

lex_phases_eof ()
{
    USAGE:	eof_nline
    KEY (ISO)	"2.1" | "5.1.1.2"
    KEY (STD)	"File does not end in newline character"
}

lex_phases_comm_eof ()
{
    KEY (STD)	"Unterminated comment"
}

lex_phases_str_eof ()
{
    KEY (STD)	"End of file in string literal"
}


/*  --------------------------------------------------------------------
    2.2		Basic source character set
		[lex.charset]
    --------------------------------------------------------------------  */

lex_charset_len ( cint: c, unsigned: n )
{
    KEY (ISO)	"2.2" | "5.2.1"
    KEY (STD)	"Universal character '\\"c"' should be followed by "n"
		 hexadecimal digits"
}

lex_charset_replace ( ucint: c )
{
    USAGE:	trigraph
    KEY (STD)	"Universal character '"c"' used"
}

lex_charset_bad ( ucint: c )
{
    KEY (STD)	"Invalid universal character '"c"'"
}


/*  --------------------------------------------------------------------
    2.3		Trigraph sequences
		[lex.trigraph]
    --------------------------------------------------------------------  */

lex_trigraph_replace ( cint: c1, cint: c2 )
{
    USAGE:	trigraph
    KEY (ISO)	"2.3" | "5.2.1.1"
    KEY (STD)	"Trigraph '??"c1"' replaced by '"c2"'"
}


/*  --------------------------------------------------------------------
    2.4		Preprocessing tokens
		[lex.pptoken]
    --------------------------------------------------------------------  */

lex_pptoken_unknown ( cint: c )
{
    KEY (ISO)	"2.4" | "6.1"
    KEY (STD)	"Illegal character, '"c"'"
}

lex_pptoken_unicode ( ucint: c )
{
    KEY (STD)	"Illegal universal character, '"c"'"
}


/*  --------------------------------------------------------------------
    2.5		Alternative tokens
		[lex.digraph]
    --------------------------------------------------------------------  */

lex_digraph_replace ( LEX: lex1, LEX: lex2 )
{
    USAGE:	digraph
    KEY (ISO)	"2.5" | "Amendment 1"
    KEY (STD)	"Digraph '"lex1"' replaced by '"lex2"'"
}

lex_digraph_iso ( HASHID: lex1, LEX: lex2 )
{
    USAGE:	iso_keyword
    KEY (STD)	"ISO keyword '"lex1"' replaced by '"lex2"'"
}


/*  --------------------------------------------------------------------
    2.6		Tokens
		[lex.token]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    2.7		Comments
		[lex.comment]
    --------------------------------------------------------------------  */

lex_comment_nest ()
{
    USAGE:	nest_comment
    KEY (ISO)	"2.7" | "6.1.9"
    KEY (STD)	"'/*' in comment"
}


/*  --------------------------------------------------------------------
    2.8		Header names
		[lex.header]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    2.9		Preprocessing numbers
		[lex.ppnumber]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    2.10	Identifiers
		[lex.name]
    --------------------------------------------------------------------  */

lex_name_limit ( HASHID: nm, ulong: m, ulong: n )
{
    USAGE:	name_limit
    KEY (ISO)	"2.10" | "6.1.2"
    KEY (STD)	"Length of identifier '"nm"' ("m") exceeds "n
}

lex_name_extendid ( ucint: c )
{
    KEY (STD)	"Invalid universal character, '"c"', in identifier"
}


/*  --------------------------------------------------------------------
    2.11	Keywords
		[lex.key]
    --------------------------------------------------------------------  */

lex_key_word ( LEX: lex )
{
    KEY (ISO)	"2.11" | "6.1.1"
    KEY (STD)	"'"lex"' is now a keyword"
}

lex_key_iso ( HASHID: nm )
{
    USAGE:	wall
    KEY (STD)	"ISO keyword '"nm"' is not a valid macro identifier"
}

lex_key_reserve ( HASHID: nm )
{
    USAGE:	wall
    KEY (STD)	"'"nm"' is a reserved identifier"
}


/*  --------------------------------------------------------------------
    2.12	Operators and punctuators
		[lex.op]
    --------------------------------------------------------------------  */

lex_op_old_assign ( cint: c1, cint: c2 )
{
    USAGE:	none
    KEY (ISO)	"2.12" | "6.1.5"
    KEY (STD)	"Old style assignment operator '="c1"', assuming '= "c2"'"
}


/*  --------------------------------------------------------------------
    2.13	Literals
		[lex.literal]
    --------------------------------------------------------------------  */

lex_literal_bad ( string: num )
{
    KEY (ISO)	"2.13" | "6.1.3"
    KEY (STD)	"Can't convert '"num"' to a number"
}


/*  --------------------------------------------------------------------
    2.13.1	Integer literals
		[lex.icon]
    --------------------------------------------------------------------  */

lex_icon_octal ( string: num )
{
    KEY (ISO)	"2.13.1" | "6.1.3.2"
    KEY (STD)	"Illegal octal digits in '"num"'"
}

lex_icon_large ( string: num, NAT: n )
{
    KEY (STD)	"Integer literal '"num"' exceeds maximum value ("n")"
}

lex_icon_llong ( string: num )
{
    USAGE:	longlong
    KEY (STD)	"'long long' integer literal '"num"'"
}


/*  --------------------------------------------------------------------
    2.13.2	Character literals
		[lex.ccon]
    --------------------------------------------------------------------  */

lex_ccon_multibyte ()
{
    KEY (ISO)	"2.13.2" | "5.2.1.2"
    KEY (STD)	"Invalid multibyte character"
}

lex_ccon_empty ()
{
    KEY (ISO)	"2.13.2" | "6.1.3.4"
    KEY (STD)	"Empty character literal"
}

lex_ccon_multi ( STRING: str )
{
    USAGE:	wall
    KEY (STD)	"Multicharacter character literal, "str
}

lex_ccon_escape ( cint: c )
{
    USAGE:	escape_unknown
    KEY (STD)	"Unknown escape sequence, '\\"c"'"
}

lex_ccon_hex ( cint: c )
{
    USAGE:	escape_unknown
    KEY (STD)	"Invalid hexadecimal escape sequence, '\\"c"'"
}

lex_ccon_large ()
{
    USAGE:	escape_overflow
    KEY (STD)	"Character out of range"
}


/*  --------------------------------------------------------------------
    2.13.3	Floating literals
		[lex.fcon]
    --------------------------------------------------------------------  */

lex_fcon_large ( FLOAT: f )
{
    KEY (ISO)	"2.13.3" | "6.1.3.1"
    KEY (STD)	"Floating point literal '"f"' too large"
}


/*  --------------------------------------------------------------------
    2.13.4	String literals
		[lex.string]
    --------------------------------------------------------------------  */

lex_string_nl ( unsigned: n, plural: s )
{
    KEY (ISO)	"2.13.4" | "6.1.4"
    KEY (STD)	n" newline character"s" in string literal"
}

lex_string_pp_nl ()
{
    KEY (STD)	"End of line in string literal"
}

lex_string_concat ()
{
    USAGE:	concat_string
    KEY (STD)	"Concatenation of different string literal types"
}


/*  --------------------------------------------------------------------
    2.13.5	Boolean literals
		[lex.bool]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    3		Basic concepts
		[basic]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    3.1		Declarations and definitions
		[basic.def]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    3.2		One definition rule
		[basic.def.odr] = [basic.odr]
    --------------------------------------------------------------------  */

basic_odr_decl ( IDENTIFIER: id, PTR_LOC: loc )
{
    KEY (ISO)	"3.2" | "6.5"
    KEY (STD)	"'"id"' has already been declared (at "loc")"
}

basic_odr_diff ( IDENTIFIER: id, PTR_LOC: loc )
{
    KEY (STD)	"'"id"' has already been declared as a different kind
		 of object (at "loc")"
}

basic_odr_typedef ( IDENTIFIER: id, PTR_LOC: loc )
{
    USAGE:	type_redef
    KEY (STD)	"Type '"id"' redeclared (see "loc")"
}

basic_odr_def ( IDENTIFIER: id, PTR_LOC: loc )
{
    KEY (ISO)	"3.2" | "6.7"
    KEY (STD)	"'"id"' has already been defined (at "loc")"
}

basic_odr_def_func ( LONG_ID: id, PTR_LOC: loc )
{
    KEY (STD)	"The function '"id"' has already been defined (at "loc")"
}

basic_odr_undef ( LONG_ID: id )
{
    KEY (STD)	"'"id"' has been used but not defined"
}

basic_odr_inline ( LONG_ID: id )
{
    KEY (STD)	"The 'inline' function '"id"' has been used but not defined"
}

basic_odr_unused ( LONG_ID: id )
{
    USAGE:	whatever
    KEY (STD)	"'"id"' has been defined but not used"
}

basic_odr_redundant ( LONG_ID: id )
{
    USAGE:	whatever
    KEY (STD)	"'"id"' has been declared but not used or defined"
}

basic_odr_tentative ( IDENTIFIER: id, PTR_LOC: loc )
{
    USAGE:	wall
    KEY (ISO)	"3.2" | "6.7.2"
    KEY (STD)	"Multiple definition of '"id"' (see "loc")"
}

basic_odr_def_type ( LONG_ID: id, PTR_LOC: loc )
{
    KEY (ISO)	"3.2" | "6.5.2.3"
    KEY (STD)	"The type '"id"' has already been defined (at "loc")"
}


/*  --------------------------------------------------------------------
    3.3		Declarative regions and scopes
		[basic.scope]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    3.3.1	Point of declaration
		[basic.scope.pdecl]
    --------------------------------------------------------------------  */

basic_scope_pdecl_param ( LONG_ID: id )
{
    USAGE:	wall
    KEY (ISO)	"3.3.1" | "6.1.2.1"
    KEY (STD)	"The type '"id"' has function parameter scope - it is only
		 in scope in this declaration"
}


/*  --------------------------------------------------------------------
    3.3.2	Local scope
		[basic.scope.local]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    3.3.3	Function prototype scope
		[basic.scope.proto]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    3.3.4	Function scope
		[basic.scope.function]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    3.3.5	Namespace scope
		[basic.scope.namespace]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    3.3.6	Class scope
		[basic.scope.class]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    3.3.7	Name hiding
		[basic.scope.hiding]
    --------------------------------------------------------------------  */

basic_scope_hide ( HASHID: nm, PTR_LOC: loc )
{
    USAGE:	decl_hide
    KEY (ISO)	"3.3.7" | "6.1.2.1"
    KEY (STD)	"Declaration of '"nm"' hides a previous declaration
		 (at "loc")"
}

basic_scope_hide_mem ( HASHID: nm, IDENTIFIER: id )
{
    USAGE:	decl_hide
    KEY (STD)	"Declaration of '"nm"' hides the member '"id"'"
}


/*  --------------------------------------------------------------------
    3.4		Name look up
		[basic.lookup] = [lookup]
    --------------------------------------------------------------------  */

lookup_ambig_id ( IDENTIFIER: id )
{
    KEY (ISO)	"3.4" | "6.3.1"
    KEY (STD)	"The name '"id"' is ambiguous"
}

lookup_ambig_mem ( IDENTIFIER: id )
{
    KEY (STD)	"The member '"id"' is ambiguous"
}

lookup_ambig_list ()
{
    USAGE:	whatever
    KEY (STD)	"Ambiguous meanings are as follows"
}


/*  --------------------------------------------------------------------
    3.4.1	Unqualified name look up
		[basic.lookup.unqual] = [lookup.unqual]
    --------------------------------------------------------------------  */

lookup_unqual_undef ( HASHID: nm )
{
    KEY (ISO)	"3.4.1" | "6.3.1"
    KEY (STD)	"The identifier '"nm"' hasn't been declared in this scope"
}

lookup_unqual_vis ( IDENTIFIER: id )
{
    KEY (STD)	"Previous declaration of '"id"' isn't visible in this scope"
}


/*  --------------------------------------------------------------------
    3.4.2	Argument-dependent name look up
		[basic.lookup.koenig] = [lookup.koenig]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    3.4.3	Qualified name look up
		[basic.lookup.qual] = [lookup.qual]
    --------------------------------------------------------------------  */

lookup_qual_undef ( HASHID: nm, NAMESPACE: ns )
{
    KEY (ISO)	"3.4.3" | "6.5.2.1"
    KEY (STD)	"The member '"nm"' of '"ns"' hasn't been declared"
}

lookup_qual_bad ( IDENTIFIER: id, NAMESPACE: ns )
{
    KEY (STD)	"'"id"' is not a member of '"ns"'"
}

lookup_qual_decl ( IDENTIFIER: id, NAMESPACE: ns )
{
    KEY (STD)	"'"id"' is not an immediate member of '"ns"'"
}


/*  --------------------------------------------------------------------
    3.4.3.1	Class members
		[class.qual]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    3.4.3.2	Namespace members
		[namespace.qual] = [nspace.qual]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    3.4.4	Elaborate type specifiers
		[basic.lookup.elab] = [lookup.elab]
    --------------------------------------------------------------------  */

lookup_elab_alias ( BASE_TYPE: bt, IDENTIFIER: id )
{
    KEY (ISO)	"3.4.4" | "6.5.2.3"
    KEY (STD)	"'typedef' name used in '"bt" "id"'"
}

lookup_elab_invalid ( BASE_TYPE: bt, IDENTIFIER: id )
{
    KEY (STD)	"Invalid identifier used in '"bt" "id"'"
}

lookup_elab_enum ( LONG_ID: id )
{
    USAGE:	enum_decl
    KEY (STD)	"Can't declare the enumeration '"id"'"
}


/*  --------------------------------------------------------------------
    3.4.5	Class member access
		[basic.lookup.classref] = [lookup.classref]
    --------------------------------------------------------------------  */

lookup_classref_ambig ( IDENTIFIER: id )
{
    KEY (ISO)	"3.4.5" | "????"
    KEY (STD)	"Ambiguous class member look-up for '"id"'"
}


/*  --------------------------------------------------------------------
    3.4.6	Using directives and namespace aliases
		[basic.lookup.udir] = [lookup.udir]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    3.5		Program and linkage
		[basic.link]
    --------------------------------------------------------------------  */

basic_link_mem_extern ( LONG_ID: id )
{
    KEY (ISO)	"3.5" | "6.1.2.2"
    KEY (STD)	"The member '"id"' has external linkage"
}

basic_link_none ( TYPE: t, LONG_ID: id )
{
    USAGE:	cpp_error
    KEY (STD)	"A type with no linkage, '"t"', can't be used to declare
		 an object with linkage, '"id"'"
}

basic_link_qual ( CV_SPEC: cv1, CV_SPEC: cv2 )
{
    USAGE:	type_qual_incompat
    KEY (ISO)	"3.5" | "6.5.3"
    KEY (STD)	"The type qualifiers '"cv1"' and '"cv2"' are incompatible"
}

basic_link_incompat ( TYPE: t1, TYPE: t2 )
{
    KEY (ISO)	"3.5" | "6.1.2.6"
    KEY (STD)	"The types '"t1"' and '"t2"' are incompatible"
}

basic_link_decl_type ( IDENTIFIER: id, PTR_LOC: loc )
{
    USAGE:	whatever
    KEY (STD)	"The declaration of '"id"' should be compatible with
		 that at "loc
}

basic_link_typedef ( IDENTIFIER: id, PTR_LOC: loc )
{
    USAGE:	whatever
    KEY (STD)	"The redefinition of type '"id"' should be compatible
		 with that at "loc
}

basic_link_unmatch ( TYPE: t, IDENTIFIER: id )
{
    KEY (STD)	"The type '"t"' does not match any declaration of the
		 member '"id"'"
}


/*  --------------------------------------------------------------------
    3.6		Start and termination
		[basic.start]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    3.6.1	Main function
		[basic.start.main]
    --------------------------------------------------------------------  */

basic_start_main_over ( IDENTIFIER: id )
{
    KEY (ISO)	"3.6.1" | "5.1.2.2"
    KEY (STD)	"Can't overload '"id"'"
}

basic_start_main_ret ( TYPE: t, HASHID: nm )
{
    USAGE:	error | wall
    KEY (STD)	"Illegal return type '"t"' for '"nm"'"
}

basic_start_main_proto ( TYPE: t, HASHID: nm )
{
    USAGE:	wall
    KEY (STD)	"Unorthodox type '"t"' for '"nm"'"
}

basic_start_main_link ( HASHID: nm, DECL_SPEC: ds )
{
    USAGE:	error | wall
    KEY (STD)	"Can't declare '"nm"' to be '"ds"'"
}

basic_start_main_call ( IDENTIFIER: id )
{
    USAGE:	cpp_error
    KEY (STD)	"Can't call '"id"' from within a program"
}

basic_start_main_addr ( IDENTIFIER: id )
{
    USAGE:	cpp_error
    KEY (STD)	"Can't take the address of '"id"'"
}

basic_start_main_fall ( IDENTIFIER: id, TYPE: t )
{
    USAGE:	wall | func_ret_void
    KEY (STD)	"Implicit 'return 0' in function '"id"' which returns '"t"'"
}


/*  --------------------------------------------------------------------
    3.6.2	Initialization of non-local objects
		[basic.start.init]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    3.6.3	Termination
		[basic.start.term]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    3.7		Storage duration
		[basic.stc]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    3.7.1	Static storage duration
		[basic.stc.static]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    3.7.2	Automatic storage duration
		[basic.stc.auto]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    3.7.3	Dynamic storage duration
		[basic.stc.dynamic]
    --------------------------------------------------------------------  */

basic_stc_alloc_ret ( HASHID: nm, TYPE: t )
{
    KEY (ISO)	"3.7.3" | "????"
    KEY (STD)	"'"nm"' should return '"t"'"
}

basic_stc_alloc_p1 ( HASHID: nm, TYPE: t )
{
    KEY (STD)	"First parameter of '"nm"' should have type '"t"'"
}

basic_stc_alloc_d1 ( HASHID: nm )
{
    KEY (STD)	"First parameter of '"nm"' can't have default argument"
}

basic_stc_alloc_p2 ( HASHID: nm, TYPE: t )
{
    USAGE:	delete_over
    KEY (STD)	"Second parameter of '"nm"' should have type '"t"'"
}

basic_stc_alloc_pn ( HASHID: nm )
{
    USAGE:	delete_over
    KEY (STD)	"Too many parameters for '"nm"'"
}

basic_stc_alloc_templ ( HASHID: nm )
{
    KEY (STD)	"Template '"nm"' should have at least two parameters"
}

basic_stc_alloc_nspace ( IDENTIFIER: id )
{
    KEY (STD)	"Should declare '"id"' in global namespace scope"
}

basic_stc_alloc_link ( IDENTIFIER: id )
{
    KEY (STD)	"Can't declare '"id"' with internal linkage"
}


/*  --------------------------------------------------------------------
    3.7.3.1	Allocation functions
		[basic.stc.dynamic.allocation] = [basic.stc.alloc]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    3.7.3.2	Deallocation functions
		[basic.stc.dynamic.deallocation] = [basic.stc.dealloc]
    --------------------------------------------------------------------  */

basic_stc_dealloc_over ( IDENTIFIER: id )
{
    USAGE:	delete_over
    KEY (ISO)	"3.7.3.2" | "????"
    KEY (STD)	"Can't overload '"id"'"
}


/*  --------------------------------------------------------------------
    3.7.4	Duration of sub-objects
		[basic.stc.inherit]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    3.8		Object Lifetime
		[basic.life]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    3.9		Types
		[basic.types]
    --------------------------------------------------------------------  */

basic_types_def_incompl ( IDENTIFIER: id )
{
    KEY (ISO)	"3.9" | "6.5"
    KEY (STD)	"The defined object '"id"' must have complete object type"
}

basic_types_par_incompl ( IDENTIFIER: id )
{
    KEY (STD)	"The parameter '"id"' must have complete object type"
}

basic_types_tent_incompl ( IDENTIFIER: id )
{
    KEY (ISO)	"3.9" | "6.7.2"
    KEY (STD)	"The implicitly defined object '"id"' must have complete
		 object type"
}

basic_types_obj_func ( TYPE: t )
{
    USAGE:	whatever
    KEY (ISO)	"3.9" | "6.1.2.5"
    KEY (STD)	"The function type '"t"' is not an object type"
}

basic_types_obj_ref ( TYPE: t )
{
    USAGE:	whatever
    KEY (STD)	"The reference type '"t"' is not an object type"
}

basic_types_incompl ( TYPE: t )
{
    USAGE:	whatever
    KEY (STD)	"The type '"t"' is incomplete"
}

basic_types_completed ( TYPE: t )
{
    USAGE:	complete_struct
    KEY (STD)	"The type '"t"' has not been completed in its scope"
}

basic_types_obj_incompl ()
{
    USAGE:	whatever
    KEY (STD)	"An incomplete type is not a complete object type"
}

basic_types_obj_void ( TYPE: t )
{
    USAGE:	ptr_void
    KEY (STD)	"'"t"' is not a pointer to a complete object type"
}


/*  --------------------------------------------------------------------
    3.9.1	Fundamental types
		[basic.fundamental] = [basic.fund]
    --------------------------------------------------------------------  */

basic_fund_void_decl ( IDENTIFIER: id, TYPE: t )
{
    KEY (ISO)	"3.9.1" | "6.1.2.5"
    KEY (STD)	"The object '"id"' declared to have type '"t"'"
}

basic_fund_void_mem ( IDENTIFIER: id, TYPE: t )
{
    KEY (STD)	"The class member '"id"' declared to have type '"t"'"
}

basic_fund_void_exp ( TYPE: t )
{
    KEY (STD)	"Invalid use of expression of type '"t"'"
}


/*  --------------------------------------------------------------------
    3.9.2	Compound types
		[basic.compound]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    3.9.3	CV-qualifiers
		[basic.type.qualifier]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    3.10	Lvalues and rvalues
		[basic.lval]
    --------------------------------------------------------------------  */

basic_lval_not ()
{
    USAGE:	whatever
    KEY (ISO)	"3.10" | "6.2.2.1"
    KEY (STD)	"Expression is not an lvalue"
}

basic_lval_mod_rvalue ()
{
    KEY (STD)	"Expression should be an lvalue to be modifiable"
}

basic_lval_mod_array ()
{
    KEY (STD)	"Lvalues of array type are not modifiable"
}

basic_lval_mod_func ()
{
    KEY (STD)	"Lvalues of function type are not modifiable"
}

basic_lval_mod_incompl ()
{
    KEY (STD)	"Lvalues of incomplete types are not modifiable"
}

basic_lval_mod_const ()
{
    KEY (STD)	"A 'const' qualified lvalue is not modifiable"
}

basic_lval_mod_member ( TYPE: t )
{
    USAGE:	c_error
    KEY (STD)	"A type with a 'const' member, '"t"', is not modifiable"
}


/*  --------------------------------------------------------------------
    4		Standard conversions
		[conv]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    4.1		Lvalue-to-rvalue conversion
		[conv.lval]
    --------------------------------------------------------------------  */

conv_lval_incompl ()
{
    KEY (ISO)	"4.1" | "6.2.2.1"
    KEY (STD)	"Can't perform lvalue conversion on an incomplete type"
}


/*  --------------------------------------------------------------------
    4.2		Array-to-pointer conversion
		[conv.array]
    --------------------------------------------------------------------  */

conv_array_string ()
{
    USAGE:	const_string
    KEY (ISO)	"4.2" | "6.1.4"
    KEY (STD)	"Conversion of string literal to non-'const' type"
}

conv_array_str_mod ()
{
    USAGE:	const_string
    KEY (STD)	"String literals are not modifiable"
}


/*  --------------------------------------------------------------------
    4.3		Function-to-pointer conversion
		[conv.func]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    4.4		Qualification conversions
		[conv.qual]
    --------------------------------------------------------------------  */

conv_qual_cast ( CV_SPEC: cv )
{
    USAGE:	type_qual_incompat
    KEY (ISO)	"4.4" | "6.3.16.1"
    KEY (STD)	"Conversion casts away '"cv"'-ness"
}

conv_qual_multi ()
{
    USAGE:	type_qual_incompat
    KEY (STD)	"Multi-level qualification conversion should contain
		 'const' at each level"
}


/*  --------------------------------------------------------------------
    4.5		Integral promotions
		[conv.prom]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    4.6		Floating point promotion
		[conv.fpprom]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    4.7		Integral conversions
		[conv.integral]
    --------------------------------------------------------------------  */

conv_integral_cast ( TYPE: t1, TYPE: t2 )
{
    USAGE:	whatever
    KEY (ISO)	"4.7" | "6.2.1"
    KEY (STD)	"Integral conversion from '"t1"' to '"t2"'"
}


/*  --------------------------------------------------------------------
    4.8		Floating point conversions
		[conv.double]
    --------------------------------------------------------------------  */

conv_double_cast ( TYPE: t1, TYPE: t2 )
{
    USAGE:	whatever
    KEY (ISO)	"4.8" | "6.2.1"
    KEY (STD)	"Floating point conversion from '"t1"' to '"t2"'"
}


/*  --------------------------------------------------------------------
    4.9		Floating-integral conversions
		[conv.fpint]
    --------------------------------------------------------------------  */

conv_fpint_trunc ( TYPE: t1, TYPE: t2 )
{
    USAGE:	whatever
    KEY (ISO)	"4.9" | "6.2.1"
    KEY (STD)	"Floating point truncation from '"t1"' to '"t2"'"
}

conv_fpint_float ( TYPE: t1, TYPE: t2 )
{
    USAGE:	whatever
    KEY (STD)	"Integer to floating point conversion from '"t1"' to '"t2"'"
}

conv_fpint_large ( FLOAT: f )
{
    USAGE:	int_overflow
    KEY (STD)	"Integer overflow in truncation of '"f"'"
}


/*  --------------------------------------------------------------------
    4.10	Pointer conversions
		[conv.ptr]
    --------------------------------------------------------------------  */

conv_ptr_null_complex ()
{
    USAGE:	ptr_operator
    KEY (ISO)	"4.10" | "6.2.2.3"
    KEY (STD)	"Complex null pointer constant"
}

conv_ptr_nonzero ( TYPE: t1, TYPE: t2 )
{
    KEY (ISO)	"4.10" | "6.3.4"
    KEY (STD)	"Conversion of nonzero value of type '"t1"' to type '"t2"'"
}

conv_ptr_cast ( TYPE: t1, TYPE: t2 )
{
    KEY (STD)	"Pointer conversion from '"t1"' to '"t2"'"
}

conv_ptr_incompat ()
{
    USAGE:	whatever
    KEY (STD)	"Types in pointer conversion should be compatible"
}

conv_ptr_ambiguous ()
{
    KEY (STD)	"Base class in pointer conversion must be unambiguous"
}

conv_ptr_access ()
{
    KEY (STD)	"Accessible base required in base class conversion"
}

conv_ptr_common ()
{
    USAGE:	whatever
    KEY (STD)	"Can't bring incompatible types to a common pointer type"
}

conv_ptr_gen ( TYPE: t )
{
    USAGE:	gen_ptr_char
    KEY (STD)	"Type '"t"' used as generic pointer type"
}


/*  --------------------------------------------------------------------
    4.11	Pointer to member conversions
		[conv.mem]
    --------------------------------------------------------------------  */

conv_mem_nonzero ( TYPE: t1, TYPE: t2 )
{
    KEY (ISO)	"4.11" | "????"
    KEY (STD)	"Conversion of nonzero value of type '"t1"' to type '"t2"'"
}

conv_mem_cast ( TYPE: t1, TYPE: t2 )
{
    KEY (STD)	"Pointer to member conversion from '"t1"' to '"t2"'"
}

conv_mem_ambiguous ()
{
    KEY (STD)	"Base class in pointer to member conversion must
		 be unambiguous"
}

conv_mem_virtual ()
{
    KEY (STD)	"Base class in pointer to member conversion can't be virtual"
}

conv_mem_common ()
{
    USAGE:	whatever
    KEY (STD)	"Can't bring incompatible types to a common pointer to
		 member type"
}


/*  --------------------------------------------------------------------
    4.12	Boolean conversions
		[conv.bool]
    --------------------------------------------------------------------  */

conv_bool_cast ( TYPE: t )
{
    KEY (ISO)	"4.12" | "6.3"
    KEY (STD)	"Can't convert expression of type '"t"' to a boolean"
}

conv_bool_assign ()
{
    USAGE:	bool_assign
    KEY (STD)	"Assignment in boolean value"
}


/*  --------------------------------------------------------------------
    5		Expressions
		[expr]
    --------------------------------------------------------------------  */

expr_paren_left ( LEX: op1, LEX: op2 )
{
    USAGE:	paren
    KEY (ISO)	"5" | "6.3"
    KEY (STD)	"Operator precedence is '( a "op1" b ) "op2" c'"
}

expr_paren_right ( LEX: op1, LEX: op2 )
{
    USAGE:	paren
    KEY (STD)	"Operator precedence is 'a "op1" ( b "op2" c )'"
}

expr_convert_op ( unsigned: n, LEX: op )
{
    USAGE:	whatever
    KEY (STD)	"Conversion of operand "n" in operation '"op"'"
}


/*  --------------------------------------------------------------------
    5.1		Primary expressions
		[expr.prim]
    --------------------------------------------------------------------  */

expr_prim_this ()
{
    KEY (ISO)	"5.1" | "6.3.1"
    KEY (STD)	"'this' is only in scope in non-static member functions"
}

expr_prim_mem ( LONG_ID: id )
{
    KEY (STD)	"Can't use non-static member '"id"' in this context"
}

expr_prim_type ( LONG_ID: id )
{
    KEY (STD)	"'"id"' denotes a type, not an expression"
}


/*  --------------------------------------------------------------------
    5.2		Postfix expressions
		[expr.post]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    5.2.1	Subscripting
		[expr.sub]
    --------------------------------------------------------------------  */

expr_sub_ptr_op ( TYPE: t1, TYPE: t2 )
{
    KEY (ISO)	"5.2.1" | "6.3.2.1"
    KEY (STD)	"One operand of '[]' should have pointer type, not
		 '"t1"' and '"t2"'"
}

expr_sub_int_op ( TYPE: t )
{
    KEY (STD)	"Non-pointer operand of '[]' should have integral type,
		 not '"t"'"
}

expr_sub_char_op ( TYPE: t )
{
    USAGE:	ptr_operator
    KEY (STD)	"Non-pointer operand of '[]' has type '"t"'"
}

expr_sub_incompl ()
{
    KEY (STD)	"Pointer to complete object type expected in '[]'"
}


/*  --------------------------------------------------------------------
    5.2.2	Function call
		[expr.call]
    --------------------------------------------------------------------  */

expr_call_func ( LONG_ID: id )
{
    USAGE:	whatever
    KEY (ISO)	"5.2.2" | "6.3.2.2"
    KEY (STD)	"In call of function '"id"'"
}

expr_call_op ( TYPE: t )
{
    KEY (STD)	"Invalid function type, '"t"'"
}

expr_call_ret ()
{
    KEY (STD)	"Function return type should be a complete object type
		 or 'void'"
}

expr_call_mem ( LONG_ID: id )
{
    KEY (STD)	"Non-static member function '"id"' should have an
		 associated object"
}

expr_call_undecl ( LONG_ID: id )
{
    USAGE:	func_impl
    KEY (STD)	"Implicit declaration of function '"id"'"
}

expr_call_arg ( unsigned: n )
{
    USAGE:	whatever
    KEY (STD)	"Argument "n" is converted to parameter type"
}

expr_call_ellipsis ( unsigned: n )
{
    USAGE:	whatever
    KEY (STD)	"Argument "n" is converted to its promotion type"
}

expr_call_weak_arg ( unsigned: n, PTR_LOC: loc )
{
    USAGE:	weak
    KEY (STD)	"Incompatible type for argument "n" (see "loc")"
}

expr_call_args_exact ( unsigned: n, plural: s, unsigned: m )
{
    KEY (STD)	"Function call has "n" argument"s", it should have "m
}

expr_call_args_range ( unsigned: n, plural: s, unsigned: m1, unsigned: m2 )
{
    KEY (STD)	"Function call has "n" argument"s", it should have
		 between "m1" and "m2
}

expr_call_args_min ( unsigned: n, plural: s, unsigned: m )
{
    KEY (STD)	"Function call has "n" argument"s", it should have at
		 least "m
}

expr_call_struct ( TYPE: t )
{
    USAGE:	wall
    KEY (STD)	"Argument of type '"t"' is passed as a data structure"
}

expr_call_ell_func ()
{
    KEY (STD)	"Can only use '...' in function defined using '...'"
}

expr_call_ell_exp ()
{
    USAGE:	ellipsis_ident
    KEY (STD)	"'...' used as an expression"
}


/*  --------------------------------------------------------------------
    5.2.3	Explicit type conversion (functional notation)
		[expr.type.conv]
    --------------------------------------------------------------------  */

expr_type_conv_incompl ()
{
    KEY (ISO)	"5.2.3" | "6.3.4"
    KEY (STD)	"Complete object type required in type conversion"
}

expr_type_conv_array ( TYPE: t )
{
    KEY (STD)	"Can't use array type '"t"' in function-style cast"
}

expr_type_conv_bad ()
{
    USAGE:	whatever
    KEY (STD)	"Can't perform this conversion using a function-style cast"
}

expr_type_conv_many ( TYPE: t )
{
    KEY (STD)	"A function-style cast with more than one argument
		 requires a class type, not '"t"'"
}


/*  --------------------------------------------------------------------
    5.2.4	Pseudo-destructor call
		[expr.pseudo]
    --------------------------------------------------------------------  */

expr_pseudo_type ( TYPE: t1, TYPE: t2 )
{
    KEY (ISO)	"5.2.4" | "????"
    KEY (STD)	"Type mismatch for pseudo-destructor '"t1"::~"t2"'"
}

expr_pseudo_scalar ( TYPE: t )
{
    KEY (STD)	"Can only have pseudo-destructor for scalar types, not '"t"'"
}

expr_pseudo_obj ( HASHID: nm, TYPE: t )
{
    KEY (STD)	"Pseudo-destructor '"nm"' applied to type '"t"'"
}

expr_pseudo_args ( HASHID: nm )
{
    KEY (STD)	"Can't give arguments to pseudo-destructor '"nm"'"
}


/*  --------------------------------------------------------------------
    5.2.5	Class member access
		[expr.ref]
    --------------------------------------------------------------------  */

expr_ref_arrow_op ( TYPE: t, string: key )
{
    KEY (ISO)	"5.2.5" | "6.3.2.3"
    KEY (STD)	"First operand of '->' should have type pointer to "key",
		 not '"t"'"
}

expr_ref_dot_op ( TYPE: t, string: key )
{
    KEY (STD)	"First operand of '.' should have "key" type, not '"t"'"
}

expr_ref_arrow_dot ( TYPE: t )
{
    KEY (STD)	"Should use '.' with operand of type '"t"', not '->'"
}

expr_ref_dot_arrow ( TYPE: t )
{
    KEY (STD)	"Should use '->' with operand of type '"t"', not '.'"
}

expr_ref_incompl ( LEX: op, BASE_TYPE: key )
{
    KEY (STD)	"The "key" associated with the operand of '"op"' should
		 be complete"
}

expr_ref_select ( LEX: op, string: key )
{
    KEY (STD)	"Second operand of '"op"' should be a member of the "key"
		 given by the first operand"
}

expr_ref_call ()
{
    KEY (STD)	"Can only use member function selector in function call"
}

expr_ref_qual ( QUALIFIER: qual, IDENTIFIER: id )
{
    USAGE:	none
    KEY (STD)	"Illegal member access specifier, '"qual id"'"
}

expr_ref_func_type ( CLASS_TYPE: ct )
{
    KEY (STD)	"Member function called with unrelated class '"ct"'"
}

expr_ref_type ( IDENTIFIER: id )
{
    KEY (STD)	"'"id"' denotes a type member"
}


/*  --------------------------------------------------------------------
    5.2.6	Increment and decrement
		[expr.post.incr]
    --------------------------------------------------------------------  */

expr_post_incr_mod ( LEX: op )
{
    USAGE:	whatever
    KEY (ISO)	"5.2.6" | "6.3.2.4"
    KEY (STD)	"Operand of postfix '"op"' should be modifiable"
}

expr_post_incr_op ( LEX: op, TYPE: t )
{
    KEY (STD)	"Operand of postfix '"op"' should have arithmetic or
		 pointer type, not '"t"'"
}

expr_post_incr_incompl ( LEX: op )
{
    KEY (STD)	"Pointer to complete object type expected in postfix
		 '"op"' operation"
}

expr_post_incr_bool_inc ( LEX: op, TYPE: t )
{
    USAGE:	int_operator
    KEY (STD)	"Use of postfix '"op"' on type '"t"' is deprecated"
}

expr_post_incr_bool_dec ( LEX: op, TYPE: t )
{
    KEY (STD)	"Postfix '"op"' can't be applied to type '"t"'"
}


/*  --------------------------------------------------------------------
    5.2.7	Dynamic cast
		[expr.dynamic.cast] = [expr.cast.dynam]
    --------------------------------------------------------------------  */

expr_cast_dynam_typedef ()
{
    KEY (ISO)	"5.2.7" | "6.3.4"
    KEY (STD)	"Can't define a type in a 'dynamic_cast' expression"
}

expr_cast_dynam_bad ()
{
    USAGE:	whatever
    KEY (STD)	"Can't perform this conversion using 'dynamic_cast'"
}

expr_cast_dynam_type ( TYPE: t )
{
    KEY (STD)	"Pointer or reference to complete class expected in
		 'dynamic_cast', not '"t"'"
}

expr_cast_dynam_ptr ( TYPE: t )
{
    KEY (STD)	"Operand to 'dynamic_cast' should be a pointer to
		 complete class, not '"t"'"
}

expr_cast_dynam_ref ( TYPE: t )
{
    KEY (STD)	"Operand to 'dynamic_cast' should be an lvalue of
		 complete class type, not '"t"'"
}

expr_cast_dynam_poly ( CLASS_TYPE: ct )
{
    KEY (STD)	"Operand to 'dynamic_cast' should have polymorphic
		 class, not '"ct"'"
}


/*  --------------------------------------------------------------------
    5.2.8	Type identification
		[expr.typeid]
    --------------------------------------------------------------------  */

expr_typeid_index ( LEX: op )
{
    USAGE:	wall
    KEY (ISO)	"5.2.8" | "????"
    KEY (STD)	"Index in '"op"' expression is unevaluated"
}

expr_typeid_side ( LEX: op )
{
    USAGE:	wall
    KEY (STD)	"Side effects in unevaluated '"op"' expression"
}

expr_typeid_typedef ( LEX: op )
{
    KEY (STD)	"Can't define a type in a '"op"' expression"
}

expr_typeid_incompl ( LEX: op )
{
    KEY (STD)	"Can't have incomplete class in a '"op"' expression"
}

expr_typeid_vtable ( LEX: op )
{
    KEY (STD)	"Can only apply '"op"' to polymorphic types"
}


/*  --------------------------------------------------------------------
    5.2.9	Static cast
		[expr.static.cast] = [expr.cast.stat]
    --------------------------------------------------------------------  */

expr_cast_stat_typedef ()
{
    KEY (ISO)	"5.2.9" | "6.3.4"
    KEY (STD)	"Can't define a type in a 'static_cast' expression"
}

expr_cast_stat_bad ()
{
    USAGE:	whatever
    KEY (STD)	"Can't perform this conversion using 'static_cast'"
}

expr_cast_stat_int_enum ( TYPE: t1, TYPE: t2 )
{
    KEY (STD)	"Integer to enumeration conversion from '"t1"' to '"t2"'"
}

expr_cast_stat_enum_enum ( TYPE: t1, TYPE: t2 )
{
    KEY (STD)	"Conversion between different enumeration types '"t1"'
		 and '"t2"'"
}

expr_cast_stat_virt ()
{
    KEY (STD)	"Base class in pointer up-cast can't be virtual"
}

expr_cast_stat_func ( TYPE: t )
{
    KEY (STD)	"Can't cast to the function type '"t"'"
}


/*  --------------------------------------------------------------------
    5.2.10	Reinterpret cast
		[expr.reinterpret.cast] = [expr.cast.reint]
    --------------------------------------------------------------------  */

expr_cast_reint_typedef ()
{
    KEY (ISO)	"5.2.10" | "6.3.4"
    KEY (STD)	"Can't define a type in a 'reinterpret_cast' expression"
}

expr_cast_reint_bad ()
{
    USAGE:	whatever
    KEY (STD)	"Can't perform this conversion using 'reinterpret_cast'"
}

expr_cast_reint_int_ptr ( TYPE: t1, TYPE: t2 )
{
    KEY (STD)	"Integer to pointer conversion from '"t1"' to '"t2"'"
}

expr_cast_reint_ptr_int ( TYPE: t1, TYPE: t2 )
{
    KEY (STD)	"Pointer to integer conversion from '"t1"' to '"t2"'"
}

expr_cast_reint_func_ptr ( TYPE: t1, TYPE: t2 )
{
    USAGE:	conv_ptr_func
    KEY (STD)	"Can't convert function pointer '"t1"' to non-function
		 pointer '"t2"'"
}

expr_cast_reint_mem_func ( TYPE: t1, TYPE: t2 )
{
    KEY (STD)	"Pointer to member function '"t1"' converted to pointer
		 to function '"t2"'"
}


/*  --------------------------------------------------------------------
    5.2.11	Const cast
		[expr.const.cast] = [expr.cast.const]
    --------------------------------------------------------------------  */

expr_cast_const_typedef ()
{
    KEY (ISO)	"5.2.11" | "6.3.4"
    KEY (STD)	"Can't define a type in a 'const_cast' expression"
}

expr_cast_const_bad ()
{
    USAGE:	whatever
    KEY (STD)	"Can't perform this conversion using 'const_cast'"
}


/*  --------------------------------------------------------------------
    5.3		Unary expressions
		[expr.unary]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    5.3.1	Unary operators
		[expr.unary.op]
    --------------------------------------------------------------------  */

expr_unary_op_indir_op ( TYPE: t )
{
    KEY (ISO)	"5.3.1" | "6.3.3.2"
    KEY (STD)	"Operand of unary '*' should have pointer type, not '"t"'"
}

expr_unary_op_indir_void ( TYPE: t )
{
    USAGE:	none
    KEY (STD)	"Can't apply unary '*' to a operand of type '"t"'"
}

expr_unary_op_indir_null ( LEX: op )
{
    USAGE:	ptr_operator
    KEY (STD)	"'"op"' is undefined on null pointers"
}

expr_unary_op_ref_lvalue ()
{
    KEY (STD)	"Operand of unary '&' should be an lvalue"
}

expr_unary_op_ref_void ( TYPE: t )
{
    KEY (STD)	"Can't apply unary '&' to a operand of type '"t"'"
}

expr_unary_op_ref_incompl ()
{
    USAGE:	none
    KEY (STD)	"Operand of unary '&' can't be incomplete"
}

expr_unary_op_ref_post ( IDENTIFIER: id )
{
    USAGE:	wall
    KEY (STD)	"Function '"id"' declared in class previously taken address
		 of as incomplete type"
}

expr_unary_op_ref_bitf ()
{
    KEY (STD)	"Operand of unary '&' can't be a bitfield"
}

expr_unary_op_ref_register ( IDENTIFIER: id )
{
    USAGE:	addr_register
    KEY (STD)	"Can't take the address of the 'register' variable '"id"'"
}

expr_unary_op_ref_paren ()
{
    KEY (STD)	"Member operand to unary '&' can't be parenthesized"
}

expr_unary_op_ref_full ()
{
    USAGE:	none
    KEY (STD)	"Member operand to unary '&' can't be a fully qualified
		 identifier"
}

expr_unary_op_ref_unqual ()
{
    KEY (STD)	"Member operand to unary '&' must be a qualified identifier"
}

expr_unary_op_uplus_op ( LEX: op, TYPE: t )
{
    KEY (ISO)	"5.3.1" | "6.3.3.3"
    KEY (STD)	"Operand of unary '"op"' should have arithmetic or pointer
		 type, not '"t"'"
}

expr_unary_op_uminus_op ( LEX: op, TYPE: t )
{
    KEY (STD)	"Operand of unary '"op"' should have arithmetic type,
		 not '"t"'"
}

expr_unary_op_compl_op ( LEX: op, TYPE: t )
{
    KEY (STD)	"Operand of '"op"' should have integral type, not '"t"'"
}

expr_unary_op_not_op ()
{
    USAGE:	whatever
    KEY (STD)	"Operand of '!' is converted to a boolean"
}


/*  --------------------------------------------------------------------
    5.3.2	Increment and decrement
		[expr.pre.incr]
    --------------------------------------------------------------------  */

expr_pre_incr_mod ( LEX: op )
{
    USAGE:	whatever
    KEY (ISO)	"5.3.2" | "6.3.3.1"
    KEY (STD)	"Operand of prefix '"op"' should be modifiable"
}

expr_pre_incr_op ( LEX: op, TYPE: t )
{
    KEY (STD)	"Operand of prefix '"op"' should have arithmetic or
		 pointer type, not '"t"'"
}

expr_pre_incr_incompl ( LEX: op )
{
    KEY (STD)	"Pointer to complete object type expected in prefix
		 '"op"' operation"
}

expr_pre_incr_bool_inc ( LEX: op, TYPE: t )
{
    USAGE:	int_operator
    KEY (STD)	"Use of prefix '"op"' on type '"t"' is deprecated"
}

expr_pre_incr_bool_dec ( LEX: op, TYPE: t )
{
    KEY (STD)	"Postfix '"op"' can't be applied to type '"t"'"
}


/*  --------------------------------------------------------------------
    5.3.3	Sizeof
		[expr.sizeof]
    --------------------------------------------------------------------  */

expr_sizeof_func ( LEX: op )
{
    KEY (ISO)	"5.3.3" | "6.3.3.4"
    KEY (STD)	"Can't apply '"op"' to a function type"
}

expr_sizeof_bitf ( LEX: op )
{
    KEY (STD)	"Can't apply '"op"' to a bitfield type"
}

expr_sizeof_incompl ( LEX: op )
{
    KEY (STD)	"Can't apply '"op"' to an incomplete type"
}

expr_sizeof_typedef ( LEX: op )
{
    USAGE:	cpp_error
    KEY (STD)	"Can't define a type in a '"op"' expression"
}

expr_sizeof_side ( LEX: op )
{
    USAGE:	wall
    KEY (STD)	"Side effects in unevaluated '"op"' expression"
}


/*  --------------------------------------------------------------------
    5.3.4	New
		[expr.new]
    --------------------------------------------------------------------  */

expr_new_typedef ()
{
    KEY (ISO)	"5.3.4" | "????"
    KEY (STD)	"Can't declare types in a 'new' expression"
}

expr_new_incompl ()
{
    KEY (STD)	"Type in 'new' expression should be a complete object type"
}

expr_new_abstract ()
{
    KEY (STD)	"Type in 'new' expression can't be abstract"
}

expr_new_dim ( TYPE: t )
{
    KEY (STD)	"Array bound in 'new' expression should have integral
		 type, not '"t"'"
}

expr_new_init ( LEX: op )
{
    USAGE:	whatever
    KEY (STD)	"In '"op"' expression initializer"
}

expr_new_array_init ( LEX: op )
{
    KEY (STD)	"Can't have an initializer in '"op"' expression"
}


/*  --------------------------------------------------------------------
    5.3.5	Delete
		[expr.delete]
    --------------------------------------------------------------------  */

expr_delete_ptr ( LEX: op, TYPE: t )
{
    KEY (ISO)	"5.3.5" | "????"
    KEY (STD)	"Operand of '"op"' expression should have pointer type,
		 not '"t"'"
}

expr_delete_conv ( LEX: op )
{
    USAGE:	whatever
    KEY (STD)	"Operand of '"op"' expression is converted to a pointer type"
}

expr_delete_void ( LEX: op, TYPE: t )
{
    USAGE:	wall
    KEY (STD)	"Operand of '"op"' expression can't have type '"t"'"
}

expr_delete_obj ( LEX: op )
{
    KEY (STD)	"Pointer in '"op"' expression should be to an object type"
}

expr_delete_incompl ( LEX: op )
{
    USAGE:	wall
    KEY (STD)	"Pointer in '"op"' expression should be to a complete type"
}

expr_delete_post ( IDENTIFIER: id )
{
    USAGE:	wall
    KEY (STD)	"Function '"id"' declared in class deleted through
		 pointer to incomplete type"
}

expr_delete_const ( CV_SPEC: cv )
{
    USAGE:	none
    KEY (STD)	"Can't delete a '"cv"' object"
}

expr_delete_array ( LEX: op )
{
    KEY (STD)	"The array bound in '"op"' is anachronistic"
}


/*  --------------------------------------------------------------------
    5.4		Explicit type conversion (cast notation)
		[expr.cast]
    --------------------------------------------------------------------  */

expr_cast_expl_used ()
{
    USAGE:	cast_explicit
    KEY (ISO)	"5.4" | "6.3.4"
    KEY (STD)	"Explicit cast expression"
}

expr_cast_expl_typedef ()
{
    USAGE:	cpp_error
    KEY (STD)	"Can't define a type in a cast expression"
}

expr_cast_expl_scalar ( TYPE: t )
{
    USAGE:	c_error
    KEY (STD)	"Can't cast to the non-scalar type '"t"'"
}

expr_cast_invalid ( TYPE: t1, TYPE: t2 )
{
    KEY (STD)	"Illegal conversion from type '"t1"' to type '"t2"'"
}

expr_cast_expl_bad ()
{
    USAGE:	whatever
    KEY (STD)	"Can't perform this conversion using an explicit cast"
}

expr_cast_ref ( TYPE: t1, TYPE: t2 )
{
    USAGE:	whatever
    KEY (STD)	"'cast < "t1" > ( a )' is equivalent to
		 '*cast < "t2" > ( &a )'"
}


/*  --------------------------------------------------------------------
    5.5		Pointer-to-member operators
		[expr.mptr.oper]
    --------------------------------------------------------------------  */

expr_mptr_oper_arrow_op ( LONG_ID: id, TYPE: t )
{
    KEY (ISO)	"5.5" | "????"
    KEY (STD)	"First operand of '->*' should have type pointer to
		 '"id"', not '"t"'"
}

expr_mptr_oper_dot_op ( LONG_ID: id, TYPE: t )
{
    KEY (STD)	"First operand of '.*' should have type '"id"', not '"t"'"
}

expr_mptr_oper_arrow_dot ( TYPE: t )
{
    KEY (STD)	"Should use '.*' with operand of type '"t"', not '->*'"
}

expr_mptr_oper_dot_arrow ( TYPE: t )
{
    KEY (STD)	"Should use '->*' with operand of type '"t"', not '.*'"
}

expr_mptr_oper_op2 ( LEX: op, TYPE: t )
{
    KEY (STD)	"Second operand of '"op"' should have pointer to member
		 type, not '"t"'"
}

expr_mptr_oper_compl ( LEX: op )
{
    KEY (STD)	"Class in '"op"' should be complete"
}

expr_mptr_oper_ambig ( LEX: op )
{
    KEY (STD)	"Base class conversion in '"op"' must be unambiguous"
}

expr_mptr_oper_call ()
{
    KEY (STD)	"Can only use function member selector in a function call"
}

expr_mptr_oper_null ( LEX: op )
{
    USAGE:	ptr_operator
    KEY (STD)	"'"op"' is undefined on null pointer to members"
}

expr_mptr_oper_paren ()
{
    USAGE:	whatever
    KEY (STD)	"Possible precedence error involving '.*' or '->*'"
}


/*  --------------------------------------------------------------------
    5.6		Multiplicative operators
		[expr.mul]
    --------------------------------------------------------------------  */

expr_mul_mul_op ( LEX: op, TYPE: t1, TYPE: t2 )
{
    KEY (ISO)	"5.6" | "6.3.5"
    KEY (STD)	"Operands of binary '"op"' should be arithmetic, not
		 '"t1"' and '"t2"'"
}

expr_mul_rem_op ( LEX: op, TYPE: t1, TYPE: t2 )
{
    KEY (STD)	"Operands of '"op"' should be integral, not '"t1"' and '"t2"'"
}

expr_mul_div_zero ( LEX: op )
{
    USAGE:	int_overflow
    KEY (STD)	"Division operation '"op"' with zero divisor is undefined"
}

expr_mul_div_neg ( LEX: op, NAT: n )
{
    USAGE:	int_operator
    KEY (STD)	"Division operation '"op"' involving negative operand
		 '"n"' is implementation dependent"
}


/*  --------------------------------------------------------------------
    5.7		Additive operators
		[expr.add]
    --------------------------------------------------------------------  */

expr_add_op ( LEX: op, TYPE: t1, TYPE: t2 )
{
    KEY (ISO)	"5.7" | "6.3.6"
    KEY (STD)	"Can't perform binary '"op"' on operands of types '"t1"'
		 and '"t2"'"
}

expr_add_incompl ( LEX: op )
{
    KEY (STD)	"Pointer to complete object type expected in binary '"op"'"
}

expr_add_ptrdiff ()
{
    USAGE:	whatever
    KEY (STD)	"Pointers in '-' should be to compatible types"
}

expr_add_array ( NAT: n, TYPE: t, LEX: op )
{
    USAGE:	ptr_operator
    KEY (STD)	"Can't address element '"n"' of array of type '"t"'
		 using '"op"'"
}

expr_add_different ()
{
    USAGE:	ptr_operator
    KEY (STD)	"Pointers in '-' should be to elements of the same array"
}


/*  --------------------------------------------------------------------
    5.8		Shift operators
		[expr.shift]
    --------------------------------------------------------------------  */

expr_shift_op ( LEX: op, TYPE: t1, TYPE: t2 )
{
    KEY (ISO)	"5.8" | "6.3.7"
    KEY (STD)	"Operands of '"op"' should be integral, not '"t1"' and '"t2"'"
}

expr_shift_op1_sign ( LEX: op )
{
    USAGE:	int_operator
    KEY (STD)	"Shift operation '"op"' with signed first operand is
		 implementation dependent"
}

expr_shift_op1_neg ( LEX: op, NAT: n )
{
    USAGE:	int_operator
    KEY (STD)	"Shift operation '"op"' with negative first operand '"n"'
		 is implementation dependent"
}

expr_shift_op2_neg ( LEX: op, NAT: n )
{
    USAGE:	int_operator
    KEY (STD)	"Shift operation '"op"' with negative second operand '"n"'
		 is undefined"
}

expr_shift_op2_big ( LEX: op, NAT: n, TYPE: t )
{
    USAGE:	int_operator
    KEY (STD)	"Shift operation '"op"' second operand '"n"' exceeds
		 the minimum size of first operand type, '"t"'"
}


/*  --------------------------------------------------------------------
    5.9		Relational operators
		[expr.rel]
    --------------------------------------------------------------------  */

expr_rel_op ( LEX: op, TYPE: t1, TYPE: t2 )
{
    KEY (ISO)	"5.9" | "6.3.8"
    KEY (STD)	"Can't perform '"op"' on operands of types '"t1"' and '"t2"'"
}

expr_rel_nonzero ( LEX: op, TYPE: t1, TYPE: t2 )
{
    KEY (STD)	"Can't perform '"op"' on an operand of type '"t1"' and a
		 nonzero value of type '"t2"'"
}

expr_rel_ptr ( LEX: op )
{
    USAGE:	whatever
    KEY (STD)	"Pointer operands of '"op"' are converted to a common type"
}

expr_rel_ptr_void ( LEX: op, TYPE: t1, TYPE: t2 )
{
    USAGE:	ptr_operator | error
    KEY (STD)	"Comparison '"op"' performed on operands of types '"t1"'
		 and '"t2"'"
}

expr_rel_paren ( LEX: op1, LEX: op2 )
{
    USAGE:	paren
    KEY (STD)	"Expressions like 'a "op1" b "op2" c' do not have their
		 mathematical meaning"
}

expr_rel_true ()
{
    USAGE:	int_operator
    KEY (STD)	"The relation 'a >= 0' is always true for unsigned
		 comparisons"
}

expr_rel_false ()
{
    USAGE:	int_operator
    KEY (STD)	"The relation 'a < 0' is always false for unsigned
		 comparisons"
}

expr_rel_null ( LEX: op )
{
    USAGE:	ptr_operator | error
    KEY (STD)	"Can't have null pointer operand to '"op"'"
}


/*  --------------------------------------------------------------------
    5.10	Equality operators
		[expr.eq]
    --------------------------------------------------------------------  */

expr_eq_op ( LEX: op, TYPE: t1, TYPE: t2 )
{
    KEY (ISO)	"5.10" | "6.3.9"
    KEY (STD)	"Can't perform '"op"' on operands of types '"t1"' and '"t2"'"
}

expr_eq_nonzero ( LEX: op, TYPE: t1, TYPE: t2 )
{
    KEY (STD)	"Can't perform '"op"' on an operand of type '"t1"' and
		 a nonzero value of type '"t2"'"
}

expr_eq_ptr ( LEX: op )
{
    USAGE:	whatever
    KEY (STD)	"Pointer operands of '"op"' are converted to a common type"
}

expr_eq_mptr ( LEX: op )
{
    USAGE:	whatever
    KEY (STD)	"Pointer to member operands of '"op"' are converted to a
		 common type"
}

expr_eq_float ( LEX: op )
{
    USAGE:	int_operator
    KEY (STD)	"Floating point '"op"' operation"
}


/*  --------------------------------------------------------------------
    5.11	Bitwise AND operator
		[expr.bit.and]
    --------------------------------------------------------------------  */

expr_bit_and_op ( LEX: op, TYPE: t1, TYPE: t2 )
{
    KEY (ISO)	"5.11" | "6.3.10"
    KEY (STD)	"Operands of binary '"op"' should be integral, not
		 '"t1"' and '"t2"'"
}


/*  --------------------------------------------------------------------
    5.12	Bitwise exclusive OR operator
		[expr.xor]
    --------------------------------------------------------------------  */

expr_xor_op ( LEX: op, TYPE: t1, TYPE: t2 )
{
    KEY (ISO)	"5.12" | "6.3.11"
    KEY (STD)	"Operands of '"op"' should be integral, not '"t1"'
		 and '"t2"'"
}


/*  --------------------------------------------------------------------
    5.13	Bitwise inclusive OR operator
		[expr.or]
    --------------------------------------------------------------------  */

expr_or_op ( LEX: op, TYPE: t1, TYPE: t2 )
{
    KEY (ISO)	"5.13" | "6.3.12"
    KEY (STD)	"Operands of '"op"' should be integral, not '"t1"'
		 and '"t2"'"
}


/*  --------------------------------------------------------------------
    5.14	Logical AND operator
		[expr.log.and]
    --------------------------------------------------------------------  */

expr_log_and_op ( LEX: op )
{
    USAGE:	whatever
    KEY (ISO)	"5.14" | "6.3.13"
    KEY (STD)	"Operands of '"op"' are converted to booleans"
}


/*  --------------------------------------------------------------------
    5.15	Logical OR operator
		[expr.log.or]
    --------------------------------------------------------------------  */

expr_log_or_op ( LEX: op )
{
    USAGE:	whatever
    KEY (ISO)	"5.15" | "6.3.14"
    KEY (STD)	"Operands of '"op"' are converted to booleans"
}


/*  --------------------------------------------------------------------
    5.16	Conditional operator
		[expr.cond]
    --------------------------------------------------------------------  */

expr_cond_bool ()
{
    USAGE:	whatever
    KEY (ISO)	"5.16" | "6.3.15"
    KEY (STD)	"The condition of '?:' is converted to a boolean"
}

expr_cond_const ()
{
    USAGE:	const_cond
    KEY (STD)	"Constant condition in '?:' expression"
}

expr_cond_op ( TYPE: t1, TYPE: t2 )
{
    KEY (STD)	"Can't perform '?:' on operands of types '"t1"' and '"t2"'"
}

expr_cond_qual ( TYPE: t1, TYPE: t2 )
{
    USAGE:	none
    KEY (STD)	"Qualifier mismatch for operands of types '"t1"' and
		 '"t2"' in '?:'"
}

expr_cond_nonzero ( TYPE: t1, TYPE: t2 )
{
    KEY (STD)	"Can't perform '?:' on an operand of type '"t1"' and a
		 nonzero value of type '"t2"'"
}

expr_cond_ptr ()
{
    USAGE:	whatever
    KEY (STD)	"Pointer operands of '?:' are converted to a common type"
}

expr_cond_mptr ()
{
    USAGE:	whatever
    KEY (STD)	"Pointer to member operands of '?:' are converted
		 to a common type"
}


/*  --------------------------------------------------------------------
    5.17	Assignment operators
		[expr.ass]
    --------------------------------------------------------------------  */

expr_ass_mod ( LEX: op )
{
    USAGE:	whatever
    KEY (ISO)	"5.17" | "6.3.16"
    KEY (STD)	"Left operand of '"op"' should be modifiable"
}

expr_ass_op ( LEX: op, TYPE: t1, TYPE: t2 )
{
    KEY (STD)	"Can't perform '"op"' on operands of types '"t1"' and '"t2"'"
}

expr_ass_incompl ( LEX: op )
{
    KEY (STD)	"Pointer to complete object type expected in '"op"'"
}

expr_ass_conv ()
{
    USAGE:	whatever
    KEY (STD)	"Can't perform this conversion by assignment"
}

expr_ass_twice ( IDENTIFIER: id )
{
    USAGE:	variable
    KEY (STD)	"Variable '"id"' modified twice in expression"
}


/*  --------------------------------------------------------------------
    5.18	Comma operator
		[expr.comma]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    5.19	Constant expressions
		[expr.const]
    --------------------------------------------------------------------  */

expr_const_bad ()
{
    USAGE:	whatever
    KEY (ISO)	"5.19" | "6.4"
    KEY (STD)	"Illegal integer constant expression"
}

expr_const_int ( TYPE: t )
{
    USAGE:	whatever
    KEY (STD)	"Constant expression should have integral type, not '"t"'"
}

expr_const_off_mem ( LONG_ID: id )
{
    KEY (STD)	"Member '"id"' doesn't designate a constant offset"
}

expr_const_off_array ( TYPE: t )
{
    KEY (STD)	"Array type required in constant offset, not '"t"'"
}

expr_const_off_dim ()
{
    KEY (STD)	"Constant index required in constant offset"
}


/*  --------------------------------------------------------------------
    6		Statements
		[stmt.stmt]
    --------------------------------------------------------------------  */

stmt_stmt_unreach ()
{
    USAGE:	reached
    KEY (ISO)	"6" | "6.6"
    KEY (STD)	"Statement not reached"
}

stmt_stmt_empty ( LEX: op )
{
    USAGE:	empty_body
    KEY (STD)	"Empty body in '"op"' statement"
}


/*  --------------------------------------------------------------------
    6.1		Labeled statement
		[stmt.label]
    --------------------------------------------------------------------  */

stmt_label_redef ( IDENTIFIER: lab, LONG_ID: fn, PTR_LOC: loc )
{
    KEY (ISO)	"6.1" | "6.6.1"
    KEY (STD)	"Label '"lab"' already defined in function '"fn"' (at "loc")"
}

stmt_label_unused ( IDENTIFIER: lab, LONG_ID: fn )
{
    USAGE:	reached
    KEY (STD)	"Label '"lab"' defined but not used in function '"fn"'"
}

stmt_label_case ()
{
    KEY (STD)	"'case' should be inside a 'switch' statement"
}

stmt_label_default ()
{
    KEY (STD)	"'default' should be inside a 'switch' statement"
}

stmt_label_fall ( LEX: op )
{
    USAGE:	case_fall
    KEY (STD)	"Fall into '"op"' statement"
}


/*  --------------------------------------------------------------------
    6.2		Expression statement
		[stmt.expr]
    --------------------------------------------------------------------  */

stmt_expr_discard_func ()
{
    USAGE:	discard_func
    KEY (ISO)	"6.2" | "6.6.3"
    KEY (STD)	"Discarded function return"
}

stmt_expr_discard_val ()
{
    USAGE:	discard_value
    KEY (STD)	"Discarded value"
}

stmt_expr_incompl ()
{
    USAGE:	none
    KEY (STD)	"Incomplete value discarded"
}


/*  --------------------------------------------------------------------
    6.3		Compound statement or block
		[stmt.block]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    6.4		Selection statements
		[stmt.select]
    --------------------------------------------------------------------  */

stmt_select_type ( TYPE: t )
{
    KEY (ISO)	"6.4" | "6.6.4"
    KEY (STD)	"Invalid type for condition declaration, '"t"'"
}

stmt_select_typedef ()
{
    KEY (STD)	"Can't declare a type in a condition declaration"
}


/*  --------------------------------------------------------------------
    6.4.1	The if statement
		[stmt.if]
    --------------------------------------------------------------------  */

stmt_if_cond ()
{
    USAGE:	whatever
    KEY (ISO)	"6.4.1" | "6.6.4.1"
    KEY (STD)	"Condition of an 'if' statement is converted to a boolean"
}

stmt_if_const ()
{
    USAGE:	const_cond
    KEY (STD)	"Constant condition in 'if' statement"
}

stmt_if_no_else ()
{
    USAGE:	cond_default
    KEY (STD)	"No 'else' in 'if' statement"
}


/*  --------------------------------------------------------------------
    6.4.2	The switch statement
		[stmt.switch]
    --------------------------------------------------------------------  */

stmt_switch_control ( TYPE: t )
{
    KEY (ISO)	"6.4.2" | "6.6.4.2"
    KEY (STD)	"Control expression of a 'switch' statement should have
		 integral type, not '"t"'"
}

stmt_switch_conv ()
{
    USAGE:	whatever
    KEY (STD)	"Control expression of a 'switch' statement is converted
		 to an integral type"
}

stmt_switch_const ()
{
    USAGE:	const_cond
    KEY (STD)	"Constant control expression in 'switch' statement"
}

stmt_switch_case_const ()
{
    KEY (STD)	"Expression in a 'case' statement should be an integer
		 constant"
}

stmt_switch_case_dup ( NAT: n, PTR_LOC: loc )
{
    KEY (STD)	"'case "n"' already defined in 'switch' (at "loc")"
}

stmt_switch_default_dup ( PTR_LOC: loc )
{
    KEY (STD)	"'default' already defined in 'switch' (at "loc")"
}

stmt_switch_case_not ( NAT: n )
{
    KEY (STD)	"'case "n"' not defined in 'switch'"
}

stmt_switch_default_not ()
{
    KEY (STD)	"'default' not defined in 'switch'"
}

stmt_switch_exhaust_none ()
{
    KEY (STD)	"No cases in exhaustive 'switch' statement"
}

stmt_switch_exhaust_default ()
{
    KEY (STD)	"Can't have 'default' in exhaustive 'switch' statement"
}

stmt_switch_case_none ()
{
    USAGE:	const_cond
    KEY (STD)	"No cases in 'switch' statement"
}

stmt_switch_no_default ()
{
    USAGE:	cond_default
    KEY (STD)	"No 'default' in 'switch' statement"
}

stmt_switch_case_enum ( LONG_ID: id )
{
    USAGE:	enum_switch
    KEY (STD)	"Enumerator '"id"' not covered in 'switch'"
}

stmt_switch_case_extra ( NAT: n, TYPE: t )
{
    USAGE:	enum_switch
    KEY (STD)	"'case "n"' is not a valid value for type '"t"'"
}


/*  --------------------------------------------------------------------
    6.5		Iteration statements
		[stmt.iter]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    6.5.1	The while statement
		[stmt.while]
    --------------------------------------------------------------------  */

stmt_while_cond ()
{
    USAGE:	whatever
    KEY (ISO)	"6.5.1" | "6.6.5.1"
    KEY (STD)	"Condition of a 'while' statement is converted to a boolean"
}

stmt_while_const ()
{
    USAGE:	const_cond
    KEY (STD)	"Constant condition in 'while' statement"
}


/*  --------------------------------------------------------------------
    6.5.2	The do statement
		[stmt.do]
    --------------------------------------------------------------------  */

stmt_do_cond ()
{
    USAGE:	whatever
    KEY (ISO)	"6.5.2" | "6.6.5.2"
    KEY (STD)	"Condition of a 'do' statement is converted to a boolean"
}

stmt_do_const ()
{
    USAGE:	const_cond
    KEY (STD)	"Constant condition in 'do' statement"
}


/*  --------------------------------------------------------------------
    6.5.3	The for statement
		[stmt.for]
    --------------------------------------------------------------------  */

stmt_for_cond ()
{
    USAGE:	whatever
    KEY (ISO)	"6.5.3" | "6.6.5.3"
    KEY (STD)	"Condition of a 'for' statement is converted to a boolean"
}

stmt_for_const ()
{
    USAGE:	const_cond
    KEY (STD)	"Constant condition in 'for' statement"
}

stmt_for_init ( IDENTIFIER: id )
{
    USAGE:	for_scope
    KEY (STD)	"Variable '"id"' used outside its 'for' statement"
}


/*  --------------------------------------------------------------------
    6.6		Jump statements
		[stmt.jump]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    6.6.1	The break statement
		[stmt.break]
    --------------------------------------------------------------------  */

stmt_break_bad ()
{
    KEY (ISO)	"6.6.1" | "6.6.6.3"
    KEY (STD)	"'break' should be inside an iteration or 'switch' statement"
}


/*  --------------------------------------------------------------------
    6.6.2	The continue statement
		[stmt.cont]
    --------------------------------------------------------------------  */

stmt_cont_bad ()
{
    KEY (ISO)	"6.6.2" | "6.6.6.2"
    KEY (STD)	"'continue' should be inside an iteration statement"
}


/*  --------------------------------------------------------------------
    6.6.3	The return statement
		[stmt.return]
    --------------------------------------------------------------------  */

stmt_return_void ( IDENTIFIER: id, TYPE: t )
{
    USAGE:	func_ret_void
    KEY (ISO)	"6.6.3" | "6.6.6.4"
    KEY (STD)	"'return' with no value in function '"id"' which
		 returns '"t"'"
}

stmt_return_none ( IDENTIFIER: id, TYPE: t )
{
    KEY (STD)	"'return' with value in function '"id"' which returns '"t"'"
}

stmt_return_bottom ( IDENTIFIER: id, TYPE: t )
{
    KEY (STD)	"Can't return from function '"id"' which returns '"t"'"
}

stmt_return_conv ()
{
    USAGE:	whatever
    KEY (STD)	"'return' value is converted to function return type"
}

stmt_return_fall ( IDENTIFIER: id, TYPE: t )
{
    USAGE:	func_ret_void
    KEY (STD)	"Fall out of function '"id"' which returns '"t"'"
}

stmt_return_auto ( LONG_ID: id, LEX: op )
{
    USAGE:	ptr_operator
    KEY (STD)	"Reference to local variable '"id"' in '"op"'"
}


/*  --------------------------------------------------------------------
    6.6.4	The goto statement
		[stmt.goto]
    --------------------------------------------------------------------  */

stmt_goto_undef ( IDENTIFIER: lab, LONG_ID: fn )
{
    KEY (ISO)	"6.6.4" | "6.6.6.1"
    KEY (STD)	"Label '"lab"' used but not defined in function '"fn"'"
}

stmt_goto_case ( LEX: op )
{
    KEY (STD)	"Can't have 'goto "op"'"
}


/*  --------------------------------------------------------------------
    6.7		Declaration statement
		[stmt.dcl]
    --------------------------------------------------------------------  */

stmt_dcl_start ()
{
    USAGE:	c_error
    KEY (ISO)	"6.7" | "6.6.2"
    KEY (STD)	"Declaration statement should be at start of block"
}

stmt_dcl_bypass_lab ( IDENTIFIER: lab, IDENTIFIER: id )
{
    USAGE:	error | variable
    KEY (STD)	"Jump to label '"lab"' bypasses initialization of '"id"'"
}

stmt_dcl_bypass_case ( NAT: n, IDENTIFIER: id )
{
    USAGE:	error | variable
    KEY (STD)	"Jump to 'case "n"' bypasses initialization of '"id"'"
}

stmt_dcl_bypass_default ( IDENTIFIER: id )
{
    USAGE:	error | variable
    KEY (STD)	"Jump to 'default' bypasses initialization of '"id"'"
}

stmt_dcl_unused ( LONG_ID: id )
{
    USAGE:	variable
    KEY (STD)	"Variable '"id"' not used"
}

stmt_dcl_unset ( LONG_ID: id )
{
    USAGE:	variable
    KEY (STD)	"Variable '"id"' may be used without being set"
}

stmt_dcl_reset ( LONG_ID: id )
{
    USAGE:	variable
    KEY (STD)	"Variable '"id"' not used since previous assignment"
}


/*  --------------------------------------------------------------------
    6.8		Ambiguity resolution
		[stmt.ambig]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    7		Declarations
		[dcl.dcl]
    --------------------------------------------------------------------  */

dcl_dcl_none ()
{
    USAGE:	decl_none
    KEY (ISO)	"7" | "6.7"
    KEY (STD)	"No declarations in translation unit"
}

dcl_dcl_empty ()
{
    USAGE:	decl_empty
    KEY (ISO)	"7" | "6.5"
    KEY (STD)	"Every declaration must introduce a name"
}

dcl_dcl_semicolon ()
{
    USAGE:	semicolon_extra
    KEY (STD)	"Can't have empty declaration"
}

dcl_dcl_anon ()
{
    USAGE:	decl_struct_anon
    KEY (STD)	"Every type definition must introduce a name"
}

dcl_dcl_ds_empty ()
{
    USAGE:	dspec_none
    KEY (STD)	"No declaration specifiers in declaration"
}

dcl_dcl_ds_func ()
{
    USAGE:	dspec_none_func
    KEY (STD)	"No declaration specifiers in function definition"
}


/*  --------------------------------------------------------------------
    7.1		Specifiers
		[dcl.spec]
    --------------------------------------------------------------------  */

dcl_spec_dup ( DECL_SPEC: ds )
{
    KEY (ISO)	"7.1" | "6.5.1"
    KEY (STD)	"Duplicate declaration specifier, '"ds" "ds"'"
}

dcl_spec_order ( DECL_SPEC: ds )
{
    USAGE:	wall
    KEY (STD)	"Declaration specifier, '"ds"' after type specifier"
}


/*  --------------------------------------------------------------------
    7.1.1	Storage class specifiers
		[dcl.stc]
    --------------------------------------------------------------------  */

dcl_stc_dup ( DECL_SPEC: ds1, DECL_SPEC: ds2 )
{
    KEY (ISO)	"7.1.1" | "6.5.1"
    KEY (STD)	"Multiple storage class specifiers '"ds1"', assuming '"ds2"'"
}

dcl_stc_stat_block ()
{
    USAGE:	func_block
    KEY (STD)	"Can't declare 'static' functions inside a block"
}

dcl_stc_bad ( DECL_SPEC: ds )
{
    USAGE:	cpp_error
    KEY (ISO)	"7.1.1" | "6.7"
    KEY (STD)	"Storage class specifier '"ds"' must be applied to an object"
}

dcl_stc_expl_spec ( DECL_SPEC: ds )
{
    KEY (STD)	"Can't apply '"ds"' to an explicit specialization or
		 instantiation"
}

dcl_stc_auto_bad ( DECL_SPEC: ds )
{
    KEY (STD)	"Can only apply '"ds"' to a function parameter or variable"
}

dcl_stc_auto_func ( DECL_SPEC: ds )
{
    KEY (STD)	"Can't apply '"ds"' to a function declaration"
}

dcl_stc_ext_inline ()
{
    USAGE:	none
    KEY (STD)	"Can't declare a function 'extern inline'"
}

dcl_stc_ext_mem ()
{
    KEY (STD)	"Can't apply 'extern' to a class member"
}

dcl_stc_mut_bad ()
{
    KEY (STD)	"Can only apply 'mutable' to a data member"
}

dcl_stc_mut_const ( LONG_ID: id )
{
    KEY (STD)	"Can't apply 'mutable' to the 'const' member '"id"'"
}

dcl_stc_param ( DECL_SPEC: ds )
{
    KEY (ISO)	"7.1.1" | "6.7.1"
    KEY (STD)	"Can't apply '"ds"' to a function parameter"
}

dcl_stc_auto_par ()
{
    USAGE:	c_error
    KEY (STD)	"Can't apply 'auto' to a function parameter"
}

dcl_stc_internal ( LONG_ID: id, PTR_LOC: loc )
{
    USAGE:	link_incompat
    KEY (ISO)	"7.1.1" | "6.1.2.2"
    KEY (STD)	"'"id"' previously declared with internal linkage (at "loc")"
}

dcl_stc_external ( LONG_ID: id, PTR_LOC: loc )
{
    USAGE:	link_resolve
    KEY (STD)	"'"id"' previously declared with external linkage (at "loc")"
}


/*  --------------------------------------------------------------------
    7.1.2	Function specifiers
		[dcl.fct.spec]
    --------------------------------------------------------------------  */

dcl_fct_spec_inline_bad ()
{
    KEY (ISO)	"7.1.2" | "6.5.1"
    KEY (STD)	"The specifier 'inline' can only applied to function
		 declarations"
}

dcl_fct_spec_block ()
{
    KEY (STD)	"Can't declare 'inline' functions inside a block"
}

dcl_fct_spec_virtual ()
{
    KEY (STD)	"The specifier 'virtual' can only applied to function members"
}

dcl_fct_spec_explicit ()
{
    KEY (STD)	"The specifier 'explicit' can only applied to function members"
}

dcl_fct_spec_expl_constr ()
{
    KEY (STD)	"Can only apply 'explicit' to a constructor"
}

dcl_fct_spec_expl_conv ()
{
    KEY (STD)	"Can't apply 'explicit' to a conversion function"
}

dcl_fct_spec_inline_call ( LONG_ID: id )
{
    USAGE:	none
    KEY (STD)	"The inline function '"id"' has been called before it
		 is defined"
}


/*  --------------------------------------------------------------------
    7.1.3	The typedef specifier
		[dcl.typedef]
    --------------------------------------------------------------------  */

dcl_typedef_func ()
{
    KEY (ISO)	"7.1.3" | "6.5.1"
    KEY (STD)	"Can't apply 'typedef' to a function definition"
}

dcl_typedef_par ()
{
    KEY (STD)	"Can't apply 'typedef' to a function parameter"
}

dcl_typedef_dspec ( DECL_SPEC: ds )
{
    KEY (STD)	"Can't use declaration specifier(s) '"ds"' with 'typedef'"
}

dcl_typedef_dcl ()
{
    USAGE:	none
    KEY (STD)	"The 'typedef' specifier must define a type"
}

dcl_typedef_constr ( IDENTIFIER: id, HASHID: nm )
{
    KEY (STD)	"Can't use 'typedef' name '"id"' in constructor '"nm"'"
}

dcl_typedef_destr ( IDENTIFIER: id, HASHID: nm )
{
    KEY (STD)	"Can't use 'typedef' name '"id"' in destructor '"nm"'"
}


/*  --------------------------------------------------------------------
    7.1.4	The friend specifier
		[dcl.friend]
    --------------------------------------------------------------------  */

dcl_friend_class ()
{
    KEY (ISO)	"7.1.4" | "????"
    KEY (STD)	"The specifier 'friend' can only be used in a class
		 definition"
}


/*  --------------------------------------------------------------------
    7.1.5	Type specifiers
		[dcl.type]
    --------------------------------------------------------------------  */

dcl_type_infer ( TYPE: t )
{
    USAGE:	whatever
    KEY (ISO)	"7.1.5" | "6.5.2"
    KEY (STD)	"Type '"t"' inferred"
}

dcl_type_none ()
{
    USAGE:	infer_int
    KEY (STD)	"No type specifier given in declaration"
}

dcl_type_qual ()
{
    USAGE:	infer_int_cv
    KEY (STD)	"Only type qualifiers given in type specifier"
}

dcl_type_cv_dup ( CV_SPEC: cv )
{
    KEY (ISO)	"7.1.5" | "6.5.3"
    KEY (STD)	"Duplicate type qualifier, '"cv" "cv"'"
}

dcl_type_type_cv ( LONG_ID: id, CV_SPEC: cv )
{
    USAGE:	wall | error
    KEY (STD)	"Type '"id"' is already '"cv"' qualified"
}


/*  --------------------------------------------------------------------
    7.1.5.1	The cv-qualifiers
		[dcl.type.cv]
    --------------------------------------------------------------------  */

dcl_type_cv_unused ( CV_SPEC: cv )
{
    USAGE:	cpp_error
    KEY (ISO)	"7.1.5.1" | "6.5.3"
    KEY (STD)	"Type specifier(s) '"cv"' not used"
}


/*  --------------------------------------------------------------------
    7.1.5.2	Simple type specifiers
		[dcl.type.simple]
    --------------------------------------------------------------------  */

dcl_type_simple_dup ( BASE_TYPE: bt )
{
    KEY (ISO)	"7.1.5.2" | "6.5.2"
    KEY (STD)	"Duplicate type specifier, '"bt" "bt"'"
}

dcl_type_simple_bad ( BASE_TYPE: bt1, BASE_TYPE: bt2 )
{
    KEY (STD)	"Illegal type specifier, '"bt1"', assuming '"bt2"'"
}

dcl_type_simple_llong ( BASE_TYPE: bt )
{
    USAGE:	longlong
    KEY (STD)	"Type specifier '"bt"' used"
}

dcl_type_simple_many ( TYPE: t1, TYPE: t2 )
{
    KEY (STD)	"Duplicate type names, '"t1"' and '"t2"'"
}

dcl_type_simple_undecl ( BASE_TYPE: bt, TYPE: t )
{
    KEY (STD)	"Can't use type specifiers '"bt"' with '"t"'"
}

dcl_type_simple_undef ( IDENTIFIER: id )
{
    KEY (STD)	"The type '"id"' hasn't been declared"
}


/*  --------------------------------------------------------------------
    7.1.5.3	Elaborated type specifiers
		[dcl.type.elab]
    --------------------------------------------------------------------  */

dcl_type_elab_bad ( BASE_TYPE: bt1, BASE_TYPE: bt2, IDENTIFIER: id, PTR_LOC: loc )
{
    USAGE:	type_tag_ignore
    KEY (ISO)	"7.1.5.3" | "6.5.2.3"
    KEY (STD)	"Inconsistent key '"bt1"' used for '"bt2" "id"' (see "loc")"
}

dcl_type_elab_qual ( BASE_TYPE: bt )
{
    KEY (STD)	"A type declaration should have the form '"bt" identifier'"
}


/*  --------------------------------------------------------------------
    7.2		Enumeration declarations
		[dcl.enum]
    --------------------------------------------------------------------  */

dcl_enum_none ()
{
    USAGE:	c_error
    KEY (ISO)	"7.2" | "6.5.2.2"
    KEY (STD)	"No enumerators in enumeration type"
}

dcl_enum_const ( LONG_ID: id )
{
    KEY (STD)	"Value for enumerator '"id"' should be an integer
		 constant expression"
}

dcl_enum_zero ( TYPE: t )
{
    USAGE:	wall
    KEY (STD)	"Zero is not a valid enumerator value for '"t"'"
}


/*  --------------------------------------------------------------------
    7.3		Namespaces
		[basic.namespace] = [dcl.nspace]
    --------------------------------------------------------------------  */

dcl_nspace_scope ()
{
    KEY (ISO)	"7.3" | "????"
    KEY (STD)	"A namespace can only be defined in namespace scope"
}

dcl_nspace_undef ( IDENTIFIER: id )
{
    KEY (STD)	"The namespace '"id"' hasn't been defined"
}


/*  --------------------------------------------------------------------
    7.3.1	Namespace definition
		[namespace.def] = [dcl.nspace.def]
    --------------------------------------------------------------------  */

dcl_nspace_def_orig ( IDENTIFIER: id1, IDENTIFIER: id2 )
{
    KEY (ISO)	"7.3.1" | "????"
    KEY (STD)	"Namespace extension should use original name, '"id1"',
		 not the alias '"id2"'"
}


/*  --------------------------------------------------------------------
    7.3.1.1	Unnamed namespaces
		[namespace.unnamed] = [dcl.nspace.unnamed]
    --------------------------------------------------------------------  */

dcl_nspace_unnamed_static ()
{
    USAGE:	none
    KEY (ISO)	"7.3.1.1" | "????"
    KEY (STD)	"Use of 'static' in namespace scope is deprecated"
}


/*  --------------------------------------------------------------------
    7.3.1.2	Namespace member definitions
		[namespace.memdef] = [dcl.nspace.memdef]
    --------------------------------------------------------------------  */

dcl_nspace_memdef_scope ( LONG_ID: id )
{
    KEY (ISO)	"7.3.1.2" | "6.5.7"
    KEY (STD)	"'"id"' can only be defined in an enclosing namespace scope"
}


/*  --------------------------------------------------------------------
    7.3.2	Namespace or class alias
		[namespace.alias] = [dcl.nspace.alias]
    --------------------------------------------------------------------  */

dcl_nspace_alias_class ( NAMESPACE: ns )
{
    KEY (ISO)	"7.3.2" | "????"
    KEY (STD)	"Namespace alias can't refer to the class '"ns"'"
}

dcl_nspace_alias_bad ( IDENTIFIER: id, PTR_LOC: loc )
{
    KEY (STD)	"Namespace alias '"id"' has already been defined as an
		 original namespace name (at "loc")"
}

dcl_nspace_alias_redef ( IDENTIFIER: id, PTR_LOC: loc )
{
    KEY (STD)	"Namespace '"id"' redefined inconsistently (see "loc")"
}


/*  --------------------------------------------------------------------
    7.3.3	The using declaration
		[namespace.udecl] = [dcl.nspace.udecl]
    --------------------------------------------------------------------  */

dcl_nspace_udecl_unqual ()
{
    KEY (ISO)	"7.3.3" | "????"
    KEY (STD)	"The identifier in a 'using' declaration must be qualified"
}

dcl_nspace_udecl_mem ( IDENTIFIER: id )
{
    KEY (STD)	"Can't use '"id"' in its own scope"
}

dcl_nspace_udecl_base ( IDENTIFIER: id, CLASS_TYPE: ct )
{
    KEY (STD)	"Used identifier '"id"' is not a member of a base class
		 of '"ct"'"
}

dcl_nspace_udecl_vis ( IDENTIFIER: id, CLASS_TYPE: ct )
{
    KEY (STD)	"Used identifier '"id"' is not visible in '"ct"'"
}

dcl_nspace_udecl_id ( IDENTIFIER: id )
{
    KEY (STD)	"'"id"' can only be used in a derived class"
}

dcl_nspace_udecl_constr ( IDENTIFIER: id )
{
    KEY (STD)	"Can't use the member '"id"'"
}

dcl_nspace_udecl_acc ( IDENTIFIER: id, PTR_LOC: loc )
{
    USAGE:	wall
    KEY (STD)	"Declaration reduces access to '"id"' (see "loc")"
}

dcl_nspace_udecl_multi ( IDENTIFIER: id, PTR_LOC: loc )
{
    KEY (STD)	"Invalid redeclaration of '"id"' (see "loc")"
}

dcl_nspace_udecl_redecl ( IDENTIFIER: id, PTR_LOC: loc )
{
    KEY (STD)	"Can't redeclare '"id"' (see "loc")"
}


/*  --------------------------------------------------------------------
    7.3.4	Using directive
		[namespace.udir] = [dcl.nspace.udir]
    --------------------------------------------------------------------  */


dcl_nspace_udir_class ( NAMESPACE: ns )
{
    KEY (ISO)	"7.3.4" | "????"
    KEY (STD)	"Can't use the class namespace '"ns"'"
}

dcl_nspace_udir_dup ( NAMESPACE: ns )
{
    USAGE:	none
    KEY (STD)	"Namespace '"ns"' already used in this scope"
}


/*  --------------------------------------------------------------------
    7.4		The asm declaration
		[dcl.asm]
    --------------------------------------------------------------------  */

dcl_asm_ti ()
{
    USAGE:	wall
    KEY (ISO)	"7.4" | "Annex G"
    KEY (STD)	"'asm' declarations are not portable"
}

dcl_asm_args ()
{
    KEY (STD)	"Can't have arguments with 'asm'"
}


/*  --------------------------------------------------------------------
    7.5		Linkage specifications
		[dcl.link]
    --------------------------------------------------------------------  */

dcl_link_unknown ( STRING: str )
{
    KEY (ISO)	"7.5" | "????"
    KEY (STD)	"Unknown linkage specifier, "str
}

dcl_link_scope ()
{
    KEY (STD)	"Linkage specifications can only occur in namespace scope"
}

dcl_link_lang ( LONG_ID: id, string: s, PTR_LOC: loc )
{
    USAGE:	link_incompat
    KEY (STD)	"'"id"' previously declared with "s" linkage (at "loc")"
}

dcl_link_func ( string: s )
{
    USAGE:	func_linkage
    KEY (STD)	"Function type previously declared with "s" linkage"
}

dcl_link_conv ()
{
    USAGE:	func_linkage
    KEY (STD)	"Differing function linkage specifications in conversion"
}

dcl_link_over ()
{
    USAGE:	whatever
    KEY (STD)	"Only one function in a set of overloaded functions
		 can have C linkage"
}

dcl_link_redecl ( HASHID: nm, PTR_LOC: loc )
{
    USAGE:	whatever | none
    KEY (STD)	"Two objects with C linkage named '"nm"' are the same"
}


/*  --------------------------------------------------------------------
    8		Declarators
		[dcl.decl]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    8.1		Type names
		[dcl.name]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    8.2		Ambiguity resolution
		[dcl.ambig.res]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    8.3		Meaning of declarators
		[dcl.meaning]
    --------------------------------------------------------------------  */

dcl_meaning_id ( QUALIFIER: qual, IDENTIFIER: id )
{
    KEY (ISO)	"8.3" | "6.5.4"
    KEY (STD)	"The identifier '"qual id"' can't be used in this context"
}

dcl_meaning_full ( QUALIFIER: qual, IDENTIFIER: id )
{
    USAGE:	none
    KEY (STD)	"The fully qualified identifier '"qual id"' can't be
		 used in this context"
}

dcl_meaning_mem ( QUALIFIER: qual, IDENTIFIER: id )
{
    KEY (STD)	"Illegally qualified member declaration '"qual id"'"
}

dcl_meaning_paren ()
{
    USAGE:	wall
    KEY (STD)	"Redundant parentheses in declarator"
}


/*  --------------------------------------------------------------------
    8.3.1	Pointers
		[dcl.ptr]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    8.3.2	References
		[dcl.ref]
    --------------------------------------------------------------------  */

dcl_ref_cv ( CV_SPEC: cv )
{
    KEY (ISO)	"8.3.2" | "????"
    KEY (STD)	"Can't have '"cv"' qualified references"
}

dcl_ref_cv_type ( CV_SPEC: cv, LONG_ID: id )
{
    USAGE:	wall
    KEY (STD)	"'"cv"' qualifier for reference type '"id"'"
}

dcl_ref_void ( TYPE: t )
{
    KEY (STD)	"Can't have references to '"t"'"
}

dcl_ref_ref ()
{
    KEY (STD)	"Can't have references to references"
}

dcl_ref_ptr ()
{
    KEY (STD)	"Can't have pointers to references"
}

dcl_ref_array ()
{
    KEY (STD)	"Can't have arrays of references"
}


/*  --------------------------------------------------------------------
    8.3.3	Pointers to members
		[dcl.mptr]
    --------------------------------------------------------------------  */

dcl_mptr_type ( IDENTIFIER: id )
{
    KEY (ISO)	"8.3.3" | "????"
    KEY (STD)	"Class name required in pointer to member, not '"id"'"
}

dcl_mptr_class ( TYPE: t )
{
    KEY (STD)	"Class type required in pointer to member, not '"t"'"
}

dcl_mptr_void ( TYPE: t )
{
    KEY (STD)	"Can't have pointers to '"t"' members"
}

dcl_mptr_ref ()
{
    KEY (STD)	"Can't have pointers to reference members"
}


/*  --------------------------------------------------------------------
    8.3.4	Arrays
		[dcl.array]
    --------------------------------------------------------------------  */

dcl_array_void ( TYPE: t )
{
    KEY (ISO)	"8.3.4" | "6.1.2.5"
    KEY (STD)	"Can't have arrays of '"t"'"
}

dcl_array_incompl ()
{
    USAGE:	type_obj_incompl
    KEY (STD)	"Can't have arrays of incomplete types"
}

dcl_array_abstract ()
{
    KEY (STD)	"Can't have arrays of abstract types"
}

dcl_array_array ()
{
    KEY (STD)	"Can't have arrays of incomplete arrays"
}

dcl_array_bitf ()
{
    KEY (STD)	"Can't have arrays of bitfields"
}

dcl_array_func ()
{
    KEY (STD)	"Can't have arrays of functions"
}

dcl_array_dim_const ()
{
    KEY (ISO)	"8.3.4" | "6.5.4.2"
    KEY (STD)	"Array bound should be an integer constant expression"
}

dcl_array_dim_zero ()
{
    KEY (STD)	"Array bound can't be zero"
}

dcl_array_dim_neg ( NAT: n )
{
    KEY (STD)	"Array bound should be greater than zero, not "n
}


/*  --------------------------------------------------------------------
    8.3.5	Functions
		[dcl.fct]
    --------------------------------------------------------------------  */

dcl_fct_par_void ( IDENTIFIER: id, TYPE: t )
{
    KEY (ISO)	"8.3.5" | "6.5.4.3"
    KEY (STD)	"Parameter '"id"' declared to have type '"t"'"
}

dcl_fct_par_array ( IDENTIFIER: id, TYPE: t )
{
    USAGE:	cpp_error
    KEY (STD)	"Parameter '"id"' declared to have incomplete array
		 type '"t"'"
}

dcl_fct_par_weak ()
{
    KEY (STD)	"Parameter required in weak function prototype"
}

dcl_fct_par_empty ()
{
    KEY (STD)	"Precisely '( void )' required in empty parameter list"
}

dcl_fct_par_ellipsis ()
{
    USAGE:	none | ellipsis_ident
    KEY (STD)	"Need at least one parameter before '...'"
}

dcl_fct_weak ()
{
    KEY (STD)	"Can only have parameter list in function definition"
}

dcl_fct_proto ()
{
    USAGE:	func_proto
    KEY (STD)	"Function prototype used"
}

dcl_fct_nonproto ()
{
    USAGE:	func_weak
    KEY (STD)	"Non-prototype function used"
}

dcl_fct_array ()
{
    KEY (STD)	"Can't have functions returning arrays"
}

dcl_fct_bitf ()
{
    KEY (STD)	"Can't have functions returning bitfields"
}

dcl_fct_func ()
{
    KEY (STD)	"Can't have functions returning functions"
}

dcl_fct_typedef_par ()
{
    USAGE:	cpp_error
    KEY (STD)	"Can't define a type in a function parameter"
}

dcl_fct_typedef_ret ()
{
    USAGE:	cpp_error
    KEY (STD)	"Can't define a type in a function return"
}

dcl_fct_cv_ret ( CV_SPEC: cv )
{
    USAGE:	none
    KEY (STD)	"A function can't return a '"cv"' qualified type"
}

dcl_fct_cv ( CV_SPEC: cv )
{
    KEY (STD)	"Invalid use of '"cv"' qualified function"
}

dcl_fct_cv_decl ( CV_SPEC: cv )
{
    KEY (STD)	"Only non-static member functions can be '"cv"' qualified"
}

dcl_fct_compat_ellipsis ()
{
    USAGE:	ellipsis_extra
    KEY (STD)	"Compatible function types should agree on use of ellipsis"
}

dcl_fct_compat_prom ( TYPE: t )
{
    USAGE:	func_incompat
    KEY (STD)	"The type '"t"' is not compatible with its argument
		 promotion type"
}

dcl_fct_qual ( CV_SPEC: cv, LONG_ID: id )
{
    KEY (ISO)	"8.3.5" | "6.5.3"
    KEY (STD)	"'"cv"' qualifier for function type '"id"'"
}

dcl_fct_ret ()
{
    KEY (ISO)	"8.3.5" | "6.7.1"
    KEY (STD)	"Function return type should be a complete object type or
		 'void'"
}

dcl_fct_ret_void ( TYPE: t )
{
    KEY (STD)	"Function return type can't be '"t"'"
}

dcl_fct_typedef ()
{
    KEY (STD)	"Can't define a function using a 'typedef' function type"
}

dcl_fct_par_proto ()
{
    KEY (STD)	"Can't have parameter list with prototype"
}

dcl_fct_par_anon ()
{
    USAGE:	c_error
    KEY (STD)	"Must have parameter name in function definition"
}

dcl_fct_par_undecl ( HASHID: nm )
{
    KEY (STD)	"Parameter '"nm"' doesn't appear in parameter list"
}

dcl_fct_par_typedef ( IDENTIFIER: id )
{
    KEY (STD)	"Can't use type name '"id"' in parameter list"
}

dcl_fct_par_none ()
{
    KEY (STD)	"Parameter declaration should contain a declarator"
}

dcl_fct_par_impl ( IDENTIFIER: id )
{
    USAGE:	param_impl
    KEY (STD)	"Implicit declaration of parameter '"id"'"
}

dcl_fct_par_order ()
{
    USAGE:	wall
    KEY (STD)	"Function parameters declared out of sequence"
}


/*  --------------------------------------------------------------------
    8.3.6	Default arguments
		[dcl.fct.default]
    --------------------------------------------------------------------  */

dcl_fct_default_bad ()
{
    KEY (ISO)	"8.3.6" | "6.7.1"
    KEY (STD)	"Can only have default arguments in a function declaration"
}

dcl_fct_default_missing ( IDENTIFIER: id )
{
    KEY (STD)	"Parameter '"id"' should have a default argument"
}

dcl_fct_default_dup ( IDENTIFIER: id, PTR_LOC: loc )
{
    KEY (STD)	"Duplicate default argument for parameter '"id"' (see "loc")"
}

dcl_fct_default_redef ( IDENTIFIER: id, PTR_LOC: loc )
{
    KEY (STD)	"Default argument for parameter '"id"' redefined
		 inconsistently (see "loc")"
}

dcl_fct_default_templ ()
{
    KEY (STD)	"Can't add default arguments to template functions"
}

dcl_fct_default_param ( IDENTIFIER: id )
{
    KEY (STD)	"'"id"' can't be used in a default argument"
}

dcl_fct_default_weak ( IDENTIFIER: id )
{
    USAGE:	c_error
    KEY (STD)	"Can't initialize the parameter '"id"'"
}


/*  --------------------------------------------------------------------
    8.4		Function definitions
		[dcl.fct.def]
    --------------------------------------------------------------------  */

dcl_fct_def_scope ()
{
    KEY (ISO)	"8.4" | "6.7.1"
    KEY (STD)	"A function can only be defined in namespace or class scope"
}

dcl_fct_def_comment ( LONG_ID: id )
{
    USAGE:	whatever
    KEY (STD)	"In definition of function '"id"'"
}


/*  --------------------------------------------------------------------
    8.5		Initializers
		[dcl.init]
    --------------------------------------------------------------------  */

dcl_init_decl ( IDENTIFIER: id, string: s )
{
    USAGE:	whatever
    KEY (ISO)	"8.5" | "6.5.7"
    KEY (STD)	"In initialization of '"id s"'"
}

dcl_init_typedef ( IDENTIFIER: id )
{
    KEY (STD)	"Can't initialize the type '"id"'"
}

dcl_init_incompl ()
{
    KEY (STD)	"Can't initialize objects of incomplete type"
}

dcl_init_func ( LONG_ID: id )
{
    KEY (STD)	"Can't initialize the function '"id"'"
}

dcl_init_bad ()
{
    KEY (STD)	"Badly placed function style initializer"
}

dcl_init_const ()
{
    USAGE:	cpp_error
    KEY (STD)	"'const' objects should be initialized"
}

dcl_init_ctor ( TYPE: t )
{
    KEY (STD)	"A constructor-style initializer with more than one
		 argument requires a class type, not '"t"'"
}

dcl_init_conv ()
{
    USAGE:	whatever
    KEY (STD)	"Can't perform this conversion by initialization"
}

dcl_init_assign ()
{
    USAGE:	whatever
    KEY (STD)	"Initializers are converted as if by assignment"
}

dcl_init_dynamic ()
{
    USAGE:	init_dynamic
    KEY (STD)	"Object initializer should be a constant expression"
}


/*  --------------------------------------------------------------------
    8.5.1	Aggregates
		[dcl.init.aggr]
    --------------------------------------------------------------------  */

dcl_init_aggr_array_bad ()
{
    KEY (ISO)	"8.5.1" | "6.5.7"
    KEY (STD)	"Bad array initializer"
}

dcl_init_aggr_dynamic ()
{
    USAGE:	init_dynamic
    KEY (STD)	"Expression in aggregate initializer should be constant"
}

dcl_init_aggr_array_ti ( NAT: n, TYPE: t )
{
    USAGE:	init_aggregate
    KEY (STD)	"Target dependent initialization, '"n"' elements for
		 array of type '"t"'"
}

dcl_init_aggr_excess ( TYPE: t )
{
    KEY (STD)	"Too many elements in initializer for type '"t"'"
}

dcl_init_aggr_pad ( NAT: n, TYPE: t )
{
    USAGE:	init_aggregate
    KEY (STD)	"'"n"' too few elements in initializer for type '"t"'"
}

dcl_init_aggr_type ( TYPE: t )
{
    KEY (STD)	"Can't initialize objects of type '"t"' using aggregate
		 initializers"
}

dcl_init_aggr_empty ()
{
    USAGE:	c_error
    KEY (STD)	"Empty aggregate initializer"
}

dcl_init_aggr_no_scalar ()
{
    KEY (STD)	"Scalar aggregate initializers can't be empty"
}

dcl_init_aggr_nest ()
{
    KEY (STD)	"Scalar aggregate initializers can't be nested"
}

dcl_init_aggr_partial ()
{
    USAGE:	init_aggregate
    KEY (STD)	"Partially bracketed aggregate initializer"
}

dcl_init_aggr_auto ( IDENTIFIER: id )
{
    USAGE:	init_struct
    KEY (STD)	"Initializer for local aggregate variable '"id"'"
}


/*  --------------------------------------------------------------------
    8.5.2	Character arrays
		[dcl.init.string]
    --------------------------------------------------------------------  */

dcl_init_string_char ()
{
    KEY (ISO)	"8.5.2" | "6.5.7"
    KEY (STD)	"Can only initialize character arrays with string literals"
}

dcl_init_string_wchar ()
{
    KEY (STD)	"Can only initialize wide character arrays with wide
		 string literals"
}

dcl_init_string_excess ( TYPE: t )
{
    KEY (STD)	"Initializer string too long for type '"t"'"
}

dcl_init_string_zero ( TYPE: t )
{
    USAGE:	cpp_error
    KEY (STD)	"Initializer string (including terminal zero) too long
		 for type '"t"'"
}


/*  --------------------------------------------------------------------
    8.5.3	References
		[dcl.init.ref]
    --------------------------------------------------------------------  */

dcl_init_ref_none ()
{
    KEY (ISO)	"8.5.3" | "6.5.7"
    KEY (STD)	"References should be initialized"
}

dcl_init_ref_ambig ()
{
    KEY (STD)	"Base class in reference binding must be unambiguous"
}

dcl_init_ref_const ()
{
    KEY (STD)	"A non-'const' reference can't be initialized using
		 an rvalue"
}

dcl_init_ref_qual ( CV_SPEC: cv )
{
    KEY (STD)	"Reference binding from more '"cv"' qualified type"
}

dcl_init_ref_func ()
{
    KEY (STD)	"A reference to function can only be initialized
		 by a function"
}

dcl_init_ref_tmp ( TYPE: t )
{
    USAGE:	wall
    KEY (STD)	"Introducing temporary variable of type '"t"'"
}


/*  --------------------------------------------------------------------
    9		Classes
		[class]
    --------------------------------------------------------------------  */

class_none ()
{
    USAGE:	c_error
    KEY (ISO)	"9" | "6.5.2.1"
    KEY (STD)	"No members in class definition"
}


/*  --------------------------------------------------------------------
    9.1		Class names
		[class.name]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    9.2		Class members
		[class.mem]
    --------------------------------------------------------------------  */

class_mem_empty ()
{
    USAGE:	decl_empty
    KEY (ISO)	"9.2" | "6.5.2.1"
    KEY (STD)	"Every member declaration must introduce a name"
}

class_mem_declarator ()
{
    USAGE:	c_error
    KEY (STD)	"A member declaration should contain a declarator"
}

class_mem_semicolon ()
{
    USAGE:	semicolon_extra
    KEY (STD)	"Can't have empty member declaration"
}

class_mem_anon ()
{
    USAGE:	decl_struct_anon
    KEY (STD)	"Every type definition must introduce a member name"
}

class_mem_ds_empty ()
{
    USAGE:	dspec_none
    KEY (STD)	"No declaration specifiers in member declaration"
}

class_mem_redecl ( IDENTIFIER: id, PTR_LOC: loc )
{
    KEY (STD)	"The member '"id"' has already been declared (at "loc")"
}

class_mem_incompl_mem ( IDENTIFIER: id )
{
    KEY (STD)	"The member '"id"' must have complete object type"
}

class_mem_init_mem ( LONG_ID: id )
{
    KEY (STD)	"Can't have initializer with non-static member '"id"'"
}

class_mem_def ( LONG_ID: id )
{
    KEY (STD)	"Can't define the non-static member '"id"'"
}

class_mem_init_const ()
{
    KEY (STD)	"A member initializer should be a constant expression"
}

class_mem_incompl_stat ( IDENTIFIER: id )
{
    KEY (STD)	"The static member '"id"' must have complete object type"
}

class_mem_ctor ( IDENTIFIER: id )
{
    USAGE:	cpp_error
    KEY (STD)	"The member '"id"' can't have the same name as its class"
}

class_mem_ctor_data ( IDENTIFIER: id )
{
    USAGE:	new | none
    KEY (STD)	"The data member '"id"' can't have the same name as its class"
}

class_mem_ref ( CLASS_TYPE: ct )
{
    USAGE:	whatever
    KEY (STD)	"'"ct"' has a non-static reference member"
}

class_mem_const ( CLASS_TYPE: ct )
{
    USAGE:	whatever
    KEY (STD)	"'"ct"' has a non-static 'const' member"
}


/*  --------------------------------------------------------------------
    9.3		Member functions
		[class.mfct]
    --------------------------------------------------------------------  */

class_mfct_eof ( LONG_ID: id )
{
    KEY (ISO)	"9.3" | "????"
    KEY (STD)	"End of file encountered in rewriting '"id"'"
}

class_mfct_scope ( LONG_ID: id )
{
    KEY (STD)	"'"id"' can only be defined in its class or an enclosing
		 namespace scope"
}

class_mfct_redecl ( LONG_ID: id )
{
    KEY (STD)	"Can't redeclare the member function '"id"'"
}


/*  --------------------------------------------------------------------
    9.3.1	Nonstatic member functions
		[class.mfct.nonstatic]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    9.3.2	The this pointer
		[class.this]
    --------------------------------------------------------------------  */

class_this_qual ( CV_SPEC: cv )
{
    KEY (ISO)	"9.3.2" | "????"
    KEY (STD)	"Member function called for more '"cv"' qualified object"
}


/*  --------------------------------------------------------------------
    9.4		Static members
		[class.static]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    9.4.1	Static member functions
		[class.static.mfct]
    --------------------------------------------------------------------  */

class_static_mfct_virt ()
{
    KEY (ISO)	"9.4.1" | "????"
    KEY (STD)	"Can't have virtual static member functions"
}


/*  --------------------------------------------------------------------
    9.4.2	Static data members
		[class.static.data]
    --------------------------------------------------------------------  */

class_static_data_init ( IDENTIFIER: id, TYPE: t )
{
    KEY (ISO)	"9.4.2" | "????"
    KEY (STD)	"The static member '"id"' can only have an initializer
		 if it has integral type, not '"t"'"
}

class_static_data_const ( IDENTIFIER: id, TYPE: t )
{
    KEY (STD)	"The static member '"id"' can only have an initializer
		 if it has 'const' type, not '"t"'"
}

class_static_data_def ( IDENTIFIER: id, PTR_LOC: loc )
{
    KEY (STD)	"'"id"' was initialized in its class (at "loc"),
		 and so can't be assigned a value in its definition"
}

class_static_data_scope ( IDENTIFIER: id )
{
    KEY (STD)	"'"id"' can only be defined in its class or an enclosing
		 namespace scope"
}

class_static_data_anon ( IDENTIFIER: id )
{
    KEY (STD)	"Can't have static member '"id"' in an anonymous class"
}


/*  --------------------------------------------------------------------
    9.5		Unions
		[class.union]
    --------------------------------------------------------------------  */

class_union_deriv ( CLASS_TYPE: ct )
{
    KEY (ISO)	"9.5" | "6.5.2.1"
    KEY (STD)	"The union '"ct"' can't have base classes"
}

class_union_base ( CLASS_TYPE: ct )
{
    KEY (STD)	"The union '"ct"' can't be used as a base class"
}

class_union_static ( CLASS_TYPE: ct )
{
    KEY (STD)	"The union '"ct"' can't contain a static data member"
}

class_union_virtual ( CLASS_TYPE: ct )
{
    KEY (STD)	"The union '"ct"' can't contain a virtual function"
}

class_union_ref ( CLASS_TYPE: ct, TYPE: t )
{
    KEY (STD)	"The union '"ct"' can't have a member of reference type '"t"'"
}

class_union_mem ( CLASS_TYPE: ct, TYPE: t )
{
    KEY (STD)	"The union '"ct"' can't have a member of type '"t"'"
}

class_union_anon ()
{
    USAGE:	anon_union
    KEY (STD)	"A union declaration should contain a tag or a declarator"
}

class_union_anon_private ()
{
    KEY (STD)	"An anonymous union can't have 'private' or 'protected'
		 members"
}

class_union_anon_func ()
{
    KEY (STD)	"An anonymous union can't have function members"
}

class_union_anon_static ()
{
    KEY (STD)	"An anonymous union can't have external linkage"
}

class_union_anon_mem ()
{
    KEY (STD)	"An anonymous union can't be a static data member of a class"
}


/*  --------------------------------------------------------------------
    9.6		Bit-fields
		[class.bit]
    --------------------------------------------------------------------  */

class_bit_base ( TYPE: t )
{
    KEY (ISO)	"9.6" | "6.5.2.1"
    KEY (STD)	"Bitfield base type should be integral, not '"t"'"
}

class_bit_base_int ( TYPE: t )
{
    USAGE:	bitf_type
    KEY (STD)	"Only 'int' types allowed in bitfields, not '"t"'"
}

class_bit_sign ( BASE_TYPE: bt )
{
    USAGE:	wall
    KEY (STD)	"Sign of a bitfield of type '"bt"' is implementation dependent"
}

class_bit_dim_const ()
{
    KEY (STD)	"Bitfield width should be an integer constant expression"
}

class_bit_dim_zero ()
{
    KEY (STD)	"Only unnamed bitfields can have width zero"
}

class_bit_dim_neg ( NAT: n )
{
    KEY (STD)	"Bitfield width should be non-negative, not '"n"'"
}

class_bit_dim_big ( NAT: n, TYPE: t )
{
    USAGE:	bitf_overflow
    KEY (STD)	"Bitfield width '"n"' exceeds minimum size for base
		 type, '"t"'"
}

class_bit_static ()
{
    KEY (STD)	"A bitfield can't be a static member"
}

class_bit_typedef ()
{
    KEY (STD)	"Can't use 'typedef' to define a bitfield type"
}

class_bit_ptr ()
{
    KEY (STD)	"Can't have pointers to bitfields"
}

class_bit_ref ()
{
    KEY (STD)	"Can't have references to bitfields"
}

class_bit_mptr ()
{
    KEY (STD)	"Can't have pointers to bitfield members"
}


/*  --------------------------------------------------------------------
    9.7		Nested class declarations
		[class.nest]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    9.8		Local class declarations
		[class.local]
    --------------------------------------------------------------------  */

class_local_func ( LONG_ID: id )
{
    USAGE:	none
    KEY (ISO)	"9.8" | "6.5.2.1"
    KEY (STD)	"Member function '"id"' of a local class should be
		 defined in that class"
}

class_local_static ( IDENTIFIER: id )
{
    KEY (STD)	"Can't have static member '"id"' in a local class"
}

class_local_auto ( IDENTIFIER: id )
{
    KEY (STD)	"Can't use variable '"id"' in local class"
}


/*  --------------------------------------------------------------------
    9.9		Nested type names
		[class.nested.type]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    10		Derived classes
		[class.derived]
    --------------------------------------------------------------------  */

class_derived_class ( TYPE: t )
{
    KEY (ISO)	"10" | "????"
    KEY (STD)	"A base class should have class type, not '"t"'"
}

class_derived_incompl ()
{
    KEY (STD)	"A base class should be complete"
}

class_derived_empty ( CLASS_TYPE: ct )
{
    KEY (STD)	"Empty base class list for '"ct"'"
}

class_derived_base ( CLASS_TYPE: ct, CLASS_TYPE: cs )
{
    USAGE:	whatever
    KEY (STD)	"'"ct"' has a base class, '"cs"'"
}

class_derived_virt ( CLASS_TYPE: ct, CLASS_TYPE: cs )
{
    USAGE:	whatever
    KEY (STD)	"'"ct"' is a virtual base class of '"cs"'"
}


/*  --------------------------------------------------------------------
    10.1	Multiple base classes
		[class.mi]
    --------------------------------------------------------------------  */

class_mi_dup ( CLASS_TYPE: ct, CLASS_TYPE: cs )
{
    KEY (ISO)	"10.1" | "????"
    KEY (STD)	"Class '"ct"' already has a base class '"cs"'"
}


/*  --------------------------------------------------------------------
    10.2	Member name lookup
		[class.member.lookup]
    --------------------------------------------------------------------  */

class_member_lookup_ambig ( CLASS_TYPE: ct, CLASS_TYPE: cs )
{
    USAGE:	whatever
    KEY (ISO)	"10.2" | "????"
    KEY (STD)	"'"ct"' is an ambiguous base class of '"cs"'"
}

class_member_lookup_func ()
{
    KEY (STD)	"Can't call a member function inherited from an ambiguous
		 base class"
}


/*  --------------------------------------------------------------------
    10.3	Virtual functions
		[class.virtual]
    --------------------------------------------------------------------  */

class_virtual_poly ( CLASS_TYPE: ct )
{
    USAGE:	whatever
    KEY (ISO)	"10.3" | "????"
    KEY (STD)	"'"ct"' is a polymorphic type"
}

class_virtual_override ( HASHID: nm )
{
    USAGE:	wall
    KEY (STD)	"'"nm"' is an overriding virtual function"
}

class_virtual_hide ( HASHID: nm, LONG_ID: id )
{
    USAGE:	wall
    KEY (STD)	"'"nm"' hides rather than overrides the virtual
		 function '"id"'"
}

class_virtual_ret ( IDENTIFIER: id1, LONG_ID: id2, PTR_LOC: loc )
{
    KEY (STD)	"Return type for overriding virtual function '"id1"'
		 differs from that for '"id2"' (see "loc")"
}

class_virtual_darg ( IDENTIFIER: id )
{
    USAGE:	wall
    KEY (STD)	"Default arguments for virtual function '"id"' differ
		 from those of overridden function"
}

class_virtual_ambig ( IDENTIFIER: id1, LONG_ID: id2 )
{
    KEY (STD)	"Conversion from return type of '"id1"' to that of
		 '"id2"' must be unambiguous"
}

class_virtual_final ( LONG_ID: id, CLASS_TYPE: ct )
{
    KEY (STD)	"Virtual function '"id"' doesn't have a unique final
		 overrider in '"ct"'"
}

class_virtual_destr ( CLASS_TYPE: ct )
{
    USAGE:	wall
    KEY (STD)	"The polymorphic type '"ct"' doesn't have a virtual destructor"
}

class_virtual_not ( LONG_ID: id )
{
    USAGE:	wall
    KEY (STD)	"Call to '"id"' is not virtual"
}


/*  --------------------------------------------------------------------
    10.4	Abstract classes
		[class.abstract]
    --------------------------------------------------------------------  */

class_abstract_virt ()
{
    KEY (ISO)	"10.4" | "????"
    KEY (STD)	"Only virtual functions can be pure"
}

class_abstract_zero ()
{
    KEY (STD)	"A pure specifier should be precisely '0'"
}

class_abstract_class ( CLASS_TYPE: ct )
{
    USAGE:	whatever
    KEY (STD)	"The class '"ct"' is abstract"
}

class_abstract_pure ( LONG_ID: id )
{
    USAGE:	whatever
    KEY (STD)	"'"id"' is a pure virtual function"
}

class_abstract_decl ( IDENTIFIER: id )
{
    KEY (STD)	"The object '"id"' can't have abstract type"
}

class_abstract_mem ( IDENTIFIER: id )
{
    KEY (STD)	"The member '"id"' can't have abstract type"
}

class_abstract_par ()
{
    KEY (STD)	"A function parameter can't have abstract type"
}

class_abstract_ret ()
{
    KEY (STD)	"A function can't return an abstract type"
}

class_abstract_cast ()
{
    KEY (STD)	"Can't explicitly cast to an abstract type"
}

class_abstract_call ( LONG_ID: id )
{
    USAGE:	wall
    KEY (STD)	"Calling the pure virtual function '"id"' is undefined"
}


/*  --------------------------------------------------------------------
    11		Member access control
		[class.access]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    11.1	Access specifiers
		[class.access.spec]
    --------------------------------------------------------------------  */

class_access_spec_priv ( CLASS_TYPE: ct )
{
    USAGE:	whatever
    KEY (ISO)	"11.1" | "????"
    KEY (STD)	"'"ct"' has a 'private' or 'protected' member"
}

class_access_spec_id ( LONG_ID: id, ACCESS: acc, LONG_ID: fn )
{
    KEY (STD)	"The '"acc"' member '"id"' can't be accessed by '"fn"'"
}

class_access_spec_none ( LONG_ID: id, ACCESS: acc )
{
    KEY (STD)	"Can't access the '"acc"' member '"id"'"
}

class_access_spec_change ( LONG_ID: id, PTR_LOC: loc )
{
    KEY (STD)	"Can't change access in redeclaration of '"id"' (see "loc")"
}


/*  --------------------------------------------------------------------
    11.2	Access of base classes and base class members
		[class.access.base]
    --------------------------------------------------------------------  */

class_access_base_acc ( LONG_ID: id, ACCESS: acc )
{
    USAGE:	wall
    KEY (ISO)	"11.2" | "????"
    KEY (STD)	"Missing base class access, '"acc" "id"'"
}

class_access_base_id ( CLASS_TYPE: b, CLASS_TYPE: d, ACCESS: acc, LONG_ID: fn )
{
    KEY (STD)	"The '"acc"' base '"b"' of '"d"' can't be accessed by '"fn"'"
}

class_access_base_none ( CLASS_TYPE: b, CLASS_TYPE: d, ACCESS: acc )
{
    KEY (STD)	"Can't access the '"acc"' base '"b"' of '"d"'"
}


/*  --------------------------------------------------------------------
    11.3	Access declarations
		[class.access.dcl]
    --------------------------------------------------------------------  */

class_access_dcl_using ( IDENTIFIER: id )
{
    USAGE:	none
    KEY (ISO)	"11.3" | "????"
    KEY (STD)	"Access declarations are deprecated: use 'using "id"'"
}


/*  --------------------------------------------------------------------
    11.4	Friends
		[class.friend]
    --------------------------------------------------------------------  */

class_friend_decl ()
{
    KEY (ISO)	"11.4" | "????"
    KEY (STD)	"Only functions and classes can be friends"
}

class_friend_elab ()
{
    KEY (STD)	"Elaborated type specifier required in friend declaration"
}

class_friend_storage ( DECL_SPEC: ds )
{
    KEY (STD)	"The 'friend' specifier can't be used with the storage
		 class specifier '"ds"'"
}

class_friend_def ()
{
    KEY (STD)	"Can't apply 'friend' to a class definition"
}

class_friend_local ()
{
    KEY (STD)	"Can't define a 'friend' function in a local class"
}

class_friend_pre ( IDENTIFIER: id )
{
    USAGE:	wall
    KEY (STD)	"'"id"' first declared in a friend declaration"
}

class_friend_dup_func ( LONG_ID: id, CLASS_TYPE: ct )
{
    USAGE:	wall
    KEY (STD)	"Function '"id"' is already a friend of '"ct"'"
}

class_friend_dup_class ( CLASS_TYPE: cs, CLASS_TYPE: ct )
{
    USAGE:	wall
    KEY (STD)	"Class '"cs"' is already a friend of '"ct"'"
}


/*  --------------------------------------------------------------------
    11.5	Protected member access
		[class.protected]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    11.6	Access to virtual functions
		[class.access.virt]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    11.7	Multiple access
		[class.paths]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    12		Special member functions
		[special]
    --------------------------------------------------------------------  */

class_special_decl ( LONG_ID: id )
{
    KEY (ISO)	"12" | "????"
    KEY (STD)	"Can't explicitly declare the implicit function '"id"'"
}


/*  --------------------------------------------------------------------
    12.1	Constructors
		[class.ctor]
    --------------------------------------------------------------------  */

class_ctor_static ()
{
    KEY (ISO)	"12.1" | "????"
    KEY (STD)	"Constructors can't be static members"
}

class_ctor_virtual ()
{
    KEY (STD)	"Constructors can't be virtual members"
}

class_ctor_ret ( HASHID: nm )
{
    KEY (STD)	"Can't give return type for constructor '"nm"'"
}

class_ctor_qual ( HASHID: nm, CV_SPEC: cv )
{
    KEY (STD)	"The constructor '"nm"' can't be '"cv"' qualified"
}

class_ctor_result ( LONG_ID: id )
{
    KEY (STD)	"Can't return a value from the constructor '"id"'"
}

class_ctor_addr ( LONG_ID: id )
{
    KEY (STD)	"Can't take the address of the constructor '"id"'"
}

class_ctor_default ( CLASS_TYPE: ct )
{
    KEY (STD)	"'"ct"' has no default constructor"
}

class_ctor_user ( CLASS_TYPE: ct )
{
    USAGE:	whatever
    KEY (STD)	"'"ct"' has a user-defined constructor"
}

class_ctor_nontriv ( CLASS_TYPE: ct )
{
    USAGE:	whatever
    KEY (STD)	"'"ct"' has a non-trivial constructor"
}

class_ctor_make ( CLASS_TYPE: ct )
{
    USAGE:	wall
    KEY (STD)	"'"ct"' has only copy constructors"
}

class_ctor_private ( CLASS_TYPE: ct )
{
    USAGE:	wall
    KEY (STD)	"'"ct"' has only private non-copy constructors and
		 no friends"
}


/*  --------------------------------------------------------------------
    12.2	Temporary objects
		[class.temporary]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    12.3	Conversions
		[class.conv]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    12.3.1	Conversion by constructor
		[class.conv.ctor]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    12.3.2	Conversion functions
		[class.conv.fct]
    --------------------------------------------------------------------  */

class_conv_fct_typedef ( HASHID: nm )
{
    KEY (ISO)	"12.3.2" | "????"
    KEY (STD)	"Can't declare type in conversion function name '"nm"'"
}

class_conv_fct_ret ( HASHID: nm )
{
    KEY (STD)	"Can't give return type for conversion function '"nm"'"
}

class_conv_fct_ret_bad ( HASHID: nm, TYPE: t )
{
    KEY (STD)	"Conversion function '"nm"' declared to return '"t"'"
}

class_conv_fct_pars ( HASHID: nm )
{
    KEY (STD)	"Can't give parameter types for conversion function '"nm"'"
}

class_conv_fct_void ( HASHID: nm )
{
    USAGE:	none
    KEY (STD)	"Illegal conversion function '"nm"'"
}

class_conv_fct_mem ()
{
    KEY (STD)	"A conversion function must be a non-static member"
}


/*  --------------------------------------------------------------------
    12.4	Destructors
		[class.dtor]
    --------------------------------------------------------------------  */

class_dtor_static ()
{
    KEY (ISO)	"12.4" | "????"
    KEY (STD)	"Destructors can't be static members"
}

class_dtor_ret ( HASHID: nm )
{
    KEY (STD)	"Can't give return type for destructor '"nm"'"
}

class_dtor_pars ( HASHID: nm )
{
    KEY (STD)	"Can't give parameter types for destructor '"nm"'"
}

class_dtor_func ( HASHID: nm )
{
    KEY (STD)	"The destructor '"nm"' must be a member function"
}

class_dtor_inherit ( HASHID: nm, NAMESPACE: ns )
{
    KEY (STD)	"The destructor '"nm"' can't be inherited by '"ns"'"
}

class_dtor_qual ( HASHID: nm, CV_SPEC: cv )
{
    KEY (STD)	"The destructor '"nm"' can't be '"cv"' qualified"
}

class_dtor_default ( CLASS_TYPE: ct )
{
    KEY (STD)	"'"ct"' has no default destructor"
}

class_dtor_nontriv ( CLASS_TYPE: ct )
{
    USAGE:	whatever
    KEY (STD)	"'"ct"' has a non-trivial destructor"
}

class_dtor_result ( LONG_ID: id )
{
    KEY (STD)	"Can't return a value from the destructor '"id"'"
}

class_dtor_addr ( LONG_ID: id )
{
    KEY (STD)	"Can't take the address of the destructor '"id"'"
}

class_dtor_private ( CLASS_TYPE: ct )
{
    USAGE:	wall
    KEY (STD)	"'"ct"' has a private destructor and no friends"
}

class_dtor_three ( CLASS_TYPE: ct )
{
    USAGE:	wall
    KEY (STD)	"A class '"ct"' with a destructor, copy constructor
		 or copy assignment operator should have all three"
}


/*  --------------------------------------------------------------------
    12.5	Free store
		[class.free]
    --------------------------------------------------------------------  */

class_free_static ( HASHID: nm )
{
    USAGE:	whatever
    KEY (ISO)	"12.5" | "????"
    KEY (STD)	"'"nm"' is implicitly declared static"
}


/*  --------------------------------------------------------------------
    12.6	Initialization
		[class.init]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    12.6.1	Explicit initialization
		[class.expl.init]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    12.6.2	Initializing bases and members
		[class.base.init]
    --------------------------------------------------------------------  */

class_base_init_bad ( LONG_ID: id )
{
    KEY (ISO)	"12.6.2" | "????"
    KEY (STD)	"The function '"id"' can't have constructor-style
		 initializers"
}

class_base_init_empty ( LONG_ID: id )
{
    KEY (STD)	"Empty constructor-style initializer for function '"id"'"
}

class_base_init_old ( LONG_ID: id )
{
    KEY (STD)	"Anachronistic base class initializer in '"id"'"
}

class_base_init_uniq ( CLASS_TYPE: ct )
{
    KEY (STD)	"Class '"ct"' does not have a unique base class"
}

class_base_init_static ( IDENTIFIER: id )
{
    KEY (STD)	"Initializer '"id"' isn't a non-static member or a base class"
}

class_base_init_inherit ( IDENTIFIER: id )
{
    KEY (STD)	"Can't use inherited member '"id"' as an initializer"
}

class_base_init_base ( CLASS_TYPE: ct )
{
    KEY (STD)	"The base class initializer '"ct"' should be a direct
		 or a virtual base"
}

class_base_init_ambig ( CLASS_TYPE: ct )
{
    KEY (STD)	"The base class initializer '"ct"' is both a direct and
		 a virtual base"
}

class_base_init_dup ( IDENTIFIER: id )
{
    KEY (STD)	"Initializer for '"id"' already given"
}

class_base_init_none ( IDENTIFIER: id )
{
    USAGE:	variable
    KEY (STD)	"No initializer for '"id"' in constructor"
}

class_base_init_order ( IDENTIFIER: id )
{
    USAGE:	variable
    KEY (STD)	"Constructor initializer for '"id"' out of sequence"
}

class_base_init_union ( CLASS_TYPE: ct )
{
    KEY (STD)	"More than one initializer given for union '"ct"'"
}

class_base_init_anon ( IDENTIFIER: id )
{
    KEY (STD)	"More than one initializer given for anonymous union
		 member '"id"'"
}

class_base_init_err ( LONG_ID: id )
{
    USAGE:	whatever
    KEY (STD)	"In special member function '"id"'"
}

class_base_init_impl ( LONG_ID: id )
{
    USAGE:	whatever
    KEY (STD)	"In implicit definition of '"id"'"
}


/*  --------------------------------------------------------------------
    12.7	Construction and destruction
		[class.cdtor]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    12.8	Copying class objects
		[class.copy]
    --------------------------------------------------------------------  */

class_copy_bad ( HASHID: nm )
{
    KEY (ISO)	"12.8" | "????"
    KEY (STD)	"Copy constructor '"nm"' should have a reference parameter"
}

class_copy_constr ( CLASS_TYPE: ct )
{
    KEY (STD)	"'"ct"' has no copy constructor"
}

class_copy_assign ( CLASS_TYPE: ct )
{
    KEY (STD)	"'"ct"' has no copy assignment operator"
}

class_copy_nontriv_constr ( CLASS_TYPE: ct )
{
    USAGE:	whatever
    KEY (STD)	"'"ct"' has a non-trivial copy constructor"
}

class_copy_nontriv_assign ( CLASS_TYPE: ct )
{
    USAGE:	whatever
    KEY (STD)	"'"ct"' has a non-trivial copy assignment operator"
}

class_copy_ptr ()
{
    USAGE:	wall
    KEY (STD)	"Pointers are shallow copied"
}


/*  --------------------------------------------------------------------
    13		Overloading
		[over]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    13.1	Overloadable declarations
		[over.load]
    --------------------------------------------------------------------  */

over_load_pars ()
{
    USAGE:	whatever
    KEY (ISO)	"13.1" | "????"
    KEY (STD)	"Can't overload functions with indistinguishable
		 parameter types"
}


/*  --------------------------------------------------------------------
    13.2	Declaration matching
		[over.dcl]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    13.3	Overload resolution
		[over.match]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    13.3.1	Candidate functions and argument lists
		[over.match.funcs]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    13.3.1.1	Function call syntax
		[over.match.call]
    --------------------------------------------------------------------  */

over_match_call_mem ( IDENTIFIER: id )
{
    KEY (ISO)	"13.3.1.1" | "????"
    KEY (STD)	"Can't have member function '&"id"' in call"
}

over_match_call_ok ( LONG_ID: id )
{
    USAGE:	overload_res
    KEY (STD)	"Overloaded function call resolves to '"id"'"
}

over_match_call_target ( IDENTIFIER: id )
{
    USAGE:	overload_dep
    KEY (STD)	"Target dependent resolution for call to overloaded
		 function '"id"'"
}

over_match_call_ambig ( IDENTIFIER: id )
{
    USAGE:	overload_ambig
    KEY (STD)	"Ambiguous call to overloaded function '"id"'"
}


/*  --------------------------------------------------------------------
    13.3.1.1.1	Call to named function
		[over.call.func]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    13.3.1.1.2	Call to object of class type
		[over.call.object]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    13.3.1.2	Operators in expressions
		[over.match.oper]
    --------------------------------------------------------------------  */

over_match_oper_ok ( LONG_ID: id )
{
    USAGE:	overload_res
    KEY (ISO)	"13.3.1.2" | "????"
    KEY (STD)	"Overloaded operator resolves to '"id"'"
}

over_match_oper_target ( LEX: op )
{
    USAGE:	overload_dep
    KEY (STD)	"Target dependent resolution for overloaded operator '"op"'"
}

over_match_oper_ambig ( LEX: op )
{
    USAGE:	overload_ambig
    KEY (STD)	"Ambiguous overloaded operator '"op"'"
}

over_match_oper_arrow ()
{
    KEY (STD)	"Infinite loop in overloading of '->'"
}


/*  --------------------------------------------------------------------
    13.3.1.3	Initialization by constructor
		[over.match.ctor]
    --------------------------------------------------------------------  */

over_match_ctor_ok ( LONG_ID: id )
{
    USAGE:	overload_res
    KEY (ISO)	"13.3.1.3" | "????"
    KEY (STD)	"Overloaded constructor call resolves to '"id"'"
}

over_match_ctor_target ( IDENTIFIER: id )
{
    USAGE:	overload_dep
    KEY (STD)	"Target dependent resolution for call to overloaded
		 constructor '"id"'"
}

over_match_ctor_ambig ( IDENTIFIER: id )
{
    USAGE:	overload_ambig
    KEY (STD)	"Ambiguous call to overloaded constructor '"id"'"
}

over_match_ctor_none ( IDENTIFIER: id )
{
    KEY (STD)	"None of the overloaded constructors '"id"' is viable
		 for given call"
}


/*  --------------------------------------------------------------------
    13.3.1.4	Copy-initialization of class by user-defined conversion
		[over.match.copy]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    13.3.1.5	Initialization by conversion function
		[over.match.conv]
    --------------------------------------------------------------------  */

over_match_conv_ok ( LONG_ID: id )
{
    USAGE:	overload_res
    KEY (ISO)	"13.3.1.5" | "????"
    KEY (STD)	"Overloaded user-defined conversion resolves to '"id"'"
}

over_match_conv_target ( TYPE: t1, TYPE: t2 )
{
    USAGE:	overload_dep
    KEY (STD)	"Target dependent resolution for user-defined conversion
		 from '"t1"' to '"t2"'"
}

over_match_conv_ambig ( TYPE: t1, TYPE: t2 )
{
    USAGE:	overload_ambig
    KEY (STD)	"Ambiguous user-defined conversion from '"t1"' to '"t2"'"
}

over_match_conv_dup ( TYPE: t )
{
    KEY (STD)	"Ambiguous user-defined conversions from '"t"'"
}


/*  --------------------------------------------------------------------
    13.3.1.6	Initialization by conversion function for direct
		reference binding
		[over.match.ref]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    13.3.2	Viable functions
		[over.match.viable]
    --------------------------------------------------------------------  */

over_match_viable_none ( IDENTIFIER: id )
{
    KEY (ISO)	"13.3.2" | "????"
    KEY (STD)	"None of the overloaded functions '"id"' is viable for
		 given call"
}

over_match_viable_list ()
{
    USAGE:	whatever
    KEY (STD)	"Viable candidates are as follows"
}


/*  --------------------------------------------------------------------
    13.3.3	Best Viable Function
		[over.match.best]
    --------------------------------------------------------------------  */

over_match_best_install ()
{
    USAGE:	overload_ambig
    KEY (ISO)	"13.3.3" | "????"
    KEY (STD)	"Failed target dependent overload resolution"
}

over_match_best_common ()
{
    KEY (STD)	"Can't find common return type for target dependent
		 overload resolution"
}


/*  --------------------------------------------------------------------
    13.3.3.1	Implicit conversion sequences
		[over.best.ics]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    13.3.3.1.1	Standard conversion sequences
		[over.ics.scs]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    13.3.3.1.2	User-defined conversion sequences
		[over.ics.user]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    13.3.3.1.3	Ellipsis conversion sequences
		[over.ics.ellipsis]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    13.3.3.1.4	Reference binding
		[over.ics.ref]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    13.3.3.2	Ranking implicit conversion sequences
		[over.ics.rank]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    13.4	Address of overloaded function
		[over.over]
    --------------------------------------------------------------------  */

over_over_context ( IDENTIFIER: id )
{
    KEY (ISO)	"13.4" | "????"
    KEY (STD)	"Can't use the overloaded function '"id"' in this context"
}

over_over_none ( IDENTIFIER: id, TYPE: t )
{
    KEY (STD)	"None of the overloaded functions '"id"' has type '"t"'"
}

over_over_ok ( LONG_ID: id )
{
    USAGE:	overload_res
    KEY (STD)	"Address of overloaded function resolves to '"id"'"
}


/*  --------------------------------------------------------------------
    13.5	Overloaded operators
		[over.oper]
    --------------------------------------------------------------------  */

over_oper_bad ( LEX: op )
{
    KEY (ISO)	"13.5" | "????"
    KEY (STD)	"Can't overload '"op"'"
}

over_oper_static ()
{
    KEY (STD)	"Overloaded operators can't be static members"
}

over_oper_type ( HASHID: nm )
{
    KEY (STD)	"'"nm"' should have an overloadable parameter type"
}

over_oper_default ( HASHID: nm )
{
    KEY (STD)	"'"nm"' can't have default arguments"
}

over_oper_func ( IDENTIFIER: id )
{
    KEY (STD)	"'"id"' is not a function"
}


/*  --------------------------------------------------------------------
    13.5.1	Unary operators
		[over.unary]
    --------------------------------------------------------------------  */

over_unary_pars ( HASHID: nm, unsigned: n, plural: s )
{
    KEY (ISO)	"13.5.1" | "????"
    KEY (STD)	"'"nm"' should have "n" parameter"s
}


/*  --------------------------------------------------------------------
    13.5.2	Binary operators
		[over.binary]
    --------------------------------------------------------------------  */

over_binary_pars_p2 ( HASHID: nm, unsigned: n, plural: s )
{
    KEY (ISO)	"13.5.2" | "????"
    KEY (STD)	"'"nm"' should have "n" parameter"s
}

over_binary_pars_p1 ( HASHID: nm, unsigned: n, unsigned: m, plural: s )
{
    KEY (STD)	"'"nm"' should have "n" or "m" parameter"s
}


/*  --------------------------------------------------------------------
    13.5.3	Assignment
		[over.ass]
    --------------------------------------------------------------------  */

over_ass_mem ( HASHID: nm )
{
    KEY (ISO)	"13.5.3" | "????"
    KEY (STD)	"'"nm"' should be a member function"
}

over_ass_pars ( HASHID: nm, unsigned: n, plural: s )
{
    KEY (STD)	"'"nm"' should have "n" parameter"s
}


/*  --------------------------------------------------------------------
    13.5.4	Function call
		[over.call]
    --------------------------------------------------------------------  */

over_call_mem ( HASHID: nm )
{
    KEY (ISO)	"13.5.4" | "????"
    KEY (STD)	"'"nm"' should be a member function"
}


/*  --------------------------------------------------------------------
    13.5.5	Subscripting
		[over.sub]
    --------------------------------------------------------------------  */

over_sub_mem ( HASHID: nm )
{
    KEY (ISO)	"13.5.5" | "????"
    KEY (STD)	"'"nm"' should be a member function"
}

over_sub_pars ( HASHID: nm, unsigned: n, plural: s )
{
    KEY (STD)	"'"nm"' should have "n" parameter"s
}


/*  --------------------------------------------------------------------
    13.5.6	Class member access
		[over.ref]
    --------------------------------------------------------------------  */

over_ref_mem ( HASHID: nm )
{
    KEY (ISO)	"13.5.6" | "????"
    KEY (STD)	"'"nm"' should be a member function"
}

over_ref_pars ( HASHID: nm, unsigned: n, plural: s )
{
    KEY (STD)	"'"nm"' should have "n" parameter"s
}


/*  --------------------------------------------------------------------
    13.5.7	Increment and decrement
		[over.inc]
    --------------------------------------------------------------------  */

over_inc_pars ( HASHID: nm, unsigned: n, unsigned: m, plural: s )
{
    KEY (ISO)	"13.5.7" | "????"
    KEY (STD)	"'"nm"' should have "n" or "m" parameter"s
}

over_inc_pars_p2 ( HASHID: nm, TYPE: t )
{
    KEY (STD)	"Extra parameter to '"nm"' should be of type '"t"'"
}


/*  --------------------------------------------------------------------
    13.6	Built-in operators
		[over.built]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    14		Templates
		[temp]
    --------------------------------------------------------------------  */

temp_decl_bad ()
{
    KEY (ISO)	"14" | "????"
    KEY (STD)	"Invalid template declaration"
}

temp_decl_scope ()
{
    KEY (STD)	"A template can only be declared in namespace or class scope"
}

temp_decl_func ()
{
    KEY (STD)	"Can't have partially specialized template functions"
}

temp_decl_one ()
{
    KEY (STD)	"Can only declare a single object in a template declaration"
}

temp_decl_linkage ()
{
    KEY (STD)	"A template can't have C linkage"
}

temp_decl_export ( IDENTIFIER: id )
{
    KEY (STD)	"Can't export the template '"id"'"
}

temp_decl_undef ( LONG_ID: id )
{
    KEY (STD)	"The non-exported template '"id"' has not been defined"
}


/*  --------------------------------------------------------------------
    14.1	Template parameters
		[temp.param]
    --------------------------------------------------------------------  */

temp_param_eof ()
{
    KEY (ISO)	"14.1" | "????"
    KEY (STD)	"End of file in template parameters"
}

temp_param_dup ( HASHID: nm )
{
    KEY (STD)	"Duplicate template parameter '"nm"'"
}

temp_param_type ( IDENTIFIER: id, TYPE: t )
{
    KEY (STD)	"The template parameter '"id"' can't have type '"t"'"
}

temp_param_dcl_stc ( DECL_SPEC: ds )
{
    KEY (STD)	"Can't apply '"ds"' to a template parameter"
}

temp_param_default ( IDENTIFIER: id )
{
    KEY (STD)	"The template parameter '"id"' should have a default argument"
}

temp_param_func ()
{
    KEY (STD)	"Can't have default arguments in template function"
}

temp_param_redecl ()
{
    KEY (STD)	"Can't have default arguments in template redeclaration"
}

temp_param_none ( LONG_ID: id )
{
    KEY (STD)	"No template from which to specialize '"id"'"
}


/*  --------------------------------------------------------------------
    14.2	Names of template specializations
		[temp.names]
    --------------------------------------------------------------------  */

temp_names_eof ( LONG_ID: id )
{
    KEY (ISO)	"14.2" | "????"
    KEY (STD)	"End of file in arguments for template '"id"'"
}

temp_names_hack ()
{
    KEY (STD)	"'>>' in template arguments interpreted as '> >'"
}

temp_names_bad ()
{
    KEY (STD)	"Bad 'template' qualifier"
}

temp_names_not ( IDENTIFIER: id )
{
    KEY (STD)	"'template "id"' doesn't name a template member"
}

temp_names_mem ( IDENTIFIER: id )
{
    KEY (STD)	"Member '"id"' should be prefixed by 'template'"
}


/*  --------------------------------------------------------------------
    14.3	Template arguments
		[temp.arg]
    --------------------------------------------------------------------  */

temp_arg_type ( IDENTIFIER: pid, LONG_ID: id )
{
    KEY (ISO)	"14.3" | "????"
    KEY (STD)	"Type expected for parameter '"pid"' of template '"id"'"
}

temp_arg_exp ( IDENTIFIER: pid, LONG_ID: id )
{
    KEY (STD)	"Expression expected for parameter '"pid"' of template '"id"'"
}

temp_arg_less ( LONG_ID: id )
{
    KEY (STD)	"Not enough arguments for template '"id"'"
}

temp_arg_more ( LONG_ID: id )
{
    KEY (STD)	"Too many arguments for template '"id"'"
}

temp_arg_local ( TYPE: t )
{
    KEY (STD)	"Type argument '"t"' should have external linkage"
}

temp_arg_const ()
{
    KEY (STD)	"A non-type template argument should be constant"
}

temp_arg_internal ()
{
    KEY (STD)	"A non-type template argument should have external linkage"
}

temp_arg_over ()
{
    KEY (STD)	"A non-type template argument can't be an overloaded
		 pointer to member"
}

temp_arg_bad ()
{
    KEY (STD)	"Invalid non-type template argument"
}

temp_arg_init ( IDENTIFIER: pid, LONG_ID: id )
{
    USAGE:	whatever
    KEY (STD)	"In initialization of template parameter '"pid"' of '"id"'"
}

temp_arg_templ ( IDENTIFIER: pid, LONG_ID: id )
{
    KEY (STD)	"Template name expected for parameter '"pid"' of
		 template '"id"'"
}

temp_arg_templ_not ( IDENTIFIER: pid, IDENTIFIER: id )
{
    KEY (STD)	"Value for template parameter '"pid"', '"id"' does
		 not denote a type name"
}

temp_arg_templ_bad ( IDENTIFIER: pid, TYPE: t )
{
    KEY (STD)	"Invalid type for template parameter '"pid"', '"t"'"
}


/*  --------------------------------------------------------------------
    14.4	Type equivalence
		[temp.type]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    14.5	Template declarations
		[temp.decls]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    14.5.1	Class templates
		[temp.class]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    14.5.1.1	Member functions of class templates
		[temp.mem.func]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    14.5.1.2	Member classes of class templates
		[temp.mem.class]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    14.5.1.3	Static data members of class templates
		[temp.static]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    14.5.2	Member templates
		[temp.mem]
    --------------------------------------------------------------------  */

temp_mem_virtual ()
{
    KEY (ISO)	"14.5.2" | "????"
    KEY (STD)	"A template member function can't be virtual"
}

temp_mem_destr ()
{
    KEY (STD)	"A destructor can't be a template member function"
}

temp_mem_local ()
{
    KEY (STD)	"A local class can't have a template member or friend"
}


/*  --------------------------------------------------------------------
    14.5.3	Friends
		[temp.friend]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    14.5.4	Class template partial specializations
		[temp.class.spec]
    --------------------------------------------------------------------  */

temp_class_spec_primary ( TYPE: t )
{
    KEY (ISO)	"14.5.4" | "????"
    KEY (STD)	"Specialization '"t"' should be more specialized than
		 its primary template"
}

temp_class_spec_depend ( TYPE: t )
{
    KEY (STD)	"Dependent non-type argument in specialization '"t"'"
}

temp_class_spec_darg ()
{
    KEY (STD)	"Can't have default arguments in template specialization"
}


/*  --------------------------------------------------------------------
    14.5.4.1	Matching of class template partial specializations
		[temp.class.spec.match]
    --------------------------------------------------------------------  */

temp_class_spec_ambig ( TYPE: t )
{
    KEY (ISO)	"14.5.4.1" | "????"
    KEY (STD)	"Ambiguous specialization for template '"t"'"
}

temp_class_spec_match ( LONG_ID: id )
{
    USAGE:	wall
    KEY (STD)	"Specialization '"id"' used"
}


/*  --------------------------------------------------------------------
    14.5.4.2	Partial ordering of class template specializations
		[temp.class.order]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    14.5.4.3	Member functions of class template specializations
		[temp.class.spec.mfunc]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    14.5.5	Function templates
		[temp.fct]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    14.5.5.1	Function template overloading
		[temp.over.link]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    14.5.5.2	Partial ordering of function templates
		[temp.func.order]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    14.6	Name resolution
		[temp.res]
    --------------------------------------------------------------------  */

temp_res_nspace ( NAMESPACE: ns, TYPE: t )
{
    KEY (ISO)	"14.6" | "????"
    KEY (STD)	"Qualifier '"ns"' expands to the non-class type '"t"'"
}

temp_res_qual ()
{
    KEY (STD)	"Qualifier in 'typename' doesn't depend on a template
		 parameter"
}

temp_res_type ( NAMESPACE: ns, HASHID: nm )
{
    KEY (STD)	"'typename "ns"::"nm"' doesn't denote a type"
}

temp_res_key ( BASE_TYPE: key, IDENTIFIER: id, LONG_ID: tid, TYPE: t )
{
    KEY (STD)	"Template parameter '"id"' of '"tid"' should be '"key"',
		 not '"t"'"
}


/*  --------------------------------------------------------------------
    14.6.1	Locally declared names
		[temp.local]
    --------------------------------------------------------------------  */

temp_local_not ( TYPE: t )
{
    KEY (ISO)	"14.6.1" | "????"
    KEY (STD)	"Can't use the template type '"t"' in this context"
}

temp_local_hide ( IDENTIFIER: id )
{
    KEY (STD)	"Can't hide the template parameter '"id"'"
}


/*  --------------------------------------------------------------------
    14.6.2	Dependent names
		[temp.dep]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    14.6.2.1	Dependent types
		[temp.dep.type]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    14.6.2.2	Type-dependent expressions
		[temp.dep.expr]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    14.6.2.3	Value-dependent expressions
		[temp.dep.constexpr]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    14.6.2.4	Dependent template arguments
		[temp.dep.temp]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    14.6.3	Non-dependent names
		[temp.nondep]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    14.6.4	Dependent name resolution
		[temp.dep.res]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    14.6.4.1	Point of instantiation
		[temp.point]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    14.6.4.2	Candidate functions
		[temp.dep.candidate]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    14.6.4.3	Conversions
		[temp.dep.conv]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    14.6.5	Friend names declared within a class template
		[temp.inject]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    14.7	Template specialization
		[temp.spec]
    --------------------------------------------------------------------  */

temp_spec_type ( TYPE: t, IDENTIFIER: id )
{
    KEY (ISO)	"14.7" | "????"
    KEY (STD)	"Invalid type '"t"' for specialization of template '"id"'"
}

temp_spec_bad ( TYPE: t )
{
    KEY (STD)	"Invalid specialization for template '"t"'"
}

temp_spec_member ( LONG_ID: id )
{
    KEY (STD)	"Can't specialize '"id"' in a class"
}

temp_spec_prefix ()
{
    USAGE:	new
    KEY (STD)	"'template <>' required in template specialization"
}

temp_spec_reinst ( TYPE: t )
{
    KEY (STD)	"Template '"t"' already explicitly instantiated"
}

temp_spec_respec ( TYPE: t )
{
    USAGE:	none
    KEY (STD)	"Template '"t"' already explicitly specialized"
}

temp_spec_redecl ( TYPE: t )
{
    KEY (STD)	"Template '"t"' both explicitly instantiated and
		 explicitly specialized"
}

temp_spec_used ( TYPE: t )
{
    KEY (STD)	"Template '"t"' specialized after use"
}

temp_spec_post ( TYPE: t, TYPE: s )
{
    KEY (STD)	"Template specialization '"t"' matches previously
		 used instance '"s"'"
}


/*  --------------------------------------------------------------------
    14.7.1	Implicit instantiation
		[temp.inst]
    --------------------------------------------------------------------  */

temp_inst_def ( TYPE: t )
{
    USAGE:	wall
    KEY (ISO)	"14.7.1" | "????"
    KEY (STD)	"Instantiating template '"t"'"
}

temp_inst_depth ( ulong: n )
{
    KEY (STD)	"Template instantiation depth too great ("n")"
}

temp_inst_comment ( TYPE: t, PTR_LOC: loc )
{
    USAGE:	whatever
    KEY (STD)	"In instantiation of template '"t"' (at "loc")"
}


/*  --------------------------------------------------------------------
    14.7.2	Explicit instantiation
		[temp.explicit]
    --------------------------------------------------------------------  */

temp_explicit_bad ( LONG_ID: id )
{
    KEY (ISO)	"14.7.2" | "????"
    KEY (STD)	"No template from which to instantiate '"id"'"
}

temp_explicit_id ( IDENTIFIER: id )
{
    USAGE:	none
    KEY (STD)	"'"id" <>' required in explicit template instantiation"
}

temp_explicit_def ()
{
    KEY (STD)	"Can't have definition in explicit template instantiation"
}

temp_explicit_incompl ()
{
    KEY (STD)	"Complete class required in explicit template instantiation"
}

temp_explicit_templ ()
{
    KEY (STD)	"Invalid template instantiation"
}


/*  --------------------------------------------------------------------
    14.7.3	Explicit specialization
		[temp.expl.spec]
    --------------------------------------------------------------------  */

temp_expl_spec_dargs ()
{
    KEY (ISO)	"14.7.3" | "????"
    KEY (STD)	"Can't have default function arguments in explicit
		 specialization"
}


/*  --------------------------------------------------------------------
    14.8	Function template specializations
		[temp.fct.spec]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    14.8.1	Explicit template argument specification
		[temp.arg.explicit]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    14.8.2	Template argument deduction
		[temp.deduct]
    --------------------------------------------------------------------  */

temp_deduct_fail ( LONG_ID: id )
{
    KEY (ISO)	"14.8.2" | "????"
    KEY (STD)	"Template argument deduction failed for '"id"'"
}

temp_deduct_undef ( IDENTIFIER: pid, LONG_ID: id )
{
    KEY (STD)	"Can't deduce value of template parameter '"pid"'"
}


/*  --------------------------------------------------------------------
    14.8.3	Overload resolution
		[temp.over]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    15		Exception handling
		[except]
    --------------------------------------------------------------------  */

except_handlers ()
{
    KEY (ISO)	"15" | "????"
    KEY (STD)	"A 'try' block must have at least one associated
		 'catch' handler"
}

except_not ()
{
    USAGE:	throw_bad
    KEY (STD)	"Body of 'try' block doesn't throw an exception"
}

except_jump_into ()
{
    KEY (STD)	"Can't jump into a 'try' block or handler"
}


/*  --------------------------------------------------------------------
    15.1	Throwing an exception
		[except.throw]
    --------------------------------------------------------------------  */

except_throw_type ()
{
    KEY (ISO)	"15.1" | "????"
    KEY (STD)	"Can only throw an expression, not a type"
}

except_throw_typedef ()
{
    KEY (STD)	"Can't define a type in a 'throw' expression"
}

except_throw_copy ()
{
    USAGE:	whatever
    KEY (STD)	"'throw' expression is copied to temporary variable"
}

except_throw_incompl ()
{
    KEY (STD)	"Can't throw a reference to an incomplete class"
}

except_throw_ambig ()
{
    USAGE:	none
    KEY (STD)	"Can't throw an expression with an ambiguous base class"
}


/*  --------------------------------------------------------------------
    15.2	Constructors and destructors
		[except.ctor]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    15.3	Handling an exception
		[except.handle]
    --------------------------------------------------------------------  */

except_handle_typedef ()
{
    KEY (ISO)	"15.3" | "????"
    KEY (STD)	"Can't define a type in an exception declaration"
}

except_handle_unreach ( TYPE: t1, TYPE: t2 )
{
    USAGE:	throw_bad
    KEY (STD)	"Exceptions of type '"t1"' will be caught by the
		 previous '"t2"' handler"
}

except_handle_ellipsis ()
{
    KEY (STD)	"A '...' exception handler must be the last in its block"
}

except_handle_incompl ()
{
    KEY (STD)	"Can't catch a reference to an incomplete class"
}

except_handle_return ( IDENTIFIER: id )
{
    KEY (STD)	"Can't return from exception handler in '"id"'"
}


/*  --------------------------------------------------------------------
    15.4	Exception specifications
		[except.spec]
    --------------------------------------------------------------------  */

except_spec_bad ()
{
    KEY (ISO)	"15.4" | "????"
    KEY (STD)	"Can only use exception specification in a function declarator"
}

except_spec_typedef ()
{
    KEY (STD)	"Can't define a type in an exception specification"
}

except_spec_ellipsis ()
{
    KEY (STD)	"Can't use '...' in an exception specification"
}

except_spec_incompl ()
{
    USAGE:	new
    KEY (STD)	"Can't have a reference to an incomplete class in
		 an exception specification"
}

except_spec_wrong ( IDENTIFIER: id, PTR_LOC: loc )
{
    KEY (STD)	"Redeclaration of '"id"' should have the same exception
		 specifiers (see "loc")"
}

except_spec_virtual ( IDENTIFIER: id1, LONG_ID: id2, PTR_LOC: loc )
{
    KEY (STD)	"Exception specifiers for overriding virtual function
		 '"id1"' should be more restrictive than those for
		 '"id2"' (see "loc")"
}

except_spec_assign ()
{
    KEY (STD)	"Exception specifiers in conversion should be more restrictive"
}

except_spec_init ()
{
    KEY (STD)	"Exception specifiers in initialization should match"
}

except_spec_throw ( TYPE: t )
{
    USAGE:	throw_bad
    KEY (STD)	"Uncaught exception of type '"t"' thrown"
}

except_spec_call ( LONG_ID: id, TYPE: t )
{
    USAGE:	throw_bad
    KEY (STD)	"Function '"id"' may throw an uncaught exception of type '"t"'"
}


/*  --------------------------------------------------------------------
    15.5	Special functions
		[except.special]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    15.5.1	The terminate() function
		[except.terminate]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    15.5.2	The unexpected() function
		[except.unexpected]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    15.6	Exceptions and access
		[except.access]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    16		Preprocessing directives
		[cpp]
    --------------------------------------------------------------------  */

cpp_bad ()
{
    USAGE:	ppdir_id
    KEY (ISO)	"16" | "6.8"
    KEY (STD)	"Bad preprocessing directive"
}

cpp_unknown ( HASHID: nm )
{
    USAGE:	ppdir_unknown
    KEY (STD)	"Unknown preprocessing directive, '#"nm"'"
}

cpp_end ( LEX: dir )
{
    KEY (STD)	"End of '#"dir"' directive expected"
}

cpp_indent ()
{
    USAGE:	ppdir_indent
    KEY (STD)	"Indented preprocessing directive"
}

cpp_indent_dir ()
{
    USAGE:	ppdir_indent_dir
    KEY (STD)	"Space after '#' in preprocessing directive"
}

cpp_space_replace ()
{
    KEY (STD)	"White space required before illegal character in
		 replacement list"
}

cpp_old ( LEX: dir )
{
    USAGE:	none
    KEY (STD)	"Pre-ISO preprocessors don't handle '#"dir"'"
}


/*  --------------------------------------------------------------------
    16.1	Conditional inclusion
		[cpp.cond]
    --------------------------------------------------------------------  */

cpp_cond_if_match ( LEX: dir1, LEX: dir2 )
{
    KEY (ISO)	"16.1" | "6.8.1"
    KEY (STD)	"'#"dir1"' without matching '#"dir2"'"
}

cpp_cond_else_dup ( LEX: dir1, LEX: dir2, PTR_LOC: loc )
{
    KEY (STD)	"'#"dir1"' after '#"dir2"' (at "loc")"
}

cpp_cond_def_id ()
{
    KEY (STD)	"Bad 'defined' operation"
}

cpp_cond_def_replace ()
{
    USAGE:	wall
    KEY (STD)	"Macro expansion gives 'defined'"
}

cpp_cond_ifdef_id ( LEX: dir )
{
    KEY (STD)	"Macro identifier expected after '#"dir"'"
}

cpp_cond_zero ( HASHID: nm )
{
    USAGE:	none
    KEY (STD)	"Identifier '"nm"' replaced by '0'"
}

cpp_cond_if_const ( LEX: dir )
{
    KEY (STD)	"Integer constant expression expected after '#"dir"'"
}

cpp_cond_if_ti ( LEX: dir )
{
    USAGE:	wall
    KEY (STD)	"Target dependent '#"dir"'"
}

cpp_cond_if_ti_decl ( LEX: dir )
{
    USAGE:	decl_cond
    KEY (STD)	"Can't have target dependent '#"dir"' at outer level"
}

cpp_cond_if_jump_into ()
{
    KEY (STD)	"Can't jump into a target dependent '#if' statement"
}

cpp_cond_if_macro ( HASHID: nm )
{
    KEY (ISO)   "16.1" | "6.8.1"
    KEY (STD)	"Can't define macro '"nm"' in a target dependent '#if'
		 statement"
}
cpp_cond_endif_end ( LEX: dir )
{
    USAGE:	ppdir_text
    KEY (STD)	"No text allowed after '#"dir"' directive"
}


/*  --------------------------------------------------------------------
    16.2	Source file inclusion
		[cpp.include]
    --------------------------------------------------------------------  */

cpp_include_bad ()
{
    KEY (ISO)	"16.2" | "6.8.2"
    KEY (STD)	"Illegal header name"
}

cpp_include_incompl ()
{
    KEY (STD)	"Incomplete header name"
}

cpp_include_undef ( string: str )
{
    USAGE:	wall
    KEY (STD)	"Undefined header name, '"str"'"
}

cpp_include_empty ()
{
    KEY (STD)	"Empty header name"
}

cpp_include_full ( string: str )
{
    USAGE:	include_full
    KEY (STD)	"Inclusion of '"str"' may not be portable"
}

cpp_include_unknown ( string: str )
{
    KEY (STD)	"Can't open included file, '"str"'"
}

cpp_include_open ( string: str )
{
    USAGE:	include_verbose
    KEY (STD)	"Opening included file, '"str"'"
}

cpp_include_close ( string: str )
{
    USAGE:	include_verbose
    KEY (STD)	"Closing included file, '"str"'"
}

cpp_include_depth ( ulong: n )
{
    KEY (STD)	"Include depth too great ("n")"
}

cpp_include_dup ( string: str, PTR_LOC: loc )
{
    USAGE:	include_verbose
    KEY (STD)	"File '"str"' has already been included (from "loc")"
}

cpp_include_date ()
{
    USAGE:	wall
    KEY (STD)	"Date stamp on file has changed"
}


/*  --------------------------------------------------------------------
    16.3	Macro replacement
		[cpp.replace]
    --------------------------------------------------------------------  */

cpp_replace_id ( LEX: dir )
{
    KEY (ISO)	"16.3" | "6.8.3"
    KEY (STD)	"Macro identifier expected after '#"dir"'"
}

cpp_replace_redef_ok ( IDENTIFIER: id, PTR_LOC: loc )
{
    USAGE:	none
    KEY (STD)	"Macro '"id"' redefined (see "loc")"
}

cpp_replace_redef_bad ( IDENTIFIER: id, PTR_LOC: loc )
{
    USAGE:	macro_redef
    KEY (STD)	"Macro '"id"' redefined inconsistently (see "loc")"
}

cpp_replace_redef_weak ( IDENTIFIER: id, PTR_LOC: loc )
{
    USAGE:	macro_weak
    KEY (STD)	"Macro '"id"' redefined with parameter renaming (see "loc")"
}

cpp_replace_redef_space ( IDENTIFIER: id, PTR_LOC: loc )
{
    USAGE:	macro_weak
    KEY (STD)	"Macro '"id"' redefined with differing white space (see "loc")"
}

cpp_replace_redef_nest ( IDENTIFIER: id, PTR_LOC: loc )
{
    USAGE:	macro_nest
    KEY (STD)	"Nested definition of macro '"id"' (see "loc")"
}

cpp_replace_par_dup ( HASHID: nm1, HASHID: nm2 )
{
    KEY (STD)	"Parameter '"nm1"' already defined for macro '"nm2"'"
}

cpp_replace_par_bad ( HASHID: nm )
{
    KEY (STD)	"Badly punctuated parameters for macro '"nm"'"
}

cpp_replace_arg_none ( HASHID: nm )
{
    USAGE:	wall
    KEY (STD)	"Macro '"nm"' invoked without arguments"
}

cpp_replace_arg_empty ( unsigned: n, HASHID: nm )
{
    USAGE:	wall
    KEY (STD)	"Argument "n" for macro '"nm"' is empty"
}

cpp_replace_arg_ppdir ( HASHID: nm )
{
    USAGE:	macro_arg_dir
    KEY (STD)	"Preprocessing directive in arguments for macro '"nm"'"
}

cpp_replace_arg_eof ( HASHID: nm )
{
    KEY (STD)	"Unterminated arguments for macro '"nm"'"
}

cpp_replace_arg_number ( HASHID: nm, unsigned: n, plural: s, unsigned: m )
{
    KEY (STD)	"Macro '"nm"' applied with "n" argument"s", not "m
}


/*  --------------------------------------------------------------------
    16.3.1	Argument substitution
		[cpp.subst]
    --------------------------------------------------------------------  */


/*  --------------------------------------------------------------------
    16.3.2	The # operator
		[cpp.stringize]
    --------------------------------------------------------------------  */

cpp_stringize_par ( HASHID: nm )
{
    USAGE:	hash_ident
    KEY (ISO)	"16.3.2" | "6.8.3.2"
    KEY (STD)	"'#' should be followed by a parameter for macro '"nm"'"
}

cpp_stringize_bad ( HASHID: nm )
{
    KEY (STD)	"Invalid string formed by macro '"nm"'"
}

cpp_stringize_old ( HASHID: par, HASHID: nm )
{
    USAGE:	wall
    KEY (STD)	"Quoted parameter '"par"' in definition of macro '"nm"'"
}


/*  --------------------------------------------------------------------
    16.3.3	The ## operator
		[cpp.concat]
    --------------------------------------------------------------------  */

cpp_concat_place ( HASHID: nm )
{
    KEY (ISO)	"16.3.3" | "6.8.3.3"
    KEY (STD)	"Badly placed '##' operator in macro '"nm"'"
}

cpp_concat_bad ( HASHID: nm )
{
    KEY (STD)	"Invalid result for '##' operator in macro '"nm"'"
}


/*  --------------------------------------------------------------------
    16.3.4	Rescanning and further replacement
		[cpp.rescan]
    --------------------------------------------------------------------  */

cpp_rescan_recursive ( HASHID: nm )
{
    USAGE:	wall
    KEY (ISO)	"16.3.4" | "6.8.3.4"
    KEY (STD)	"Macro '"nm"' used recursively"
}


/*  --------------------------------------------------------------------
    16.3.5	Scope of macro definitions
		[cpp.scope]
    --------------------------------------------------------------------  */

cpp_scope_id ( LEX: dir )
{
    KEY (ISO)	"16.3.5" | "6.8.3.5"
    KEY (STD)	"Macro identifier expected after '#"dir"'"
}

cpp_scope_undef ( HASHID: nm )
{
    USAGE:	none
    KEY (STD)	"Undefined macro '"nm"' was not defined"
}


/*  --------------------------------------------------------------------
    16.4	Line control
		[cpp.line]
    --------------------------------------------------------------------  */

cpp_line_bad ( LEX: dir )
{
    KEY (ISO)	"16.4" | "6.8.4"
    KEY (STD)	"Line number expected after '#"dir"'"
}

cpp_line_float ( LEX: dir )
{
    KEY (STD)	"Invalid line number in '#"dir"'"
}

cpp_line_range ( LEX: dir )
{
    KEY (STD)	"Line number out of range in '#"dir"'"
}


/*  --------------------------------------------------------------------
    16.5	Error directive
		[cpp.error]
    --------------------------------------------------------------------  */

cpp_error_msg ( string: str )
{
    KEY (ISO)	"16.5" | "6.8.5"
    KEY (STD)	str
}


/*  --------------------------------------------------------------------
    16.6	Pragma directive
		[cpp.pragma]
    --------------------------------------------------------------------  */

cpp_pragma_unknown ( LEX: dir )
{
    USAGE:	pragma_unknown
    KEY (ISO)	"16.6" | "6.8.6"
    KEY (STD)	"Unknown '#"dir"' directive"
}


/*  --------------------------------------------------------------------
    16.7	Null directive
		[cpp.null]
    --------------------------------------------------------------------  */

cpp_null ()
{
    USAGE:	wall
    KEY (ISO)	"16.7" | "6.8.7"
    KEY (STD)	"Null preprocessing directive"
}


/*  --------------------------------------------------------------------
    16.8	Predefined macro names
		[cpp.predefined] = [cpp.predef]
    --------------------------------------------------------------------  */

cpp_predef_bad ( HASHID: nm, LEX: dir )
{
    KEY (ISO)	"16.8" | "6.8.8"
    KEY (STD)	"Identifier '"nm"' subject of '#"dir"' directive"
}

cpp_predef_undef ( IDENTIFIER: id )
{
    KEY (STD)	"Undefining built-in macro '"id"'"
}

cpp_predef_redef ( IDENTIFIER: id )
{
    KEY (STD)	"Built-in macro '"id"' redefined"
}

cpp_predef_keyword ( HASHID: nm )
{
    USAGE:	wall
    KEY (STD)	"Keyword '"nm"' redefined using '#define'"
}


/*  --------------------------------------------------------------------
    18		Language support library
		[lib.language.support]
    --------------------------------------------------------------------  */

lib_builtin ( string: ns, HASHID: nm )
{
    KEY (ISO)	"18" | "????"
    KEY (STD)	"Built-in '"ns"::"nm"' not declared"
}


/*  --------------------------------------------------------------------
    27		Input/output library
		[lib.input.output]
    --------------------------------------------------------------------  */

printf_unknown ( string: s )
{
    USAGE:	printf_string
    PROPERTIES:	non_iso, printf
    KEY (STD)	"Unknown format string, '"s"'"
}

printf_invalid ( string: s )
{
    USAGE:	printf_string
    PROPERTIES:	non_iso, printf
    KEY (STD)	"Invalid format string, '"s"'"
}

printf_unterm ( string: s )
{
    USAGE:	printf_string
    PROPERTIES:	non_iso, printf
    KEY (STD)	"Unterminated '"s"' format string"
}

printf_flags ( string: t, string: s )
{
    USAGE:	printf_string
    PROPERTIES:	non_iso, printf
    KEY (STD)	"Can't have flags '"t"' with '"s"' format string"
}

printf_width ( string: s )
{
    USAGE:	printf_string
    PROPERTIES:	non_iso, printf
    KEY (STD)	"Can't have field width with '"s"' format string"
}

printf_precision ( string: s )
{
    USAGE:	printf_string
    PROPERTIES:	non_iso, printf
    KEY (STD)	"Can't have precision with '"s"' format string"
}

printf_arg_zero ()
{
    USAGE:	printf_string
    PROPERTIES:	non_iso, printf
    KEY (STD)	"Can't have argument zero in format string"
}

printf_arg_large ( unsigned: n )
{
    USAGE:	printf_string
    PROPERTIES:	non_iso, printf
    KEY (STD)	"Argument "n" in format string out of range"
}

printf_arg_compat ( unsigned: n )
{
    USAGE:	printf_string
    PROPERTIES:	non_iso, printf
    KEY (STD)	"Incompatible format string for argument "n
}

printf_arg_none ( unsigned: n )
{
    USAGE:	printf_string
    PROPERTIES:	non_iso, printf
    KEY (STD)	"No format string given for argument "n
}

printf_arg_mix ()
{
    USAGE:	printf_string
    PROPERTIES:	non_iso, printf
    KEY (STD)	"Can't mix numbered and unnumbered arguments in format string"
}


/*  --------------------------------------------------------------------
    Annex B	Implementation quantities
		[lib.language.support]
    --------------------------------------------------------------------  */

limits_max ( string: s, ulong: m, ulong: n )
{
    KEY (ISO)	"Annex B" | "5.2.4.1"
    KEY (STD)	"Value for '"s"' ("m") exceeds implementation limit ("n")"
}

limits_min ( string: s, ulong: m, ulong: n )
{
    USAGE:	wall
    KEY (STD)	"Value for '"s"' ("m") exceeds minimum implementation
		 limit ("n")"
}


/*  --------------------------------------------------------------------
    A.1		Pragma syntax
		[pragma]
    --------------------------------------------------------------------  */

pragma_scope_undef ( HASHID: nm )
{
    PROPERTIES:	non_iso, pragma
    KEY (ISO)	/* none */
    KEY (STD)	"Checking scope '"nm"' not defined"
}

pragma_scope_redef ( HASHID: nm )
{
    PROPERTIES:	non_iso, pragma
    KEY (STD)	"Checking scope '"nm"' already defined"
}

pragma_scope_end ()
{
    PROPERTIES:	non_iso, pragma
    KEY (STD)	"Unexpected end of checking scope"
}

pragma_scope_set ( string: s )
{
    PROPERTIES:	non_iso, pragma
    KEY (STD)	"Option '"s"' has already been set in this scope"
}

pragma_dblock_name ( HASHID: nm )
{
    PROPERTIES:	non_iso, pragma
    KEY (STD)	"Name mismatch for end of declaration block '"nm"'"
}

pragma_dblock_end ()
{
    PROPERTIES:	non_iso, pragma
    KEY (STD)	"Unexpected end of declaration block"
}

pragma_dir_undef ( string: d )
{
    PROPERTIES:	non_iso, pragma
    KEY (STD)	"Directory '"d"' not defined"
}

pragma_dir_mode ( string: d )
{
    PROPERTIES:	non_iso, pragma
    KEY (STD)	"Checking mode for directory '"d"' already defined"
}

pragma_error_bad ( STRING: s )
{
    PROPERTIES:	non_iso, pragma
    KEY (STD)	"Unknown error, "s
}

pragma_option_bad ( STRING: s )
{
    PROPERTIES:	non_iso, pragma
    KEY (STD)	"Unknown option, "s
}

pragma_keyword_bad ( HASHID: nm )
{
    PROPERTIES:	non_iso, pragma
    KEY (STD)	"Unknown keyword, '"nm"'"
}

pragma_char_lit ( TYPE: t )
{
    PROPERTIES:	non_iso, pragma
    KEY (STD)	"Character literal should have integral type, not '"t"'"
}

pragma_builtin_type ( TYPE: t )
{
    PROPERTIES:	non_iso, pragma
    KEY (STD)	"Built-in type should be integral, not '"t"'"
}

pragma_promote_type ( TYPE: t )
{
    PROPERTIES:	non_iso, pragma
    KEY (STD)	"Promotion type should be integral, not '"t"'"
}

pragma_promote_compat ( TYPE: t )
{
    USAGE:	whatever
    PROPERTIES:	non_iso, pragma
    KEY (STD)	"Promotion types for '"t"' should be compatible"
}

pragma_compat_type ()
{
    PROPERTIES:	non_iso, pragma
    KEY (STD)	"Invalid arguments for directive"
}

pragma_arg_dup ( TYPE: t )
{
    PROPERTIES:	non_iso, pragma
    KEY (STD)	"Inconsistent compatible argument type for '"t"'"
}

pragma_arg_cycle ()
{
    PROPERTIES:	non_iso, pragma
    KEY (STD)	"Directive completes a cycle of compatible argument types"
}

pragma_lit_type ( TYPE: t )
{
    PROPERTIES:	non_iso, pragma
    KEY (STD)	"Literal type should be a promoted integral type, not '"t"'"
}

pragma_lit_range ( NAT: n, TYPE: t )
{
    USAGE:	none
    PROPERTIES:	non_iso, pragma
    KEY (STD)	"Literal limit '"n"' doesn't fit into type '"t"'"
}

pragma_lit_question ()
{
    PROPERTIES:	non_iso, pragma
    KEY (STD)	"Type required in '?:' literal limit"
}

pragma_token_sort ( IDENTIFIER: id )
{
    PROPERTIES:	non_iso, token
    KEY (STD)	"Invalid sort for token '"id"'"
}

pragma_preserve_undecl ( LEX: op, IDENTIFIER: id )
{
    PROPERTIES:	non_iso, pragma
    KEY (STD)	"Identifier in '"op"' directive, '"id"', doesn't have linkage"
}

pragma_weak_redef ( IDENTIFIER: id )
{
    PROPERTIES:	non_iso, pragma
    KEY (STD)	"Weak symbol '"id"' already defined"
}

pragma_cpp_known ( LEX: dir )
{
    PROPERTIES:	non_iso, pragma
    KEY (STD)	"Preprocessing directive '#"dir"' used"
}

pragma_cpp_ident ( LEX: dir )
{
    PROPERTIES:	non_iso, pragma
    KEY (STD)	"String literal expected after '#"dir"'"
}

pragma_assert_id ( LEX: dir )
{
    PROPERTIES:	non_iso, pragma
    KEY (STD)	"Predicate identifier expected after '#"dir"'"
}

pragma_assert_open ( LEX: dir )
{
    PROPERTIES:	non_iso, pragma
    KEY (STD)	"Open bracket expected after predicate in '#"dir"'"
}

pragma_assert_paren ( LEX: dir )
{
    PROPERTIES:	non_iso, pragma
    KEY (STD)	"Unterminated predicate token sequence in '#"dir"'"
}

pragma_assert_empty ( LEX: dir )
{
    PROPERTIES:	non_iso, pragma
    KEY (STD)	"Empty predicate token sequence in '#"dir"'"
}

pragma_assert_pred ( HASHID: nm )
{
    USAGE:	ppdir_assert
    PROPERTIES:	non_iso, pragma
    KEY (STD)	"Predicate '"nm"' used"
}

port_entry_undef ( string: s )
{
    PROPERTIES:	non_iso, pragma
    KEY (STD)	"Portability table entry '"s"' not defined"
}

port_entry_redef ( string: s )
{
    PROPERTIES:	non_iso, pragma
    KEY (STD)	"Portability table entry '"s"' already defined"
}


/*  --------------------------------------------------------------------
    A.2		Token syntax
		[token]
    --------------------------------------------------------------------  */

token_info ( IDENTIFIER: id )
{
    USAGE:	whatever
    PROPERTIES:	non_iso, token
    KEY (ISO)	/* none */
    KEY (STD)	"'"id"' is tokenized"
}

token_redecl ( IDENTIFIER: id, PTR_LOC: loc )
{
    PROPERTIES:	non_iso, token
    KEY (STD)	"Token '"id"' declared inconsistently (see "loc")"
}

token_redef ( IDENTIFIER: id, PTR_LOC: loc )
{
    PROPERTIES:	non_iso, token
    KEY (STD)	"Incompatible redefinition for token '"id"' (see "loc")"
}

token_redef_ok ( IDENTIFIER: id, PTR_LOC: loc )
{
    USAGE:	token_redef
    PROPERTIES:	non_iso, token
    KEY (STD)	"Redefinition of token '"id"' (see "loc")"
}

token_undef ( IDENTIFIER: id )
{
    USAGE:	token_undef
    PROPERTIES:	non_iso, token
    KEY (STD)	"Token '"id"' not defined"
}

token_undecl ( IDENTIFIER: id )
{
    PROPERTIES:	non_iso, token
    KEY (STD)	"Token '"id"' not declared"
}

token_qual ( IDENTIFIER: id )
{
    PROPERTIES:	non_iso, token
    KEY (STD)	"Can't qualify the token name '"id"'"
}

token_scope ( IDENTIFIER: id )
{
    PROPERTIES:	non_iso, token
    KEY (STD)	"Identifier '"id"' used out of scope"
}

token_no_def ( IDENTIFIER: id, PTR_LOC: loc )
{
    PROPERTIES:	non_iso, token
    KEY (STD)	"Token in 'no_def' directive, '"id"', has already been
		 defined (at "loc")"
}

token_def_not ( IDENTIFIER: id )
{
    PROPERTIES:	non_iso, token
    KEY (STD)	"Can't define token '"id"'"
}

token_def_args ( IDENTIFIER: id )
{
    PROPERTIES:	non_iso, token
    KEY (STD)	"Wrong number of parameters in definition of token '"id"'"
}

token_def_func ( IDENTIFIER: id, TYPE: t )
{
    PROPERTIES:	non_iso, token
    KEY (STD)	"Function of type '"t"' required in 'FUNC' token
		 definition, not '"id"'"
}

token_def_ambig ( IDENTIFIER: id )
{
    PROPERTIES:	non_iso, token
    KEY (STD)	"Ambiguous 'FUNC' token '"id"' in definition"
}

token_def_except ()
{
    PROPERTIES:	non_iso, token
    KEY (STD)	"Exception specifiers should match in 'FUNC' token definition"
}

token_def_implicit ( IDENTIFIER: id )
{
    USAGE:	func_token_undef
    PROPERTIES:	non_iso, token
    KEY (STD)	"Implicit definition of token '"id"'"
}

token_proc_high ()
{
    PROPERTIES:	non_iso, token
    KEY (STD)	"High-level 'PROC' tokens not allowed"
}

token_func ( TYPE: t )
{
    PROPERTIES:	non_iso, token
    KEY (STD)	"A 'FUNC' token should have function type, not '"t"'"
}

token_mem ( TYPE: t )
{
    PROPERTIES:	non_iso, token
    KEY (STD)	"The second type in a 'MEMBER' token should have class
		 type, not '"t"'"
}

token_mem_off ()
{
    USAGE:	whatever
    PROPERTIES:	non_iso, token
    KEY (STD)	"Constant offset required in 'MEMBER' token"
}

token_stmt_ret ( IDENTIFIER: id )
{
    PROPERTIES:	non_iso, token
    KEY (STD)	"Can't have 'return' statement in 'STATEMENT' token '"id"'"
}

token_stmt_jump ()
{
    PROPERTIES:	non_iso, token
    KEY (STD)	"Jump into 'STATEMENT' token"
}

token_const ( IDENTIFIER: id )
{
    USAGE:	token_const
    PROPERTIES:	non_iso, token
    KEY (STD)	"Non-constant 'EXP' token '"id"' used in constant expression"
}

token_arg_sort ( IDENTIFIER: id )
{
    PROPERTIES:	non_iso, token
    KEY (STD)	"Wrong sort for 'PROC' token parameter '"id"'"
}

token_arg_bad ( IDENTIFIER: id )
{
    PROPERTIES:	non_iso, token
    KEY (STD)	"Invalid 'PROC' token parameter '"id"'"
}

token_arg_exp ( IDENTIFIER: id )
{
    USAGE:	whatever
    PROPERTIES:	non_iso, token
    KEY (STD)	"Values for 'EXP' token '"id"' are converted to the token type"
}

token_arg_const ( IDENTIFIER: id )
{
    PROPERTIES:	non_iso, token
    KEY (STD)	"Non-constant value for constant 'EXP' token '"id"'"
}

token_arg_lvalue ( IDENTIFIER: id )
{
    PROPERTIES:	non_iso, token
    KEY (STD)	"Value for lvalue 'EXP' token '"id"' is an rvalue"
}

token_arg_mem ( IDENTIFIER: id )
{
    USAGE:	whatever
    PROPERTIES:	non_iso, token
    KEY (STD)	"Types for 'MEMBER' token '"id"' should be compatible"
}

token_arg_nat ( IDENTIFIER: id )
{
    PROPERTIES:	non_iso, token
    KEY (STD)	"Non-negative integer constant required in 'NAT' token '"id"'"
}

token_arg_type ( LEX: tok, IDENTIFIER: id, TYPE: t )
{
    PROPERTIES:	non_iso, token
    KEY (STD)	"Invalid type for '"tok"' token '"id"', '"t"'"
}

token_recursive ( IDENTIFIER: id )
{
    PROPERTIES:	non_iso, token
    KEY (STD)	"Token '"id"' defined recursively"
}

token_arg_undef ( IDENTIFIER: pid, IDENTIFIER: id )
{
    PROPERTIES:	non_iso, token
    KEY (STD)	"Can't deduce value of token parameter '"pid"' in
		 application of token '"id"'"
}

token_conv ( IDENTIFIER: id, TYPE: t, TYPE: s )
{
    USAGE:	none
    PROPERTIES:	non_iso, token
    KEY (STD)	"Using token '"id"' for conversion from '"t"' to '"s"'"
}
