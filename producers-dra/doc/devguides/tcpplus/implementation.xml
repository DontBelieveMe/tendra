<?xml version="1.0" standalone="no"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
	"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">

<!--
	$Id$
-->

<chapter>
    <title>Other implementation details</title>


  <section>
    <title>Intermodule analysis</title>
<!-- TODO: does this belong here, or is it user-facing? -->
	<warning>
  <para>The C++ spec linking routines have not yet been completely implemented,
  and so are disabled in the current version of the C++ producer.</para>
	</warning>
  <para>
  A C++ spec file is a dump of the C++ producer's <A HREF="alg.html">internal
  representation</A> of a translation unit.  Such files can be written
  to, and read from, disk to perform such operations as intermodule
  analysis.
  </para>
  <para>
  Note that the format of a C++ spec file is specific to the C++ producer
  and may change between releases to reflect modifications in the internal
  type system.  The C producer has a similar dump format, called a C
  spec file, however the two are incompatible.  If intermodule analysis
  between C and C++ source files is required then the <A HREF="dump.html">symbol
  table dump</A> format should be used.
  </para>
  </section>

  <section id="undefined-conversions">
    <title>Undefined conversions</title>
  <para>
  Several conversions in C and C++ can only be represented by undefined
  TDF.  For example, converting a pointer to an integer can only be
  represented in TDF by forming a union of the pointer and integer shapes,
  putting the pointer into the union and pulling the integer out.  Such
  conversions are tokenised.  Undefined conversions not mentioned below
  may be performed by combining those given with the standard, well-defined,
  conversions.
  </para>
  <para>
  The token:
  <programlisting language="TDF">
~ptr_to_ptr : ( ALIGNMENT a, ALIGNMENT b, EXP POINTER a ) -&gt; EXP POINTER b</programlisting>
  is used to convert between two incompatible pointer types.  The first
  alignment describes the source pointer shape while the second describes
  the destination pointer shape.  Note that if the destination alignment
  is greater than the source alignment then the source pointer can be
  used in most TDF constructs in place of the destination pointer, so
  the use of <code>~ptr_to_ptr</code> can be omitted (the exception
  is
  <code>pointer_test</code> which requires equal alignments).  Base
  class pointer conversions are examples of these well-behaved, alignment
  preserving conversions.
  </para>
  <para>
  The tokens:
  <programlisting language="TDF">
~f_to_pv : ( EXP PROC ) -&gt; EXP pv
~pv_to_f : ( EXP pv ) -&gt; EXP PROC</programlisting>
  are used to convert pointers to functions to and from <code>void *</code>
  (these conversions are not allowed in ISO C/C++ but are in older dialects).
  </para>
  <para>
  The tokens:
  <programlisting language="TDF">
~i_to_p : ( VARIETY v, ALIGNMENT a, EXP INTEGER v ) -&gt; EXP POINTER a
~p_to_i : ( ALIGNMENT a, VARIETY v, EXP POINTER a ) -&gt; EXP INTEGER v
~i_to_pv : ( VARIETY v, EXP INTEGER v ) -&gt; EXP pv
~pv_to_i : ( VARIETY v, EXP pv ) -&gt; EXP INTEGER v</programlisting>
  are used to convert integers to and from <code>void *</code> and other
  pointers.
  </para>
  </section>

  <section id="div">
    <title>Integer division</title>
  <para>
  The precise form of the integer division and remainder operations
  in C and C++ is left unspecified with respect to the sign of the result
  if either operand is negative.  The tokens:
  <programlisting language="TDF">
~div : ( EXP INTEGER v, EXP INTEGER v ) -&gt; EXP INTEGER v
~rem : ( EXP INTEGER v, EXP INTEGER v ) -&gt; EXP INTEGER v</programlisting>
  are used to represent integer division and remainder.  They will map
  onto one of the pairs of TDF constructs, <code>div0</code> and <code>rem0</code>,
  <code>div1</code> and <code>rem1</code> or <code>div2</code> and
  <code>rem2</code>.
  </para>
  </section>

  <section id="dynamic-initialisation">
    <title>Dynamic initialisation</title>
  <para>
  The dynamic initialisation of variables with static storage duration
  in C++ is implemented by means of the TDF <code>initial_value</code>
  construct.  However in order for the producer to maintain control
  over the order of initialisation, rather than each variable being
  initialised separately using <code>initial_value</code>, a single
  expression is created which initialises all the variables in a module,
  and this initialiser expression is used to initialise a single dummy
  variable using <code>initial_value</code>.  Note that, while this
  enables the variables within a single module to be initialised in
  the order in which they are defined, the order of initialisation between
  different modules is unspecified.
  </para>
  <para>
  The implementation needs to keep a list of those variables with static
  storage duration which have been initialised so that it can call the
  destructors for these objects at the end of the program. This is done
  by declaring a variable of shape:
  <programlisting language="TDF">
~cpp.destr.type : () -&gt; SHAPE</programlisting>
  for each such object with a non-trivial destructor.  Each element
  of an array is considered a distinct object.  Immediately after the
  variable has been initialised the token:
  <programlisting language="TDF">
~cpp.destr.global : ( EXP pd, EXP POINTER c, EXP PROC ) -&gt; EXP TOP</programlisting>
  is called to add the variable to the list of objects to be destroyed.
  The first argument is the address of the dummy variable just declared,
  the second is the address of the object to be destroyed, and the third
  is the destructor to be used.  In this way a list giving the objects
  to be destroyed, and the order in which to destroy them, is built
  up.  Note that partially constructed objects are destroyed within
  their constructors (see <link linkend="partial">above</link>) so that only
  completely constructed objects need to be considered.
  </para>
  <para>
  The implementation also needs to ensure that it calls the destructors
  in this list at the end of the program, including calls of
  <code>exit</code>.  This is done by calling the token:
  <programlisting language="TDF">
~cpp.destr.init : () -&gt; EXP TOP</programlisting>
  at the start of each <code>initial_value</code> construct.  In the
  default implementation this uses <code>atexit</code> to register a
  function, <code>__TCPPLUS_term</code>, which calls the destructors.
  To aid alternative implementations the token:
  <programlisting language="TDF">
~cpp.start : () -&gt; EXP TOP</programlisting>
  is called at the start of the <code>main</code> function, however
  this has no effect in the default implementation.
  </para>
  </section>

</chapter>

