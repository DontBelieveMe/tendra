<?xml version="1.0" standalone="no"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
	"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">

<!--
	$Id$
-->

<chapter>
    <title>Implementation details</title>
  <para>
  This section describes various of the implementation details of the
  C++ producer TDF output.  In particular it describes the standard
  TDF tokens used to represent the target dependent aspects of the language
  and to provide links into the run-time system.  Many of these tokens
  are common to the C and C++ producers.  Those which are unique to
  the C++ producer have names of the form <code>~cpp.*</code>.  Note
  that the description is in terms of TDF tokens, not the internal tokens
  introduced by the
  <A HREF="token.html"><code>#pragma token</code> syntax</A>.
  </para>
  <para>
  There are two levels of implementation in the run-time system.  The
  actual interface between the producer and the run-time system is given
  by the standard tokens.  The provided implementation defines these
  tokens in a way appropriate to itself.  An alternative implementation
  would have to define the tokens differently.  It is intended that
  the standard tokens are sufficiently generic to allow a variety of
  implementations to hook into the producer output in the manner they
  require.
  </para>


  <section>
    <title>Intermodule analysis</title>
<!-- TODO: does this belong here, or is it user-facing? -->
	<warning>
  <para>The C++ spec linking routines have not yet been completely implemented,
  and so are disabled in the current version of the C++ producer.</para>
	</warning>
  <para>
  A C++ spec file is a dump of the C++ producer's <A HREF="alg.html">internal
  representation</A> of a translation unit.  Such files can be written
  to, and read from, disk to perform such operations as intermodule
  analysis.
  </para>
  <para>
  Note that the format of a C++ spec file is specific to the C++ producer
  and may change between releases to reflect modifications in the internal
  type system.  The C producer has a similar dump format, called a C
  spec file, however the two are incompatible.  If intermodule analysis
  between C and C++ source files is required then the <A HREF="dump.html">symbol
  table dump</A> format should be used.
  </para>
  </section>

  <section id="arith">
    <title>Arithmetic types</title>
  <para>
  The representations of the basic arithmetic types are target dependent,
  so, for example, an <code>int</code> may contain 16, 32, 64 or some
  other number of bits.  Thus it is necessary to introduce a token to
  stand for each of the built-in arithmetic types (including the
  <A HREF="pragma.html#longlong"><code>long long</code> types</A>).
  Each integral type is represented by a <code>VARIETY</code> token
  as follows: </para>

  <table>
  <tr><th>Type</th>
  <th>Token</th>
  <th>Encoding</th>
  </tr>
  <tr><td>char</td>
  <td>~char</td>
  <td>0</td>
  </tr>
  <tr><td>signed char</td>
  <td>~signed_char</td>
  <td>0 | 4 = 4</td>
  </tr>
  <tr><td>unsigned char</td>
  <td>~unsigned_char</td>
  <td>0 | 8 = 8</td>
  </tr>
  <tr><td>signed short</td>
  <td>~signed_short</td>
  <td>1 | 4 = 5</td>
  </tr>
  <tr><td>unsigned short</td>
  <td>~unsigned_short</td>
  <td>1 | 8 = 9</td>
  </tr>
  <tr><td>signed int</td>
  <td>~signed_int</td>
  <td>2 | 4 = 6</td>
  </tr>
  <tr><td>unsigned int</td>
  <td>~unsigned_int</td>
  <td>2 | 8 = 10</td>
  </tr>
  <tr><td>signed long</td>
  <td>~signed_long</td>
  <td>3 | 4 = 7</td>
  </tr>
  <tr><td>unsigned long</td>
  <td>~unsigned_long</td>
  <td>3 | 8 = 11</td>
  </tr>
  <tr><td>signed long long</td>
  <td>~signed_longlong</td>
  <td>3 | 4 | 16 = 23 </td>
  </tr>
  <tr><td>unsigned long long</td>
  <td>~unsigned_longlong</td>
  <td>3 | 8 | 16 = 27</td>
  </tr>
  </table>

  <para>
  Similarly each floating point type is represent by a
  <code>FLOATING_VARIETY</code> token:
  </para>

  <table>
  <tr><th>Type</th>   <th>Token</th>
  </tr>
  <tr><td>float</td>  <td>~float</td>
  </tr>
  <tr><td>double</td> <td>~double</td>
  </tr>
  <tr><td>long double</td> <td>~long_double</td>
  </tr>
  </table>

  <para>
  Each integral type also has an encoding as a <code>SIGNED_NAT</code>
  as shown above.  This number is a bit pattern built up from the following
  values:
  </para>

  <table>
  <tr><th>Type</th>   <th>Encoding</th>
  </tr>
  <tr><td>char</td>  <td>0</td>
  </tr>
  <tr><td>short</td>  <td>1</td>
  </tr>
  <tr><td>int</td>  <td>2</td>
  </tr>
  <tr><td>long</td>  <td>3</td>
  </tr>
  <tr><td>signed</td> <td>4</td>
  </tr>
  <tr><td>unsigned</td> <td>8</td>
  </tr>
  <tr><td>long long</td> <td>16</td>
  </tr>
  </table>

  <para>
  Any target dependent integral type can be represented by a
  <code>SIGNED_NAT</code> token using this encoding.  This representation,
  rather than one based on <code>VARIETY</code>s, is used for ease of
  manipulation.  The token:
  <programlisting language="TDF">
~convert : ( SIGNED_NAT ) -&gt; VARIETY</programlisting>
  gives the mapping from the integral encoding to the representing variety.
  For example, it will map <code>6</code> to <code>~signed_int</code>.
  </para>
  <para>
  The token:
  <programlisting language="TDF">
~promote : ( SIGNED_NAT ) -&gt; SIGNED_NAT</programlisting>
  describes how to form the promotion of an integral type according
  to the ISO C/C++ value preserving rules, and is used by the producer
  to represent target dependent promotion types.  For example, the promotion
  of <code>unsigned short</code> may be <code>int</code> or <code>unsigned
  int</code> depending on the representation of these types; that is
  to say, <code>~promote ( 9 )</code> will be <code>6</code> on some
  machines and <code>10</code> on others.  Although <code>~promote</code>
  is used by default, a program may specify another token with the same
  sort signature to be used in its place by means of the directive:
  <programlisting language="C++">
#pragma TenDRA compute promote <emphasis>identifier</emphasis></programlisting>
  For example, a standard token <code>~sign_promote</code> is defined
  which gives the older C sign preserving promotion rules.  In addition,
  the promotion of an individual type can be specified using:
  <programlisting language="C++">
#pragma TenDRA promoted <emphasis>type-id</emphasis> : <emphasis>promoted-type-id</emphasis></programlisting>
  </para>
  <para>
  The token:
  <programlisting language="TDF">
~arith_type : ( SIGNED_NAT, SIGNED_NAT ) -&gt; SIGNED_NAT</programlisting>
  similarly describes how to form the usual arithmetic result type from
  two promoted integral operand types.  For example, the arithmetic
  type of <code>long</code> and <code>unsigned int</code> may be
  <code>long</code> or <code>unsigned long</code> depending on the representation
  of these types; that is to say,
  <code>~arith_type ( 7, 10 )</code> will be <code>7</code> on some
  machines and <code>11</code> on others.
  </para>
  <para>
  Any tokenised type declared using:
  <programlisting language="C++">
#pragma token VARIETY v # tv</programlisting>
  will be represented by a <code>SIGNED_NAT</code> token with external
  name
  <code>tv</code> corresponding to the encoding of <code>v</code>.
  Special cases of this are the implementation dependent integral types
  which arise naturally within the language.  The external token names
  for these types are given below:
  </para>

  <table>
  <tr><th>Type</th>   <th>Token</th>
  </tr>
  <tr><td>bool</td>  <td>~cpp.bool</td>
  </tr>
  <tr><td>ptrdiff_t</td> <td>ptrdiff_t</td>
  </tr>
  <tr><td>size_t</td> <td>size_t</td>
  </tr>
  <tr><td>wchar_t</td> <td>wchar_t</td>
  </tr>
  </table>

  <para>
  So, for example, a <code>sizeof</code> expression has shape
  <code>~convert ( size_t )</code>.  The token <code>~cpp.bool</code>
  is defined in the default implementation, but the other tokens are
  defined according to their definitions on the target machine in the
  normal API library building mechanism.
  </para>
  </section>

  <section id="literal">
    <title>Integer literal types</title>
  <para>
  The <A HREF="pragma.html#int">type of an integer literal</A> is defined
  in terms of the first in a list of possible integral types.  The first
  type in which the literal value can be represented gives the type
  of the literal.  For small literals it is possible to work out the
  type exactly, however for larger literals the result is target dependent.
  For example, the literal <code>50000</code> will have type <code>int</code>
  on machines in which <code>50000</code> fits into an <code>int</code>,
  and
  <code>long</code> otherwise.  This target dependent mapping is given
  by a series of tokens of the form:
  <programlisting language="TDF">
~lit_* : ( SIGNED_NAT ) -&gt; SIGNED_NAT</programlisting>
  which map a literal value to the representation of an integral type.
  The token used depends on the list of possible types, which in turn
  depends on the base used to represent the literal and the integer
  suffix used, as given in the following table:
  </para>

  <table>
  <tr><th>Base</th>
  <th>Suffix</th>
  <th>Token</th>
  <th>Types</th>
  </tr>
  <tr><td>decimal</td>
  <td>none</td>
  <td>~lit_int</td>
  <td>int, long, unsigned long</td>
  </tr>
  <tr><td>octal</td>
  <td>none</td>
  <td>~lit_hex</td>
  <td>int, unsigned int, long, unsigned long</td>
  </tr>
  <tr><td>hexadecimal</td>
  <td>none</td>
  <td>~lit_hex</td>
  <td>int, unsigned int, long, unsigned long</td>
  </tr>
  <tr><td>any</td>
  <td>U</td>
  <td>~lit_unsigned</td>
  <td>unsigned int, unsigned long</td>
  </tr>
  <tr><td>any</td>
  <td>L</td>
  <td>~lit_long</td>
  <td>long, unsigned long</td>
  </tr>
  <tr><td>any</td>
  <td>UL</td>
  <td>~lit_ulong</td>
  <td>unsigned long</td>
  </tr>
  <tr><td>any</td>
  <td>LL</td>
  <td>~lit_longlong</td>
  <td>long long, unsigned long long</td>
  </tr>
  <tr><td>any</td>
  <td>ULL</td>
  <td>~lit_ulonglong</td>
  <td>unsigned long long</td>
  </tr>
  </table>

  <para>
  Thus, for example, the shape of the integer literal 50000 is:
  <programlisting language="TDF">
~convert ( ~lit_int ( 50000 ) )</programlisting>
  </para>
  </section>

  <section id="bitfield">
    <title>Bitfield types</title>
  <para>
  The sign of a plain bitfield type, declared without using
  <code>signed</code> or <code>unsigned</code>, is left unspecified
  in C and C++.  The token:
  <programlisting language="TDF">
~cpp.bitf_sign : ( SIGNED_NAT ) -&gt; BOOL</programlisting>
  is used to give a mapping from integral types to the sign of a plain
  bitfield of that type, in a form suitable for use in the TDF
  <code>bfvar_bits</code> construct.  (Note that <code>~cpp.bitf_sign</code>
  should have been a standard C token but was omitted.)
  </para>
  </section>

  <section id="pointer">
    <title>Generic pointers</title>
  <para>
  TDF has no concept of a generic pointer type, so tokens are used to
  defer the representation of <code>void *</code> and the basic operations
  on it to the target machine.  The fundamental token is:
  <programlisting language="TDF">
~ptr_void : () -&gt; SHAPE</programlisting>
  which gives the representation of <code>void *</code>.  This shape
  will be denoted by <code>pv</code> in the description of the following
  tokens.  It is not guaranteed that <code>pv</code> is a TDF <code>pointer</code>
  shape, although normally it will be implemented as a pointer to a
  suitable alignment.
  </para>
  <para>
  The token:
  <programlisting language="TDF">
~null_pv : () -&gt; EXP pv</programlisting>
  gives the value of a null pointer of type <code>void *</code>.  Generic
  pointers can also be converted to and from other pointers.  These
  conversions are represented by the tokens:
  <programlisting language="TDF">
~to_ptr_void : ( ALIGNMENT a, EXP POINTER a ) -&gt; EXP pv
~from_ptr_void : ( ALIGNMENT a, EXP pv ) -&gt; EXP POINTER a</programlisting>
  where the given alignment describes the destination or source pointer
  type.  Finally a generic pointer may be tested against the null pointer
  or two generic pointers may be compared.  These operations are represented
  by the tokens:
  <programlisting language="TDF">
~cpp.pv_compare : ( EXP pv, EXP pv, LABEL, NTEST ) -&gt; EXP TOP</programlisting>
  where the given <code>NTEST</code> gives the comparison to be applied
  and the given label gives the destination to jump to if the test fails.
  (Note that <code>~cpp.pv_compare</code> should have been a standard
  C token but was omitted.)
  </para>
  </section>

  <section id="undefined-conversions">
    <title>Undefined conversions</title>
  <para>
  Several conversions in C and C++ can only be represented by undefined
  TDF.  For example, converting a pointer to an integer can only be
  represented in TDF by forming a union of the pointer and integer shapes,
  putting the pointer into the union and pulling the integer out.  Such
  conversions are tokenised.  Undefined conversions not mentioned below
  may be performed by combining those given with the standard, well-defined,
  conversions.
  </para>
  <para>
  The token:
  <programlisting language="TDF">
~ptr_to_ptr : ( ALIGNMENT a, ALIGNMENT b, EXP POINTER a ) -&gt; EXP POINTER b</programlisting>
  is used to convert between two incompatible pointer types.  The first
  alignment describes the source pointer shape while the second describes
  the destination pointer shape.  Note that if the destination alignment
  is greater than the source alignment then the source pointer can be
  used in most TDF constructs in place of the destination pointer, so
  the use of <code>~ptr_to_ptr</code> can be omitted (the exception
  is
  <code>pointer_test</code> which requires equal alignments).  Base
  class pointer conversions are examples of these well-behaved, alignment
  preserving conversions.
  </para>
  <para>
  The tokens:
  <programlisting language="TDF">
~f_to_pv : ( EXP PROC ) -&gt; EXP pv
~pv_to_f : ( EXP pv ) -&gt; EXP PROC</programlisting>
  are used to convert pointers to functions to and from <code>void *</code>
  (these conversions are not allowed in ISO C/C++ but are in older dialects).
  </para>
  <para>
  The tokens:
  <programlisting language="TDF">
~i_to_p : ( VARIETY v, ALIGNMENT a, EXP INTEGER v ) -&gt; EXP POINTER a
~p_to_i : ( ALIGNMENT a, VARIETY v, EXP POINTER a ) -&gt; EXP INTEGER v
~i_to_pv : ( VARIETY v, EXP INTEGER v ) -&gt; EXP pv
~pv_to_i : ( VARIETY v, EXP pv ) -&gt; EXP INTEGER v</programlisting>
  are used to convert integers to and from <code>void *</code> and other
  pointers.
  </para>
  </section>

  <section id="div">
    <title>Integer division</title>
  <para>
  The precise form of the integer division and remainder operations
  in C and C++ is left unspecified with respect to the sign of the result
  if either operand is negative.  The tokens:
  <programlisting language="TDF">
~div : ( EXP INTEGER v, EXP INTEGER v ) -&gt; EXP INTEGER v
~rem : ( EXP INTEGER v, EXP INTEGER v ) -&gt; EXP INTEGER v</programlisting>
  are used to represent integer division and remainder.  They will map
  onto one of the pairs of TDF constructs, <code>div0</code> and <code>rem0</code>,
  <code>div1</code> and <code>rem1</code> or <code>div2</code> and
  <code>rem2</code>.
  </para>
  </section>

  <section id="call">
    <title>Calling conventions</title>
  <para>
  The function calling conventions used by the C++ producer are essentially
  the same as those used by the C producer with one exception.  That
  is to say, all types except arrays are passed by value (note that
  individual installers may modify these conventions to conform to their
  own ABIs).
  </para>
  <para>
  The exception concerns classes with a non-trivial constructor, destructor
  or assignment operator.  These classes are passed as function arguments
  by taking a reference to a copy of the object (although it is often
  possible to eliminate the copy and pass a reference to the object
  directly).  They are passed as function return values by adding an
  extra parameter to the start of the function parameters giving a reference
  to a location into which the return value should be copied.
  </para>

<section>
	<title>Member functions</title>
  <para>
  Non-static member functions are implemented in the obvious fashion,
  by passing a pointer to the object the method is being applied to
  as the first argument (or the second argument if the method has an
  extra argument for its return value).
  </para>
</section>

<section id="ellipsis-funcs">
	<title>Ellipsis functions</title>
  <para>
  Calls to functions declared with ellipses are via the
  <code>apply_proc</code> TDF construct, with all the arguments being
  treated as non-variable.  However the definition of such a function
  uses the <code>make_proc</code> construct with a variable parameter.
  This parameter can be referred to within the program using the
  <A HREF="pragma.html#ellipsis"><code>...</code> expression</A>.  The
  type of this expression is given by the built-in token:
  <programlisting language="TDF">
~__va_t : () -&gt; SHAPE</programlisting>
  The <code>va_start</code> macro declared in the
  <code>&lt;stdarg.h&gt;</code> header then describes how the variable
  parameter (expressed as <code>...</code>) can be converted to an expression
  of type <code>va_list</code> suitable for use in the
  <code>va_arg</code> macro.
  </para>
  <para>
  Note that the variable parameter is in effect only being used to determine
  where the first optional parameter is defined.  The assumption is
  that all such parameters are located contiguously on the stack, however
  the fact that calls to such functions do not use the variable parameter
  mechanism means that this is not automatically the case.  Strictly
  speaking this means that the implementation of ellipsis functions
  uses undefined behaviour in TDF, however given the non-type-safe function
  calling rules in C this is unavoidable and installers need to make
  provision for such calls (by dumping any parameters from registers
  to the stack if necessary).  Given the theoretically type-safe nature
  of C++ it would be possible to avoid such undefined behaviour, but
  the need for C-compatible calling conventions prevents this.
  </para>
</section>
  </section>

  <section id="ptr_mem">
    <title>Pointers to data members</title>
  <para>
  The representation of, and operations on, pointers to data members
  are represented by tokens to allow for a variety of implementations.
  It is assumed that all pointers to data members (as opposed to pointers
  to function members) are represented by the same shape:
  <programlisting language="TDF">
~cpp.pm.type : () -&gt; SHAPE</programlisting>
  This shape will be denoted by <code>pm</code> in the description of
  the following tokens.
  </para>
  <para>
  There are two basic methods of constructing a pointer to a data member.
  The first is to take the address of a data member of a class.  A data
  member is represented in TDF by an expression which gives the offset
  of the member from the start of its enclosing <code>compound</code>
  shape (note that it is not possible to take the address of a member
  of a virtual base). The mapping from this offset to a pointer to a
  data member is given by:
  <programlisting language="TDF">
~cpp.pm.make : ( EXP OFFSET ) -&gt; EXP pm</programlisting>
  The second way of constructing a pointer to a data member is to use
  a null pointer to member:
  <programlisting language="TDF">
~cpp.pm.null : () -&gt; EXP pm</programlisting>
  The other fundamental operation on a pointer to data member is to
  turn it back into an offset expression which can be added to a pointer
  to a class to access a member of that class in a <code>.*</code> or
  <code>-&gt;*</code>
  operation.  This is done by the token:
  <programlisting language="TDF">
~cpp.pm.offset : ( EXP pm, ALIGNMENT a ) -&gt; EXP OFFSET ( a, a )</programlisting>
  Note that it is necessary to specify an alignment in order to describe
  the shape of the result.  The value of this token is undefined if
  the given expression is a null pointer to data member.
  </para>
  <para>
  A pointer to a data member of a non-virtual base class can be converted
  to a pointer to a data member of a derived class.  The reverse conversion
  is also possible using <code>static_cast</code>.  If the base is a
  <link linkend="primary">primary base class</link> then these conversions are
  trivial and have no effect.  Otherwise null pointers to data members
  are converted to null pointers to data members, and the non-null cases
  are handled by the tokens:
  <programlisting language="TDF">
~cpp.pm.cast : ( EXP pm, EXP OFFSET ) -&gt; EXP pm
~cpp.pm.uncast : ( EXP pm, EXP OFFSET ) -&gt; EXP pm</programlisting>
  where the given offset is the offset of the base class within the
  derived class.  It is also possible to convert between any two pointers
  to data members using <code>reinterpret_cast</code>.  This conversion
  is implied by the equality of representation between any two pointers
  to data members and has no effect.
  </para>
  <para>
  The only remaining operations on pointer to data members are to test
  one against the null pointer to data member and to compare two pointer
  to data members.  These are represented by the tokens:
  <programlisting language="TDF">
~cpp.pm.test : ( EXP pm, LABEL, NTEST ) -&gt; EXP TOP
~cpp.pm.compare : ( EXP pm, EXP pm, LABEL, NTEST ) -&gt; EXP TOP</programlisting>
  where the given <code>NTEST</code> gives the comparison to be applied
  and the given label gives the destination to jump to if the test fails.
  </para>
  <para>
  In the default implementation, pointers to data members are implemented
  as <code>int</code>.  The null pointer to member is represented by
  0 and the address of a class member is represented by 1 plus the offset
  of the member (in bytes).  Casting to and from a derived class then
  correspond to adding or subtracting the base class offset (in bytes),
  and pointer to member comparisons correspond to integer comparisons.
  </para>
  </section>

  <section id="ptr_mem_func">
    <title>Pointers to function members</title>
  <para>
  As with pointers to data members, pointers to function members and
  the operations on them are represented by tokens to allow for a range
  of implementations.  All pointers to function members are represented
  by the same shape:
  <programlisting language="TDF">
~cpp.pmf.type : () -&gt; SHAPE</programlisting>
  This shape will be denoted by <code>pmf</code> in the description
  of the following tokens.  Many of the tokens take an expression which
  has a shape which is a pointer to the alignment of <code>pmf</code>.
  This will be denoted by <code>ppmf</code>.
  </para>
  <para>
  There are two basic methods for constructing a pointer to a function
  member.  The first is to take the address of a non-static member function
  of a class.  There are two cases, depending on whether or not the
  member function is virtual.  The non-virtual case is given by the
  token:
  <programlisting language="TDF">
~cpp.pmf.make : ( EXP PROC, EXP OFFSET, EXP OFFSET ) -&gt; EXP pmf</programlisting>
  where the first argument is the address of the corresponding function,
  the second argument gives any base class offset which is to be added
  when calling this function (to deal with inherited member functions),
  and the third argument is a zero offset.
  </para>
  <para>
  For virtual functions, a pointer to function member of the form above
  is entered in the <link linkend="vtable">virtual function table</link> for
  the corresponding class.  The actual pointer to the virtual function
  member then gives a reference into the virtual function table as follows:
  <programlisting language="TDF">
~cpp.pmf.vmake : ( SIGNED_NAT, EXP OFFSET, EXP, EXP ) -&gt; EXP pmf</programlisting>
  where the first argument gives the index of the function within the
  virtual function table, the second argument gives the offset of the
  <emphasis>vptr</emphasis> field within the class, and the third and fourth arguments
  are zero offsets.
  </para>
  <para>
  The second way of constructing a pointer to a function member is to
  use a null pointer to function member:
  <programlisting language="TDF">
~cpp.pmf.null : () -&gt; EXP pmf
~cpp.pmf.null2 : () -&gt; EXP pmf</programlisting>
  For technical reasons there are two versions of this token, although
  they have the same value.  The first token is used in static initialisers;
  the second token is used in other expressions. </para>
  <para>
  The cast operations on pointers to function members are more complex
  than those on pointers to data members.  The value to be cast is copied
  into a temporary and one of the tokens:
  <programlisting language="TDF">
~cpp.pmf.cast : ( EXP ppmf, EXP OFFSET, EXP, EXP OFFSET ) -&gt; EXP TOP
~cpp.pmf.uncast : ( EXP ppmf, EXP OFFSET, EXP, EXP OFFSET ) -&gt; EXP TOP</programlisting>
  is applied to modify the value of the temporary according to the given
  cast.  The first argument gives the address of the temporary, the
  second gives the base class offset to be added or subtracted, the
  third gives the number to be added or subtracted to convert virtual
  function indexes for the base class into virtual function indexes
  for the derived class, and the fourth gives the offset of the <emphasis>vptr</emphasis>
  field within the class.  Again, the ability to use <code>reinterpret_cast</code>
  to convert between any two pointer to function member types arises
  because of the uniform representation of these types.
  </para>
  <para>
  As with pointers to data members, there are tokens implementing comparisons
  on pointers to function members:
  <programlisting language="TDF">
~cpp.pmf.test : ( EXP ppmf, LABEL, NTEST ) -&gt; EXP TOP
~cpp.pmf.compare : ( EXP ppmf, EXP ppmf, LABEL, NTEST ) -&gt; EXP TOP</programlisting>
  Note however that the arguments are passed by reference.
  </para>
  <para>
  The most important, and most complex, operation is calling a function
  through a pointer to function member.  The first step is to copy the
  pointer to function member into a temporary.  The token:
  <programlisting language="TDF">
~cpp.pmf.virt : ( EXP ppmf, EXP, ALIGNMENT ) -&gt; EXP TOP</programlisting>
  is then applied to the temporary to convert a pointer to a virtual
  function member to a normal pointer to function member by looking
  it up in the corresponding virtual function table.  The first argument
  gives the address of the temporary, the second gives the object to
  which the function is to be applied, and the third gives the alignment
  of the corresponding class.  Now the base class conversion to be applied
  to the object can be determined by applying the token:
  <programlisting language="TDF">
~cpp.pmf.delta : ( ALIGNMENT a, EXP ppmf ) -&gt; EXP OFFSET ( a, a )</programlisting>
  to the temporary to find the offset to be added.  Finally the function
  to be called can be extracted from the temporary using the token:
  <programlisting language="TDF">
~cpp.pmf.func : ( EXP ppmf ) -&gt; EXP PROC</programlisting>
  The function call then procedes as normal.
  </para>
  <para>
  The default implementation is that described in the ARM, where each
  pointer to function member is represented in the form:
  <programlisting language="C++">
struct PTR_MEM_FUNC {
    short delta ;
    short index ;
    union {
	void ( *func ) () ;
	short off ;
    } u ;
} ;</programlisting>
  The <code>delta</code> field gives the base class offset (in bytes)
  to be added before applying the function.  The <code>index</code>
  field is 0 for null pointers, -1 for non-virtual function pointers
  and the index into the virtual function table for virtual function
  pointers (as described below these indexes start from 1).  For non-virtual
  function pointers the function itself is given by the <code>u.func</code>
  field. For virtual function pointers the offset of the <emphasis>vptr</emphasis>
  field within the class is given by the <code>u.off</code> field.
  </para>
  </section>

  <section id="class">
    <title>Class layout</title>
  <para>
  Consider a class with no base classes:
  <programlisting language="C++">
class A {
    // A's members
} ;</programlisting>
  Each object of class <emphasis>A</emphasis> needs its own copy of the non-static
  data members of <emphasis>A</emphasis> and, for polymorphic types, a means of referencing
  the virtual function table and run-time type information for <emphasis>A</emphasis>.
  This is accomplished using a layout of the form:

	<figure>
		<title>Class A</title>

		<graphic fileref="images/class.png"/>
	</figure>

  where the <emphasis>A</emphasis> component consists of the non-static data members
  and
  <emphasis>vptr A</emphasis> is a pointer to the virtual function table for <emphasis>A</emphasis>.
  For non-polymorphic classes the <emphasis>vptr A</emphasis> field is omitted; otherwise
  space for <emphasis>vptr A</emphasis> needs to be allocated within the class and
  the pointer needs to be initialised in each constructor for <emphasis>A</emphasis>.
  The precise layout of the <link linkend="vtable">virtual function table</link>
  and the <link linkend="rtti">run-time type information</link> is given below.
  </para>
  <para>
  Two alternative ways of laying out the non-static data members within
  the class are implemented.  The first, which is default, gives them
  in the order in which they are declared in the class definition.
  The second lays out the <code>public</code>, the <code>protected</code>,
  and the <code>private</code> members in three distinct sections, the
  members within each section being given in the order in which they
  are declared. The latter can be enabled using the <code>-jo</code>
  command-line option.
  </para>
  <para>
  The offset of each member within the class (including <emphasis>vptr A</emphasis>)
  can be calculated in terms of the offset of the previous member.
  The first member has offset zero.  The offset of any other member
  is given by the offset of the previous member plus the size of the
  previous member, rounded up to the alignment of the current member.
  The overall size of the class is given by the offset of the last member
  plus the size of the last member, rounded up using the token:
  <programlisting language="TDF">
~comp_off : ( EXP OFFSET ) -&gt; EXP OFFSET</programlisting>
  which allows for any target dependent padding at the end of the class.
  The shape of the class is then a <code>compound</code> shape with
  this offset.
  </para>
  <para>
  Classes with no members need to be treated slightly differently.
  The shape of such a class is given by the token:
  <programlisting language="TDF">
~cpp.empty.shape : () -&gt; SHAPE</programlisting>
  (recall that an empty class still has a nonzero size).  The token:
  <programlisting language="TDF">
~cpp.empty.offset : () -&gt; EXP OFFSET</programlisting>
  is used to represent the offset required for an empty class when it
  is used as a base class.  This may be a zero offset.
  </para>
  <para>
  Bitfield members provide a slight complication to the picture above.
  The offset of a bitfield is additionally padded using the token:
  <programlisting language="TDF">
~pad : ( EXP OFFSET, SHAPE, SHAPE ) -&gt; EXP OFFSET</programlisting>
  where the two shapes give the type underlying the bitfield and the
  bitfield itself.
  </para>
  <para>
  The layout of unions is similar to that of classes except that all
  members have zero offset, and the size of the union is the maximum
  of the sizes of its members, suitably padded.  Of course unions cannot
  be polymorphic and cannot have base classes.
  </para>
  <para>
  Pointers to incomplete classes are represented by means of the alignment:
  <programlisting language="TDF">
~cpp.empty.align : () -&gt; ALIGNMENT</programlisting>
  This token is also used for the alignment of a complete class if that
  class is never used in the generated TDF in a manner which requires
  it to be complete.  This can lead to savings on the size of the generated
  code by preventing the need to define all the member offset tokens
  in order to find the shape of the class.
  </para>
  </section>

  <section id="derive">
    <title>Derived class layout</title>
  <para>
  The description of the implementation of derived classes will be given
  in terms of the example class hierarchy given by:
  <programlisting language="C++">
class A {
    // A's members
} ;

class B : public A {
    // B's members
} ;

class C : public A {
    // C's members
} ;

class D : public B, public C {
    // D's members
} ;</programlisting>
  or, as a directed acyclic graph:
  </para>

	<figure>
		<title>Class D</title>

		<graphic fileref="images/graph.png"/>
	</figure>


<section>
	<title>Single inheritance</title>
  <para>
  The layout of class <emphasis>A</emphasis> is given by:

	<figure>
		<title>Class A</title>

		<graphic fileref="images/classA.png"/>
	</figure>

  as above.  Class <emphasis>B</emphasis> inherits all the members of class <emphasis>A</emphasis>
  plus those members explicitly declared within class <emphasis>B</emphasis>.  In
  addition, class <emphasis>B</emphasis> inherits all the virtual member functions
  of <emphasis>A</emphasis>, some of which may be overridden in <emphasis>B</emphasis>, extended
  by any additional virtual functions declared in <emphasis>B</emphasis>.  This may
  be represented as follows:

	<figure>
		<title>Class B</title>

		<graphic fileref="images/classB.png"/>
	</figure>

  where <emphasis>A</emphasis> denotes those members inherited from the base class
  and
  <emphasis>B</emphasis> denotes those members added in the derived class.  Note that
  an object of class <emphasis>B</emphasis> contains a sub-object of class <emphasis>A</emphasis>.
  The fact that this sub-object is located at the start of <emphasis>B</emphasis>
  means that the base class conversion from <emphasis>B</emphasis> to <emphasis>A</emphasis> is
  trivial.  Any base class with this property is called a
  <A id="primary">primary base class</A>.
  </para>
  <para>
  Note that in theory two virtual function tables are required, the
  normal virtual function table for <emphasis>B</emphasis>, denoted by <emphasis>vtbl B</emphasis>,
  and a modified virtual function table for <emphasis>A</emphasis>, denoted by <emphasis>vtbl
  B::A</emphasis>, taking into account any overriding virtual functions within
  <emphasis>B</emphasis>, and pointing to <emphasis>B</emphasis>'s run-time type information.  This
  latter means that the dynamic type information for the <emphasis>A</emphasis> sub-object
  relates to
  <emphasis>B</emphasis> rather than <emphasis>A</emphasis>.  However these two tables can usually
  be combined - if the virtual functions added in <emphasis>B</emphasis> are listed
  in the virtual function table after those inherited from <emphasis>A</emphasis>
  and the form of the overriding is <link linkend="override">suitably well
  behaved</link>
  (in the sense defined below) then <emphasis>vptr B::A</emphasis> is an initial segment
  of <emphasis>vptr B</emphasis>.  It is also possible to remove the <emphasis>vptr B</emphasis>
  field and use <emphasis>vptr B::A</emphasis> in its place in this case (it has to
  be this way round to preserve the <emphasis>A</emphasis> sub-object).  Thus the
  items shaded in the diagram can be removed.
  </para>
  <para>
  The class <emphasis>C</emphasis> is similarly given by:

	<figure>
		<title>Class C</title>

		<graphic fileref="images/classC.png"/>
	</figure>

  </para>
</section>

<section>
	<title>Multiple inheritance</title>
  <para>
  Class <emphasis>D</emphasis> is more complex because of the presence of multiple
  inheritance.  <emphasis>D</emphasis> inherits all the members of <emphasis>B</emphasis>, including
  those which <emphasis>B</emphasis> inherits from <emphasis>A</emphasis>, plus all the members
  of
  <emphasis>C</emphasis>, including those which <emphasis>C</emphasis> inherits from <emphasis>A</emphasis>.
  It also inherits all of the virtual member functions from <emphasis>B</emphasis>
  and
  <emphasis>C</emphasis>, some of which may be overridden in <emphasis>D</emphasis>, extended by
  any additional virtual functions declared in <emphasis>D</emphasis>.  This may be
  represented as follows:

	<figure>
		<title>Class D</title>

		<graphic fileref="images/classD.png"/>
	</figure>

  Note that there are two copies of <emphasis>A</emphasis> in <emphasis>D</emphasis> because virtual
  inheritance has not been used.
  </para>
  <para>
  The <emphasis>B</emphasis> base class of <emphasis>D</emphasis> is essentially similar to the
  single inheritance case already discussed; the <emphasis>C</emphasis> base class
  is different however.  Note firstly that the <emphasis>C</emphasis> sub-object of
  <emphasis>D</emphasis> is located at a non-zero offset, <emphasis>delta D::C</emphasis>, from
  the start of the object. This means that the base class conversion
  from <emphasis>D</emphasis> to <emphasis>C</emphasis>
  consists of adding this offset (for pointer conversions things are
  further complicated by the need to allow for null pointers).  Also
  <emphasis>vtbl D::C</emphasis> is not an initial segment of <emphasis>vtbl D</emphasis> because
  this contains the virtual functions inherited from <emphasis>B</emphasis> first,
  followed by those inherited from <emphasis>C</emphasis>, followed by those first
  declared in <emphasis>D</emphasis> (there are <link linkend="override">other reasons</link>
  as well).  Thus <emphasis>vtbl D::C</emphasis> cannot be eliminated.
  </para>
</section>

<section>
	<title>Virtual inheritance</title>
  <para>
  Virtual inheritance introduces a further complication.  Now consider
  the class hierarchy given by:
  <programlisting language="C++">
class A {
    // A's members
} ;

class B : virtual public A {
    // B's members
} ;

class C : virtual public A {
    // C's members
} ;

class D : public B, public C {
    // D's members
} ;</programlisting>
  or, as a <A id="diamond">directed acyclic graph</A>:

	<figure>
		<title>Class D</title>

		<graphic fileref="images/diamond.png"/>
	</figure>

  As before <emphasis>A</emphasis> is given by:

	<figure>
		<title>Class A</title>

		<graphic fileref="images/classA.png"/>
	</figure>

  but now <emphasis>B</emphasis> is given by:

	<figure>
		<title>Class B</title>

		<graphic fileref="images/virtualB.png"/>
	</figure>

  Rather than having the sub-object of class <emphasis>A</emphasis> directly as part
  of
  <emphasis>B</emphasis>, the class now contains a pointer, <emphasis>ptr A</emphasis>, to this
  sub-object.  The virtual sub-objects are always located at the end
  of a class layout; their offset may therefore vary for different objects,
  however the offset for <emphasis>ptr A</emphasis> is always fixed.  The <emphasis>ptr A</emphasis>
  field is initialised in each constructor for <emphasis>B</emphasis>.  In order to
  perform the base class conversion from <emphasis>B</emphasis> to <emphasis>A</emphasis>, the contents
  of <emphasis>ptr A</emphasis> are taken (again provision needs to be made for null
  pointers in pointer conversions).  In cases when the dynamic type
  of the <emphasis>B</emphasis> object can be determined statically it is possible
  to access the <emphasis>A</emphasis> sub-object directly by adding a suitable offset.
  Because this conversion is non-trivial (see <link linkend="override">below</link>)
  the virtual function table <emphasis>vtbl B::A</emphasis> is not an initial segment
  of
  <emphasis>vtbl B</emphasis> and cannot be eliminated.
  </para>
  <para>
  The class <emphasis>C</emphasis> is similarly given by:

	<figure>
		<title>Class C</title>

		<graphic fileref="images/virtualC.png"/>
	</figure>

  Now the class <emphasis>D</emphasis> is given by:

	<figure>
		<title>Class D</title>

		<graphic fileref="images/virtualD.png"/>
	</figure>

  Note that there is a single <emphasis>A</emphasis> sub-object of <emphasis>D</emphasis> referenced
  by the <emphasis>ptr A</emphasis> fields in both the <emphasis>B</emphasis> and <emphasis>C</emphasis> sub-objects.
  The elimination of <emphasis>vtbl D::B</emphasis> is as above.
  </para>
</section>
  </section>

  <section id="constr">
    <title>Constructors and destructors</title>
  <para>
  The implementation of constructors and destructors, whether explicitly
  or implicitly defined, is slightly more complex than that of other
  member functions.  For example, the constructors need to set up the
  internal <emphasis>vptr</emphasis> and <emphasis>ptr</emphasis> fields mentioned above.
  </para>
  <para>
  The order of initialisation in a constructor is as follows:
  <itemizedlist>
  <listitem>The internal <emphasis>ptr</emphasis> fields giving the locations of the virtual
  base classes are initialised.
  </listitem>
  <listitem>The constructors for the virtual base classes are called.
  </listitem>
  <listitem>The constructors for the non-virtual direct base classes are called.
  </listitem>
  <listitem>The internal <emphasis>vptr</emphasis> fields giving the locations of the virtual
  function tables are initialised.
  </listitem>
  <listitem>The constructors for the members of the class are called.
  </listitem>
  <listitem>The main constructor body is executed.
  </listitem>
  </itemizedlist>
  To ensure that each virtual base is only initialised once, if a class
  has a virtual base class then all its constructors have an implicit
  extra parameter of type <code>int</code>.  The first two steps above
  are then only applied if this flag is nonzero.  In normal applications
  of the constructor this argument will be 1, however in base class
  initialisations such as those in the third and fourth steps above,
  it will be 0.
  </para>
  <para>
  Note that similar steps to protect virtual base classes are not taken
  in an implicitly declared <code>operator=</code> function.  The order
  of assignment in this case is as follows:
  <itemizedlist>
  <listitem>The assignment operators for the direct base classes (both virtual
  and non-virtual) are called.
  </listitem>
  <listitem>The assignment operators for the members of the class are called.
  </listitem>
  <listitem>A reference to the object assigned to (i.e. <code>*this</code>)
  is     returned.
  </listitem>
  </itemizedlist>
  </para>
  <para>
  The order of destruction in a destructor is essentially the reverse
  of the order of construction:
  <itemizedlist>
  <listitem>The main destructor body is executed.
  </listitem>
  <listitem>The destructor for the members of the class are called.
  </listitem>
  <listitem>The internal <emphasis>vptr</emphasis> fields giving the locations of the virtual
  function tables are re-initialised.
  </listitem>
  <listitem>The destructors for the non-virtual direct base classes are called.
  </listitem>
  <listitem>The destructors for the virtual base classes are called.
  </listitem>
  <listitem>If necessary the space occupied by the object is deallocated.
  </listitem>
  </itemizedlist>
  All destructors have an extra parameter of type <code>int</code>.
  The virtual base classes are only destroyed if this flag is nonzero
  when and-ed with 2.  The space occupied by the object is only deallocated
  if this flag is nonzero when and-ed with 1.  This deallocation is
  equivalent to inserting:
  <programlisting language="C++">
delete this ;</programlisting>
  in the destructor.  The <code>operator delete</code> function is called
  via the destructor in this way in order to implement the pseudo-virtual
  nature of these deallocation functions.  Thus for normal destructor
  calls the extra argument is 2, for base class destructor calls it
  is 0, and for calls arising from a <code>delete</code> expression
  it is 3.
  </para>
  <para>
  The point at which the virtual function tables are initialised in
  the constructor, and the fact that they are re-initialised in the
  destructor, is to ensure that virtual functions called from base class
  initialisers are handled correctly (see ISO C++ 12.7).
  </para>
  <para>
  A further complication arises from the need to destroy
  <A id="partial">partially constructed objects</A> if an exception
  is thrown in a constructor.  A count is maintained of the number of
  base classes and members constructed within a constructor.  If an
  exception is thrown then it is caught in the constructor, the constructed
  base classes and members are destroyed, and the exception is re-thrown.
  The count variable is used to determine which bases and members need
  to be destroyed.
  </para>
	<warning>
  <para>These partial destructors
  currently do not interact correctly with any exception specification
  on the constructor.  Exceptions thrown within destructors are not
  correctly handled either.</para>
	</warning>
  </section>

  <section id="vtable">
    <title>Virtual function tables</title>
  <para>
  The virtual functions in a polymorphic class are given in its virtual
  function table in the following order: firstly those virtual functions
  inherited from its direct base classes (which may be overridden in
  the derived class) followed by those first declared in the derived
  class in the order in which they are declared.  Note that this can
  result in virtual functions inherited from virtual base classes appearing
  more than once.  The virtual functions are numbered from 1 (this is
  slightly more convenient than numbering from 0 in the default implementation).
  </para>
  <para>
  The virtual function table for this class has shape:
  <programlisting language="TDF">
~cpp.vtab.type : ( NAT ) -&gt; SHAPE</programlisting>
  the argument being <emphasis>n + 1</emphasis> where <emphasis>n</emphasis> is the number of virtual
  functions in the class (there is also a token:
  <programlisting language="TDF">
~cpp.vtab.diag : () -&gt; SHAPE</programlisting>
  which is used in the diagnostic output for a generic virtual function
  table).  The table is created using the token:
  <programlisting language="TDF">
~cpp.vtab.make : ( EXP pti, EXP OFFSET, NAT, EXP NOF ) -&gt; EXP vt</programlisting>
  where the first expression gives the address of the <link linkend="rtti">run-time
  type information structure</link> for the class, the second expression
  gives the offset of the <emphasis>vptr</emphasis> field within the class (i.e. <emphasis>voff</emphasis>),
  the integer constant is <emphasis>n + 1</emphasis>, and the final expression is
  a
  <code>make_nof</code> construct giving information on each of the
  <emphasis>n</emphasis>
  virtual functions.
  </para>
  <para>
  The information given on each virtual function in this table has the
  form of a <link linkend="ptr_mem_func">pointer to function member</link> formed
  using the token:
  <programlisting language="TDF">
~cpp.pmf.make : ( EXP PROC, EXP OFFSET, EXP OFFSET ) -&gt; EXP pmf</programlisting>
  as above, except that the third argument gives the offset of the base
  class in virtual function tables such as <emphasis>vtbl B::A</emphasis>.  For pure
  virtual functions the function pointer in this token is given by:
  <programlisting language="TDF">
~cpp.vtab.pure : () -&gt; EXP PROC</programlisting>
  In the default implementation this gives a function
  <code>__TCPPLUS_pure</code> which just calls <code>abort</code>.
  </para>
  <para>
  To avoid duplicate copies of virtual function tables and run-time
  type information structures being created, the ARM algorithm is used.
  The virtual function table and run-time type information structure
  for a class are defined in the module containing the definition of
  the first non-inline, non-pure virtual function declared in that class.
  If such a function does not exist then duplicate copies are created
  in every module which requires them.  In the former case the virtual
  function table will have an <link linkend="other">external tag name</link>;
  in the latter case it will be an internal tag.  This scheme can be
  overridden using the <code>-jv</code> command-line option, which causes
  local virtual function tables to be output for all classes.
  </para>
  <para>
  Note that the discussion above applies to both simple virtual function
  tables, such as <emphasis>vtbl B</emphasis> above, and to those arising from base
  classes, such as <emphasis>vtbl B::A</emphasis>.  <A id="override">We are now
  in a position to precisely determine when <emphasis>vtbl B::A</emphasis> is an initial
  segment of <emphasis>vtbl B</emphasis> and hence can be eliminated</A>.  Firstly,
  <emphasis>A</emphasis> must be the first direct base class of <emphasis>B</emphasis> and cannot
  be virtual.  This is to ensure both that there are no virtual functions
  in <emphasis>vtbl B</emphasis> before those inherited from <emphasis>A</emphasis>, and that the
  corresponding base class conversion is trivial so that the pointers
  to function members of <emphasis>B</emphasis> comprising the virtual function table
  can be equally regarded as pointers to function members of <emphasis>A</emphasis>.
  The second requirement is that if a virtual function for <emphasis>A</emphasis>,
  <emphasis>f</emphasis>, is overridden in <emphasis>B</emphasis> then the return type for <emphasis>B::f</emphasis>
  cannot differ from the return type for <emphasis>A::f</emphasis> by a non-trivial
  conversion (recall that ISO C++ allows the return types to differ
  by a base class conversion).  In the non-trivial conversion case the
  function entered in <emphasis>vtbl B::A</emphasis> needs to be, not <emphasis>B::f</emphasis>
  as in <emphasis>vtbl B</emphasis>, but a stub function which calls <emphasis>B::f</emphasis> and
  converts its return value to the return type of <emphasis>A::f</emphasis>.
  </para>

<section>
	<title>Calling virtual functions</title>
  <para>
  The virtual function call mechanism is implemented using the token:
  <programlisting language="TDF">
~cpp.vtab.func : ( EXP ppvt, SIGNED_NAT ) -&gt; EXP ppmf</programlisting>
  which has as its arguments a reference to the <emphasis>vptr</emphasis> field of
  the object the function is to be called for, and the number of the
  virtual function to be called.  It returns a reference to the corresponding
  pointer to function member within the object's virtual function table.
  The function is then called by extracting the base class offset to
  be added, and the function to be called, from this reference using
  the tokens:
  <programlisting language="TDF">
~cpp.pmf.delta : ( ALIGNMENT a, EXP ppmf ) -&gt; EXP OFFSET ( a, a )
~cpp.pmf.func : ( EXP ppmf ) -&gt; EXP PROC</programlisting>
  described as part of the <link linkend="ptr_mem_func">pointer to function
  member call mechanism</link> above.
  </para>
</section>
  </section>

  <section id="rtti">
    <title>Run-time type information</title>
  <para>
  Each C++ type can be associated with a run-time type information structure
  giving information about that type.  These type information structures
  have shape given by the token:
  <programlisting language="TDF">
~cpp.typeid.type : () -&gt; SHAPE</programlisting>
  which corresponds to the representation for the standard type
  <code>std::type_info</code> declared in the header
  <code>&lt;typeinfo&gt;</code>.  Each type information structure consists
  of a tag number, giving information on the kind of type represented,
  a string literal, giving the name of the type, and a pointer to a
  list of base type information structures.  These are combined to give
  a type information structure using the token:
  <programlisting language="TDF">
~cpp.typeid.make : ( SIGNED_NAT, EXP, EXP ) -&gt; EXP ti</programlisting>
  Each base type information structure has shape given by the token:
  <programlisting language="TDF">
~cpp.baseid.type : () -&gt; SHAPE</programlisting>
  It consists of a pointer to a type information structure, an expression
  used to describe the offset of a base class, a pointer to the next
  base type information structure in the list, and two integers giving
  information on type qualifiers etc.  These are combined to give a
  base type information structure using the token:
  <programlisting language="TDF">
~cpp.baseid.make : ( EXP, EXP, EXP, SIGNED_NAT, SIGNED_NAT ) -&gt; EXP bi</programlisting>
  </para>
  <para>
  The following table gives the various tag numbers used in type information
  structures plus a list of the base type information structures associated
  with each type.  Macros giving these tag numbers are provided in the
  default implementation in a header, <code>interface.h</code>, which
  is shared by the C++ producer.
  </para>
  <para>

  <table>
  <tr><th>Type</th>
  <th>Form</th>
  <th>Tag</th>
  <th>Base information</th>
  </tr>
  <tr><td>integer</td>
  <td>-</td>
  <td>0</td>
  <td>-</td>
  </tr>
  <tr><td>floating point</td>
  <td>-</td>
  <td>1</td>
  <td>-</td>
  </tr>
  <tr><td>void</td>
  <td>-</td>
  <td>2</td>
  <td>-</td>
  </tr>
  <tr><td>class or struct</td>
  <td>class T</td>
  <td>3</td>
  <td>[base,access,virtual], ....</td>
  </tr>
  <tr><td>union</td>
  <td>union T</td>
  <td>4</td>
  <td>-</td>
  </tr>
  <tr><td>enumeration</td>
  <td>enum T</td>
  <td>5</td>
  <td>-</td>
  </tr>
  <tr><td>pointer</td>
  <td>cv T *</td>
  <td>6</td>
  <td>[T,cv,0]</td>
  </tr>
  <tr><td>reference</td>
  <td>cv T &amp;</td>
  <td>7</td>
  <td>[T,cv,0]</td>
  </tr>
  <tr><td>pointer to member</td>
  <td>cv T S::*</td>
  <td>8</td>
  <td>[S,0,0], [T,cv,0]</td>
  </tr>
  <tr><td>array</td>
  <td>cv T [n]</td>
  <td>9</td>
  <td>[T,cv,n]</td>
  </tr>
  <tr><td>bitfield</td>
  <td>cv T : n</td>
  <td>10</td>
  <td>[T,cv,n]</td>
  </tr>
  <tr><td>C++ function</td>
  <td>cv T ( S1, ...., Sn )</td>
  <td>11</td>
  <td>[T,cv,0], [S1,0,0], ...., [Sn,0,0]</td>
  </tr>
  <tr><td>C function</td>
  <td>cv T ( S1, ...., Sn )</td>
  <td>12</td>
  <td>[T,cv,0], [S1,0,0], ...., [Sn,0,0]</td>
  </tr>
  </table>

  </para>
  <para>
  In the form column <code>cv T</code> is used to denote not only the
  normal cv-qualifiers but, when <code>T</code> is a function type,
  the member function cv-qualifiers.  Arrays with an unspecified bound
  are treated as if their bound was zero.  Functions with ellipsis are
  treated as if they had an extra parameter of a dummy type named
  <code>...</code> (see below).  Note the distinction between C++ and
  C function types.
  </para>
  <para>
  Each base type information structure is described as a triple consisting
  of a type and two integers.  One of these integers may be used to
  encode a type qualifier, <code>cv</code>, as follows:
  </para>
  <para>

  <table>
  <tr><th>Qualifier</th>   <th>Encoding</th>
  </tr>
  <tr><td>none</td>  <td>0</td>
  </tr>
  <tr><td>const</td>  <td>1</td>
  </tr>
  <tr><td>volatile</td> <td>2</td>
  </tr>
  <tr><td>const volatile</td><td>3</td>
  </tr>
  </table>

  </para>
  <para>
  The base type information for a class consists of information on each
  of its direct base classes.  The includes the offset of this base
  within the class (for a virtual base class this is the offset of the
  corresponding
  <emphasis>ptr</emphasis> field), whether the base is virtual (1) or not (0), and
  the base class access, encoded as follows:
  </para>
  <para>

  <table>
  <tr><th>Access</th>   <th>Encoding</th>
  </tr>
  <tr><td>public</td> <td>0</td>
  </tr>
  <tr><td>protected</td> <td>1</td>
  </tr>
  <tr><td>private</td> <td>2</td>
  </tr>
  </table>

  </para>
  <para>
  For example, the run-time type information structures for the classes
  declared in the <link linkend="diamond">diamond lattice</link> above can be
  represented as follows:

	<figure>
		<title>Type ID D</title>

		<graphic fileref="images/rttiD.png"/>
	</figure>

  </para>

<section>
	<title>Defining run-time type information structures</title>
  <para>
  For built-in types, the run-time type information structure may be
  referenced by the token:
  <programlisting language="TDF">
~cpp.typeid.basic : ( SIGNED_NAT ) -&gt; EXP pti</programlisting>
  where the argument gives the encoding of the type as given in the
  following table:
  </para>

  <table>
  <tr><th>Type</th>   <th>Encoding</th>
  <th>Type</th>   <th>Encoding</th>
  </tr>
  <tr><td>char</td>  <td>0</td>
  <td>unsigned long</td> <td>11</td>
  </tr>
  <tr><td>(error)</td> <td>1</td>
  <td>float</td>  <td>12</td>
  </tr>
  <tr><td>void</td>  <td>2</td>
  <td>double</td> <td>13</td>
  </tr>
  <tr><td>(bottom)</td> <td>3</td>
  <td>long double</td> <td>14</td>
  </tr>
  <tr><td>signed char</td> <td>4</td>
  <td>wchar_t</td> <td>16</td>
  </tr>
  <tr><td>signed short</td> <td>5</td>
  <td>bool</td>  <td>17</td>
  </tr>
  <tr><td>signed int</td> <td>6</td>
  <td>(ptrdiff_t)</td> <td>18</td>
  </tr>
  <tr><td>signed long</td> <td>7</td>
  <td>(size_t)</td> <td>19</td>
  </tr>
  <tr><td>unsigned char</td> <td>8</td>
  <td>(...)</td>  <td>20</td>
  </tr>
  <tr><td>unsigned short</td><td>9</td>
  <td>signed long long</td>
  <td>23</td>
  </tr>
  <tr><td>unsigned int</td> <td>10</td>
  <td>unsigned long long</td>
  <td>27</td>
  </tr>
  </table>

  <para>
  Note that the encoding for the basic integral types is the same as
  that
  <link linkend="arith">given above</link>.  The other types are assigned to
  unused values.  Note that the encodings for <code>ptrdiff_t</code>
  and
  <code>size_t</code> are not used, instead that for their implementation
  is used (using the standard tokens <code>ptrdiff_t</code> and
  <code>size_t</code>).  The encodings for <code>bool</code> and
  <code>wchar_t</code> are used because they are conceptually distinct
  types even though they are implemented as one of the basic integral
  types.  The type labelled <code>...</code> is the dummy used in the
  representation of ellipsis functions.  The default implementation
  uses an array of type information structures, <code>__TCPPLUS_typeid</code>,
  to implement <code>~cpp.typeid.basic</code>.
  </para>
  <para>
  The run-time type information structures for classes are defined in
  the same place as their <link linkend="vtable">virtual function tables</link>.
  Other run-time type information structures are defined in whatever
  modules require them.  In the former case the type information structure
  will have an <link linkend="other">external tag name</link>; in the latter
  case it will be an internal tag.
  </para>
</section>

<section>
	<title>Accessing run-time type information</title>
  <para>
  The primary means of accessing the run-time type information for an
  object is using the <code>typeid</code> construct.  In cases where
  the operand type can be determined statically, the address of the
  corresponding type information structure is returned.  In other cases
  the token:
  <programlisting language="TDF">
~cpp.typeid.ref : ( EXP ppvt ) -&gt; EXP pti</programlisting>
  is used, where the argument gives a reference to the <emphasis>vptr</emphasis> field
  of the object being checked.  From this information it is trivial
  to trace the corresponding type information.
  </para>
  <para>
  Another means of querying the run-time type information for an object
  is using the <code>dynamic_cast</code> construct.  When the result
  cannot be determined statically, this is implemented using the token:
  <programlisting language="TDF">
~cpp.dynam.cast : ( EXP ppvt, EXP pti ) -&gt; EXP pv</programlisting>
  where the first expression gives a reference to the <emphasis>vptr</emphasis> field
  of the object being cast and the second gives the run-time type information
  for the type being cast to.  In the default implementation this token
  is implemented by the procedure <code>__TCPPLUS_dynamic_cast</code>.
  The key point to note is that the virtual function table contains
  the offset, <emphasis>voff</emphasis>, of the <emphasis>vptr</emphasis> field from the start of
  the most complete object.  Thus it is possible to find the address
  of the most complete object.  The run-time type information contains
  enough information to determine whether this object has a sub-object
  of the type being cast to, and if so, how to find the address of this
  sub-object.  The result is returned as a <code>void *</code>, with
  the null pointer indicating that the conversion is not possible.
  </para>
  </section>
  </section>

  <section id="dynamic-initialisation">
    <title>Dynamic initialisation</title>
  <para>
  The dynamic initialisation of variables with static storage duration
  in C++ is implemented by means of the TDF <code>initial_value</code>
  construct.  However in order for the producer to maintain control
  over the order of initialisation, rather than each variable being
  initialised separately using <code>initial_value</code>, a single
  expression is created which initialises all the variables in a module,
  and this initialiser expression is used to initialise a single dummy
  variable using <code>initial_value</code>.  Note that, while this
  enables the variables within a single module to be initialised in
  the order in which they are defined, the order of initialisation between
  different modules is unspecified.
  </para>
  <para>
  The implementation needs to keep a list of those variables with static
  storage duration which have been initialised so that it can call the
  destructors for these objects at the end of the program. This is done
  by declaring a variable of shape:
  <programlisting language="TDF">
~cpp.destr.type : () -&gt; SHAPE</programlisting>
  for each such object with a non-trivial destructor.  Each element
  of an array is considered a distinct object.  Immediately after the
  variable has been initialised the token:
  <programlisting language="TDF">
~cpp.destr.global : ( EXP pd, EXP POINTER c, EXP PROC ) -&gt; EXP TOP</programlisting>
  is called to add the variable to the list of objects to be destroyed.
  The first argument is the address of the dummy variable just declared,
  the second is the address of the object to be destroyed, and the third
  is the destructor to be used.  In this way a list giving the objects
  to be destroyed, and the order in which to destroy them, is built
  up.  Note that partially constructed objects are destroyed within
  their constructors (see <link linkend="partial">above</link>) so that only
  completely constructed objects need to be considered.
  </para>
  <para>
  The implementation also needs to ensure that it calls the destructors
  in this list at the end of the program, including calls of
  <code>exit</code>.  This is done by calling the token:
  <programlisting language="TDF">
~cpp.destr.init : () -&gt; EXP TOP</programlisting>
  at the start of each <code>initial_value</code> construct.  In the
  default implementation this uses <code>atexit</code> to register a
  function, <code>__TCPPLUS_term</code>, which calls the destructors.
  To aid alternative implementations the token:
  <programlisting language="TDF">
~cpp.start : () -&gt; EXP TOP</programlisting>
  is called at the start of the <code>main</code> function, however
  this has no effect in the default implementation.
  </para>
  </section>

  <section id="except">
    <title>Exception handling</title>
  <para>
  Conceptually, exception handling can be described in terms of the
  following diagram:

	<figure>
		<title>Try Stack</title>

		<graphic fileref="images/try.png"/>
	</figure>

  At any point in the execution of the program there is a stack of currently
  active <code>try</code> blocks and currently active local variables.
  A
  <code>try</code> block is pushed onto the stack as it is entered and
  popped from the stack when it is left (whether directly or via a jump).
  A local variable with a non-trivial destructor is pushed onto the
  stack just after its constructor has been called at the start of its
  scope, and popped from the stack just before its destructor is called
  at the end of its scope (including before jumps out of its scope).
  Each element of an array is considered a separate object.  Each <code>try</code>
  block has an associated list of handlers.  Each local variable has
  an associated destructor.
  </para>
  <para>
  Provided no exception is thrown this stack grows and shrinks in a
  well-behaved manner as execution proceeds.  When an exception is thrown
  an exception manager is invoked to find a matching exception handler.
  The exception manager proceeds to execute a loop to unwind the stack
  as follows.  If the stack is empty then the exception cannot be caught
  and
  <code>std::terminate</code> is called.  Otherwise the top element
  is popped from the stack.  If this is a local variable then the associated
  destructor is called for the variable.  If the top element is a
  <code>try</code> block then the current exception is compared in turn
  to each of the associated handlers.  If a match is found then execution
  jumps to the handler body, otherwise the exception manager continues
  to the next element of the stack.
  </para>
  <para>
  Note that this description is purely conceptual.  There is no need
  for exception handling to be implemented by a stack in this way (although
  the default implementation uses a similar technique).  It does however
  serve to illustrate the various stages which must exist in any implementation.
  </para>

<section>
	<title>Try blocks</title>
  <para>
  At the start of a <code>try</code> block a variable of shape:
  <programlisting language="TDF">
~cpp.try.type : () -&gt; SHAPE</programlisting>
  is declared corresponding to the stack element for this block.  This
  is then initialised using the token:
  <programlisting language="TDF">
~cpp.try.begin : ( EXP ptb, EXP POINTER fa, EXP POINTER ca ) -&gt; EXP TOP</programlisting>
  </para>
  where the first argument is a pointer to this variable, the second
  argument is the TDF <code>current_env</code> construct, and the third
  argument is the result of the TDF <code>make_local_lv</code> construct
  on the label which is used to mark the first handler associated with
  the block.  Note that the last two arguments enable a TDF
  <code>long_jump</code> construct to be applied to transfer control
  to the first handler.
  <para>
  When control exits from a <code>try</code> block, whether by reaching
  the end of the block or jumping out of it, the block is removed from
  the stack using the token:
  <programlisting language="TDF">
~cpp.try.end : ( EXP ptb ) -&gt; EXP TOP</programlisting>
  where the argument is a pointer to the <code>try</code> block variable.
  </para>
</section>

<section>
  <title>Local variables</title>
  <para>
  The technique used to add a local variable with a non-trivial destructor
  to the stack is similar to that used in the dynamic initialisation
  of global variables.  A local variable of shape <code>~cpp.destr.type</code>
  is declared at the start of the variable scope.  This is initialised
  just after the constructor for the variable is called using the token:
  <programlisting language="TDF">
~cpp.destr.local : ( EXP pd, EXP POINTER c, EXP PROC ) -&gt; EXP TOP</programlisting>
  where the first argument is a pointer to the variable being initialised,
  the  second is a pointer to the local variable to be destroyed, and
  the third is the destructor to be called.  At the end of the variable
  scope, just before its destructor is called, the token:
  <programlisting language="TDF">
~cpp.destr.end : ( EXP pd ) -&gt; EXP TOP</programlisting>
  where the argument is a pointer to destructor variable, is called
  to remove the local variable destructor from the stack.  Note that
  partially constructed objects are destroyed within their constructors
  (see
  <link linkend="partial">above</link>) so that only completely constructed
  objects need to be considered.
  </para>
  <para>
  In cases where the local variable may be conditionally initialised
  (for example a temporary variable in the second operand of a <code>||</code>
  operation) the local variable of shape <code>~cpp.destr.type</code>
  is initialised to the value given by the token:
  <programlisting language="TDF">
~cpp.destr.null : () -&gt; EXP d</programlisting>
  (normally it is  left uninitialised).  Before the destructor for this
  variable is called the value of the token:
  <programlisting language="TDF">
~cpp.destr.ptr : ( EXP pd ) -&gt; EXP POINTER c</programlisting>
  is tested.  If <code>~cpp.destr.local</code> has been called for this
  variable then this token returns a pointer to the variable, otherwise
  it returns a null pointer.  The token <code>~cpp.destr.end</code>
  and the destructor are only called if this token indicates that the
  variable has been initialised.
  </para>
</section>

<section>
  <title>Throwing an exception</title>
  <para>
  When a <code>throw</code> expression with an argument is encountered
  a number of steps performed.  Firstly, space is allocated to hold
  the exception value using the token:
  <programlisting language="TDF">
~cpp.except.alloc : ( EXP VARIETY size_t ) -&gt; EXP pv</programlisting>
  the argument of which gives the size of the value.  The space allocated
  is returned as an expression of type <code>void *</code>.  Secondly,
  the exception value is copied into the space allocated, using a copy
  constructor if appropriate.  Finally the exception is raised using
  the token:
  <programlisting language="TDF">
~cpp.except.throw : ( EXP pv, EXP pti, EXP PROC ) -&gt; EXP BOTTOM</programlisting>
  The first argument gives the pointer to the exception value, returned
  by
  <code>~cpp.except.alloc</code>, the second argument gives a pointer
  to the run-time type information for the exception type, and the third
  argument gives the destructor to be called to destroy the exception
  value (if any). This token sets the current exception to the given
  values and invokes the exception manager as above.
  </para>
  <para>
  A <code>throw</code> expression without an argument results in a call
  to the token:
  <programlisting language="TDF">
~cpp.except.rethrow : () -&gt; EXP BOTTOM</programlisting>
  which re-invokes the exception manager with the current exception.
  If there is no current exception then the implementation should call
  <code>std::terminate</code>.
  </para>
</section>

<section>
  <title>Handling an exception</title>
  <para>
  The exception manager proceeds to find an exception in the manner
  described above, unwinding the stack and calling destructors for local
  variables.  When a <code>try</code> block is popped from the stack
  a TDF <code>long_jump</code> is applied to transfer control to its
  list of handlers.  For each handler in turn it is checked whether
  the handler can catch the current exception.  For <code>...</code>
  handlers this is always true; for other handlers it is checked using
  the token:
  <programlisting language="TDF">
~cpp.except.catch : ( EXP pti ) -&gt; EXP VARIETY int</programlisting>
  where the argument is a pointer to the run-time type information for
  the handler type.  This token gives 1 if the exception is caught by
  this handler, and 0 otherwise.  If the exception is not caught by
  the handler then the next handler is checked, until there are no more
  handlers associated with the <code>try</code> block.  In this case
  control is passed back to the exception manager by re-throwing the
  current exception using <code>~cpp.except.rethrow</code>.
  </para>
  <para>
  If an exception is caught by a handler then a number of steps are
  performed. Firstly, if appropriate, the handler variable is initialised
  by copying the current exception value.  A pointer to the current
  exception value can be obtained using the token:
  <programlisting language="TDF">
~cpp.except.value : () -&gt; EXP pv</programlisting>
  Once this initialisation is complete the token:
  <programlisting language="TDF">
~cpp.except.caught : () -&gt; EXP TOP</programlisting>
  is called to indicate that the exception has been caught.  The handler
  body is then executed.  When control exits from the handler, whether
  by reaching the end of the handler or by jumping out of it, the token:
  <programlisting language="TDF">
~cpp.except.end : () -&gt; EXP TOP</programlisting>
  is called to indicate that the exception has been completed.  Note
  that the implementation should call the destructor for the current
  exception and free the space allocated by <code>~cpp.except.alloc</code>
  at this point. Execution then continues with the statement following
  the handler.
  </para>
  <para>
  To conclude, the TDF generated for a <code>try</code> block and its
  associated list of handlers has the form:
  <programlisting language="TDF">
variable (
    long_jump_access,
    stack_tag,
    make_value ( ~cpp.try.type ),
    conditional (
	handler_label,
	sequence (
	    ~cpp.try.begin (
		obtain_tag ( stack_tag ),
		current_env,
		make_local_lv ( handler_label ) ),
		<emphasis>try-block-body</emphasis>,
		~cpp.try.end ),
	    conditional (
		catch_label_1,
		sequence (
		    integer_test (
			not_equal,
			catch_label_1,
			~cpp.except.catch (
			    <emphasis>handler-1-typeid</emphasis> ) )
		    variable (
			handler_tag_1,
			<emphasis>handler-1-init</emphasis> (
			    ~cpp.except.value ),
			sequence (
			    ~cpp.except.caught,
			    <emphasis>handler-1-body</emphasis> ) )
		    ~cpp.except.end )
		conditional (
		    catch_label_2,
		    <emphasis>further-handlers</emphasis>,
		    ~cpp.except.rethrow ) ) ) )</programlisting>
  </para>
  <para>
  Note that for a local variable to maintain its previous value when
  an  exception is caught in this way it is necessary to declare it
  using the TDF <code>long_jump_access</code> construct.  Any local
  variable which contains a <code>try</code> block in its scope is declared
  in this way.
  </para>
  <para>
  To aid implementations in the writing of exception managers the following
  standard tokens are provided:
  <programlisting language="TDF">
~cpp.ptr.code : () -&gt; SHAPE POINTER ca
~cpp.ptr.frame : () -&gt; SHAPE POINTER fa
~cpp.except.jump : ( EXP POINTER fa, EXP POINTER ca ) -&gt; EXP BOTTOM</programlisting>
  These give the shape of the TDF <code>make_local_lv</code> construct,
  the shape of the TDF <code>current_env</code> construct, and direct
  access to the TDF <code>long_jump</code> access.  The exception manager
  in the default implementation is a function called <code>__TCPPLUS_throw</code>.
  </para>
</section>

<section>
  <title>Exception specifications</title>
  <para>
  If a function is declared with an exception specification then extra
  code needs to be generated in the function definition to catch any
  unexpected exceptions thrown by the function and to call <code>std::unexpected
  </code>. Since this is a potentially high overhead for small functions,
  this extra code is not generated if it can be proved that such unexpected
  exceptions can never be thrown (the analysis is essentially the same
  as that in the
  <A HREF="pragma.html#exception">exception analysis</A> check).
  </para>
  <para>
  The implementation of exception specification is to enclose the entire
  function definition in a <code>try</code> block.  The handler for
  this block uses <code>~cpp.except.catch</code> to check whether the
  current exception can be caught by any of the types listed in the
  exception specification.  If so the current exception is re-thrown.
  If none of these types catch the current exception then the token:
  <programlisting language="TDF">
~cpp.except.bad : ( SIGNED_NAT ) -&gt; EXP TOP</programlisting>
  is called.  The argument is 1 if the exception specification includes
  the special type <code>std::bad_exception</code>, and 0 otherwise.
  The implementation should call <code>std::unexpected</code>, but how
  any exceptions thrown during this call are to be handled depends on
  the value of the argument.
  </para>
  </section>
  </section>

  <section id="mangle">
    <title>Mangled identifier names</title>
  <para>
  In a similar fashion to other C++ compilers, the C++ producer needs
  a method of mapping C++ identifiers to a form suitable for further
  processing, namely TDF tag names.  This mangled name contains an encoding
  of the identifier name, its parent namespace or class and its type.
  Identifiers with C linkage are not mangled.  The producer contains
  a built-in <A HREF="man.html#unmangle">name unmangler</A>
  which performs the reverse operation of transforming the mangled form
  of an identifier name back to the underlying identifier.  This can
  be useful when analysing system linker errors.
  </para>
  <para>
  Note that the type of an identifier forms part of its mangled name
  not only for functions, but also for variables.  Many other compilers
  do not mangle variable names, however the ISO C++ rules on namespaces
  and variables with C linkage make it necessary (this can be suppressed
  using the <code>-j-n</code> command-line option).  Declaring the language
  linkage of a variable inconsistently can therefore lead to linking
  errors with the C++ producer which are not detected by other compilers.
  A common example is:
  <programlisting language="C++">
extern int errno ;</programlisting>
  which, leaving aside whether <code>errno</code> is actually an external
  variable, should be:
  <programlisting>
extern &quot;C&quot; int errno ;</programlisting>
  </para>
  <para>
  As described above, the mangled form of an identifier has three components;
  the identifier name, the identifier namespace and the identifier type.
  Two underscores (<code>__</code>) are used to separate the name component
  from the namespace and type components.  The mangling scheme used
  is based on that described in the ARM.  The description below is not
  complete; the mangling and unmangling routines themselves should be
  consulted for a complete description.
  </para>

<section>
	<title>Mangling identifier names</title>
  <para>
  Simple identifier names are mapped to themselves.  Unicode characters
  of the forms <code>\u</code><emphasis>xxxx</emphasis> and <code>\U</code><emphasis>xxxxxxxx</emphasis>
  are mapped to <code>__k</code><emphasis>xxxx</emphasis> and <code>__K</code><emphasis>xxxxxxxx</emphasis>
  respectively, where the hex digits are output in their canonical lower-case
  form.  Constructors are mapped to <code>__ct</code> and destructors
  to <code>__dt</code>.  Conversions functions are mapped to
  <code>__op</code><emphasis>type</emphasis> where <emphasis>type</emphasis> is the mangled form
  of the conversion type.  Overloaded operator functions,
  <code>operator@</code>, are mapped as follows:
  </para>

  <table>
  <tr><th>Operator</th>   <th>Mapping</th>
  <th>Operator</th>   <th>Mapping</th>
  <th>Operator</th>   <th>Mapping</th>
  </tr>
  <tr><td>&amp;</td>  <td>__ad</td>
  <td>&amp;=</td> <td>__aad</td>
  <td>[]</td>  <td>__vc</td>
  </tr>
  <tr><td>-&gt;</td>  <td>__rf</td>
  <td>-&gt;*</td> <td>__rm</td>
  <td>=</td>  <td>__as</td>
  </tr>
  <tr><td>,</td>  <td>__cm</td>
  <td>~</td>  <td>__co</td>
  <td>/</td>  <td>__dv</td>
  </tr>
  <tr><td>/=</td>  <td>__adv</td>
  <td>==</td>  <td>__eq</td>
  <td>()</td>  <td>__cl</td>
  </tr>
  <tr><td>&gt;</td>  <td>__gt</td>
  <td>&gt;=</td>  <td>__ge</td>
  <td>&lt;</td>  <td>__lt</td>
  </tr>
  <tr><td>&lt;=</td>  <td>__le</td>
  <td>&amp;&amp;</td> <td>__aa</td>
  <td>||</td>  <td>__oo</td>
  </tr>
  <tr><td>&lt;&lt;</td> <td>__ls</td>
  <td>&lt;&lt;=</td> <td>__als</td>
  <td>-</td>  <td>__mi</td>
  </tr>
  <tr><td>-=</td>  <td>__ami</td>
  <td>--</td>  <td>__mm</td>
  <td>!</td>  <td>__nt</td>
  </tr>
  <tr><td>!=</td>  <td>__ne</td>
  <td>|</td>  <td>__or</td>
  <td>|=</td>  <td>__aor</td>
  </tr>
  <tr><td>+</td>  <td>__pl</td>
  <td>+=</td>  <td>__apl</td>
  <td>++</td>  <td>__pp</td>
  </tr>
  <tr><td>%</td>  <td>__md</td>
  <td>%=</td>  <td>__amd</td>
  <td>&gt;&gt;</td> <td>__rs</td>
  </tr>
  <tr><td>&gt;&gt;=</td> <td>__ars</td>
  <td>*</td>  <td>__ml</td>
  <td>*=</td>  <td>__aml</td>
  </tr>
  <tr><td>^</td>  <td>__er</td>
  <td>^=</td>  <td>__aer</td>
  <td>delete</td> <td>__dl</td>
  </tr>
  <tr><td>delete []</td> <td>__vd</td>
  <td>new</td>  <td>__nw</td>
  <td>new []</td> <td>__vn</td>
  </tr>
  <tr><td>?:</td>  <td>__cn</td>
  <td>:</td>  <td>__cs</td>
  <td>::</td>  <td>__cc</td>
  </tr>
  <tr><td>.</td>  <td>__df</td>
  <td>.*</td>  <td>__dm</td>
  <td>abs</td>  <td>__ab</td>
  </tr>
  <tr><td>max</td>  <td>__mx</td>
  <td>min</td>  <td>__mn</td>
  <td>sizeof</td> <td>__sz</td>
  </tr>
  <tr><td>typeid</td> <td>__td</td>
  <td>vtable</td> <td>__tb</td>
  <td>-</td>  <td>-</td>
  </tr>
  </table>

  <para>
  Note that this table contains a number of operators which are not
  part of C++ or cannot be overloaded in C++.  These are used in the
  representation of target dependent integer constants.
  </para>
</section>

<section>
  <title>Mangling namespace names</title>
  <para>
  The global namespace is mapped to an empty string.  Simple namespace
  and class names are mapped as above, but are preceded by a series
  of decimal digits giving the length of the mangled name.  Nested namespaces
  and classes are represented by a sequence of such namespace names,
  preceded by the number of elements in the sequence.  This takes the
  form <code>Q</code><emphasis>digit</emphasis> if there are less than 10 elements,
  or
  <code>Q_</code><emphasis>digits</emphasis><code>_</code> if there are more than
  10. Note that members of anonymous classes or namespaces are local
  to their translation unit, and so do not have external tag names.
  </para>
</section>

<section>
  <title>Mangling types</title>
  <para>
  The mangling of types is essentially similar to that used in the
  <A HREF="dump.html">symbol table dump</A> format.  The type used in
  the mangled name for an identifier ignores the return type for a function
  and ignores the most significant bound for an array.
  </para>
  <para>
  The built-in types are mapped in precisely the same way as in the
  <A HREF="dump.html#built-in">symbol table dump</A>.  Class and enumeration
  types are mapped to their type names mangled in the same way as the
  namespace names above.  The exception to this is that in a class member,
  the parent class is mapped to <code>X</code>.
  </para>
  <para>
  The composite types are again mapped in a similar fashion to that
  in the <A HREF="dump.html#composite">dump file</A>.  For example,
  <code>PCc</code> represents <code>const char *</code>.  The only difficult
  case concerns function parameter types where the ARM
  <code>T</code> and <code>N</code> encodings are used for duplicate
  parameter types.  The function return type is included in the mangled
  form except for function identifier types.  In the cases where the
  identifier is known always to represent a function (constructors,
  destructors etc.) the initial <code>F</code>
  indicating a function type is also omitted.
  </para>
  <para>
  The types of template functions and classes are represented by the
  underlying template and the template arguments giving rise to the
  instance.  Template classes are preceded by <code>t</code>; template
  functions are preceded by <code>G</code> rather than <code>F</code>.
  Type arguments are represented by <code>Z</code> followed by the type
  value; non-type arguments are represented by the argument type followed
  by the argument value.  In the underlying type the template parameters
  are represented by <code>m0</code>, <code>m1</code> etc. An alternative
  scheme, in which the mangled form of a template function includes
  the type of that instance, rather than the underlying template, can
  be enabled using the <code>-j-f</code>
  command-line option.
  </para>
</section>

<section id="other">
  <title>Other mangled names</title>
  <para>
  The <link linkend="vtable">virtual function table</link> for a class, when
  this is a variable with external linkage, is named <code>__vt__</code><emphasis>type
  </emphasis>, where <emphasis>type</emphasis> is the mangled form of the class name.  The
  virtual function table for a base class is named <code>__vt__</code><emphasis>base</emphasis>
  where <emphasis>base</emphasis> is a sequence of mangled class names specifying
  the base class.  The <link linkend="rtti">run-time type information structure</link>
  for a type, when this is a variable with external linkage, is named
  <code>__ti__</code><emphasis>type</emphasis>, where <emphasis>type</emphasis> is the mangled form
  of the type name.
  </para>
</section>

<section>
	<title>Mangled name examples</title>
  <para>
  The following gives some examples of the name mangling scheme:
  <programlisting language="C++">
class A {
    static int a ;			// a__1Ai
public :
    A () ;				// __ct__1A
    A ( int ) ;				// __ct__1Ai
    A ( const A &amp; ) ;			// __ct__1ARCX
    virtual ~A () ;			// __dt__1A
    operator bool () ;			// __opb__1A
    bool operator! () ;			// __nt__1A
} ;

// virtual function table	__vt__1A
// run-time type information	__ti__1A

int f ( A *, int, A * ) ;		// f__FP1AiT1
int b = 2 ;				// b__i
int c [3] ;				// c__A_i

namespace N {
    int *p = 0 ;			// p__1NPi
}</programlisting>
  </para>
  </section>
  </section>
</chapter>

