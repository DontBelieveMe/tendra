<?xml version="1.0" standalone="no"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
	"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">

<!--
	$Id$
-->

<chapter>
    <title>Other implementation details</title>


  <section>
    <title>Parsing C++</title>
  <para>
  The parser used in the C++ producer is generated using the
  <A HREF="../utilities/sid.html"><code>sid</code> tool</A>.  Because
  of the large size of the generated code (1.3MB), the <code>sid</code>
  output is run through a simple program, <code>sidsplit</code>, which
  splits the output into a number of more manageable modules.  It also
  transforms the code to use the <A HREF="style.html#language"><code>PROTO</code>
  macros</A> used in the rest of the program.
  </para>
  <para>
  <code>sid</code> is designed as a parser for grammars which can be
  transformed into LL(1) grammars.  The distinguishing feature of these
  grammars is that the parser can always decide what to do next based
  on the current terminal.  This is not the case in C++; in some circumstances
  a potentially unlimited look-ahead is required to distinguish, for
  example, declaration statements from expression statements.  In the
  technical phrase, C++ is an LL(k) grammar. Fortunately there are relatively
  few such situations, and <code>sid</code>
  provides a mechanism, <A HREF="../utilities/sid.html#predicate">predicates</A>,
  for bypassing the normal parsing mechanism in these cases.  Thus it
  is possible, although difficult, to express C++ as a <code>sid</code>
  grammar.
  </para>
  <para>
  The <code>sid</code> grammar file, <code>syntax.sid</code>, is closely
  based on the ISO C++ grammar.  In particular, the same production
  names have been used.  The grammar has been extended slightly to allow
  common syntactic errors to be detected elegantly.  Other parsing errors
  are handled by <code>sid</code>'s exception mechanism.  At present
  there is only limited recovery after such errors.
  </para>
  <para>
  The lexical analysis routines in the C++ producer are hand-crafted,
  based on an initial version generated by the simple lexical analyser
  generator,
  <code>lexi</code>.  <code>lexi</code> has been used more directly
  to generate the lexical analysers for certain of the other automatic
  code generating tools, including <code>calculus</code>, used in the
  producer.
  </para>
  <para>
  The <code>sid</code> grammar contains a number of entry points.  The
  most important is <code>parse_file</code>, which is used to parse
  a complete C++ translation unit.  The syntax for the
  <A HREF="pragma.html"><code>#pragma TenDRA</code> directives</A> is
  included within the same grammar with two entry points,
  <code>parse_tendra</code> in normal use, and <code>parse_preproc</code>
  for use in preprocessing mode.  There are also entry points in the
  grammar for each of the kinds of <A HREF="token.html#args">token argument</A>.
  The parsing routines for token and template arguments are largely
  hand-crafted, based on these primitives.
  </para>

    <para>Certain parsing operations are performed before control passes to
        the &sid; grammar.  As mentioned above, these include the processing
        of token and template applications.  The other important case concerns
        nested name specifiers.  For example, in:</para>

    <programlisting language="cpp">class A {
    class B {
    static int c ;
    } ;
} ;

int A::B::c = 0 ;</programlisting>

    <para>the qualified identifier <code>A::B::c</code> is split into two terminals,
        a nested name specifier, <code>A::B::</code>, and an identifier, <code>c</code>,
        which is looked up in the corresponding namespace.  Note that it is
        at this stage that name look-up occurs. An identifier can be mapped
        to one of a number of terminals, including  keywords, type names,
        namespace names and other identifiers, according to the result of
        this look-up.  If the look-up gives a macro then this is expanded
        at this stage.</para>
    </section>



  <section>
    <title>Intermodule analysis</title>
<!-- TODO: does this belong here, or is it user-facing? -->
	<warning>
  <para>The C++ spec linking routines have not yet been completely implemented,
  and so are disabled in the current version of the C++ producer.</para>
	</warning>
  <para>
  A C++ spec file is a dump of the C++ producer's <A HREF="alg.html">internal
  representation</A> of a translation unit.  Such files can be written
  to, and read from, disk to perform such operations as intermodule
  analysis.
  </para>
  <para>
  Note that the format of a C++ spec file is specific to the C++ producer
  and may change between releases to reflect modifications in the internal
  type system.  The C producer has a similar dump format, called a C
  spec file, however the two are incompatible.  If intermodule analysis
  between C and C++ source files is required then the <A HREF="dump.html">symbol
  table dump</A> format should be used.
  </para>
  </section>

  <section id="undefined-conversions">
    <title>Undefined conversions</title>
  <para>
  Several conversions in C and C++ can only be represented by undefined
  TDF.  For example, converting a pointer to an integer can only be
  represented in TDF by forming a union of the pointer and integer shapes,
  putting the pointer into the union and pulling the integer out.  Such
  conversions are tokenised.  Undefined conversions not mentioned below
  may be performed by combining those given with the standard, well-defined,
  conversions.
  </para>
  <para>
  The token:
  <programlisting language="TDF">
~ptr_to_ptr : ( ALIGNMENT a, ALIGNMENT b, EXP POINTER a ) -&gt; EXP POINTER b</programlisting>
  is used to convert between two incompatible pointer types.  The first
  alignment describes the source pointer shape while the second describes
  the destination pointer shape.  Note that if the destination alignment
  is greater than the source alignment then the source pointer can be
  used in most TDF constructs in place of the destination pointer, so
  the use of <code>~ptr_to_ptr</code> can be omitted (the exception
  is
  <code>pointer_test</code> which requires equal alignments).  Base
  class pointer conversions are examples of these well-behaved, alignment
  preserving conversions.
  </para>
  <para>
  The tokens:
  <programlisting language="TDF">
~f_to_pv : ( EXP PROC ) -&gt; EXP pv
~pv_to_f : ( EXP pv ) -&gt; EXP PROC</programlisting>
  are used to convert pointers to functions to and from <code>void *</code>
  (these conversions are not allowed in ISO C/C++ but are in older dialects).
  </para>
  <para>
  The tokens:
  <programlisting language="TDF">
~i_to_p : ( VARIETY v, ALIGNMENT a, EXP INTEGER v ) -&gt; EXP POINTER a
~p_to_i : ( ALIGNMENT a, VARIETY v, EXP POINTER a ) -&gt; EXP INTEGER v
~i_to_pv : ( VARIETY v, EXP INTEGER v ) -&gt; EXP pv
~pv_to_i : ( VARIETY v, EXP pv ) -&gt; EXP INTEGER v</programlisting>
  are used to convert integers to and from <code>void *</code> and other
  pointers.
  </para>
  </section>

  <section id="div">
    <title>Integer division</title>
  <para>
  The precise form of the integer division and remainder operations
  in C and C++ is left unspecified with respect to the sign of the result
  if either operand is negative.  The tokens:
  <programlisting language="TDF">
~div : ( EXP INTEGER v, EXP INTEGER v ) -&gt; EXP INTEGER v
~rem : ( EXP INTEGER v, EXP INTEGER v ) -&gt; EXP INTEGER v</programlisting>
  are used to represent integer division and remainder.  They will map
  onto one of the pairs of TDF constructs, <code>div0</code> and <code>rem0</code>,
  <code>div1</code> and <code>rem1</code> or <code>div2</code> and
  <code>rem2</code>.
  </para>
  </section>

  <section id="dynamic-initialisation">
    <title>Dynamic initialisation</title>
  <para>
  The dynamic initialisation of variables with static storage duration
  in C++ is implemented by means of the TDF <code>initial_value</code>
  construct.  However in order for the producer to maintain control
  over the order of initialisation, rather than each variable being
  initialised separately using <code>initial_value</code>, a single
  expression is created which initialises all the variables in a module,
  and this initialiser expression is used to initialise a single dummy
  variable using <code>initial_value</code>.  Note that, while this
  enables the variables within a single module to be initialised in
  the order in which they are defined, the order of initialisation between
  different modules is unspecified.
  </para>
  <para>
  The implementation needs to keep a list of those variables with static
  storage duration which have been initialised so that it can call the
  destructors for these objects at the end of the program. This is done
  by declaring a variable of shape:
  <programlisting language="TDF">
~cpp.destr.type : () -&gt; SHAPE</programlisting>
  for each such object with a non-trivial destructor.  Each element
  of an array is considered a distinct object.  Immediately after the
  variable has been initialised the token:
  <programlisting language="TDF">
~cpp.destr.global : ( EXP pd, EXP POINTER c, EXP PROC ) -&gt; EXP TOP</programlisting>
  is called to add the variable to the list of objects to be destroyed.
  The first argument is the address of the dummy variable just declared,
  the second is the address of the object to be destroyed, and the third
  is the destructor to be used.  In this way a list giving the objects
  to be destroyed, and the order in which to destroy them, is built
  up.  Note that partially constructed objects are destroyed within
  their constructors (see <link linkend="partial">above</link>) so that only
  completely constructed objects need to be considered.
  </para>
  <para>
  The implementation also needs to ensure that it calls the destructors
  in this list at the end of the program, including calls of
  <code>exit</code>.  This is done by calling the token:
  <programlisting language="TDF">
~cpp.destr.init : () -&gt; EXP TOP</programlisting>
  at the start of each <code>initial_value</code> construct.  In the
  default implementation this uses <code>atexit</code> to register a
  function, <code>__TCPPLUS_term</code>, which calls the destructors.
  To aid alternative implementations the token:
  <programlisting language="TDF">
~cpp.start : () -&gt; EXP TOP</programlisting>
  is called at the start of the <code>main</code> function, however
  this has no effect in the default implementation.
  </para>
  </section>

	<section>
		<title>Error catalogue</title>

	<para>This section describes the error catalogue which lies at the heart
		of the C++ producer's error reporting routines.  The full
		<A HREF="error1.html">error catalogue syntax</A> is given as an annex.
		A typical entry in the catalogue is as follows:</para>

	<programlisting language="Error">
class_union_deriv ( CLASS_TYPE: ct )
{
    USAGE:              serious
    PROPERTIES:         ansi
    KEY (ISO)           &quot;9.5&quot;
    KEY (STANDARD)      &quot;The union '&quot;ct&quot;' can't have base classes&quot;
}</programlisting>

	<para>This defines an error, <code>class_union_deriv</code>, which takes
		a single parameter <code>ct</code> of type <code>CLASS_TYPE</code>.
		The severity of this error is <code>serious</code>; that is to say,
		a constraint error.  The error property <code>ansi</code> indicates
		that the error arises from the ISO C++ standard, the associated
		<code>ISO</code> key indicating section 9.5.  Finally the text to
		be printed for this error, including a reference to <code>ct</code>,
		is given.  Looking up section 9.5 in the ISO C++ standard reveals
		the corresponding constraint in paragraph 1:</para>
		<blockquote>A union shall not have base classes.</blockquote>
		<para>Each constraint within the ISO C++ standard has a corresponding error
		in this way.  The errors are named in a systematic fashion using the
		section names used in the draft standard.  For example, section 9.5
		is called <code>class.union</code>, so all the constraint errors arising
		from this section have names of the form <code>class_union_*</code>.
		These error names can be used in the <A HREF="pragma.html#low">low
		level directives</A> such as:</para>

	<programlisting language="C++">
#pragma TenDRA++ error &quot;class_union_deriv&quot; <emphasis>allow</emphasis></programlisting>

	<para>to modify the error severity.  The effect of reducing the severity
		of a constraint error in this way is undefined.</para>

	<para>In addition to the obvious error severity levels, <code>serious</code>,
		<code>warning</code> and <code>none</code>, the error catalogue specifies
		a list of optional severity levels along with their default values.
		For example, the entry:</para>

	<programlisting language="Error">link_incompat = serious</programlisting>

	<para>sets up an option named <code>link_incompat</code> which is a constraint
		error by default.  Errors with this severity, such as:</para>

	<programlisting language="Error">dcl_stc_external ( LONG_ID: id, PTR_LOC: loc )
{
    USAGE:              link_incompat
    PROPERTIES:         ansi
    KEY (ISO)           &quot;7.1.1&quot;
    KEY (STANDARD)      &quot;'&quot;id&quot;' previously declared with external
             linkage (at &quot;loc&quot;)&quot;
}</programlisting>

	<para>are therefore constraint errors.  The severity associated with
		<code>link_incompat</code> can be modified either
		<A HREF="pragma.html#low">directly</A>, using the directive:</para>

	<programlisting language="C++">#pragma TenDRA++ option &quot;link_incompat&quot; <emphasis>allow</emphasis></programlisting>

	<para>or <A HREF="pragma.html#linkage">indirectly</A> using the directive:</para>

	<programlisting language="C++">#pragma TenDRA incompatible linkage <emphasis>allow</emphasis></programlisting>

	<para>the effect being to modify the severity of the associated error messages.</para>

	<para>The error catalogue is processed by a simple tool,
		<code>make_err</code>, which generates C code which is compiled into
		the C++ producer.  Each error in the catalogue is assigned a number
		(there are currently 873 errors in the catalogue) which gives an index
		into an automatically generated table of error information.  It is
		this error number, together with a list of error arguments, which
		forms the associated <A HREF="alg.html#err"><code>ERROR</code> object</A>.
		<code>make_err</code> generates a macro for each error in the catalogue
		which takes arguments of the appropriate types (which may be statically
		checked) and creates an <code>ERROR</code> object.  For example, for
		the entry above this macro takes the form:</para>

  <programlisting language="cpp">
ERROR ERR_class_union_deriv ( CLASS_TYPE ) ;</programlisting>

	<para>These macros hide the error catalogue numbers from the rest of the
		C++ producer.</para>

	<para>It is also possible to join a number of simple <code>ERROR</code>
		objects to form a single composite <code>ERROR</code>.  The severity
		of the composite error is the maximum of the severities of the component
		errors.  To this purpose a dummy error severity level <code>whatever</code>
		is introduced which is less severe than any other level.  This is
		intended for use with error messages which are only ever used to add
		information to existing errors, and which inherit their severity level
		from the main error.</para>

	<para>The text of a simple error message can be found in the table of error
		information.  The text contains certain escape sequences indicating
		where the error arguments are to be printed.  For example,
		<code>%1</code> indicates the second argument.  The error argument
		sorts - what is referred to as the error signature - is also stored
		in the table of error information as an array of characters, each
		corresponding to an <code>ERR_KEY_</code><emphasis>type</emphasis> macro.
		The producer
		defines printing routines for each of the types given by these values,
		and calls the appropriate routine to print the argument.</para>

    <para>There are several command-line options which can be used to modify
        the form in which the error message is printed.  The default format
        is as follows:</para>

    <screen>&quot;file.C&quot;, line 42: Error:
    [ISO 9.5]: The union 'U' can't have base classes.</screen>

    <para>The ISO section number can be suppressed using <code>-m-s</code>.
        The <code>-mc</code> option causes the source code line giving rise
        to the error to be printed as part of the message, with <code>!!!!</code>
        marking the position of the error within the line.  The <code>-me</code>
        option causes the error name, <code>class_union_deriv</code>, to be
        printed as part of the message.  The <code>-ml</code> option causes
        the full file location, including the list of <code>#include</code>
        directives used in reaching the file, to be printed.  The <code>-mt</code>
        option causes <code>typedef</code> names to be used when printing
        types, rather than expanding to the type definition.</para>
    </section>


</chapter>

