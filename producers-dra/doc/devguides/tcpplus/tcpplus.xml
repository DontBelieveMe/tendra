<?xml version="1.0" standalone="no"?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
  "http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">

<!--
  $Id$
-->

<article xmlns:dt="http://xml.water-powered.com/docs">
  <articleinfo>
    <title>C++ Producer Component Developer Guide</title>

    <othercredit class="copyeditor">
      <firstname>Katherine</firstname>
      <surname>Flavel</surname>
      <affiliation><orgname>The TenDRA Project</orgname></affiliation>
    </othercredit>
    <othercredit class="copyeditor">
      <firstname>Jeroen</firstname>
      <surname>Ruigrok van der Werven</surname>
      <affiliation><orgname>The TenDRA Project</orgname></affiliation>
    </othercredit>
    <corpauthor>DERA</corpauthor>

    <pubdate>2004</pubdate>

    <copyright>
      <year>2004</year>
      <year>2005</year>
      <year>2007</year>

      <holder>The TenDRA Project</holder>
    </copyright>

    <copyright>
      <year>1998</year>

      <holder>DERA</holder>
    </copyright>

	<revhistory>
		<revision>
			<date>01 10 2007</date>
			<revremark>Split off developer documentation from the
				<dt:doc name="user/guides/tcpplus"/></revremark>
			<author><firstname>kate</firstname></author>
		</revision>
	</revhistory>
  </articleinfo>

  <chapter id="intro">
    <title>Introduction</title>

	<!-- TODO -->
    <para>
    The warning sign:

    <warning/>

    is used within the document to indicate areas where the implementation
    is currently incomplete or incorrect.
    </para>
  </chapter>

  <chapter id="program">
    <title>Program overview</title>
  <para>
  The C++ producer is a large program (over 200000 lines, including
  automatically generated code) written in C.  A description of the
  <A HREF="style.html#language">coding conventions</A> used, the
  <A HREF="style.html#api">API</A> observed and the basic organisation
  of the <A HREF="style.html#src">source code</A> are described in the
  first section.
  </para>
  <para>
  One of the design methods used in the C++ producer is the extensive
  use of automatic code generation tools.  The type system is based
  around the <code>calculus</code> tool, which allows complex type systems
  to be described in a simple format.  The interface generated by <code>calculus
  </code> allows for rigorous static type checking, generic type constructors
  for lists, stacks etc., encapsulation of the operations on the types
  within the system, and optional run-time checking for null pointers
  and discriminated union tags.  An overview is given of the <A HREF="alg.html">type
  system</A> used as the basis of the C++ producer design.  Also see
  the
  <A HREF="../utilities/calc.html"><code>calculus</code> users' guide</A>.
  </para>
  <para>
  The other general purpose code generation tool used in the C++ producer
  is the parser generator, <code>sid</code>.  A brief description of
  the problems in writing a <A HREF="parse.html">C++ parser</A> is given.
  Also see the <A HREF="../utilities/sid.html"><code>sid</code> users'
  guide</A>.
  </para>
  <para>
  The other code generation tools used were written specifically for
  the C++ producer.  The error reporting routines within the producer
  are based on an <A HREF="error.html">error catalogue</A>, from which
  code for constructing and printing errors is generated.  The
  <A HREF="tdf.html">TDF output routines</A> are based on primitives
  automatically generated from a standard database describing the TDF
  specification.
  </para>
  <para>
  The program itself is well commented, so no lower level program documentation
  has been provided.  When performing development work the producer
  should be compiled with the <code>DEBUG</code> macro defined. This
  enables the <code>calculus</code> run-time checks, along with other
  assertions, and makes available the debugging routines,
  <code>DEBUG_</code><emphasis>type</emphasis>, which can be used to print an object
  from the internal type system.
  </para>
  </chapter>

  <chapter>
  <title>Invocation</title>

  <section>
    <title>Intermodule analysis</title>
	<warning>
  <para>The C++ spec linking routines have not yet been completely implemented,
  and so are disabled in the current version of the C++ producer.</para>
	</warning>
  <para>
  A C++ spec file is a dump of the C++ producer's <A HREF="alg.html">internal
  representation</A> of a translation unit.  Such files can be written
  to, and read from, disk to perform such operations as intermodule
  analysis.
  </para>
  <para>
  Note that the format of a C++ spec file is specific to the C++ producer
  and may change between releases to reflect modifications in the internal
  type system.  The C producer has a similar dump format, called a C
  spec file, however the two are incompatible.  If intermodule analysis
  between C and C++ source files is required then the <A HREF="dump.html">symbol
  table dump</A> format should be used.
  </para>
  </section>

  <section>
    <title>Implementation details</title>
  <para>
  This section describes various of the implementation details of the
  C++ producer TDF output.  In particular it describes the standard
  TDF tokens used to represent the target dependent aspects of the language
  and to provide links into the run-time system.  Many of these tokens
  are common to the C and C++ producers.  Those which are unique to
  the C++ producer have names of the form <code>~cpp.*</code>.  Note
  that the description is in terms of TDF tokens, not the internal tokens
  introduced by the
  <A HREF="token.html"><code>#pragma token</code> syntax</A>.
  </para>
  <para>
  There are two levels of implementation in the run-time system.  The
  actual interface between the producer and the run-time system is given
  by the standard tokens.  The provided implementation defines these
  tokens in a way appropriate to itself.  An alternative implementation
  would have to define the tokens differently.  It is intended that
  the standard tokens are sufficiently generic to allow a variety of
  implementations to hook into the producer output in the manner they
  require.
  </para>


  <section id="arith">
    <title>Arithmetic types</title>
  <para>
  The representations of the basic arithmetic types are target dependent,
  so, for example, an <code>int</code> may contain 16, 32, 64 or some
  other number of bits.  Thus it is necessary to introduce a token to
  stand for each of the built-in arithmetic types (including the
  <A HREF="pragma.html#longlong"><code>long long</code> types</A>).
  Each integral type is represented by a <code>VARIETY</code> token
  as follows: </para>

  <table>
  <tr><th>Type</th>
  <th>Token</th>
  <th>Encoding</th>
  </tr>
  <tr><td>char</td>
  <td>~char</td>
  <td>0</td>
  </tr>
  <tr><td>signed char</td>
  <td>~signed_char</td>
  <td>0 | 4 = 4</td>
  </tr>
  <tr><td>unsigned char</td>
  <td>~unsigned_char</td>
  <td>0 | 8 = 8</td>
  </tr>
  <tr><td>signed short</td>
  <td>~signed_short</td>
  <td>1 | 4 = 5</td>
  </tr>
  <tr><td>unsigned short</td>
  <td>~unsigned_short</td>
  <td>1 | 8 = 9</td>
  </tr>
  <tr><td>signed int</td>
  <td>~signed_int</td>
  <td>2 | 4 = 6</td>
  </tr>
  <tr><td>unsigned int</td>
  <td>~unsigned_int</td>
  <td>2 | 8 = 10</td>
  </tr>
  <tr><td>signed long</td>
  <td>~signed_long</td>
  <td>3 | 4 = 7</td>
  </tr>
  <tr><td>unsigned long</td>
  <td>~unsigned_long</td>
  <td>3 | 8 = 11</td>
  </tr>
  <tr><td>signed long long</td>
  <td>~signed_longlong</td>
  <td>3 | 4 | 16 = 23 </td>
  </tr>
  <tr><td>unsigned long long</td>
  <td>~unsigned_longlong</td>
  <td>3 | 8 | 16 = 27</td>
  </tr>
  </table>

  <para>
  Similarly each floating point type is represent by a
  <code>FLOATING_VARIETY</code> token:
  </para>

  <table>
  <tr><th>Type</th>   <th>Token</th>
  </tr>
  <tr><td>float</td>  <td>~float</td>
  </tr>
  <tr><td>double</td> <td>~double</td>
  </tr>
  <tr><td>long double</td> <td>~long_double</td>
  </tr>
  </table>

  <para>
  Each integral type also has an encoding as a <code>SIGNED_NAT</code>
  as shown above.  This number is a bit pattern built up from the following
  values:
  </para>

  <table>
  <tr><th>Type</th>   <th>Encoding</th>
  </tr>
  <tr><td>char</td>  <td>0</td>
  </tr>
  <tr><td>short</td>  <td>1</td>
  </tr>
  <tr><td>int</td>  <td>2</td>
  </tr>
  <tr><td>long</td>  <td>3</td>
  </tr>
  <tr><td>signed</td> <td>4</td>
  </tr>
  <tr><td>unsigned</td> <td>8</td>
  </tr>
  <tr><td>long long</td> <td>16</td>
  </tr>
  </table>

  <para>
  Any target dependent integral type can be represented by a
  <code>SIGNED_NAT</code> token using this encoding.  This representation,
  rather than one based on <code>VARIETY</code>s, is used for ease of
  manipulation.  The token:
  <programlisting language="TDF">
~convert : ( SIGNED_NAT ) -&gt; VARIETY</programlisting>
  gives the mapping from the integral encoding to the representing variety.
  For example, it will map <code>6</code> to <code>~signed_int</code>.
  </para>
  <para>
  The token:
  <programlisting language="TDF">
~promote : ( SIGNED_NAT ) -&gt; SIGNED_NAT</programlisting>
  describes how to form the promotion of an integral type according
  to the ISO C/C++ value preserving rules, and is used by the producer
  to represent target dependent promotion types.  For example, the promotion
  of <code>unsigned short</code> may be <code>int</code> or <code>unsigned
  int</code> depending on the representation of these types; that is
  to say, <code>~promote ( 9 )</code> will be <code>6</code> on some
  machines and <code>10</code> on others.  Although <code>~promote</code>
  is used by default, a program may specify another token with the same
  sort signature to be used in its place by means of the directive:
  <programlisting language="C++">
#pragma TenDRA compute promote <emphasis>identifier</emphasis></programlisting>
  For example, a standard token <code>~sign_promote</code> is defined
  which gives the older C sign preserving promotion rules.  In addition,
  the promotion of an individual type can be specified using:
  <programlisting language="C++">
#pragma TenDRA promoted <emphasis>type-id</emphasis> : <emphasis>promoted-type-id</emphasis></programlisting>
  </para>
  <para>
  The token:
  <programlisting language="TDF">
~arith_type : ( SIGNED_NAT, SIGNED_NAT ) -&gt; SIGNED_NAT</programlisting>
  similarly describes how to form the usual arithmetic result type from
  two promoted integral operand types.  For example, the arithmetic
  type of <code>long</code> and <code>unsigned int</code> may be
  <code>long</code> or <code>unsigned long</code> depending on the representation
  of these types; that is to say,
  <code>~arith_type ( 7, 10 )</code> will be <code>7</code> on some
  machines and <code>11</code> on others.
  </para>
  <para>
  Any tokenised type declared using:
  <programlisting language="C++">
#pragma token VARIETY v # tv</programlisting>
  will be represented by a <code>SIGNED_NAT</code> token with external
  name
  <code>tv</code> corresponding to the encoding of <code>v</code>.
  Special cases of this are the implementation dependent integral types
  which arise naturally within the language.  The external token names
  for these types are given below:
  </para>

  <table>
  <tr><th>Type</th>   <th>Token</th>
  </tr>
  <tr><td>bool</td>  <td>~cpp.bool</td>
  </tr>
  <tr><td>ptrdiff_t</td> <td>ptrdiff_t</td>
  </tr>
  <tr><td>size_t</td> <td>size_t</td>
  </tr>
  <tr><td>wchar_t</td> <td>wchar_t</td>
  </tr>
  </table>

  <para>
  So, for example, a <code>sizeof</code> expression has shape
  <code>~convert ( size_t )</code>.  The token <code>~cpp.bool</code>
  is defined in the default implementation, but the other tokens are
  defined according to their definitions on the target machine in the
  normal API library building mechanism.
  </para>
  </section>

  <section id="literal">
    <title>Integer literal types</title>
  <para>
  The <A HREF="pragma.html#int">type of an integer literal</A> is defined
  in terms of the first in a list of possible integral types.  The first
  type in which the literal value can be represented gives the type
  of the literal.  For small literals it is possible to work out the
  type exactly, however for larger literals the result is target dependent.
  For example, the literal <code>50000</code> will have type <code>int</code>
  on machines in which <code>50000</code> fits into an <code>int</code>,
  and
  <code>long</code> otherwise.  This target dependent mapping is given
  by a series of tokens of the form:
  <programlisting language="TDF">
~lit_* : ( SIGNED_NAT ) -&gt; SIGNED_NAT</programlisting>
  which map a literal value to the representation of an integral type.
  The token used depends on the list of possible types, which in turn
  depends on the base used to represent the literal and the integer
  suffix used, as given in the following table:
  </para>

  <table>
  <tr><th>Base</th>
  <th>Suffix</th>
  <th>Token</th>
  <th>Types</th>
  </tr>
  <tr><td>decimal</td>
  <td>none</td>
  <td>~lit_int</td>
  <td>int, long, unsigned long</td>
  </tr>
  <tr><td>octal</td>
  <td>none</td>
  <td>~lit_hex</td>
  <td>int, unsigned int, long, unsigned long</td>
  </tr>
  <tr><td>hexadecimal</td>
  <td>none</td>
  <td>~lit_hex</td>
  <td>int, unsigned int, long, unsigned long</td>
  </tr>
  <tr><td>any</td>
  <td>U</td>
  <td>~lit_unsigned</td>
  <td>unsigned int, unsigned long</td>
  </tr>
  <tr><td>any</td>
  <td>L</td>
  <td>~lit_long</td>
  <td>long, unsigned long</td>
  </tr>
  <tr><td>any</td>
  <td>UL</td>
  <td>~lit_ulong</td>
  <td>unsigned long</td>
  </tr>
  <tr><td>any</td>
  <td>LL</td>
  <td>~lit_longlong</td>
  <td>long long, unsigned long long</td>
  </tr>
  <tr><td>any</td>
  <td>ULL</td>
  <td>~lit_ulonglong</td>
  <td>unsigned long long</td>
  </tr>
  </table>

  <para>
  Thus, for example, the shape of the integer literal 50000 is:
  <programlisting language="TDF">
~convert ( ~lit_int ( 50000 ) )</programlisting>
  </para>
  </section>

  <section id="bitfield">
    <title>Bitfield types</title>
  <para>
  The sign of a plain bitfield type, declared without using
  <code>signed</code> or <code>unsigned</code>, is left unspecified
  in C and C++.  The token:
  <programlisting language="TDF">
~cpp.bitf_sign : ( SIGNED_NAT ) -&gt; BOOL</programlisting>
  is used to give a mapping from integral types to the sign of a plain
  bitfield of that type, in a form suitable for use in the TDF
  <code>bfvar_bits</code> construct.  (Note that <code>~cpp.bitf_sign</code>
  should have been a standard C token but was omitted.)
  </para>
  </section>

  <section id="pointer">
    <title>Generic pointers</title>
  <para>
  TDF has no concept of a generic pointer type, so tokens are used to
  defer the representation of <code>void *</code> and the basic operations
  on it to the target machine.  The fundamental token is:
  <programlisting language="TDF">
~ptr_void : () -&gt; SHAPE</programlisting>
  which gives the representation of <code>void *</code>.  This shape
  will be denoted by <code>pv</code> in the description of the following
  tokens.  It is not guaranteed that <code>pv</code> is a TDF <code>pointer</code>
  shape, although normally it will be implemented as a pointer to a
  suitable alignment.
  </para>
  <para>
  The token:
  <programlisting language="TDF">
~null_pv : () -&gt; EXP pv</programlisting>
  gives the value of a null pointer of type <code>void *</code>.  Generic
  pointers can also be converted to and from other pointers.  These
  conversions are represented by the tokens:
  <programlisting language="TDF">
~to_ptr_void : ( ALIGNMENT a, EXP POINTER a ) -&gt; EXP pv
~from_ptr_void : ( ALIGNMENT a, EXP pv ) -&gt; EXP POINTER a</programlisting>
  where the given alignment describes the destination or source pointer
  type.  Finally a generic pointer may be tested against the null pointer
  or two generic pointers may be compared.  These operations are represented
  by the tokens:
  <programlisting language="TDF">
~cpp.pv_compare : ( EXP pv, EXP pv, LABEL, NTEST ) -&gt; EXP TOP</programlisting>
  where the given <code>NTEST</code> gives the comparison to be applied
  and the given label gives the destination to jump to if the test fails.
  (Note that <code>~cpp.pv_compare</code> should have been a standard
  C token but was omitted.)
  </para>
  </section>

  <section id="undefined-conversions">
    <title>Undefined conversions</title>
  <para>
  Several conversions in C and C++ can only be represented by undefined
  TDF.  For example, converting a pointer to an integer can only be
  represented in TDF by forming a union of the pointer and integer shapes,
  putting the pointer into the union and pulling the integer out.  Such
  conversions are tokenised.  Undefined conversions not mentioned below
  may be performed by combining those given with the standard, well-defined,
  conversions.
  </para>
  <para>
  The token:
  <programlisting language="TDF">
~ptr_to_ptr : ( ALIGNMENT a, ALIGNMENT b, EXP POINTER a ) -&gt; EXP POINTER b</programlisting>
  is used to convert between two incompatible pointer types.  The first
  alignment describes the source pointer shape while the second describes
  the destination pointer shape.  Note that if the destination alignment
  is greater than the source alignment then the source pointer can be
  used in most TDF constructs in place of the destination pointer, so
  the use of <code>~ptr_to_ptr</code> can be omitted (the exception
  is
  <code>pointer_test</code> which requires equal alignments).  Base
  class pointer conversions are examples of these well-behaved, alignment
  preserving conversions.
  </para>
  <para>
  The tokens:
  <programlisting language="TDF">
~f_to_pv : ( EXP PROC ) -&gt; EXP pv
~pv_to_f : ( EXP pv ) -&gt; EXP PROC</programlisting>
  are used to convert pointers to functions to and from <code>void *</code>
  (these conversions are not allowed in ISO C/C++ but are in older dialects).
  </para>
  <para>
  The tokens:
  <programlisting language="TDF">
~i_to_p : ( VARIETY v, ALIGNMENT a, EXP INTEGER v ) -&gt; EXP POINTER a
~p_to_i : ( ALIGNMENT a, VARIETY v, EXP POINTER a ) -&gt; EXP INTEGER v
~i_to_pv : ( VARIETY v, EXP INTEGER v ) -&gt; EXP pv
~pv_to_i : ( VARIETY v, EXP pv ) -&gt; EXP INTEGER v</programlisting>
  are used to convert integers to and from <code>void *</code> and other
  pointers.
  </para>
  </section>

  <section id="div">
    <title>Integer division</title>
  <para>
  The precise form of the integer division and remainder operations
  in C and C++ is left unspecified with respect to the sign of the result
  if either operand is negative.  The tokens:
  <programlisting language="TDF">
~div : ( EXP INTEGER v, EXP INTEGER v ) -&gt; EXP INTEGER v
~rem : ( EXP INTEGER v, EXP INTEGER v ) -&gt; EXP INTEGER v</programlisting>
  are used to represent integer division and remainder.  They will map
  onto one of the pairs of TDF constructs, <code>div0</code> and <code>rem0</code>,
  <code>div1</code> and <code>rem1</code> or <code>div2</code> and
  <code>rem2</code>.
  </para>
  </section>

  <section id="call">
    <title>Calling conventions</title>
  <para>
  The function calling conventions used by the C++ producer are essentially
  the same as those used by the C producer with one exception.  That
  is to say, all types except arrays are passed by value (note that
  individual installers may modify these conventions to conform to their
  own ABIs).
  </para>
  <para>
  The exception concerns classes with a non-trivial constructor, destructor
  or assignment operator.  These classes are passed as function arguments
  by taking a reference to a copy of the object (although it is often
  possible to eliminate the copy and pass a reference to the object
  directly).  They are passed as function return values by adding an
  extra parameter to the start of the function parameters giving a reference
  to a location into which the return value should be copied.
  </para>

<section>
	<title>Member functions</title>
  <para>
  Non-static member functions are implemented in the obvious fashion,
  by passing a pointer to the object the method is being applied to
  as the first argument (or the second argument if the method has an
  extra argument for its return value).
  </para>
</section>

<section id="ellipsis-funcs">
	<title>Ellipsis functions</title>
  <para>
  Calls to functions declared with ellipses are via the
  <code>apply_proc</code> TDF construct, with all the arguments being
  treated as non-variable.  However the definition of such a function
  uses the <code>make_proc</code> construct with a variable parameter.
  This parameter can be referred to within the program using the
  <A HREF="pragma.html#ellipsis"><code>...</code> expression</A>.  The
  type of this expression is given by the built-in token:
  <programlisting language="TDF">
~__va_t : () -&gt; SHAPE</programlisting>
  The <code>va_start</code> macro declared in the
  <code>&lt;stdarg.h&gt;</code> header then describes how the variable
  parameter (expressed as <code>...</code>) can be converted to an expression
  of type <code>va_list</code> suitable for use in the
  <code>va_arg</code> macro.
  </para>
  <para>
  Note that the variable parameter is in effect only being used to determine
  where the first optional parameter is defined.  The assumption is
  that all such parameters are located contiguously on the stack, however
  the fact that calls to such functions do not use the variable parameter
  mechanism means that this is not automatically the case.  Strictly
  speaking this means that the implementation of ellipsis functions
  uses undefined behaviour in TDF, however given the non-type-safe function
  calling rules in C this is unavoidable and installers need to make
  provision for such calls (by dumping any parameters from registers
  to the stack if necessary).  Given the theoretically type-safe nature
  of C++ it would be possible to avoid such undefined behaviour, but
  the need for C-compatible calling conventions prevents this.
  </para>
</section>
  </section>

  <section id="ptr_mem">
    <title>Pointers to data members</title>
  <para>
  The representation of, and operations on, pointers to data members
  are represented by tokens to allow for a variety of implementations.
  It is assumed that all pointers to data members (as opposed to pointers
  to function members) are represented by the same shape:
  <programlisting language="TDF">
~cpp.pm.type : () -&gt; SHAPE</programlisting>
  This shape will be denoted by <code>pm</code> in the description of
  the following tokens.
  </para>
  <para>
  There are two basic methods of constructing a pointer to a data member.
  The first is to take the address of a data member of a class.  A data
  member is represented in TDF by an expression which gives the offset
  of the member from the start of its enclosing <code>compound</code>
  shape (note that it is not possible to take the address of a member
  of a virtual base). The mapping from this offset to a pointer to a
  data member is given by:
  <programlisting language="TDF">
~cpp.pm.make : ( EXP OFFSET ) -&gt; EXP pm</programlisting>
  The second way of constructing a pointer to a data member is to use
  a null pointer to member:
  <programlisting language="TDF">
~cpp.pm.null : () -&gt; EXP pm</programlisting>
  The other fundamental operation on a pointer to data member is to
  turn it back into an offset expression which can be added to a pointer
  to a class to access a member of that class in a <code>.*</code> or
  <code>-&gt;*</code>
  operation.  This is done by the token:
  <programlisting language="TDF">
~cpp.pm.offset : ( EXP pm, ALIGNMENT a ) -&gt; EXP OFFSET ( a, a )</programlisting>
  Note that it is necessary to specify an alignment in order to describe
  the shape of the result.  The value of this token is undefined if
  the given expression is a null pointer to data member.
  </para>
  <para>
  A pointer to a data member of a non-virtual base class can be converted
  to a pointer to a data member of a derived class.  The reverse conversion
  is also possible using <code>static_cast</code>.  If the base is a
  <link linkend="primary">primary base class</link> then these conversions are
  trivial and have no effect.  Otherwise null pointers to data members
  are converted to null pointers to data members, and the non-null cases
  are handled by the tokens:
  <programlisting language="TDF">
~cpp.pm.cast : ( EXP pm, EXP OFFSET ) -&gt; EXP pm
~cpp.pm.uncast : ( EXP pm, EXP OFFSET ) -&gt; EXP pm</programlisting>
  where the given offset is the offset of the base class within the
  derived class.  It is also possible to convert between any two pointers
  to data members using <code>reinterpret_cast</code>.  This conversion
  is implied by the equality of representation between any two pointers
  to data members and has no effect.
  </para>
  <para>
  The only remaining operations on pointer to data members are to test
  one against the null pointer to data member and to compare two pointer
  to data members.  These are represented by the tokens:
  <programlisting language="TDF">
~cpp.pm.test : ( EXP pm, LABEL, NTEST ) -&gt; EXP TOP
~cpp.pm.compare : ( EXP pm, EXP pm, LABEL, NTEST ) -&gt; EXP TOP</programlisting>
  where the given <code>NTEST</code> gives the comparison to be applied
  and the given label gives the destination to jump to if the test fails.
  </para>
  <para>
  In the default implementation, pointers to data members are implemented
  as <code>int</code>.  The null pointer to member is represented by
  0 and the address of a class member is represented by 1 plus the offset
  of the member (in bytes).  Casting to and from a derived class then
  correspond to adding or subtracting the base class offset (in bytes),
  and pointer to member comparisons correspond to integer comparisons.
  </para>
  </section>

  <section id="ptr_mem_func">
    <title>Pointers to function members</title>
  <para>
  As with pointers to data members, pointers to function members and
  the operations on them are represented by tokens to allow for a range
  of implementations.  All pointers to function members are represented
  by the same shape:
  <programlisting language="TDF">
~cpp.pmf.type : () -&gt; SHAPE</programlisting>
  This shape will be denoted by <code>pmf</code> in the description
  of the following tokens.  Many of the tokens take an expression which
  has a shape which is a pointer to the alignment of <code>pmf</code>.
  This will be denoted by <code>ppmf</code>.
  </para>
  <para>
  There are two basic methods for constructing a pointer to a function
  member.  The first is to take the address of a non-static member function
  of a class.  There are two cases, depending on whether or not the
  member function is virtual.  The non-virtual case is given by the
  token:
  <programlisting language="TDF">
~cpp.pmf.make : ( EXP PROC, EXP OFFSET, EXP OFFSET ) -&gt; EXP pmf</programlisting>
  where the first argument is the address of the corresponding function,
  the second argument gives any base class offset which is to be added
  when calling this function (to deal with inherited member functions),
  and the third argument is a zero offset.
  </para>
  <para>
  For virtual functions, a pointer to function member of the form above
  is entered in the <link linkend="vtable">virtual function table</link> for
  the corresponding class.  The actual pointer to the virtual function
  member then gives a reference into the virtual function table as follows:
  <programlisting language="TDF">
~cpp.pmf.vmake : ( SIGNED_NAT, EXP OFFSET, EXP, EXP ) -&gt; EXP pmf</programlisting>
  where the first argument gives the index of the function within the
  virtual function table, the second argument gives the offset of the
  <emphasis>vptr</emphasis> field within the class, and the third and fourth arguments
  are zero offsets.
  </para>
  <para>
  The second way of constructing a pointer to a function member is to
  use a null pointer to function member:
  <programlisting language="TDF">
~cpp.pmf.null : () -&gt; EXP pmf
~cpp.pmf.null2 : () -&gt; EXP pmf</programlisting>
  For technical reasons there are two versions of this token, although
  they have the same value.  The first token is used in static initialisers;
  the second token is used in other expressions. </para>
  <para>
  The cast operations on pointers to function members are more complex
  than those on pointers to data members.  The value to be cast is copied
  into a temporary and one of the tokens:
  <programlisting language="TDF">
~cpp.pmf.cast : ( EXP ppmf, EXP OFFSET, EXP, EXP OFFSET ) -&gt; EXP TOP
~cpp.pmf.uncast : ( EXP ppmf, EXP OFFSET, EXP, EXP OFFSET ) -&gt; EXP TOP</programlisting>
  is applied to modify the value of the temporary according to the given
  cast.  The first argument gives the address of the temporary, the
  second gives the base class offset to be added or subtracted, the
  third gives the number to be added or subtracted to convert virtual
  function indexes for the base class into virtual function indexes
  for the derived class, and the fourth gives the offset of the <emphasis>vptr</emphasis>
  field within the class.  Again, the ability to use <code>reinterpret_cast</code>
  to convert between any two pointer to function member types arises
  because of the uniform representation of these types.
  </para>
  <para>
  As with pointers to data members, there are tokens implementing comparisons
  on pointers to function members:
  <programlisting language="TDF">
~cpp.pmf.test : ( EXP ppmf, LABEL, NTEST ) -&gt; EXP TOP
~cpp.pmf.compare : ( EXP ppmf, EXP ppmf, LABEL, NTEST ) -&gt; EXP TOP</programlisting>
  Note however that the arguments are passed by reference.
  </para>
  <para>
  The most important, and most complex, operation is calling a function
  through a pointer to function member.  The first step is to copy the
  pointer to function member into a temporary.  The token:
  <programlisting language="TDF">
~cpp.pmf.virt : ( EXP ppmf, EXP, ALIGNMENT ) -&gt; EXP TOP</programlisting>
  is then applied to the temporary to convert a pointer to a virtual
  function member to a normal pointer to function member by looking
  it up in the corresponding virtual function table.  The first argument
  gives the address of the temporary, the second gives the object to
  which the function is to be applied, and the third gives the alignment
  of the corresponding class.  Now the base class conversion to be applied
  to the object can be determined by applying the token:
  <programlisting language="TDF">
~cpp.pmf.delta : ( ALIGNMENT a, EXP ppmf ) -&gt; EXP OFFSET ( a, a )</programlisting>
  to the temporary to find the offset to be added.  Finally the function
  to be called can be extracted from the temporary using the token:
  <programlisting language="TDF">
~cpp.pmf.func : ( EXP ppmf ) -&gt; EXP PROC</programlisting>
  The function call then procedes as normal.
  </para>
  <para>
  The default implementation is that described in the ARM, where each
  pointer to function member is represented in the form:
  <programlisting language="C++">
struct PTR_MEM_FUNC {
    short delta ;
    short index ;
    union {
	void ( *func ) () ;
	short off ;
    } u ;
} ;</programlisting>
  The <code>delta</code> field gives the base class offset (in bytes)
  to be added before applying the function.  The <code>index</code>
  field is 0 for null pointers, -1 for non-virtual function pointers
  and the index into the virtual function table for virtual function
  pointers (as described below these indexes start from 1).  For non-virtual
  function pointers the function itself is given by the <code>u.func</code>
  field. For virtual function pointers the offset of the <emphasis>vptr</emphasis>
  field within the class is given by the <code>u.off</code> field.
  </para>
  </section>

  <section id="class">
    <title>Class layout</title>
  <para>
  Consider a class with no base classes:
  <programlisting language="C++">
class A {
    // A's members
} ;</programlisting>
  Each object of class <emphasis>A</emphasis> needs its own copy of the non-static
  data members of <emphasis>A</emphasis> and, for polymorphic types, a means of referencing
  the virtual function table and run-time type information for <emphasis>A</emphasis>.
  This is accomplished using a layout of the form:

	<figure>
		<title>Class A</title>

		<graphic fileref="images/class.png"/>
	</figure>

  where the <emphasis>A</emphasis> component consists of the non-static data members
  and
  <emphasis>vptr A</emphasis> is a pointer to the virtual function table for <emphasis>A</emphasis>.
  For non-polymorphic classes the <emphasis>vptr A</emphasis> field is omitted; otherwise
  space for <emphasis>vptr A</emphasis> needs to be allocated within the class and
  the pointer needs to be initialised in each constructor for <emphasis>A</emphasis>.
  The precise layout of the <link linkend="vtable">virtual function table</link>
  and the <link linkend="rtti">run-time type information</link> is given below.
  </para>
  <para>
  Two alternative ways of laying out the non-static data members within
  the class are implemented.  The first, which is default, gives them
  in the order in which they are declared in the class definition.
  The second lays out the <code>public</code>, the <code>protected</code>,
  and the <code>private</code> members in three distinct sections, the
  members within each section being given in the order in which they
  are declared. The latter can be enabled using the <code>-jo</code>
  command-line option.
  </para>
  <para>
  The offset of each member within the class (including <emphasis>vptr A</emphasis>)
  can be calculated in terms of the offset of the previous member.
  The first member has offset zero.  The offset of any other member
  is given by the offset of the previous member plus the size of the
  previous member, rounded up to the alignment of the current member.
  The overall size of the class is given by the offset of the last member
  plus the size of the last member, rounded up using the token:
  <programlisting language="TDF">
~comp_off : ( EXP OFFSET ) -&gt; EXP OFFSET</programlisting>
  which allows for any target dependent padding at the end of the class.
  The shape of the class is then a <code>compound</code> shape with
  this offset.
  </para>
  <para>
  Classes with no members need to be treated slightly differently.
  The shape of such a class is given by the token:
  <programlisting language="TDF">
~cpp.empty.shape : () -&gt; SHAPE</programlisting>
  (recall that an empty class still has a nonzero size).  The token:
  <programlisting language="TDF">
~cpp.empty.offset : () -&gt; EXP OFFSET</programlisting>
  is used to represent the offset required for an empty class when it
  is used as a base class.  This may be a zero offset.
  </para>
  <para>
  Bitfield members provide a slight complication to the picture above.
  The offset of a bitfield is additionally padded using the token:
  <programlisting language="TDF">
~pad : ( EXP OFFSET, SHAPE, SHAPE ) -&gt; EXP OFFSET</programlisting>
  where the two shapes give the type underlying the bitfield and the
  bitfield itself.
  </para>
  <para>
  The layout of unions is similar to that of classes except that all
  members have zero offset, and the size of the union is the maximum
  of the sizes of its members, suitably padded.  Of course unions cannot
  be polymorphic and cannot have base classes.
  </para>
  <para>
  Pointers to incomplete classes are represented by means of the alignment:
  <programlisting language="TDF">
~cpp.empty.align : () -&gt; ALIGNMENT</programlisting>
  This token is also used for the alignment of a complete class if that
  class is never used in the generated TDF in a manner which requires
  it to be complete.  This can lead to savings on the size of the generated
  code by preventing the need to define all the member offset tokens
  in order to find the shape of the class.
  </para>
  </section>

  <section id="derive">
    <title>Derived class layout</title>
  <para>
  The description of the implementation of derived classes will be given
  in terms of the example class hierarchy given by:
  <programlisting language="C++">
class A {
    // A's members
} ;

class B : public A {
    // B's members
} ;

class C : public A {
    // C's members
} ;

class D : public B, public C {
    // D's members
} ;</programlisting>
  or, as a directed acyclic graph:
  </para>

	<figure>
		<title>Class D</title>

		<graphic fileref="images/graph.png"/>
	</figure>


<section>
	<title>Single inheritance</title>
  <para>
  The layout of class <emphasis>A</emphasis> is given by:

	<figure>
		<title>Class A</title>

		<graphic fileref="images/classA.png"/>
	</figure>

  as above.  Class <emphasis>B</emphasis> inherits all the members of class <emphasis>A</emphasis>
  plus those members explicitly declared within class <emphasis>B</emphasis>.  In
  addition, class <emphasis>B</emphasis> inherits all the virtual member functions
  of <emphasis>A</emphasis>, some of which may be overridden in <emphasis>B</emphasis>, extended
  by any additional virtual functions declared in <emphasis>B</emphasis>.  This may
  be represented as follows:

	<figure>
		<title>Class B</title>

		<graphic fileref="images/classB.png"/>
	</figure>

  where <emphasis>A</emphasis> denotes those members inherited from the base class
  and
  <emphasis>B</emphasis> denotes those members added in the derived class.  Note that
  an object of class <emphasis>B</emphasis> contains a sub-object of class <emphasis>A</emphasis>.
  The fact that this sub-object is located at the start of <emphasis>B</emphasis>
  means that the base class conversion from <emphasis>B</emphasis> to <emphasis>A</emphasis> is
  trivial.  Any base class with this property is called a
  <A id="primary">primary base class</A>.
  </para>
  <para>
  Note that in theory two virtual function tables are required, the
  normal virtual function table for <emphasis>B</emphasis>, denoted by <emphasis>vtbl B</emphasis>,
  and a modified virtual function table for <emphasis>A</emphasis>, denoted by <emphasis>vtbl
  B::A</emphasis>, taking into account any overriding virtual functions within
  <emphasis>B</emphasis>, and pointing to <emphasis>B</emphasis>'s run-time type information.  This
  latter means that the dynamic type information for the <emphasis>A</emphasis> sub-object
  relates to
  <emphasis>B</emphasis> rather than <emphasis>A</emphasis>.  However these two tables can usually
  be combined - if the virtual functions added in <emphasis>B</emphasis> are listed
  in the virtual function table after those inherited from <emphasis>A</emphasis>
  and the form of the overriding is <link linkend="override">suitably well
  behaved</link>
  (in the sense defined below) then <emphasis>vptr B::A</emphasis> is an initial segment
  of <emphasis>vptr B</emphasis>.  It is also possible to remove the <emphasis>vptr B</emphasis>
  field and use <emphasis>vptr B::A</emphasis> in its place in this case (it has to
  be this way round to preserve the <emphasis>A</emphasis> sub-object).  Thus the
  items shaded in the diagram can be removed.
  </para>
  <para>
  The class <emphasis>C</emphasis> is similarly given by:

	<figure>
		<title>Class C</title>

		<graphic fileref="images/classC.png"/>
	</figure>

  </para>
</section>

<section>
	<title>Multiple inheritance</title>
  <para>
  Class <emphasis>D</emphasis> is more complex because of the presence of multiple
  inheritance.  <emphasis>D</emphasis> inherits all the members of <emphasis>B</emphasis>, including
  those which <emphasis>B</emphasis> inherits from <emphasis>A</emphasis>, plus all the members
  of
  <emphasis>C</emphasis>, including those which <emphasis>C</emphasis> inherits from <emphasis>A</emphasis>.
  It also inherits all of the virtual member functions from <emphasis>B</emphasis>
  and
  <emphasis>C</emphasis>, some of which may be overridden in <emphasis>D</emphasis>, extended by
  any additional virtual functions declared in <emphasis>D</emphasis>.  This may be
  represented as follows:

	<figure>
		<title>Class D</title>

		<graphic fileref="images/classD.png"/>
	</figure>

  Note that there are two copies of <emphasis>A</emphasis> in <emphasis>D</emphasis> because virtual
  inheritance has not been used.
  </para>
  <para>
  The <emphasis>B</emphasis> base class of <emphasis>D</emphasis> is essentially similar to the
  single inheritance case already discussed; the <emphasis>C</emphasis> base class
  is different however.  Note firstly that the <emphasis>C</emphasis> sub-object of
  <emphasis>D</emphasis> is located at a non-zero offset, <emphasis>delta D::C</emphasis>, from
  the start of the object. This means that the base class conversion
  from <emphasis>D</emphasis> to <emphasis>C</emphasis>
  consists of adding this offset (for pointer conversions things are
  further complicated by the need to allow for null pointers).  Also
  <emphasis>vtbl D::C</emphasis> is not an initial segment of <emphasis>vtbl D</emphasis> because
  this contains the virtual functions inherited from <emphasis>B</emphasis> first,
  followed by those inherited from <emphasis>C</emphasis>, followed by those first
  declared in <emphasis>D</emphasis> (there are <link linkend="override">other reasons</link>
  as well).  Thus <emphasis>vtbl D::C</emphasis> cannot be eliminated.
  </para>
</section>

<section>
	<title>Virtual inheritance</title>
  <para>
  Virtual inheritance introduces a further complication.  Now consider
  the class hierarchy given by:
  <programlisting language="C++">
class A {
    // A's members
} ;

class B : virtual public A {
    // B's members
} ;

class C : virtual public A {
    // C's members
} ;

class D : public B, public C {
    // D's members
} ;</programlisting>
  or, as a <A id="diamond">directed acyclic graph</A>:

	<figure>
		<title>Class D</title>

		<graphic fileref="images/diamond.png"/>
	</figure>

  As before <emphasis>A</emphasis> is given by:

	<figure>
		<title>Class A</title>

		<graphic fileref="images/classA.png"/>
	</figure>

  but now <emphasis>B</emphasis> is given by:

	<figure>
		<title>Class B</title>

		<graphic fileref="images/virtualB.png"/>
	</figure>

  Rather than having the sub-object of class <emphasis>A</emphasis> directly as part
  of
  <emphasis>B</emphasis>, the class now contains a pointer, <emphasis>ptr A</emphasis>, to this
  sub-object.  The virtual sub-objects are always located at the end
  of a class layout; their offset may therefore vary for different objects,
  however the offset for <emphasis>ptr A</emphasis> is always fixed.  The <emphasis>ptr A</emphasis>
  field is initialised in each constructor for <emphasis>B</emphasis>.  In order to
  perform the base class conversion from <emphasis>B</emphasis> to <emphasis>A</emphasis>, the contents
  of <emphasis>ptr A</emphasis> are taken (again provision needs to be made for null
  pointers in pointer conversions).  In cases when the dynamic type
  of the <emphasis>B</emphasis> object can be determined statically it is possible
  to access the <emphasis>A</emphasis> sub-object directly by adding a suitable offset.
  Because this conversion is non-trivial (see <link linkend="override">below</link>)
  the virtual function table <emphasis>vtbl B::A</emphasis> is not an initial segment
  of
  <emphasis>vtbl B</emphasis> and cannot be eliminated.
  </para>
  <para>
  The class <emphasis>C</emphasis> is similarly given by:

	<figure>
		<title>Class C</title>

		<graphic fileref="images/virtualC.png"/>
	</figure>

  Now the class <emphasis>D</emphasis> is given by:

	<figure>
		<title>Class D</title>

		<graphic fileref="images/virtualD.png"/>
	</figure>

  Note that there is a single <emphasis>A</emphasis> sub-object of <emphasis>D</emphasis> referenced
  by the <emphasis>ptr A</emphasis> fields in both the <emphasis>B</emphasis> and <emphasis>C</emphasis> sub-objects.
  The elimination of <emphasis>vtbl D::B</emphasis> is as above.
  </para>
</section>
  </section>

  <section id="constr">
    <title>Constructors and destructors</title>
  <para>
  The implementation of constructors and destructors, whether explicitly
  or implicitly defined, is slightly more complex than that of other
  member functions.  For example, the constructors need to set up the
  internal <emphasis>vptr</emphasis> and <emphasis>ptr</emphasis> fields mentioned above.
  </para>
  <para>
  The order of initialisation in a constructor is as follows:
  <itemizedlist>
  <listitem>The internal <emphasis>ptr</emphasis> fields giving the locations of the virtual
  base classes are initialised.
  </listitem>
  <listitem>The constructors for the virtual base classes are called.
  </listitem>
  <listitem>The constructors for the non-virtual direct base classes are called.
  </listitem>
  <listitem>The internal <emphasis>vptr</emphasis> fields giving the locations of the virtual
  function tables are initialised.
  </listitem>
  <listitem>The constructors for the members of the class are called.
  </listitem>
  <listitem>The main constructor body is executed.
  </listitem>
  </itemizedlist>
  To ensure that each virtual base is only initialised once, if a class
  has a virtual base class then all its constructors have an implicit
  extra parameter of type <code>int</code>.  The first two steps above
  are then only applied if this flag is nonzero.  In normal applications
  of the constructor this argument will be 1, however in base class
  initialisations such as those in the third and fourth steps above,
  it will be 0.
  </para>
  <para>
  Note that similar steps to protect virtual base classes are not taken
  in an implicitly declared <code>operator=</code> function.  The order
  of assignment in this case is as follows:
  <itemizedlist>
  <listitem>The assignment operators for the direct base classes (both virtual
  and non-virtual) are called.
  </listitem>
  <listitem>The assignment operators for the members of the class are called.
  </listitem>
  <listitem>A reference to the object assigned to (i.e. <code>*this</code>)
  is     returned.
  </listitem>
  </itemizedlist>
  </para>
  <para>
  The order of destruction in a destructor is essentially the reverse
  of the order of construction:
  <itemizedlist>
  <listitem>The main destructor body is executed.
  </listitem>
  <listitem>The destructor for the members of the class are called.
  </listitem>
  <listitem>The internal <emphasis>vptr</emphasis> fields giving the locations of the virtual
  function tables are re-initialised.
  </listitem>
  <listitem>The destructors for the non-virtual direct base classes are called.
  </listitem>
  <listitem>The destructors for the virtual base classes are called.
  </listitem>
  <listitem>If necessary the space occupied by the object is deallocated.
  </listitem>
  </itemizedlist>
  All destructors have an extra parameter of type <code>int</code>.
  The virtual base classes are only destroyed if this flag is nonzero
  when and-ed with 2.  The space occupied by the object is only deallocated
  if this flag is nonzero when and-ed with 1.  This deallocation is
  equivalent to inserting:
  <programlisting language="C++">
delete this ;</programlisting>
  in the destructor.  The <code>operator delete</code> function is called
  via the destructor in this way in order to implement the pseudo-virtual
  nature of these deallocation functions.  Thus for normal destructor
  calls the extra argument is 2, for base class destructor calls it
  is 0, and for calls arising from a <code>delete</code> expression
  it is 3.
  </para>
  <para>
  The point at which the virtual function tables are initialised in
  the constructor, and the fact that they are re-initialised in the
  destructor, is to ensure that virtual functions called from base class
  initialisers are handled correctly (see ISO C++ 12.7).
  </para>
  <para>
  A further complication arises from the need to destroy
  <A id="partial">partially constructed objects</A> if an exception
  is thrown in a constructor.  A count is maintained of the number of
  base classes and members constructed within a constructor.  If an
  exception is thrown then it is caught in the constructor, the constructed
  base classes and members are destroyed, and the exception is re-thrown.
  The count variable is used to determine which bases and members need
  to be destroyed.
  </para>
	<warning>
  <para>These partial destructors
  currently do not interact correctly with any exception specification
  on the constructor.  Exceptions thrown within destructors are not
  correctly handled either.</para>
	</warning>
  </section>

  <section id="vtable">
    <title>Virtual function tables</title>
  <para>
  The virtual functions in a polymorphic class are given in its virtual
  function table in the following order: firstly those virtual functions
  inherited from its direct base classes (which may be overridden in
  the derived class) followed by those first declared in the derived
  class in the order in which they are declared.  Note that this can
  result in virtual functions inherited from virtual base classes appearing
  more than once.  The virtual functions are numbered from 1 (this is
  slightly more convenient than numbering from 0 in the default implementation).
  </para>
  <para>
  The virtual function table for this class has shape:
  <programlisting language="TDF">
~cpp.vtab.type : ( NAT ) -&gt; SHAPE</programlisting>
  the argument being <emphasis>n + 1</emphasis> where <emphasis>n</emphasis> is the number of virtual
  functions in the class (there is also a token:
  <programlisting language="TDF">
~cpp.vtab.diag : () -&gt; SHAPE</programlisting>
  which is used in the diagnostic output for a generic virtual function
  table).  The table is created using the token:
  <programlisting language="TDF">
~cpp.vtab.make : ( EXP pti, EXP OFFSET, NAT, EXP NOF ) -&gt; EXP vt</programlisting>
  where the first expression gives the address of the <link linkend="rtti">run-time
  type information structure</link> for the class, the second expression
  gives the offset of the <emphasis>vptr</emphasis> field within the class (i.e. <emphasis>voff</emphasis>),
  the integer constant is <emphasis>n + 1</emphasis>, and the final expression is
  a
  <code>make_nof</code> construct giving information on each of the
  <emphasis>n</emphasis>
  virtual functions.
  </para>
  <para>
  The information given on each virtual function in this table has the
  form of a <link linkend="ptr_mem_func">pointer to function member</link> formed
  using the token:
  <programlisting language="TDF">
~cpp.pmf.make : ( EXP PROC, EXP OFFSET, EXP OFFSET ) -&gt; EXP pmf</programlisting>
  as above, except that the third argument gives the offset of the base
  class in virtual function tables such as <emphasis>vtbl B::A</emphasis>.  For pure
  virtual functions the function pointer in this token is given by:
  <programlisting language="TDF">
~cpp.vtab.pure : () -&gt; EXP PROC</programlisting>
  In the default implementation this gives a function
  <code>__TCPPLUS_pure</code> which just calls <code>abort</code>.
  </para>
  <para>
  To avoid duplicate copies of virtual function tables and run-time
  type information structures being created, the ARM algorithm is used.
  The virtual function table and run-time type information structure
  for a class are defined in the module containing the definition of
  the first non-inline, non-pure virtual function declared in that class.
  If such a function does not exist then duplicate copies are created
  in every module which requires them.  In the former case the virtual
  function table will have an <link linkend="other">external tag name</link>;
  in the latter case it will be an internal tag.  This scheme can be
  overridden using the <code>-jv</code> command-line option, which causes
  local virtual function tables to be output for all classes.
  </para>
  <para>
  Note that the discussion above applies to both simple virtual function
  tables, such as <emphasis>vtbl B</emphasis> above, and to those arising from base
  classes, such as <emphasis>vtbl B::A</emphasis>.  <A id="override">We are now
  in a position to precisely determine when <emphasis>vtbl B::A</emphasis> is an initial
  segment of <emphasis>vtbl B</emphasis> and hence can be eliminated</A>.  Firstly,
  <emphasis>A</emphasis> must be the first direct base class of <emphasis>B</emphasis> and cannot
  be virtual.  This is to ensure both that there are no virtual functions
  in <emphasis>vtbl B</emphasis> before those inherited from <emphasis>A</emphasis>, and that the
  corresponding base class conversion is trivial so that the pointers
  to function members of <emphasis>B</emphasis> comprising the virtual function table
  can be equally regarded as pointers to function members of <emphasis>A</emphasis>.
  The second requirement is that if a virtual function for <emphasis>A</emphasis>,
  <emphasis>f</emphasis>, is overridden in <emphasis>B</emphasis> then the return type for <emphasis>B::f</emphasis>
  cannot differ from the return type for <emphasis>A::f</emphasis> by a non-trivial
  conversion (recall that ISO C++ allows the return types to differ
  by a base class conversion).  In the non-trivial conversion case the
  function entered in <emphasis>vtbl B::A</emphasis> needs to be, not <emphasis>B::f</emphasis>
  as in <emphasis>vtbl B</emphasis>, but a stub function which calls <emphasis>B::f</emphasis> and
  converts its return value to the return type of <emphasis>A::f</emphasis>.
  </para>

<section>
	<title>Calling virtual functions</title>
  <para>
  The virtual function call mechanism is implemented using the token:
  <programlisting language="TDF">
~cpp.vtab.func : ( EXP ppvt, SIGNED_NAT ) -&gt; EXP ppmf</programlisting>
  which has as its arguments a reference to the <emphasis>vptr</emphasis> field of
  the object the function is to be called for, and the number of the
  virtual function to be called.  It returns a reference to the corresponding
  pointer to function member within the object's virtual function table.
  The function is then called by extracting the base class offset to
  be added, and the function to be called, from this reference using
  the tokens:
  <programlisting language="TDF">
~cpp.pmf.delta : ( ALIGNMENT a, EXP ppmf ) -&gt; EXP OFFSET ( a, a )
~cpp.pmf.func : ( EXP ppmf ) -&gt; EXP PROC</programlisting>
  described as part of the <link linkend="ptr_mem_func">pointer to function
  member call mechanism</link> above.
  </para>
</section>
  </section>

  <section id="rtti">
    <title>Run-time type information</title>
  <para>
  Each C++ type can be associated with a run-time type information structure
  giving information about that type.  These type information structures
  have shape given by the token:
  <programlisting language="TDF">
~cpp.typeid.type : () -&gt; SHAPE</programlisting>
  which corresponds to the representation for the standard type
  <code>std::type_info</code> declared in the header
  <code>&lt;typeinfo&gt;</code>.  Each type information structure consists
  of a tag number, giving information on the kind of type represented,
  a string literal, giving the name of the type, and a pointer to a
  list of base type information structures.  These are combined to give
  a type information structure using the token:
  <programlisting language="TDF">
~cpp.typeid.make : ( SIGNED_NAT, EXP, EXP ) -&gt; EXP ti</programlisting>
  Each base type information structure has shape given by the token:
  <programlisting language="TDF">
~cpp.baseid.type : () -&gt; SHAPE</programlisting>
  It consists of a pointer to a type information structure, an expression
  used to describe the offset of a base class, a pointer to the next
  base type information structure in the list, and two integers giving
  information on type qualifiers etc.  These are combined to give a
  base type information structure using the token:
  <programlisting language="TDF">
~cpp.baseid.make : ( EXP, EXP, EXP, SIGNED_NAT, SIGNED_NAT ) -&gt; EXP bi</programlisting>
  </para>
  <para>
  The following table gives the various tag numbers used in type information
  structures plus a list of the base type information structures associated
  with each type.  Macros giving these tag numbers are provided in the
  default implementation in a header, <code>interface.h</code>, which
  is shared by the C++ producer.
  </para>
  <para>

  <table>
  <tr><th>Type</th>
  <th>Form</th>
  <th>Tag</th>
  <th>Base information</th>
  </tr>
  <tr><td>integer</td>
  <td>-</td>
  <td>0</td>
  <td>-</td>
  </tr>
  <tr><td>floating point</td>
  <td>-</td>
  <td>1</td>
  <td>-</td>
  </tr>
  <tr><td>void</td>
  <td>-</td>
  <td>2</td>
  <td>-</td>
  </tr>
  <tr><td>class or struct</td>
  <td>class T</td>
  <td>3</td>
  <td>[base,access,virtual], ....</td>
  </tr>
  <tr><td>union</td>
  <td>union T</td>
  <td>4</td>
  <td>-</td>
  </tr>
  <tr><td>enumeration</td>
  <td>enum T</td>
  <td>5</td>
  <td>-</td>
  </tr>
  <tr><td>pointer</td>
  <td>cv T *</td>
  <td>6</td>
  <td>[T,cv,0]</td>
  </tr>
  <tr><td>reference</td>
  <td>cv T &amp;</td>
  <td>7</td>
  <td>[T,cv,0]</td>
  </tr>
  <tr><td>pointer to member</td>
  <td>cv T S::*</td>
  <td>8</td>
  <td>[S,0,0], [T,cv,0]</td>
  </tr>
  <tr><td>array</td>
  <td>cv T [n]</td>
  <td>9</td>
  <td>[T,cv,n]</td>
  </tr>
  <tr><td>bitfield</td>
  <td>cv T : n</td>
  <td>10</td>
  <td>[T,cv,n]</td>
  </tr>
  <tr><td>C++ function</td>
  <td>cv T ( S1, ...., Sn )</td>
  <td>11</td>
  <td>[T,cv,0], [S1,0,0], ...., [Sn,0,0]</td>
  </tr>
  <tr><td>C function</td>
  <td>cv T ( S1, ...., Sn )</td>
  <td>12</td>
  <td>[T,cv,0], [S1,0,0], ...., [Sn,0,0]</td>
  </tr>
  </table>

  </para>
  <para>
  In the form column <code>cv T</code> is used to denote not only the
  normal cv-qualifiers but, when <code>T</code> is a function type,
  the member function cv-qualifiers.  Arrays with an unspecified bound
  are treated as if their bound was zero.  Functions with ellipsis are
  treated as if they had an extra parameter of a dummy type named
  <code>...</code> (see below).  Note the distinction between C++ and
  C function types.
  </para>
  <para>
  Each base type information structure is described as a triple consisting
  of a type and two integers.  One of these integers may be used to
  encode a type qualifier, <code>cv</code>, as follows:
  </para>
  <para>

  <table>
  <tr><th>Qualifier</th>   <th>Encoding</th>
  </tr>
  <tr><td>none</td>  <td>0</td>
  </tr>
  <tr><td>const</td>  <td>1</td>
  </tr>
  <tr><td>volatile</td> <td>2</td>
  </tr>
  <tr><td>const volatile</td><td>3</td>
  </tr>
  </table>

  </para>
  <para>
  The base type information for a class consists of information on each
  of its direct base classes.  The includes the offset of this base
  within the class (for a virtual base class this is the offset of the
  corresponding
  <emphasis>ptr</emphasis> field), whether the base is virtual (1) or not (0), and
  the base class access, encoded as follows:
  </para>
  <para>

  <table>
  <tr><th>Access</th>   <th>Encoding</th>
  </tr>
  <tr><td>public</td> <td>0</td>
  </tr>
  <tr><td>protected</td> <td>1</td>
  </tr>
  <tr><td>private</td> <td>2</td>
  </tr>
  </table>

  </para>
  <para>
  For example, the run-time type information structures for the classes
  declared in the <link linkend="diamond">diamond lattice</link> above can be
  represented as follows:

	<figure>
		<title>Type ID D</title>

		<graphic fileref="images/rttiD.png"/>
	</figure>

  </para>

<section>
	<title>Defining run-time type information structures</title>
  <para>
  For built-in types, the run-time type information structure may be
  referenced by the token:
  <programlisting language="TDF">
~cpp.typeid.basic : ( SIGNED_NAT ) -&gt; EXP pti</programlisting>
  where the argument gives the encoding of the type as given in the
  following table:
  </para>

  <table>
  <tr><th>Type</th>   <th>Encoding</th>
  <th>Type</th>   <th>Encoding</th>
  </tr>
  <tr><td>char</td>  <td>0</td>
  <td>unsigned long</td> <td>11</td>
  </tr>
  <tr><td>(error)</td> <td>1</td>
  <td>float</td>  <td>12</td>
  </tr>
  <tr><td>void</td>  <td>2</td>
  <td>double</td> <td>13</td>
  </tr>
  <tr><td>(bottom)</td> <td>3</td>
  <td>long double</td> <td>14</td>
  </tr>
  <tr><td>signed char</td> <td>4</td>
  <td>wchar_t</td> <td>16</td>
  </tr>
  <tr><td>signed short</td> <td>5</td>
  <td>bool</td>  <td>17</td>
  </tr>
  <tr><td>signed int</td> <td>6</td>
  <td>(ptrdiff_t)</td> <td>18</td>
  </tr>
  <tr><td>signed long</td> <td>7</td>
  <td>(size_t)</td> <td>19</td>
  </tr>
  <tr><td>unsigned char</td> <td>8</td>
  <td>(...)</td>  <td>20</td>
  </tr>
  <tr><td>unsigned short</td><td>9</td>
  <td>signed long long</td>
  <td>23</td>
  </tr>
  <tr><td>unsigned int</td> <td>10</td>
  <td>unsigned long long</td>
  <td>27</td>
  </tr>
  </table>

  <para>
  Note that the encoding for the basic integral types is the same as
  that
  <link linkend="arith">given above</link>.  The other types are assigned to
  unused values.  Note that the encodings for <code>ptrdiff_t</code>
  and
  <code>size_t</code> are not used, instead that for their implementation
  is used (using the standard tokens <code>ptrdiff_t</code> and
  <code>size_t</code>).  The encodings for <code>bool</code> and
  <code>wchar_t</code> are used because they are conceptually distinct
  types even though they are implemented as one of the basic integral
  types.  The type labelled <code>...</code> is the dummy used in the
  representation of ellipsis functions.  The default implementation
  uses an array of type information structures, <code>__TCPPLUS_typeid</code>,
  to implement <code>~cpp.typeid.basic</code>.
  </para>
  <para>
  The run-time type information structures for classes are defined in
  the same place as their <link linkend="vtable">virtual function tables</link>.
  Other run-time type information structures are defined in whatever
  modules require them.  In the former case the type information structure
  will have an <link linkend="other">external tag name</link>; in the latter
  case it will be an internal tag.
  </para>
</section>

<section>
	<title>Accessing run-time type information</title>
  <para>
  The primary means of accessing the run-time type information for an
  object is using the <code>typeid</code> construct.  In cases where
  the operand type can be determined statically, the address of the
  corresponding type information structure is returned.  In other cases
  the token:
  <programlisting language="TDF">
~cpp.typeid.ref : ( EXP ppvt ) -&gt; EXP pti</programlisting>
  is used, where the argument gives a reference to the <emphasis>vptr</emphasis> field
  of the object being checked.  From this information it is trivial
  to trace the corresponding type information.
  </para>
  <para>
  Another means of querying the run-time type information for an object
  is using the <code>dynamic_cast</code> construct.  When the result
  cannot be determined statically, this is implemented using the token:
  <programlisting language="TDF">
~cpp.dynam.cast : ( EXP ppvt, EXP pti ) -&gt; EXP pv</programlisting>
  where the first expression gives a reference to the <emphasis>vptr</emphasis> field
  of the object being cast and the second gives the run-time type information
  for the type being cast to.  In the default implementation this token
  is implemented by the procedure <code>__TCPPLUS_dynamic_cast</code>.
  The key point to note is that the virtual function table contains
  the offset, <emphasis>voff</emphasis>, of the <emphasis>vptr</emphasis> field from the start of
  the most complete object.  Thus it is possible to find the address
  of the most complete object.  The run-time type information contains
  enough information to determine whether this object has a sub-object
  of the type being cast to, and if so, how to find the address of this
  sub-object.  The result is returned as a <code>void *</code>, with
  the null pointer indicating that the conversion is not possible.
  </para>
  </section>
  </section>

  <section id="dynamic-initialisation">
    <title>Dynamic initialisation</title>
  <para>
  The dynamic initialisation of variables with static storage duration
  in C++ is implemented by means of the TDF <code>initial_value</code>
  construct.  However in order for the producer to maintain control
  over the order of initialisation, rather than each variable being
  initialised separately using <code>initial_value</code>, a single
  expression is created which initialises all the variables in a module,
  and this initialiser expression is used to initialise a single dummy
  variable using <code>initial_value</code>.  Note that, while this
  enables the variables within a single module to be initialised in
  the order in which they are defined, the order of initialisation between
  different modules is unspecified.
  </para>
  <para>
  The implementation needs to keep a list of those variables with static
  storage duration which have been initialised so that it can call the
  destructors for these objects at the end of the program. This is done
  by declaring a variable of shape:
  <programlisting language="TDF">
~cpp.destr.type : () -&gt; SHAPE</programlisting>
  for each such object with a non-trivial destructor.  Each element
  of an array is considered a distinct object.  Immediately after the
  variable has been initialised the token:
  <programlisting language="TDF">
~cpp.destr.global : ( EXP pd, EXP POINTER c, EXP PROC ) -&gt; EXP TOP</programlisting>
  is called to add the variable to the list of objects to be destroyed.
  The first argument is the address of the dummy variable just declared,
  the second is the address of the object to be destroyed, and the third
  is the destructor to be used.  In this way a list giving the objects
  to be destroyed, and the order in which to destroy them, is built
  up.  Note that partially constructed objects are destroyed within
  their constructors (see <link linkend="partial">above</link>) so that only
  completely constructed objects need to be considered.
  </para>
  <para>
  The implementation also needs to ensure that it calls the destructors
  in this list at the end of the program, including calls of
  <code>exit</code>.  This is done by calling the token:
  <programlisting language="TDF">
~cpp.destr.init : () -&gt; EXP TOP</programlisting>
  at the start of each <code>initial_value</code> construct.  In the
  default implementation this uses <code>atexit</code> to register a
  function, <code>__TCPPLUS_term</code>, which calls the destructors.
  To aid alternative implementations the token:
  <programlisting language="TDF">
~cpp.start : () -&gt; EXP TOP</programlisting>
  is called at the start of the <code>main</code> function, however
  this has no effect in the default implementation.
  </para>
  </section>

  <section id="except">
    <title>Exception handling</title>
  <para>
  Conceptually, exception handling can be described in terms of the
  following diagram:

	<figure>
		<title>Try Stack</title>

		<graphic fileref="images/try.png"/>
	</figure>

  At any point in the execution of the program there is a stack of currently
  active <code>try</code> blocks and currently active local variables.
  A
  <code>try</code> block is pushed onto the stack as it is entered and
  popped from the stack when it is left (whether directly or via a jump).
  A local variable with a non-trivial destructor is pushed onto the
  stack just after its constructor has been called at the start of its
  scope, and popped from the stack just before its destructor is called
  at the end of its scope (including before jumps out of its scope).
  Each element of an array is considered a separate object.  Each <code>try</code>
  block has an associated list of handlers.  Each local variable has
  an associated destructor.
  </para>
  <para>
  Provided no exception is thrown this stack grows and shrinks in a
  well-behaved manner as execution proceeds.  When an exception is thrown
  an exception manager is invoked to find a matching exception handler.
  The exception manager proceeds to execute a loop to unwind the stack
  as follows.  If the stack is empty then the exception cannot be caught
  and
  <code>std::terminate</code> is called.  Otherwise the top element
  is popped from the stack.  If this is a local variable then the associated
  destructor is called for the variable.  If the top element is a
  <code>try</code> block then the current exception is compared in turn
  to each of the associated handlers.  If a match is found then execution
  jumps to the handler body, otherwise the exception manager continues
  to the next element of the stack.
  </para>
  <para>
  Note that this description is purely conceptual.  There is no need
  for exception handling to be implemented by a stack in this way (although
  the default implementation uses a similar technique).  It does however
  serve to illustrate the various stages which must exist in any implementation.
  </para>

<section>
	<title>Try blocks</title>
  <para>
  At the start of a <code>try</code> block a variable of shape:
  <programlisting language="TDF">
~cpp.try.type : () -&gt; SHAPE</programlisting>
  is declared corresponding to the stack element for this block.  This
  is then initialised using the token:
  <programlisting language="TDF">
~cpp.try.begin : ( EXP ptb, EXP POINTER fa, EXP POINTER ca ) -&gt; EXP TOP</programlisting>
  </para>
  where the first argument is a pointer to this variable, the second
  argument is the TDF <code>current_env</code> construct, and the third
  argument is the result of the TDF <code>make_local_lv</code> construct
  on the label which is used to mark the first handler associated with
  the block.  Note that the last two arguments enable a TDF
  <code>long_jump</code> construct to be applied to transfer control
  to the first handler.
  <para>
  When control exits from a <code>try</code> block, whether by reaching
  the end of the block or jumping out of it, the block is removed from
  the stack using the token:
  <programlisting language="TDF">
~cpp.try.end : ( EXP ptb ) -&gt; EXP TOP</programlisting>
  where the argument is a pointer to the <code>try</code> block variable.
  </para>
</section>

<section>
  <title>Local variables</title>
  <para>
  The technique used to add a local variable with a non-trivial destructor
  to the stack is similar to that used in the dynamic initialisation
  of global variables.  A local variable of shape <code>~cpp.destr.type</code>
  is declared at the start of the variable scope.  This is initialised
  just after the constructor for the variable is called using the token:
  <programlisting language="TDF">
~cpp.destr.local : ( EXP pd, EXP POINTER c, EXP PROC ) -&gt; EXP TOP</programlisting>
  where the first argument is a pointer to the variable being initialised,
  the  second is a pointer to the local variable to be destroyed, and
  the third is the destructor to be called.  At the end of the variable
  scope, just before its destructor is called, the token:
  <programlisting language="TDF">
~cpp.destr.end : ( EXP pd ) -&gt; EXP TOP</programlisting>
  where the argument is a pointer to destructor variable, is called
  to remove the local variable destructor from the stack.  Note that
  partially constructed objects are destroyed within their constructors
  (see
  <link linkend="partial">above</link>) so that only completely constructed
  objects need to be considered.
  </para>
  <para>
  In cases where the local variable may be conditionally initialised
  (for example a temporary variable in the second operand of a <code>||</code>
  operation) the local variable of shape <code>~cpp.destr.type</code>
  is initialised to the value given by the token:
  <programlisting language="TDF">
~cpp.destr.null : () -&gt; EXP d</programlisting>
  (normally it is  left uninitialised).  Before the destructor for this
  variable is called the value of the token:
  <programlisting language="TDF">
~cpp.destr.ptr : ( EXP pd ) -&gt; EXP POINTER c</programlisting>
  is tested.  If <code>~cpp.destr.local</code> has been called for this
  variable then this token returns a pointer to the variable, otherwise
  it returns a null pointer.  The token <code>~cpp.destr.end</code>
  and the destructor are only called if this token indicates that the
  variable has been initialised.
  </para>
</section>

<section>
  <title>Throwing an exception</title>
  <para>
  When a <code>throw</code> expression with an argument is encountered
  a number of steps performed.  Firstly, space is allocated to hold
  the exception value using the token:
  <programlisting language="TDF">
~cpp.except.alloc : ( EXP VARIETY size_t ) -&gt; EXP pv</programlisting>
  the argument of which gives the size of the value.  The space allocated
  is returned as an expression of type <code>void *</code>.  Secondly,
  the exception value is copied into the space allocated, using a copy
  constructor if appropriate.  Finally the exception is raised using
  the token:
  <programlisting language="TDF">
~cpp.except.throw : ( EXP pv, EXP pti, EXP PROC ) -&gt; EXP BOTTOM</programlisting>
  The first argument gives the pointer to the exception value, returned
  by
  <code>~cpp.except.alloc</code>, the second argument gives a pointer
  to the run-time type information for the exception type, and the third
  argument gives the destructor to be called to destroy the exception
  value (if any). This token sets the current exception to the given
  values and invokes the exception manager as above.
  </para>
  <para>
  A <code>throw</code> expression without an argument results in a call
  to the token:
  <programlisting language="TDF">
~cpp.except.rethrow : () -&gt; EXP BOTTOM</programlisting>
  which re-invokes the exception manager with the current exception.
  If there is no current exception then the implementation should call
  <code>std::terminate</code>.
  </para>
</section>

<section>
  <title>Handling an exception</title>
  <para>
  The exception manager proceeds to find an exception in the manner
  described above, unwinding the stack and calling destructors for local
  variables.  When a <code>try</code> block is popped from the stack
  a TDF <code>long_jump</code> is applied to transfer control to its
  list of handlers.  For each handler in turn it is checked whether
  the handler can catch the current exception.  For <code>...</code>
  handlers this is always true; for other handlers it is checked using
  the token:
  <programlisting language="TDF">
~cpp.except.catch : ( EXP pti ) -&gt; EXP VARIETY int</programlisting>
  where the argument is a pointer to the run-time type information for
  the handler type.  This token gives 1 if the exception is caught by
  this handler, and 0 otherwise.  If the exception is not caught by
  the handler then the next handler is checked, until there are no more
  handlers associated with the <code>try</code> block.  In this case
  control is passed back to the exception manager by re-throwing the
  current exception using <code>~cpp.except.rethrow</code>.
  </para>
  <para>
  If an exception is caught by a handler then a number of steps are
  performed. Firstly, if appropriate, the handler variable is initialised
  by copying the current exception value.  A pointer to the current
  exception value can be obtained using the token:
  <programlisting language="TDF">
~cpp.except.value : () -&gt; EXP pv</programlisting>
  Once this initialisation is complete the token:
  <programlisting language="TDF">
~cpp.except.caught : () -&gt; EXP TOP</programlisting>
  is called to indicate that the exception has been caught.  The handler
  body is then executed.  When control exits from the handler, whether
  by reaching the end of the handler or by jumping out of it, the token:
  <programlisting language="TDF">
~cpp.except.end : () -&gt; EXP TOP</programlisting>
  is called to indicate that the exception has been completed.  Note
  that the implementation should call the destructor for the current
  exception and free the space allocated by <code>~cpp.except.alloc</code>
  at this point. Execution then continues with the statement following
  the handler.
  </para>
  <para>
  To conclude, the TDF generated for a <code>try</code> block and its
  associated list of handlers has the form:
  <programlisting language="TDF">
variable (
    long_jump_access,
    stack_tag,
    make_value ( ~cpp.try.type ),
    conditional (
	handler_label,
	sequence (
	    ~cpp.try.begin (
		obtain_tag ( stack_tag ),
		current_env,
		make_local_lv ( handler_label ) ),
		<emphasis>try-block-body</emphasis>,
		~cpp.try.end ),
	    conditional (
		catch_label_1,
		sequence (
		    integer_test (
			not_equal,
			catch_label_1,
			~cpp.except.catch (
			    <emphasis>handler-1-typeid</emphasis> ) )
		    variable (
			handler_tag_1,
			<emphasis>handler-1-init</emphasis> (
			    ~cpp.except.value ),
			sequence (
			    ~cpp.except.caught,
			    <emphasis>handler-1-body</emphasis> ) )
		    ~cpp.except.end )
		conditional (
		    catch_label_2,
		    <emphasis>further-handlers</emphasis>,
		    ~cpp.except.rethrow ) ) ) )</programlisting>
  </para>
  <para>
  Note that for a local variable to maintain its previous value when
  an  exception is caught in this way it is necessary to declare it
  using the TDF <code>long_jump_access</code> construct.  Any local
  variable which contains a <code>try</code> block in its scope is declared
  in this way.
  </para>
  <para>
  To aid implementations in the writing of exception managers the following
  standard tokens are provided:
  <programlisting language="TDF">
~cpp.ptr.code : () -&gt; SHAPE POINTER ca
~cpp.ptr.frame : () -&gt; SHAPE POINTER fa
~cpp.except.jump : ( EXP POINTER fa, EXP POINTER ca ) -&gt; EXP BOTTOM</programlisting>
  These give the shape of the TDF <code>make_local_lv</code> construct,
  the shape of the TDF <code>current_env</code> construct, and direct
  access to the TDF <code>long_jump</code> access.  The exception manager
  in the default implementation is a function called <code>__TCPPLUS_throw</code>.
  </para>
</section>

<section>
  <title>Exception specifications</title>
  <para>
  If a function is declared with an exception specification then extra
  code needs to be generated in the function definition to catch any
  unexpected exceptions thrown by the function and to call <code>std::unexpected
  </code>. Since this is a potentially high overhead for small functions,
  this extra code is not generated if it can be proved that such unexpected
  exceptions can never be thrown (the analysis is essentially the same
  as that in the
  <A HREF="pragma.html#exception">exception analysis</A> check).
  </para>
  <para>
  The implementation of exception specification is to enclose the entire
  function definition in a <code>try</code> block.  The handler for
  this block uses <code>~cpp.except.catch</code> to check whether the
  current exception can be caught by any of the types listed in the
  exception specification.  If so the current exception is re-thrown.
  If none of these types catch the current exception then the token:
  <programlisting language="TDF">
~cpp.except.bad : ( SIGNED_NAT ) -&gt; EXP TOP</programlisting>
  is called.  The argument is 1 if the exception specification includes
  the special type <code>std::bad_exception</code>, and 0 otherwise.
  The implementation should call <code>std::unexpected</code>, but how
  any exceptions thrown during this call are to be handled depends on
  the value of the argument.
  </para>
  </section>
  </section>

  <section id="mangle">
    <title>Mangled identifier names</title>
  <para>
  In a similar fashion to other C++ compilers, the C++ producer needs
  a method of mapping C++ identifiers to a form suitable for further
  processing, namely TDF tag names.  This mangled name contains an encoding
  of the identifier name, its parent namespace or class and its type.
  Identifiers with C linkage are not mangled.  The producer contains
  a built-in <A HREF="man.html#unmangle">name unmangler</A>
  which performs the reverse operation of transforming the mangled form
  of an identifier name back to the underlying identifier.  This can
  be useful when analysing system linker errors.
  </para>
  <para>
  Note that the type of an identifier forms part of its mangled name
  not only for functions, but also for variables.  Many other compilers
  do not mangle variable names, however the ISO C++ rules on namespaces
  and variables with C linkage make it necessary (this can be suppressed
  using the <code>-j-n</code> command-line option).  Declaring the language
  linkage of a variable inconsistently can therefore lead to linking
  errors with the C++ producer which are not detected by other compilers.
  A common example is:
  <programlisting language="C++">
extern int errno ;</programlisting>
  which, leaving aside whether <code>errno</code> is actually an external
  variable, should be:
  <programlisting>
extern &quot;C&quot; int errno ;</programlisting>
  </para>
  <para>
  As described above, the mangled form of an identifier has three components;
  the identifier name, the identifier namespace and the identifier type.
  Two underscores (<code>__</code>) are used to separate the name component
  from the namespace and type components.  The mangling scheme used
  is based on that described in the ARM.  The description below is not
  complete; the mangling and unmangling routines themselves should be
  consulted for a complete description.
  </para>

<section>
	<title>Mangling identifier names</title>
  <para>
  Simple identifier names are mapped to themselves.  Unicode characters
  of the forms <code>\u</code><emphasis>xxxx</emphasis> and <code>\U</code><emphasis>xxxxxxxx</emphasis>
  are mapped to <code>__k</code><emphasis>xxxx</emphasis> and <code>__K</code><emphasis>xxxxxxxx</emphasis>
  respectively, where the hex digits are output in their canonical lower-case
  form.  Constructors are mapped to <code>__ct</code> and destructors
  to <code>__dt</code>.  Conversions functions are mapped to
  <code>__op</code><emphasis>type</emphasis> where <emphasis>type</emphasis> is the mangled form
  of the conversion type.  Overloaded operator functions,
  <code>operator@</code>, are mapped as follows:
  </para>

  <table>
  <tr><th>Operator</th>   <th>Mapping</th>
  <th>Operator</th>   <th>Mapping</th>
  <th>Operator</th>   <th>Mapping</th>
  </tr>
  <tr><td>&amp;</td>  <td>__ad</td>
  <td>&amp;=</td> <td>__aad</td>
  <td>[]</td>  <td>__vc</td>
  </tr>
  <tr><td>-&gt;</td>  <td>__rf</td>
  <td>-&gt;*</td> <td>__rm</td>
  <td>=</td>  <td>__as</td>
  </tr>
  <tr><td>,</td>  <td>__cm</td>
  <td>~</td>  <td>__co</td>
  <td>/</td>  <td>__dv</td>
  </tr>
  <tr><td>/=</td>  <td>__adv</td>
  <td>==</td>  <td>__eq</td>
  <td>()</td>  <td>__cl</td>
  </tr>
  <tr><td>&gt;</td>  <td>__gt</td>
  <td>&gt;=</td>  <td>__ge</td>
  <td>&lt;</td>  <td>__lt</td>
  </tr>
  <tr><td>&lt;=</td>  <td>__le</td>
  <td>&amp;&amp;</td> <td>__aa</td>
  <td>||</td>  <td>__oo</td>
  </tr>
  <tr><td>&lt;&lt;</td> <td>__ls</td>
  <td>&lt;&lt;=</td> <td>__als</td>
  <td>-</td>  <td>__mi</td>
  </tr>
  <tr><td>-=</td>  <td>__ami</td>
  <td>--</td>  <td>__mm</td>
  <td>!</td>  <td>__nt</td>
  </tr>
  <tr><td>!=</td>  <td>__ne</td>
  <td>|</td>  <td>__or</td>
  <td>|=</td>  <td>__aor</td>
  </tr>
  <tr><td>+</td>  <td>__pl</td>
  <td>+=</td>  <td>__apl</td>
  <td>++</td>  <td>__pp</td>
  </tr>
  <tr><td>%</td>  <td>__md</td>
  <td>%=</td>  <td>__amd</td>
  <td>&gt;&gt;</td> <td>__rs</td>
  </tr>
  <tr><td>&gt;&gt;=</td> <td>__ars</td>
  <td>*</td>  <td>__ml</td>
  <td>*=</td>  <td>__aml</td>
  </tr>
  <tr><td>^</td>  <td>__er</td>
  <td>^=</td>  <td>__aer</td>
  <td>delete</td> <td>__dl</td>
  </tr>
  <tr><td>delete []</td> <td>__vd</td>
  <td>new</td>  <td>__nw</td>
  <td>new []</td> <td>__vn</td>
  </tr>
  <tr><td>?:</td>  <td>__cn</td>
  <td>:</td>  <td>__cs</td>
  <td>::</td>  <td>__cc</td>
  </tr>
  <tr><td>.</td>  <td>__df</td>
  <td>.*</td>  <td>__dm</td>
  <td>abs</td>  <td>__ab</td>
  </tr>
  <tr><td>max</td>  <td>__mx</td>
  <td>min</td>  <td>__mn</td>
  <td>sizeof</td> <td>__sz</td>
  </tr>
  <tr><td>typeid</td> <td>__td</td>
  <td>vtable</td> <td>__tb</td>
  <td>-</td>  <td>-</td>
  </tr>
  </table>

  <para>
  Note that this table contains a number of operators which are not
  part of C++ or cannot be overloaded in C++.  These are used in the
  representation of target dependent integer constants.
  </para>
</section>

<section>
  <title>Mangling namespace names</title>
  <para>
  The global namespace is mapped to an empty string.  Simple namespace
  and class names are mapped as above, but are preceded by a series
  of decimal digits giving the length of the mangled name.  Nested namespaces
  and classes are represented by a sequence of such namespace names,
  preceded by the number of elements in the sequence.  This takes the
  form <code>Q</code><emphasis>digit</emphasis> if there are less than 10 elements,
  or
  <code>Q_</code><emphasis>digits</emphasis><code>_</code> if there are more than
  10. Note that members of anonymous classes or namespaces are local
  to their translation unit, and so do not have external tag names.
  </para>
</section>

<section>
  <title>Mangling types</title>
  <para>
  The mangling of types is essentially similar to that used in the
  <A HREF="dump.html">symbol table dump</A> format.  The type used in
  the mangled name for an identifier ignores the return type for a function
  and ignores the most significant bound for an array.
  </para>
  <para>
  The built-in types are mapped in precisely the same way as in the
  <A HREF="dump.html#built-in">symbol table dump</A>.  Class and enumeration
  types are mapped to their type names mangled in the same way as the
  namespace names above.  The exception to this is that in a class member,
  the parent class is mapped to <code>X</code>.
  </para>
  <para>
  The composite types are again mapped in a similar fashion to that
  in the <A HREF="dump.html#composite">dump file</A>.  For example,
  <code>PCc</code> represents <code>const char *</code>.  The only difficult
  case concerns function parameter types where the ARM
  <code>T</code> and <code>N</code> encodings are used for duplicate
  parameter types.  The function return type is included in the mangled
  form except for function identifier types.  In the cases where the
  identifier is known always to represent a function (constructors,
  destructors etc.) the initial <code>F</code>
  indicating a function type is also omitted.
  </para>
  <para>
  The types of template functions and classes are represented by the
  underlying template and the template arguments giving rise to the
  instance.  Template classes are preceded by <code>t</code>; template
  functions are preceded by <code>G</code> rather than <code>F</code>.
  Type arguments are represented by <code>Z</code> followed by the type
  value; non-type arguments are represented by the argument type followed
  by the argument value.  In the underlying type the template parameters
  are represented by <code>m0</code>, <code>m1</code> etc. An alternative
  scheme, in which the mangled form of a template function includes
  the type of that instance, rather than the underlying template, can
  be enabled using the <code>-j-f</code>
  command-line option.
  </para>
</section>

<section id="other">
  <title>Other mangled names</title>
  <para>
  The <link linkend="vtable">virtual function table</link> for a class, when
  this is a variable with external linkage, is named <code>__vt__</code><emphasis>type
  </emphasis>, where <emphasis>type</emphasis> is the mangled form of the class name.  The
  virtual function table for a base class is named <code>__vt__</code><emphasis>base</emphasis>
  where <emphasis>base</emphasis> is a sequence of mangled class names specifying
  the base class.  The <link linkend="rtti">run-time type information structure</link>
  for a type, when this is a variable with external linkage, is named
  <code>__ti__</code><emphasis>type</emphasis>, where <emphasis>type</emphasis> is the mangled form
  of the type name.
  </para>
</section>

<section>
	<title>Mangled name examples</title>
  <para>
  The following gives some examples of the name mangling scheme:
  <programlisting language="C++">
class A {
    static int a ;			// a__1Ai
public :
    A () ;				// __ct__1A
    A ( int ) ;				// __ct__1Ai
    A ( const A &amp; ) ;			// __ct__1ARCX
    virtual ~A () ;			// __dt__1A
    operator bool () ;			// __opb__1A
    bool operator! () ;			// __nt__1A
} ;

// virtual function table	__vt__1A
// run-time type information	__ti__1A

int f ( A *, int, A * ) ;		// f__FP1AiT1
int b = 2 ;				// b__i
int c [3] ;				// c__A_i

namespace N {
    int *p = 0 ;			// p__1NPi
}</programlisting>
  </para>
  </section>
  </section>
  </section>
  </chapter>

  <chapter>
	<title>C++ Producer Guide: Style guide</title>

  <section>
    <title>Source code organisation</title>
  <para>
  This section describes the basic organisation of the source code for
  the C++ producer.This includes the division
  of the code into separate modules and the type system conventions.
  </para>

  <section id="src">
    <title>Source code modules</title>
  <para>
  For convenience, the source code is divided between a number of directories:
  <itemizedlist>

  <listitem>The base directory contains only the module containing the
  <code>main</code> function, the basic type descriptions and the
  <code>Makefile</code>.
  </listitem>
  <listitem>The directories <code>obj_c</code> and <code>obj_tok</code> contain
  respectively the C and <code>#pragma token</code> headers generated
  from the type algebra by <A HREF="../utilities/calc.html"><code>calculus</code>
  </A>.  The directory <code>obj_templ</code> contains certain <code>calculus
  </code>
  template files.
  </listitem>
  <listitem>The directory <code>utility</code> contains routines for such
  utility operations as memory allocation and error reporting, including
  the <A HREF="error.html">error catalogue</A>.
  </listitem>
  <listitem>The directory <code>parse</code> contains routines concerned with
  parsing and preprocessing the input, including the
  <A HREF="../utilities/sid.html"><code>sid</code> grammar</A>.
  </listitem>
  <listitem>The directory <code>construct</code> contains routines for building
  up and analysing the internal representation of the parsed code.
  </listitem>
  <listitem>The directory <code>output</code> contains routines for outputting
  the internal representation in various formats including as a
  <A HREF="tdf.html">TDF capsule</A>, a <A HREF="link.html">C++ spec
  file</A>, or a <A HREF="dump.html">symbol table dump file</A>.
  </listitem>
  </itemizedlist>
  </para>
  <para>
  Each module consists of a C source file, <code><emphasis>file</emphasis>.c</code>
  say, containing function definitions, and a corresponding header file
  <code><emphasis>file</emphasis>.h</code> containing the declarations of these functions.
  The header is included within its corresponding source file to check
  these declarations; it is protected against multiple inclusions by
  a macro of the form <code><emphasis>FILE</emphasis>_INCLUDED</code>. The header
  contains a brief comment describing the purpose of the module; each
  function in the source file contains a comment describing its purpose,
  its inputs and its output.
  </para>
  <para>
  The following table lists all the source modules in the C++ producer
  with a brief description of the purpose of each:
  </para>
  <para>

  <table>
  <tr><th>Module</th> <th>Directory</th>
  <th>Purpose</th>
  </tr>
  <tr><td>access</td> <td>construct</td>
  <td>member access control</td>
  </tr>
  <tr><td>allocate</td> <td>construct</td>
  <td><code>new</code> and <code>delete</code> expressions</td>
  </tr>
  <tr><td>assign</td> <td>construct</td>
  <td>assignment expressions</td>
  </tr>
  <tr><td>basetype</td> <td>construct</td>
  <td>basic type operations</td>
  </tr>
  <tr><td>buffer</td> <td>utility</td>
  <td>buffer reading and writing routines</td>
  </tr>
  <tr><td>c_class</td> <td>obj_c</td>
  <td><code>calculus</code> support routines</td>
  </tr>
  <tr><td>capsule</td> <td>output</td>
  <td>top-level TDF encoding routines</td>
  </tr>
  <tr><td>cast</td> <td>construct</td>
  <td>cast expressions</td>
  </tr>
  <tr><td>catalog</td> <td>utility</td>
  <td>error catalogue definition</td>
  </tr>
  <tr><td>char</td> <td>parse</td>
  <td>character sets</td>
  </tr>
  <tr><td>check</td> <td>construct</td>
  <td>expression checking</td>
  </tr>
  <tr><td>chktype</td> <td>construct</td>
  <td>type checking</td>
  </tr>
  <tr><td>class</td> <td>construct</td>
  <td>class and enumeration definitions</td>
  </tr>
  <tr><td>compile</td> <td>output</td>
  <td>TDF tag definition encoding routines</td>
  </tr>
  <tr><td>constant</td> <td>parse</td>
  <td>integer constant evaluation</td>
  </tr>
  <tr><td>construct</td> <td>construct</td>
  <td>constructors and destructors</td>
  </tr>
  <tr><td>convert</td> <td>construct</td>
  <td>standard type conversions</td>
  </tr>
  <tr><td>copy</td> <td>construct</td>
  <td>expression copying</td>
  </tr>
  <tr><td>debug</td> <td>utility</td>
  <td>development aids</td>
  </tr>
  <tr><td>declare</td> <td>construct</td>
  <td>variable and function declarations</td>
  </tr>
  <tr><td>decode</td> <td>output</td>
  <td>bitstream reading routines</td>
  </tr>
  <tr><td>derive</td> <td>construct</td>
  <td>base class graphs; inherited members</td>
  </tr>
  <tr><td>destroy</td> <td>construct</td>
  <td>garbage collection routines</td>
  </tr>
  <tr><td>diag</td> <td>output</td>
  <td>TDF diagnostic output routines</td>
  </tr>
  <tr><td>dump</td> <td>output</td>
  <td>symbol table dump routines</td>
  </tr>
  <tr><td>encode</td> <td>output</td>
  <td>bitstream writing routines</td>
  </tr>
  <tr><td>error</td> <td>utility</td>
  <td>error output routines</td>
  </tr>
  <tr><td>exception</td> <td>construct</td>
  <td>exception handling</td>
  </tr>
  <tr><td>exp</td> <td>output</td>
  <td>TDF expression encoding routines</td>
  </tr>
  <tr><td>expression</td> <td>construct</td>
  <td>expression processing</td>
  </tr>
  <tr><td>file</td> <td>parse</td>
  <td>low-level I/O routines</td>
  </tr>
  <tr><td>function</td> <td>construct</td>
  <td>function definitions and calls</td>
  </tr>
  <tr><td>hash</td> <td>parse</td>
  <td>hash table and identifier name routines</td>
  </tr>
  <tr><td>identifier</td> <td>construct</td>
  <td>identifier expressions</td>
  </tr>
  <tr><td>init</td> <td>output</td>
  <td>TDF initialiser expression encoding routines</td>
  </tr>
  <tr><td>initialise</td> <td>construct</td>
  <td>variable initialisers</td>
  </tr>
  <tr><td>instance</td> <td>construct</td>
  <td>template instances and specialisations</td>
  </tr>
  <tr><td>inttype</td> <td>construct</td>
  <td>integer and floating point type routines</td>
  </tr>
  <tr><td>label</td> <td>construct</td>
  <td>labels and jumps</td>
  </tr>
  <tr><td>lex</td> <td>parse</td>
  <td>lexical analysis</td>
  </tr>
  <tr><td>literal</td> <td>parse</td>
  <td>integer and string literals</td>
  </tr>
  <tr><td>load</td> <td>output</td>
  <td>C++ spec reading routines</td>
  </tr>
  <tr><td>macro</td> <td>parse</td>
  <td>macro expansion</td>
  </tr>
  <tr><td>main</td> <td>-</td>
  <td>main routine; command-line arguments</td>
  </tr>
  <tr><td>mangle</td> <td>output</td>
  <td>identifier name mangling</td>
  </tr>
  <tr><td>member</td> <td>construct</td>
  <td>member selector expressions</td>
  </tr>
  <tr><td>merge</td> <td>construct</td>
  <td>intermodule merge routines</td>
  </tr>
  <tr><td>namespace</td> <td>construct</td>
  <td>namespaces; name look-up</td>
  </tr>
  <tr><td>operator</td> <td>construct</td>
  <td>overloaded operators</td>
  </tr>
  <tr><td>option</td> <td>utility</td>
  <td>compiler options</td>
  </tr>
  <tr><td>overload</td> <td>construct</td>
  <td>overload resolution</td>
  </tr>
  <tr><td>parse</td> <td>parse</td>
  <td>low-level parser routines</td>
  </tr>
  <tr><td>pragma</td> <td>parse</td>
  <td><code>#pragma</code> directives</td>
  </tr>
  <tr><td>predict</td> <td>parse</td>
  <td>parser look-ahead routines</td>
  </tr>
  <tr><td>preproc</td> <td>parse</td>
  <td>preprocessing directives</td>
  </tr>
  <tr><td>print</td> <td>utility</td>
  <td>error argument printing routines</td>
  </tr>
  <tr><td>quality</td> <td>construct</td>
  <td>extra expression checks</td>
  </tr>
  <tr><td>redeclare</td> <td>construct</td>
  <td>variable and function redeclarations</td>
  </tr>
  <tr><td>rewrite</td> <td>construct</td>
  <td>inline member function definitions</td>
  </tr>
  <tr><td>save</td> <td>output</td>
  <td>C++ spec writing routines</td>
  </tr>
  <tr><td>shape</td> <td>output</td>
  <td>TDF shape encoding routines</td>
  </tr>
  <tr><td>statement</td> <td>construct</td>
  <td>statement processing</td>
  </tr>
  <tr><td>stmt</td> <td>output</td>
  <td>TDF statement encoding routines</td>
  </tr>
  <tr><td>struct</td> <td>output</td>
  <td>TDF structure encoding routines</td>
  </tr>
  <tr><td>syntax[0-9]*</td> <td>parse</td>
  <td><code>sid</code> parser output</td>
  </tr>
  <tr><td>system</td> <td>utility</td>
  <td>system dependent routines</td>
  </tr>
  <tr><td>table</td> <td>parse</td>
  <td>portability table reading</td>
  </tr>
  <tr><td>template</td> <td>construct</td>
  <td>template declarations and checks</td>
  </tr>
  <tr><td>throw</td> <td>output</td>
  <td>TDF exception handling encoding routines</td>
  </tr>
  <tr><td>tok</td> <td>output</td>
  <td>TDF standard tokens encoding</td>
  </tr>
  <tr><td>tokdef</td> <td>construct</td>
  <td>token definitions</td>
  </tr>
  <tr><td>token</td> <td>construct</td>
  <td>token declarations and expansion</td>
  </tr>
  <tr><td>typeid</td> <td>construct</td>
  <td>run-time type information</td>
  </tr>
  <tr><td>unmangle</td> <td>output</td>
  <td>identifier name unmangling</td>
  </tr>
  <tr><td>variable</td> <td>construct</td>
  <td>variable analysis</td>
  </tr>
  <tr><td>virtual</td> <td>construct</td>
  <td>virtual functions</td>
  </tr>
  <tr><td>xalloc</td> <td>utility</td>
  <td>memory allocation routines</td>
  </tr>
  </table>
  </para>
  </section>
  </section>

  <section>
    <title>Type system</title>
  <para>
  This section describes the type system used in the C++ producer. Unless
  otherwise stated the types are declared using the
  <A HREF="../utilities/calc.html"><code>calculus</code> tool</A> as
  part of the algebra, <code>c_class.alg</code>.  The design of this
  type algebra was clearly largely based on the concepts underlying
  the C++ language; however TDF provided an important influence, not
  merely as the intended target language, but also because of its clear
  presentation of essential language features.
  </para>


  <section id="primitive">
    <title>Primitive types</title>
  <para>
  The primitive types used within the algebra <code>c_class</code> are
  defined as follows:
  <programlisting>
int = &quot;int&quot; ;
unsigned = &quot;unsigned&quot; ;
string = &quot;character *&quot; ;
ulong_type (ulong) = &quot;unsigned long&quot; ;
BITSTREAM_P (bits) = &quot;BITSTREAM *&quot; ;
PPTOKEN_P (pptok) = &quot;PPTOKEN *&quot; ;</programlisting>
  The integral types are self-explanatory.  All string literals used
  in the C++ producer are based on the character type:
  <programlisting language="C++">
typedef unsigned char character ;</programlisting>
  hence the definition of <code>string</code>.  The remaining primitive
  give links to those portions of the type system which are defined
  outside of the algebra.  The types <link linkend="bits"><code>BITSTREAM</code></link>
  and <link linkend="pptok"><code>PPTOKEN</code></link> are described below.
  </para>
  </section>

  <section id="cv">
    <title><code>CV_SPEC</code></title>
  <para>
  The enumeration type <code>CV_SPEC</code> (short name <code>cv</code>)
  is used to represent a C++ type qualifier.  It takes the form of a
  bitfield, the elements of which can be or-ed together to represent
  combinations of type qualifiers.  The cv-qualifiers are represented
  by <code>cv_const</code> and <code>cv_volatile</code> in the obvious
  manner.  The value <code>cv_lvalue</code> is used as a qualifier to
  indicate whether a type is an lvalue or an rvalue.  Other values are
  used in function types to represent the function language linkage.
  </para>
  </section>

  <section id="ntype">
    <title><code>BUILTIN_TYPE</code></title>
  <para>
  The enumeration type <code>BUILTIN_TYPE</code> (<code>ntype</code>)
  is used to represent the built-in C++ types (<code>char</code>,
  <code>float</code>, <code>void</code> etc.).  It is used chiefly as
  an index into tables of type information.
  </para>
  </section>

  <section id="btype">
    <title><code>BASE_TYPE</code></title>
  <para>
  The enumeration type <code>BASE_TYPE</code> (<code>btype</code>) is
  used to represent a C++ simple type specifier such as <code>signed</code>,
  <code>short</code> or <code>int</code>.  It takes the form of a bitfield,
  the elements of which can be or-ed together to represent combinations
  of type specifiers.  Its chief use is when reading a type from the
  input file; the various simple type specifiers are combined to give
  a value of this type, which is then mapped to an actual <link linkend="type">C++
  type</link>.
  </para>
  </section>

  <section id="itype">
    <title><code>INT_TYPE</code></title>
  <para>
  The union type <code>INT_TYPE</code> (<code>itype</code>) is used
  to represent an integral or bitfield C++ type.  The basic integral
  types are given by the <code>basic</code> field.  Bitfield types are
  represented by the <code>bitfield</code> field.  There are also fields
  representing target dependent integral promotion, arithmetic and integer
  literal types, plus <code>VARIETY</code> tokens.  Only one <code>INT_TYPE</code>
  object is created for each integral type.
  </para>
  </section>

  <section id="ftype">
    <title><code>FLOAT_TYPE</code></title>
  <para>
  The union type <code>FLOAT_TYPE</code> (<code>ftype</code>) is used
  to represent a floating point C++ type.  The basic floating point
  types are given by the <code>basic</code> field.  There are also fields
  representing target dependent argument promotion and arithmetic types,
  plus <code>FLOAT</code> tokens.  Only one <code>FLOAT_TYPE</code>
  object is created for each floating point type.
  </para>
  </section>

  <section id="cinfo">
    <title><code>CLASS_INFO</code></title>
  <para>
  The enumeration type <code>CLASS_INFO</code> (<code>cinfo</code>)
  is used to represent information relating to a class or enumeration
  definition.  It takes the form of a bitfield, the elements of which
  can be or-ed together to represent various combinations of properties.
  </para>
  </section>

  <section id="cusage">
    <title><code>CLASS_USAGE</code></title>
  <para>
  The enumeration type <code>CLASS_USAGE</code> (<code>cusage</code>)
  is used to represent information relating to the way a class is used.
  It takes the form of a bitfield, the elements of which can be or-ed
  together to represent various combinations of properties.
  </para>
  </section>

  <section id="ctype">
    <title><code>CLASS_TYPE</code></title>
  <para>
  The union type <code>CLASS_TYPE</code> (<code>ctype</code>) is used
  to represent a C++ class or union.  The main components are an
  <link linkend="id">identifier</link> giving the class name,
  <link linkend="cinfo">class information</link> and <link linkend="cusage">class
  usage</link> fields, a <link linkend="nspace">namespace</link> giving the class
  members, a <link linkend="graph">graph</link> representing the base class
  structure, and a <link linkend="virt">virtual function table</link>.  Only
  one
  <code>CLASS_TYPE</code> object is created for each class or union.
  </para>
  <para>
  Each class maintains a list, <code>pals</code>, of class and function
  identifiers which are declared as friends of that class.  It also
  maintains a list, <code>chums</code>, of those class types which declare
  it to be a friend (this is what is actually used in the access checks).
  Similarly each function identifier maintains a list,
  <code>chums</code>, of those class types which declare it to be a
  friend.
  </para>
  <para>
  Each class maintains a list of its constructors, destructors and conversion
  functions (included inherited conversion functions).  It also maintains
  a list of its virtual base classes.  This information can be obtained
  by other means but it is more convenient to record it within the class
  type itself.
  </para>
  </section>

  <section id="graph">
    <title><code>GRAPH</code></title>
  <para>
  The union type <code>GRAPH</code> (<code>graph</code>) is used to
  represent a directed acyclic graph arising from the base classes of
  a class.  Each node of the graph has a <code>head</code> which is
  a
  <link linkend="ctype">class type</link>, and several <code>tails</code> which
  give the base class graphs for that class.  Each node has pointers,
  <code>top</code>, to the top of the graph (i.e. the most derived class),
  and <code>up</code>, to the node of which the current node is a direct
  base.  Each node also has an <code>access</code> field which gives
  information on the base access, whether it is virtual or not, and
  so on, in the form of a <link linkend="dspec"><code>DECL_SPEC</code></link>.
  Virtual bases are handled by the <code>equal</code> field which defines
  an equivalence relation on the graph which identifies equivalent virtual
  bases.
  </para>
  </section>

  <section id="virt">
    <title><code>VIRTUAL</code></title>
  <para>
  The union type <code>VIRTUAL</code> (<code>virt</code>) is used to
  represent the virtual functions declared in a class.  The <code>table</code>
  field is used to represent a virtual function table, and consists
  primarily of a list of <code>VIRTUAL</code> objects giving the virtual
  functions for the associated class.  These virtual functions are of
  four kinds, each represented by a union field.  A virtual function
  first declared in a class is represented by the <code>simple</code>
  field; a virtual function in a class which overrides an inherited
  virtual function is represented by the <code>override</code> field;
  an inherited, non-overridden virtual function which is not overridden
  in a base class is represented by the
  <code>inherit</code> field; a inherited, non-overridden virtual function
  which is overridden in some base class is represented by the
  <code>complex</code> field.
  </para>
  </section>

  <section id="etype">
    <title><code>ENUM_TYPE</code></title>
  <para>
  The union type <code>ENUM_TYPE</code> (<code>etype</code>) is used
  to represent a C++ enumeration type.  This consists primarily of an
  <link linkend="id">identifier</link> giving the enumeration name, a
  <link linkend="cinfo">class information</link> field, a <link linkend="type">type</link>
  giving the underlying representation of the enumeration type, and
  a list of <link linkend="id">identifiers</link> giving the enumerators comprising
  the enumeration.
  </para>
  </section>

  <section id="type">
    <title><code>TYPE</code></title>
  <para>
  The union type <code>TYPE</code> (<code>type</code>) is used to represent
  a C++ type.  Every type has an associated <link linkend="cv">type qualifier</link>,
  <code>qual</code>, which determines whether the type is
  <code>const</code>, <code>volatile</code> or an lvalue.  A type may
  also have an associated <link linkend="id">identifier</link>, <code>name</code>,
  giving the corresponding type name (the null identifier being used
  for unnamed types).  The other type components are determined by the
  union tag.  Each of the type constructs above has a corresponding
  field in the <code>TYPE</code> union:
  <code>integer</code> for <link linkend="itype">integral types</link>,
  <code>floating</code> for <link linkend="ftype">floating point types</link>,
  <code>bitfield</code> for <link linkend="itype">bitfield types</link>,
  <code>compound</code> for <link linkend="ctype">class or union types</link>,
  and
  <code>enumerate</code> for <link linkend="etype">enumeration types</link>.
  There are also fields <code>top</code> and <code>bottom</code>
  corresponding to <code>void</code> and bottom (the type used to represent
  values which never return).
  </para>
  <para>
  Other fields of the <code>TYPE</code> union represent composite types;
  for example, the <code>array</code> field, representing array types,
  comprises a base type, <code>sub</code>, and an <link linkend="nat">integer
  constant</link> giving the array bound, <code>size</code>.  These are
  generally simple, apart from <code>func</code>, representing a function
  type.  This has the obvious components: a return type, <code>ret</code>,
  a list of parameter types, <code>ptypes</code>, and a flag indicating
  ellipsis functions, <code>ellipsis</code>.  It also has an associated
  <link linkend="nspace">namespace</link>, <code>pars</code>, in which the function
  parameters are declared.  The parameter identifiers are extracted
  from this as a list, <code>pids</code>.  Member function qualifiers
  and language linkage information are represented by a
  <link linkend="cv"><code>CV_QUAL</code></link>, <code>mqual</code>.  The implicit
  extra parameter for member functions is recorded in the list
  <code>mtypes</code>, which adds this extra type to the start of
  <code>ptypes</code>.  Finally <code>except</code> gives any exception
  specifiers; the case where the exception specifier is absent being
  represented by the special value, <code>univ_type_set</code>.
  </para>
  </section>

  <section id="dspec">
    <title><code>DECL_SPEC</code></title>
  <para>
  The enumeration type <code>DECL_SPEC</code> (<code>dspec</code>) is
  used to represent information on the declaration and usage of an identifier.
  It takes the form of a bitfield, the elements of which can be or-ed
  together to represent various combinations of properties.  The 32
  bits in this bitfield (the maximum which can be represented portably)
  are a significant restriction.  This means that the same member of
  <code>DECL_SPEC</code> is often used to mean different things in different
  contexts.  This can prove confusing on occasions.
  </para>
  </section>

  <section id="hashid">
    <title><code>HASHID</code></title>
  <para>
  The union type <code>HASHID</code> (<code>hashid</code>) is used to
  represent a C++ identifier name.  The simplest form of identifier
  name,
  <code>name</code>, consists of just a string of characters, such as
  <code>foo</code>.  Extended identifier names, <code>ename</code>,
  are similar, but may contain Unicode characters.  There are however
  other forms of identifier name in C++: conversion function names (<code>conv
  </code>) such as <code>operator int</code>, overloaded operator names
  (<code>op</code>) such as <code>operator+</code>, constructor names
  (<code>constr</code>), and destructor names (<code>destr</code>).
  There are also names which are used for anonymous identifiers (<code>anon</code>).
  </para>
  <para>
  Note the distinction between an identifier name and an actual
  <link linkend="id">identifier</link>.  The latter is a meaning associated
  with a name in a particular context.  Every identifier name has an
  associated underlying meaning, <code>id</code>.  This is used to handle
  keywords and macros, but for most identifier names this will be a
  dummy identifier. Nested underlying meanings (such as a macro hiding
  a keyword) are handled by linking the <code>alias</code> fields of
  the corresponding identifiers.  Every identifier name also has a <code>cache
  </code> field which is used to record the look-up of this name as
  an unqualified identifier.  This may be set to the null identifier
  to indicate that the look-up needs to be re-evaluated.
  </para>
  <para>
  Identifier names are stored in one of a small number of hash tables,
  linked using their <code>next</code> field.  Each name has only one
  entry in these tables, allowing equality of names to be implemented
  as <code>EQ_hashid</code>.
  </para>
  </section>

  <section id="qual">
    <title><code>QUALIFIER</code></title>
  <para>
  The enumeration type <code>QUALIFIER</code> (<code>qual</code>) is
  used to represent the various ways in which an identifier name can
  be qualified.  For example, <code>::A::a</code> is represented by
  <code>qual_full</code>.  The value <code>qual_mark</code> is used
  in the representation of function identifier expressions to indicate
  that overload resolution has been performed.
  </para>
  </section>

  <section id="identifier">
    <title><code>IDENTIFIER</code></title>
  <para>
  The union type <code>IDENTIFIER</code> (<code>id</code>) is used to
  represent the various kinds of C++ identifiers.  Every identifier
  has an associated <link linkend="hashid">identifier name</link>, a parent
  <link linkend="nspace">namespace</link>, a <link linkend="dspec">declaration information</link>
  field, and a <link linkend="loc">location</link> for its declaration or definition.
  Each identifier also has an
  <code>alias</code> field which is normally used to represent the aliasing
  which can occur in inheritance or <code>using</code>
  declarations.
  </para>
  <para>
  The various fields of the <code>IDENTIFIER</code> union correspond
  to the various kinds of identifier which can arise in C++ - class
  names, functions, variables, class members, macros, keywords etc.
  Each field has appropriate components giving its type, its definition
  or whatever other information is required.  For example, the <code>variable
  </code>
  field has a <link linkend="type">type</link> and two <link linkend="exp">expressions</link>,
  giving the constructor and destructor values for the object.
  </para>
  <para>
  Most of these identifier components are self-explanatory, however
  the treatment of overloaded functions bears discussion.  The various
  fields representing functions have an <code>over</code> component
  which is used to link overloaded functions together.  A set of overloaded
  functions is treated as if it were a single <code>IDENTIFIER</code>
  - the first in the list - for the purposes of storing in a <link linkend="member">namespace
  member</link>; the other overloaded meanings are accessed by chasing
  down the <code>over</code> components.  In other situations, whether
  a function identifier represents a single function or a set of overloaded
  functions can be worked out from the context.  For example, in identifier
  expressions the <link linkend="qual">identifier qualifier</link> is used to
  mark whether overload resolution has taken place.
  </para>
  </section>

  <section id="member">
    <title><code>MEMBER</code></title>
  <para>
  The union type <code>MEMBER</code> (<code>member</code>) is used to
  represent a member of a <link linkend="nspace">namespace</link>.  Each member
  contains two identifiers, <code>id</code> and <code>alt</code>.  The
  <code>id</code> field gives the meaning associated with a particular
  name in this namespace; the <code>alt</code> field is used to represent
  a type name which may be hidden by a non-type name.
  </para>
  <para>
  There are two kinds of member, <code>small</code> and <code>large</code>,
  corresponding to whether the namespace holds its members in a simple
  linked list or in a hash table.
  </para>
  </section>

  <section id="nspace">
    <title><code>NAMESPACE</code></title>
  <para>
  The union type <code>NAMESPACE</code> (<code>nspace</code>) is used
  to represent the set of identifiers declared in a particular scope.
  For example, the members declared in a C++ class or namespace, the
  parameters declared in a function declarator and the local variables
  declared in a block all form scopes.  The various kinds of scope are
  distinguished as different fields of the union, but there are basically
  two categories.  The first, such as function blocks, which have relatively
  small numbers of elements, store their members as a simple linked
  lists.  The second, such as classes, which have larger numbers of
  elements, store their members in hash tables.  In both cases the elements
  are stored using the <link linkend="member"><code>MEMBER</code></link>
  type.
  </para>
  <para>
  The key operation on a namespace is to look up a particular
  <link linkend="hashid">identifier name</link> in its linked list or hash table
  of members to find the meaning, if any, associated with that name
  in the namespace.  This can be a complex operation because of the
  need to take base classes and <code>using</code> directives (as stored
  in the <code>use</code> component) into account.
  </para>
  </section>

  <section id="nat">
    <title><code>NAT</code></title>
  <para>
  The union type <code>NAT</code> (<code>nat</code>) is used to represent
  an integer constant expression.  Values are represented as lists of
  16 bit 'digits'.  Values which fit into a single digit are represented
  by the <code>small</code> field; larger values by the <code>large</code>
  field.  Negated values can be represented by the <code>neg</code>
  field. Folding of integer constant expressions is performed in the
  producer, however the result can only be represented as described
  above if its value is target independent.  Target dependent values
  are represented by the <code>calc</code> field which contains an
  <link linkend="exp">expression</link> describing how to calculate the value.
  The <code>token</code> field is used to represent <code>NAT</code>
  tokens.
  </para>
  <para>
  Objects representing small integer constants are created at the start
  of the program and stored in a table for ease of access.  Larger constants
  are created as and when they are required.
  </para>
  </section>

  <section id="flt">
    <title><code>FLOAT</code></title>
  <para>
  The union type <code>FLOAT</code> (<code>flt</code>) is used to represent
  a floating point constant expression.  There is only one field, <code>simple
  </code>, which corresponds to a floating point literal.  No folding
  of floating point constant expressions is attempted in the producer
  (it is virtually impossible to do so in a target independent manner).
  </para>
  <para>
  Objects representing useful floating point constants (0.0, 1.0 etc.)
  are created for each floating point type and stored as part of the
  corresponding <link linkend="ftype"><code>FLOAT_TYPE</code></link>.  Other
  values are created as and when they are required.
  </para>
  </section>

  <section id="str">
    <title><code>STRING</code></title>
  <para>
  The union type <code>STRING</code> (<code>str</code>) is used to represent
  a string constant expression.  There is only one field,
  <code>simple</code>, which corresponds to a character string literal,
  however the <code>kind</code> field can be used to modify the interpretation
  put on the characters appearing in the <code>text</code>
  field.  By default, each character in <code>text</code> corresponds
  to a single character in the literal; however an alternative representation,
  in which <code>text</code> consists of a sequence of multibyte characters
  - one control character plus four value characters - is used in more
  complex cases.
  </para>
  <para>
  All strings are stored in a hash table intended to ensure that the
  same <code>STRING</code> object is used for equal string literals.
  This not only saves space during the processing of the input file,
  but also facilitates the output of shared string literals in the TDF
  capsule.
  </para>
  <para>
  Note that the terminal zero character does not form part of the
  <code>STRING</code> object.  Instead information on this is stored
  as part of the type of a <link linkend="exp">string literal expression</link>.
  The text of the string literal is either truncated or padded with
  zeros until its length matches the size of the array bound in the
  type of the corresponding literal expression.
  </para>
  </section>

  <section id="ntest">
    <title><code>NTEST</code></title>
  <para>
  The enumeration type <code>NTEST</code> (<code>ntest</code>) is used
  to represent the various C++ relational operators (<code>==</code>,
  <code>!=</code>, <code>&gt;</code> etc.).  The values correspond to
  the encoding of the TDF <code>NTEST</code> sort, which facilitates
  code generation.  The values also have the property that the values
  for complementary operators (such as <code>&lt;</code> and
  <code>&gt;=</code>) always add up to the same value,
  <code>ntest_negate</code>, allowing operators to be complemented in
  a straightforward manner.
  </para>
  </section>

  <section id="rmode">
    <title><code>RMODE</code></title>
  <para>
  The enumeration type <code>RMODE</code> (<code>rmode</code>) is used
  to represent the various C++ rounding modes (towards zero, towards
  smaller etc.).  The values correspond to the encoding of the TDF
  <code>RMODE</code> sort, which facilitates code generation.
  </para>
  </section>

  <section id="exp">
    <title><code>EXP</code></title>
  <para>
  The union type <code>EXP</code> (<code>exp</code>) is used to represent
  a C++ expression or statement.  Each expression has an associated
  <link linkend="type">type</link>, <code>type</code>, but most of the information
  about an expression is stored in one of the large number of fields
  of the <code>EXP</code> union.  Most of these fields are fairly simple.
  For example, there are fields corresponding to <link linkend="nat">integer
  literals</link>, <link linkend="flt">floating point literals</link>,
  <link linkend="str">string literals</link> and <link linkend="id">identifiers</link>.
  Composite expressions are formed in the normal way; for example, there
  are various binary operators comprising two argument expressions.
  The
  <code>EXP</code> fields corresponding to statements are slightly more
  complex.  They each have a <code>parent</code> field which points
  to the enclosing statement.  A couple of cases bear additional discussion.
  </para>
  <para>
  The <code>sequence</code> field represents a compound statement or
  block.  This contains a <link linkend="nspace">namespace</link>, in which
  any local variables are declared, and a list of expressions, giving
  the statements comprising the block.  The null namespace is used if
  the block does not constitute a scope.  The first statement in the
  list is always a dummy to enable <code>first</code> and <code>last</code>
  pointers to be maintained to the start and end of the list without
  having to worry about null lists.
  </para>
  <para>
  <A id="solve">The <code>solve_stmt</code> field corresponds to the
  TDF <code>labelled</code> construct</A> (in early versions of TDF
  this construct was called <code>solve</code>, hence the terminology).
  The problem is that C and C++ labels and <code>goto</code>s are totally
  unstructured, whereas the TDF label constructs are structured.  Any
  statement which contains unstructured labels is enclosed in a
  <code>solve_stmt</code> construct, enclosing both the labelled statement
  and all jumps to it (in general this cannot be done until the end
  of the function).  Any labels or variables which are bypassed by such
  unstructured jumps also need to be pulled out to the <code>solve_stmt</code>
  construct.  It is not just explicit labels which can cause such problems;
  complex <code>switch</code> statements have the same effect.
  </para>
  </section>

  <section id="off">
    <title><code>OFFSET</code></title>
  <para>
  The union type <code>OFFSET</code> (<code>off</code>) is used to represent
  an offset expression.  This is used as an adjunct to the normal
  <link linkend="exp">expression</link> representation.  The <code>OFFSET</code>
  union has fields corresponding to a type offset (used in pointer arithmetic),
  the offset of a member of a class and the offset of a base class.
  There are also simple operations on offsets, such as multiplication
  by an expression.
  </para>
  </section>

  <section id="tok">
    <title><code>TOKEN</code></title>
  <para>
  The union type <code>TOKEN</code> (<code>tok</code>) is used to represent
  one of a number of different categories within the C++ language.
  It corresponds to the sort of a token declared using the
  <A HREF="token.html"><code>#pragma token</code> syntax</A>.  Thus
  there are fields corresponding to expression, statement, integer constant,
  type, function, member and procedure tokens.  The similarities between
  <code>PROC</code> tokens and templates have been remarked above; for
  example, the parameters of the template:
  <programlisting language="C++">
template &lt; class T, int n &gt; class A {
    T a [n] ;
    // ....
} ;</programlisting>
  are essentially equivalent to those in the procedure token:
  <programlisting language="C++">
PROC ( TYPE T, EXP const : int : n ) ....</programlisting>
  (recall that non-type template arguments are always constant expressions).
  Thus a field, <code>templ</code>, of the <code>TOKEN</code> union
  is used to represent lists of template parameters.  Note that a further
  field, <code>class</code>, is also required to represent template
  template parameters.  A <link linkend="type">template type</link> is represented
  by a field, <code>templ</code>, of the union <code>TYPE</code>, which
  comprises a template sort and a sub-type expressed in terms of the
  template parameters.
  </para>
  <para>
  In addition to representing token and template sorts in this way,
  the
  <code>TOKEN</code> union is used to represent token and template arguments.
  Each of the parameter sorts listed above has an appropriate
  <code>value</code> component which can store a value of that sort.
  Many of the union types in the algebra, including <link linkend="type">types</link>
  and <link linkend="exp">expressions</link>, have a field of the form:
  <programlisting language="C++">
token -&gt; {
    IDENTIFIER tok ;
    LIST TOKEN args ;
}</programlisting>
  representing the given token <link linkend="id">identifier</link> applied
  to the given list of arguments.
  </para>
  <para>
  <A id="form">Template instances are represented slightly differently
  from token applications</A>.  Each instance of a template class or
  a template function gives rise to a new class or function
  <link linkend="id">identifier</link>.  This identifier has an underlying form
  giving the template identifier and the template arguments.  This is
  expressed as a <code>token</code> member of the
  <link linkend="type"><code>TYPE</code></link> union (although it is not technically
  a type, this happens to be the most convenient representation).  Each
  such form has an associated
  <link linkend="inst"><code>INSTANCE</code></link> component which gives further
  information about the template instance.  The form for a template
  function instance is stored in the <code>form</code> component of
  the corresponding <link linkend="id">identifier</link>.  The form for a template
  class instance is stored in the <code>form</code> component of the
  corresponding <link linkend="ctype">class type</link>.
  </para>
  <para>
  Members of instances of template classes also have a form type, but
  in this case the form is an <code>instance</code> type.  This gives
  a link back to the corresponding member of the template class.
  </para>
  </section>

  <section id="inst">
    <title><code>INSTANCE</code></title>
  <para>
  The union type <code>INSTANCE</code> (<code>inst</code>) is used to
  represent a particular instance of a template or token.  Each
  <link linkend="tok">template sort</link> has an associated list of all the
  instances of that template, which is used to ensure that the same
  template applied with the same arguments always has the same value.
  Information on partial or explicit specialisations and usage information
  are stored as part of the corresponding
  <code>INSTANCE</code>.  Each template instance identifier has a link
  back to its corresponding <code>INSTANCE</code> via its
  <link linkend="form"><code>form</code> component</link>.
  </para>
  </section>

  <section id="err">
    <title><code>ERROR</code></title>
  <para>
  The union type <code>ERROR</code> (<code>err</code>) is used to represent
  an error arising during the compilation of a C++ program. Errors are
  first class objects within the producer and can be passed to and from
  procedures.  Each error has an associated <code>severity</code>
  (serious, warning, none etc.).  Simple errors are represented by the
  <code>simple</code> field, which consists of an index, <code>number</code>,
  into the error catalogue, plus a variable length list of error arguments.
  Errors can be combined into composite errors using the
  <code>compound</code> field, which represents the join of two errors
  -
  <code>head</code> followed by <code>tail</code>.
  </para>
  <para>
  The chief operation on an error after it has been built up is to report
  it.  Each error report consists of an error object and a
  <link linkend="loc">file location</link> indicating where the error occurred.
  </para>
  </section>

  <section id="var">
    <title><code>VARIABLE</code></title>
  <para>
  The structure type <code>VARIABLE</code> (<code>var</code>) is used
  to represent a variable state and is used in the variable analysis
  checks.
  </para>
  </section>

  <section id="location">
    <title><code>LOCATION</code></title>
  <para>
  The structure type <code>LOCATION</code> (<code>loc</code>) is used
  to represent a location in an input file.  It comprises a pointer
  to an
  <link linkend="posn">input file position</link>, <code>posn</code>, modified
  by a line number, taking <code>#line</code> directives into account,
  <code>line</code>.  Note that character positions within the line
  are not currently recorded.
  </para>
  </section>

  <section id="posn">
    <title><code>POSITION</code></title>
  <para>
  The structure type <code>POSITION</code> (<code>posn</code>) is used
  to represent a position in an input file.  It consists of two file
  names,
  <code>file</code> taking <code>#line</code> directives into account,
  and
  <code>input</code> giving the actual file name, plus a line number
  offset, <code>offset</code>, which gives the difference between the
  line number taking <code>#line</code> directives into account and
  the actual line number.  Other information stored includes the datestamp
  on the input file, <code>datestamp</code>, and a pointer to a
  <link linkend="loc">file location</link> which, for files included using
  <code>#include</code>, gives the location the file was included from.
  </para>
  </section>

  <section id="bits">
    <title><code>BITSTREAM</code></title>
  <para>
  The structure <code>BITSTREAM</code> is not part of the
  <code>calculus</code> type system.  It is used to represent a sequence
  of bits such as is used, for example, in the encoding of TDF.
  </para>
  </section>

  <section id="buff">
    <title><code>BUFFER</code></title>
  <para>
  The structure <code>BUFFER</code> is not part of the <code>calculus</code>
  type system.  It is used to represent a sequence of characters.
  </para>
  </section>

  <section id="opt">
    <title><code>OPTIONS</code></title>
  <para>
  The structure <code>OPTIONS</code> is not part of the <code>calculus</code>
  type system.  It is used to represent the state of the
  <A HREF="pragma.html#low">compiler options</A> at a particular point
  in the input file.
  </para>
  </section>

  <section id="pptok">
    <title><code>PPTOKEN</code></title>
  <para>
  The structure <code>PPTOKEN</code> is not part of the <code>calculus</code>
  type system.  It is used to represent a linked list of preprocessing
  tokens.  Each token has an associated <code>sid</code> lexical token
  number, <code>tok</code>, plus additional data dependent on the token
  type.  Each token also records a pointer to the current
  <link linkend="opt"><code>OPTIONS</code></link> value.
  </para>
  </section>
  </section>

  <section>
    <title>Error catalogue</title>
  <para>
  This section describes the error catalogue which lies at the heart
  of the C++ producer's error reporting routines.  The full
  <A HREF="error1.html">error catalogue syntax</A> is given as an annex.
  A typical entry in the catalogue is as follows:
  <programlisting language="Error">
class_union_deriv ( CLASS_TYPE: ct )
{
    USAGE:              serious
    PROPERTIES:         ansi
    KEY (ISO)           &quot;9.5&quot;
    KEY (STANDARD)      &quot;The union '&quot;ct&quot;' can't have base classes&quot;
}</programlisting>
  This defines an error, <code>class_union_deriv</code>, which takes
  a single parameter <code>ct</code> of type <code>CLASS_TYPE</code>.
  The severity of this error is <code>serious</code>; that is to say,
  a constraint error.  The error property <code>ansi</code> indicates
  that the error arises from the ISO C++ standard, the associated
  <code>ISO</code> key indicating section 9.5.  Finally the text to
  be printed for this error, including a reference to <code>ct</code>,
  is given.  Looking up section 9.5 in the ISO C++ standard reveals
  the corresponding constraint in paragraph 1:
  <BLOCKQUOTE>
  <emphasis>A union shall not have base classes.</emphasis>
  </BLOCKQUOTE>
  Each constraint within the ISO C++ standard has a corresponding error
  in this way.  The errors are named in a systematic fashion using the
  section names used in the draft standard.  For example, section 9.5
  is called <code>class.union</code>, so all the constraint errors arising
  from this section have names of the form <code>class_union_*</code>.
  These error names can be used in the <A HREF="pragma.html#low">low
  level directives</A> such as:
  <programlisting language="C++">
#pragma TenDRA++ error &quot;class_union_deriv&quot; <emphasis>allow</emphasis></programlisting>
  to modify the error severity.  The effect of reducing the severity
  of a constraint error in this way is undefined.
  </para>
  <para>
  In addition to the obvious error severity levels, <code>serious</code>,
  <code>warning</code> and <code>none</code>, the error catalogue specifies
  a list of optional severity levels along with their default values.
  For example, the entry:
  <programlisting language="Error">
link_incompat = serious</programlisting>
  sets up an option named <code>link_incompat</code> which is a constraint
  error by default.  Errors with this severity, such as:
  <programlisting language="Error">
dcl_stc_external ( LONG_ID: id, PTR_LOC: loc )
{
    USAGE:              link_incompat
    PROPERTIES:         ansi
    KEY (ISO)           &quot;7.1.1&quot;
    KEY (STANDARD)      &quot;'&quot;id&quot;' previously declared with external
			 linkage (at &quot;loc&quot;)&quot;
}</programlisting>
  are therefore constraint errors.  The severity associated with
  <code>link_incompat</code> can be modified either
  <A HREF="pragma.html#low">directly</A>, using the directive:
  <programlisting language="C++">
#pragma TenDRA++ option &quot;link_incompat&quot; <emphasis>allow</emphasis></programlisting>
  or <A HREF="pragma.html#linkage">indirectly</A> using the directive:
  <programlisting language="C++">
#pragma TenDRA incompatible linkage <emphasis>allow</emphasis></programlisting>
  the effect being to modify the severity of the associated error messages.
  </para>
  <para>
  The error catalogue is processed by a simple tool,
  <code>make_err</code>, which generates C code which is compiled into
  the C++ producer.  Each error in the catalogue is assigned a number
  (there are currently 873 errors in the catalogue) which gives an index
  into an automatically generated table of error information.  It is
  this error number, together with a list of error arguments, which
  forms the associated <A HREF="alg.html#err"><code>ERROR</code> object</A>.
  <code>make_err</code> generates a macro for each error in the catalogue
  which takes arguments of the appropriate types (which may be statically
  checked) and creates an <code>ERROR</code> object.  For example, for
  the entry above this macro takes the form:
  <programlisting language="C++">
ERROR ERR_class_union_deriv ( CLASS_TYPE ) ;</programlisting>
  These macros hide the error catalogue numbers from the rest of the
  C++ producer.
  </para>
  <para>
  It is also possible to join a number of simple <code>ERROR</code>
  objects to form a single composite <code>ERROR</code>.  The severity
  of the composite error is the maximum of the severities of the component
  errors.  To this purpose a dummy error severity level <code>whatever</code>
  is introduced which is less severe than any other level.  This is
  intended for use with error messages which are only ever used to add
  information to existing errors, and which inherit their severity level
  from the main error.
  </para>
  <para>
  The text of a simple error message can be found in the table of error
  information.  The text contains certain escape sequences indicating
  where the error arguments are to be printed.  For example,
  <code>%1</code> indicates the second argument.  The error argument
  sorts - what is referred to as the error signature - is also stored
  in the table of error information as an array of characters, each
  corresponding to an <code>ERR_KEY_</code><emphasis>type</emphasis> macro.  The producer
  defines printing routines for each of the types given by these values,
  and calls the appropriate routine to print the argument.
  </para>
  <para>
  There are several command-line options which can be used to modify
  the form in which the error message is printed.  The default format
  is as follows:
  <programlisting language="C++">
&quot;file.C&quot;, line 42: Error:
    [ISO 9.5]: The union 'U' can't have base classes.</programlisting>
  The ISO section number can be suppressed using <code>-m-s</code>.
  The <code>-mc</code> option causes the source code line giving rise
  to the error to be printed as part of the message, with <code>!!!!</code>
  marking the position of the error within the line.  The <code>-me</code>
  option causes the error name, <code>class_union_deriv</code>, to be
  printed as part of the message.  The <code>-ml</code> option causes
  the full file location, including the list of <code>#include</code>
  directives used in reaching the file, to be printed.  The <code>-mt</code>
  option causes <code>typedef</code> names to be used when printing
  types, rather than expanding to the type definition.
  </para>
  </section>

  <section>
    <title>Parsing C++</title>
  <para>
  The parser used in the C++ producer is generated using the
  <A HREF="../utilities/sid.html"><code>sid</code> tool</A>.  Because
  of the large size of the generated code (1.3MB), the <code>sid</code>
  output is run through a simple program, <code>sidsplit</code>, which
  splits the output into a number of more manageable modules.  It also
  transforms the code to use the <A HREF="style.html#language"><code>PROTO</code>
  macros</A> used in the rest of the program.
  </para>
  <para>
  <code>sid</code> is designed as a parser for grammars which can be
  transformed into LL(1) grammars.  The distinguishing feature of these
  grammars is that the parser can always decide what to do next based
  on the current terminal.  This is not the case in C++; in some circumstances
  a potentially unlimited look-ahead is required to distinguish, for
  example, declaration statements from expression statements.  In the
  technical phrase, C++ is an LL(k) grammar. Fortunately there are relatively
  few such situations, and <code>sid</code>
  provides a mechanism, <A HREF="../utilities/sid.html#predicate">predicates</A>,
  for bypassing the normal parsing mechanism in these cases.  Thus it
  is possible, although difficult, to express C++ as a <code>sid</code>
  grammar.
  </para>
  <para>
  The <code>sid</code> grammar file, <code>syntax.sid</code>, is closely
  based on the ISO C++ grammar.  In particular, the same production
  names have been used.  The grammar has been extended slightly to allow
  common syntactic errors to be detected elegantly.  Other parsing errors
  are handled by <code>sid</code>'s exception mechanism.  At present
  there is only limited recovery after such errors.
  </para>
  <para>
  The lexical analysis routines in the C++ producer are hand-crafted,
  based on an initial version generated by the simple lexical analyser
  generator,
  <code>lexi</code>.  <code>lexi</code> has been used more directly
  to generate the lexical analysers for certain of the other automatic
  code generating tools, including <code>calculus</code>, used in the
  producer.
  </para>
  <para>
  The <code>sid</code> grammar contains a number of entry points.  The
  most important is <code>parse_file</code>, which is used to parse
  a complete C++ translation unit.  The syntax for the
  <A HREF="pragma.html"><code>#pragma TenDRA</code> directives</A> is
  included within the same grammar with two entry points,
  <code>parse_tendra</code> in normal use, and <code>parse_preproc</code>
  for use in preprocessing mode.  There are also entry points in the
  grammar for each of the kinds of <A HREF="token.html#args">token argument</A>.
  The parsing routines for token and template arguments are largely
  hand-crafted, based on these primitives.
  </para>
  <para>
  Certain parsing operations are performed before control passes to
  the
  <code>sid</code> grammar.  As mentioned above, these include the processing
  of token and template applications.  The other important case concerns
  nested name specifiers.  For example, in:
  <programlisting language="C++">
class A {
    class B {
	static int c ;
    } ;
} ;

int A::B::c = 0 ;</programlisting>
  the qualified identifier <code>A::B::c</code> is split into two terminals,
  a nested name specifier, <code>A::B::</code>, and an identifier, <code>c</code>,
  which is looked up in the corresponding namespace.  Note that it is
  at this stage that name look-up occurs. An identifier can be mapped
  to one of a number of terminals, including  keywords, type names,
  namespace names and other identifiers, according to the result of
  this look-up.  If the look-up gives a macro then this is expanded
  at this stage.
  </para>
  </section>
  </chapter>

<!-- TODO bibliography -->
  <chapter id="reference">
    <title>References</title>
    <itemizedlist>
      <listitem><dt:doc name="reference/specification"/>:
      <A HREF="../tdf/spec1.html">attached</A>.
      </listitem>
      <listitem><A id="tdfc"><code>C Checker Reference Manual</code></A>:
      <A HREF="../tdfc/tdfc1.html">attached</A>.
      </listitem>
      <listitem><dt:doc name="papers/porting"/>:
      <A HREF="../port/port1.html">attached</A>.
      </listitem>
    </itemizedlist>
  </chapter>
</article>

