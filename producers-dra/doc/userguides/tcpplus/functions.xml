<?xml version="1.0" standalone="no"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
	"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">

<chapter>
	<title>Configuration for functions</title>

	<section id="weak">
		<title>Weak function prototypes</title>

		<para>The C producer supports a concept, weak prototypes, whereby type checking
			can be applied to the arguments of a non-prototype function.	This
			checking can be enabled using the directive:</para>

		<programlisting language="C++">#pragma TenDRA weak prototype analysis <emphasis>on</emphasis></programlisting>

			<para>The concept of weak prototypes is not applicable to C++, where all
			functions are prototyped.	The C++ producer does allow the syntax
			for explicit weak prototype declarations, but treats them as if they
			were normal prototypes.	These declarations are denoted by means of
			a keyword,
			<code>WEAK</code> say, introduced by the directive:</para>

		<programlisting language="C++">#pragma TenDRA keyword <emphasis>identifier</emphasis> for weak</programlisting>

			<para>preceding the <code>(</code> of the function declarator.	The directives:</para>

		<programlisting language="C++">#pragma TenDRA prototype <emphasis>allow</emphasis>
#pragma TenDRA prototype (weak) <emphasis>allow</emphasis></programlisting>

			<para>which can be used in the C producer to warn of prototype or weak prototype
			declarations, are similarly ignored by the C++ producer.</para>

		<para>The C producer also allows the directives:</para>

		<programlisting language="C++">#pragma TenDRA argument <emphasis>type-id</emphasis> as <emphasis>type-id</emphasis>
#pragma TenDRA argument <emphasis>type-id</emphasis> as ...
#pragma TenDRA extra ... <emphasis>allow</emphasis>
#pragma TenDRA incompatible promoted function argument <emphasis>allow</emphasis></programlisting>

			<para>which control the compatibility of function types.	These directives
			are ignored by the C++ producer (some of them would make sense in
			the context of C++ but would over-complicate function overloading).</para>
	</section>

	<section id="printf">
		<title><code>printf</code> and <code>scanf</code>
			argument checking</title>

		<para>The C producer includes a number of checks that the arguments in a
			call to a function in the <code>printf</code> or <code>scanf</code>
			families match the given format string.	The check is implemented
			by using the directives:</para>

		<programlisting language="C++">#pragma TenDRA type <emphasis>identifier</emphasis> for ... printf
#pragma TenDRA type <emphasis>identifier</emphasis> for ... scanf</programlisting>

			<para>to introduce a type representing a <code>printf</code> or <code>scanf</code>
			format string.	For most purposes this type is treated as <code>const
			char *</code>, but when it appears in a function declaration it alerts
			the producer that any extra arguments passed to that function should
			match the format string passed as the corresponding argument.	The
			TenDRA API headers conditionally declare <code>printf</code>,
			<code>scanf</code> and similar functions in something like the form:</para>

		<programlisting language="C++">#ifdef __NO_PRINTF_CHECKS
		typedef const char *__printf_string ;
		#else
#pragma TenDRA type __printf_string for ... printf
		#endif

		int printf ( __printf_string, ... ) ;
		int fprintf ( FILE *, __printf_string, ... ) ;
		int sprintf ( char *, __printf_string, ... ) ;</programlisting>

			<para>These declarations can be skipped, effectively disabling this check,
			by defining the <code>__NO_PRINTF_CHECKS</code> macro.</para>
			<warning>
		<para>These <code>printf</code> and <code>scanf</code> format string checks
			have not yet been implemented in the C++ producer due to presence
			of an alternative, type checked, I/O package - namely
			<code>&lt;iostream&gt;</code>.	The format string types are simply
			treated as <code>const char *</code>.</para>
			</warning>
	</section>

	<section id="ellipsis">
		<title>Ellipsis functions</title>

		<para>The directive:</para>

		<programlisting language="C++">#pragma TenDRA ident ... <emphasis>allow</emphasis></programlisting>

			<para>may be used to enable or disable the use of <code>...</code> as a
			primary expression in a function defined with ellipsis.	The type
			of such an expression is implementation defined.	This expression
			is used in the definition of the <A HREF="lib.html#ellipsis"><code>va_start
			</code>
			macro</A> in the <code>&lt;stdarg.h&gt;</code> header.	This header
			automatically enables this switch.</para>
	</section>

	<section id="overload">
		<title>Overloaded functions</title>

		<para>Older dialects of C++ did not report ambiguous overloaded function
			resolutions, but instead resolved the call to the first of the most
			viable candidates to be declared.	This behaviour can be controlled
			using the directive:</para>

		<programlisting language="C++">#pragma TenDRA++ ambiguous overload resolution <emphasis>allow</emphasis></programlisting>

			<para>There are occasions when the resolution of an overloaded function
			call is not clear.	The directive:</para>

		<programlisting language="C++">#pragma TenDRA++ overload resolution <emphasis>allow</emphasis></programlisting>

			<para>can be used to report the resolution of any such call (whether explicit
			or implicit) where there is more than one viable candidate.</para>

		<para>An interesting consequence of compiling C++ in a target independent
			manner is that certain overload resolutions can only be determined
			at install-time. For example, in:</para>

		<programlisting language="C++">int f ( int ) ;
		int f ( unsigned int ) ;
		int f ( long ) ;
		int f ( unsigned long ) ;

		int a = f ( sizeof ( int ) ) ;	// which f?</programlisting>

			<para>the type of the <code>sizeof</code> operator, <code>size_t</code>,
			is target dependent, but its promotion must be one of the types
			<code>int</code>, <code>unsigned int</code>, <code>long</code> or
			<code>unsigned long</code>.	Thus the call to <code>f</code> always
			has a unique resolution, but what it is is target dependent.	The
			equivalent directives:</para>

		<programlisting language="C++">#pragma TenDRA++ conditional overload resolution <emphasis>allow</emphasis>
#pragma TenDRA++ conditional overload resolution (complete) <emphasis>allow</emphasis></programlisting>

			<para>can be used to warn about such target dependent overload resolutions.
			By default, such resolutions are only allowed if there is a unique
			resolution for each possible implementation of the argument types
			(note that, for simplicity, the possibility of <code>long long</code>
			implementation types is ignored).	The directive:</para>

		<programlisting language="C++">#pragma TenDRA++ conditional overload resolution (incomplete) <emphasis>allow</emphasis></programlisting>

			<para>can be used to allow target dependent overload resolutions which only
			have resolutions for some of the possible implementation types (if
			one of the <code>f</code> declarations above was removed, for example).
			If the implementation does not match one of these types then an install-time
			error is given.</para>

		<para>There are restrictions on the set of candidate functions involved
			in a target dependent overload resolution.	Most importantly, it should
			be possible to bring their return types to a common type, as if by
			a series of <code>?:</code> operations.	This common type is the type
			of the target dependent call.	By this means, target dependent types
			are prevented from propagating further out into the program.	Note
			that since sets of overloaded functions usually have the same semantics,
			this does not usually present a problem.</para>
	</section>

</chapter>

