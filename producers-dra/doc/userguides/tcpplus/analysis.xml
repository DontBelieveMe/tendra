<?xml version="1.0" standalone="no"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
	"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">

<chapter>
	<title>Static analysis</title>

	<section id="reach">
		<title>Unreached code analysis</title>

		<para>The directive:</para>

		<programlisting language="C++">#pragma TenDRA unreachable code <emphasis>allow</emphasis></programlisting>

			<para>enables a flow analysis check to detect unreachable code.	It is possible
			to assert that a statement is reached or not reached by preceding
			it by a keyword introduced by one of the directives:</para>

		<programlisting language="C++">#pragma TenDRA keyword <emphasis>identifier</emphasis> for set reachable
#pragma TenDRA keyword <emphasis>identifier</emphasis> for set unreachable</programlisting>

		<para>The fact that certain functions, such as <code>exit</code>, do not
			return a value can be exploited in the flow analysis routines.	The
			equivalent directives:</para>

		<programlisting language="C++">#pragma TenDRA bottom <emphasis>identifier</emphasis>
#pragma TenDRA++ type <emphasis>identifier</emphasis> for bottom</programlisting>

			<para>can be used to introduce a <code>typedef</code> declaration for the
			type, bottom, returned by such functions.	The TenDRA API headers
			declare
			<code>exit</code> and similar functions in this way, for example:</para>

		<programlisting language="C++">#pragma TenDRA bottom __bottom
__bottom exit ( int ) ;
__bottom abort ( void ) ;</programlisting>

			<para>The bottom type is compatible with <code>void</code> in function declarations
			to allow such functions to be redeclared in their conventional form.</para>
	</section>

	<section id="variable">
		<title>Variable flow analysis</title>

		<para>The directive:</para>

		<programlisting language="C++">#pragma TenDRA variable analysis <emphasis>on</emphasis></programlisting>

		<para>enables checks on the uses of automatic variables and function parameters.
			These checks detect:</para>

		<itemizedlist>
			<listitem>If a variable is not used in its scope.</listitem>
			<listitem>If the value of a variable is used before it has been assigned to.</listitem>
			<listitem>If a variable is assigned to twice without an intervening use.</listitem>
			<listitem>If a variable is assigned to twice without an intervening sequence point.</listitem>
		</itemizedlist>

		<para>as illustrated by the variables <code>a</code>, <code>b</code>,
			<code>c</code> and <code>d</code> respectively in:</para>

		<programlisting language="C++">void f ()
{
	int a ;			// a never used
	int b ;
	int c = b ;			// b not initialised
	c = 0 ;			// c assigned to twice
	int d = 0 ;
	d = ++d ;			// d assigned to twice
}</programlisting>

			<para>The second, and more particularly the third, of these checks requires
			some fairly sophisticated flow analysis, so any hints which can be
			picked up from <link linkend="switch">exhaustive <code>switch</code>
			statements</link> etc. is likely to increase the accuracy of the errors
			detected.</para>

		<para>In a non-static member function the various non-static data members
			are analysed as if they were automatic variables.	It is checked that
			each member is initialised in a constructor.	A common source of initialisation
			problems in a constructor is that the base classes and members are
			initialised in the canonical order of virtual bases, non-virtual direct
			bases and members in the order of their declaration, rather than in
			the order in which their initialisers appear in the constructor definition.
			Therefore a check that the initialisers appear in the canonical order
			is also applied.</para>

		<para>It is possible to change the state of a variable during the variable
			analysis using the directives:</para>

		<programlisting language="C++">#pragma TenDRA set <emphasis>expression</emphasis>
#pragma TenDRA discard <emphasis>expression</emphasis></programlisting>

		<para>The first asserts that the variable given by the <emphasis>expression</emphasis>
			has been assigned to; the second asserts that the variable is not
			used.	An alternative way of expressing this is by means of keywords:</para>

		<programlisting language="C++">SET ( <emphasis>expression</emphasis> )
DISCARD ( <emphasis>expression</emphasis> )</programlisting>

		<para>introduced using the directives.</para>

		<programlisting language="C++">
#pragma TenDRA keyword <emphasis>identifier</emphasis> for set
#pragma TenDRA keyword <emphasis>identifier</emphasis> for discard variable</programlisting>

		<para>respectively.	These expressions can appear in expression statements
			and as the first argument of a comma expression.</para>

		<warning>
			<para>The variable flow analysis checks have not yet been completely implemented.
				They may not detect errors in certain circumstances and for extremely
				convoluted code may occasionally give incorrect errors.</para>
		</warning>
	</section>

	<section id="hide">
		<title>Variable hiding</title>

		<para>The directive:</para>

		<programlisting language="C++">#pragma TenDRA variable hiding analysis <emphasis>on</emphasis></programlisting>

		<para>can be used to enable a check for hiding of other variables and, in
			member functions, data members, by local variable declarations.</para>
	</section>

	<section id="exception">
		<title>Exception analysis</title>

		<para>The ISO C++ rules do not require exception specifications to be checked
			statically.	This is to facilitate the integration of large systems
			where a single change in an exception specification could have ramifications
			throughout the system.	However it is often useful to apply such checks,
			which can be enabled using the directive:</para>

		<programlisting language="C++">#pragma TenDRA++ throw analysis <emphasis>on</emphasis></programlisting>
		<para>This detects any potentially uncaught exceptions and other exception
			problems.	In the error messages arising from this check, an uncaught
			exception of type <code>...</code> means that an uncaught exception
			of an unknown type (arising, for example, from a function without
			an exception specification) may be thrown.	For example:</para>

		<programlisting language="C++">
void f ( int ) throw ( int ) ;
void g ( int ) throw ( long ) ;
void h ( int ) ;

void e () throw ( int )
{
	f ( 1 ) ;	// OK
	g ( 2 ) ;	// uncaught 'long' exception
	h ( 3 ) ;	// uncaught '...' exception
}</programlisting>
	</section>

</chapter>

