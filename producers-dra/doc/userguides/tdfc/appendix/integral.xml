<?xml version="1.0"?>
<!DOCTYPE appendix SYSTEM "minidocbook.dtd">

<appendix>
	<title>Integral Type Specification</title>

	<section>
		<title>Specifying integer literal types</title>

		<para>The integer literal pragmas are used to define the method of
			computing the type of an integer literal. Integer literals cannot be
			used in a program unless the class to which they belong has been
			described using an integer literal pragma. Each built-in checking mode
			includes some integer literal pragmas describing the semantics
			appropriate for that mode. If these built-in modes are inappropriate,
			then the user must describe the semantics using the pragma below:</para>

		<programlisting language="c">#pragma integer literal <emphasis>literal_class lit_class_type_list</emphasis></programlisting>

		<para>The <emphasis>literal_class</emphasis> identifies the type of literal
			integer involved. The possibilities are:</para>

		<itemizedlist>
			<listitem>
				<para><code>decimal</code></para>
			</listitem>

			<listitem>
				<para><code>octal</code></para>
			</listitem>

			<listitem>
				<para><code>hexadecimal</code></para>
			</listitem>
		</itemizedlist>

		<para>Each of these types can optionally be followed by
			<code>unsigned</code> and/or <code>long</code> to specify an
			unsigned and/or long type respectively.</para>

		<para>The values of the integer literals of any particular class are
			divided into contiguous sub-ranges specified by the
			<code>lit_class_type_list</code> which takes the form below:</para>

		<programlisting language="bnf"><emphasis>lit_class_type_list</emphasis>
	*<emphasis>int_type_spec</emphasis>
		<emphasis>integer_constant int_type_spec</emphasis> | <emphasis>lit_class_type_list</emphasis><emphasis>int_type_spec</emphasis> :
		: <emphasis>type_name</emphasis>
		* warning&opt.bnf; : <emphasis>identifier</emphasis>
		** :</programlisting>

		<para>The first integer constant, <code>i1</code> say, identifies the
			range <code>[0, i1]</code>, the second, <code>i2</code> say,
			identifies the range <code>[i1 + 1, i2]</code>. The symbol
			<code>*</code> specifies the unlimited range upwards from the last
			integer constant. Each integer constant must be strictly greater
			than its predecessor.</para>

		<para>Associated with each sub-range is an <emphasis>int_type_spec</emphasis>
			which is either a type, a procedure token identifier with an
			optional warning (see G.9) or a failure. For each sub-range:</para>

		<itemizedlist>
			<listitem>
				<para>If the <emphasis>int_type_spec</emphasis> is a type name, then it must be
					an integral type and specifies the type associated with literals in
					that sub-range.</para>
			</listitem>
			<listitem>
				<para>If the <code>int_type_spec</code> is an identifier, then the
					type of integer is computed by a procedure token of that name which
					takes the integer value as a parameter and delivers its type. The
					procedure token must have been declared previously as</para>

				<programlisting language="c">#pragma token PROC ( VARIETY ) VARIETY</programlisting>

				<para>Since the type of the integer is computed by a procedure token
					which may be implemented differently on different targets, there is
					the option of producing a warning whenever the token is
					applied.</para>
			</listitem>

			<listitem>
				<para>If the <emphasis>int_type_spec</emphasis> is <code>**</code>,
					then any integer literal lying in the associated sub-range will
					cause the checker to raise an error.</para>
			</listitem>
		</itemizedlist>

		<para>For example:</para>

		<programlisting language="c">#pragma integer literal decimal 0x7fff : int | 0x7fffffff : long | * : unsigned long</programlisting>

		<para>divides unsuffixed decimal literals into three ranges: literals
			in the range <code>[0, 0x7fff]</code> are of type <code>int</code>,
			integer literals in the range <code>[0x7fff, 0x7fffffff]</code> are
			of type <code>long</code> and the remainder are of type
			<code>unsigned long</code>.</para>

		<para>There are four pre-defined procedure tokens supplied with the
			compiler which are used in the startup files to provide the default
			specification for integer literals:</para>

		<itemizedlist>
			<listitem>
				<para><code>~lit_int</code> is the external identification of a token
					that returns the integer type according to the rules of ISO C for
					an unsuffixed decimal;</para>
			</listitem>
			<listitem>
				<para><code>~lit_hex</code> is the external identification of a token
					that returns the integer type according to the rules of ISO C for
					an unsuffixed hexadecimal;</para>
			</listitem>
			<listitem>
				<para><code>~lit_unsigned</code> is the external identification of a
					token that returns the integer type according to the rules of ISO C
					for integers suffixed by <code>U</code> only;</para>
			</listitem>
			<listitem>
				<para><code>~lit_long</code> is the external identification of a
					token that returns the integer type according to the rules of ISO C
					for integers suffixed by <code>L</code> only.</para>
			</listitem>
		</itemizedlist>
	</section>

	<section>
		<title>The Portability Table</title>

		<para>The portability table is used by the checker to describe the
			minimum assumptions about the representation of the integral
			types. It contains information on the minimum integer sizes and
			the minimum range of values that can be represented by each
			integer type.</para>

		<para>Two built-in portability tables are provided. The default
			reflects the minimal requirements laid down in the ISO C standard.
			The 32-bit portability table (specified by the passing the <code>-Y32bit</code>
			option to tchk) reflects the implementation on most modern 32 bit
			machines. These tables are shown below.</para>

		<!-- XXX: check these... -->
		<table>
			<title>&iso;/&ansi; Minimum Requirements Portability Table</title>

			<col align="left"/>
			<col align="center"/>
			<col align="center"/>
			<col align="left"/>
			<col align="center"/>

			<thead>
				<tr>
					<th colspan="2" align="center">&iso;/&ansi; (default)</th>
					<th role="gap"/>
					<th colspan="2" align="center"><code>-Y32bit</code></th>
				</tr>
			</thead>

			<tbody>
				<tr>
					<td><replaceable>char_bits</replaceable></td>
					<td><code>8</code></td>
					<td role="gap"/>
					<td><replaceable>char_bits</replaceable></td>
					<td><code>8</code></td>
				</tr>

				<tr>
					<td><replaceable>short_bits</replaceable></td>
					<td><code>16</code></td>
					<td role="gap"/>
					<td><replaceable>short_bits</replaceable></td>
					<td><code>16</code></td>
				</tr>
	
				<tr>
					<td><replaceable>int_bits</replaceable></td>
					<td><code>16</code></td>
					<td role="gap"/>
					<td><replaceable>int_bits</replaceable></td>
					<td><code>32</code></td>
				</tr>
	
				<tr>
					<td><replaceable>long_bits</replaceable></td>
					<td><code>32</code></td>
					<td role="gap"/>
					<td><replaceable>long_bits</replaceable></td>
					<td><code>32</code></td>
				</tr>
	
				<tr>
					<td><replaceable>longlong_bits</replaceable></td>
					<td><code>64</code></td>
					<td role="gap"/>
					<td><replaceable>longlong_bits</replaceable></td>
					<td><code>64</code></td>
				</tr>
	
				<tr>
					<td><code>signed_range</code></td>
					<td>symmetric</td>
					<td role="gap"/>
					<td><code>signed_range</code></td>
					<td>maximum</td>
				</tr>
	
				<tr>
					<td><code>char_type</code></td>
					<td>either</td>
					<td role="gap"/>
					<td><code>char_type</code></td>
					<td>either</td>
				</tr>
	
				<tr>
					<td><code>ptr_int</code></td>
					<td>none</td>
					<td role="gap"/>
					<td><code>ptr_int</code></td>
					<td>int</td>
				</tr>
	
				<tr>
					<td><code>ptr_fn</code></td>
					<td>no</td>
					<td role="gap"/>
					<td><code>ptr_fn</code></td>
					<td>yes</td>
				</tr>
	
				<tr>
					<td><code>non_prototype_checks</code></td>
					<td>yes</td>
					<td role="gap"/>
					<td><code>non_prototype_checks</code></td>
					<td>yes</td>
				</tr>
	
				<tr>
					<td><code>multitbyte</code></td>
					<td><code>1</code></td>	<!-- TODO bool? -->
					<td role="gap"/>
					<td><code>multitbyte</code></td>
					<td><code>1</code></td>	<!-- TODO bool? -->
				</tr>
			</tbody>
		</table>

		<para>The decimal integer associated with each of
			<emphasis>char_bits</emphasis>, <emphasis>short_bits</emphasis>,
			<emphasis>int_bits</emphasis> and <emphasis>long_bits</emphasis>
			gives the minimum number of bits in the representation of each
			integer type on all target machines. For example, if
			<emphasis>int_bits</emphasis> is set to <code>32</code> the
			compiler will perform its checks in the knowledge that the
			program will not be used on a machine whose <code>int</code>
			types are represented by 16 bits although they might be
			represented by 32 or 64 bits.</para>

		<para>The minimum integer ranges are deduced from the minimum integer
			sizes as follows. Suppose <emphasis>b</emphasis> is the minimum
			number of bits that will be used to represent a certain integral
			type, then:</para>

		<itemizedlist>
			<listitem>
				<!-- TODO: mathml -->
				<para>For unsigned integer types the minimum range is [0,
					2<superscript>b</superscript>-1];</para>
			</listitem>

			<listitem>
				<para>For signed integer types if <code>signed_range</code> is
					maximum the minimum range is <code>[-2<superscript>b-1</superscript>,
					2<superscript>b-1</superscript>-1]</code>.
					Otherwise, if <emphasis>signed_range</emphasis> is symmetric the minimum range
					is <code>[-(2<superscript>b-1</superscript>-1),
					2<superscript>b-1</superscript>-1]</code>;</para>
			</listitem>

			<listitem>
				<para>For the type char which is not specified as signed or unsigned,
					if <emphasis>char_type</emphasis> is <code>signed</code> then
					<code>char</code> is treated as <code>signed</code>, if
					<emphasis>char_type</emphasis> is unsigned then <code>char</code>
					is treated as <code>unsigned</code>, and if
					<emphasis>char_type</emphasis> is <code>either</code>, the
					minimum range of <code>char</code> is the intersection of the
					minimum ranges of <code>signed char</code> and
					<code>unsigned char</code>.</para>
			</listitem>
		</itemizedlist>
	</section>
</appendix>

