/*
 * The lexical analyser for Sid's grammar parser.
 * $Id$
 */

/*
 *  AUTOMATICALLY GENERATED BY lexi VERSION 1.3
 */


/* LOOKUP TABLE */

static unsigned char lookup_tab[257] = {
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0001, 0x0001, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0001, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0004, 0x0000, 0x0000,
	0x0004, 0x0004, 0x0004, 0x0004, 0x0004, 0x0004, 0x0004, 0x0004,
	0x0004, 0x0004, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x000e, 0x000e, 0x000e, 0x000e, 0x000e, 0x000e, 0x000e,
	0x000e, 0x000e, 0x000e, 0x000e, 0x000e, 0x000e, 0x000e, 0x000e,
	0x000e, 0x000e, 0x000e, 0x000e, 0x000e, 0x000e, 0x000e, 0x000e,
	0x000e, 0x000e, 0x000e, 0x0000, 0x0000, 0x0000, 0x0000, 0x0006,
	0x0000, 0x000e, 0x000e, 0x000e, 0x000e, 0x000e, 0x000e, 0x000e,
	0x000e, 0x000e, 0x000e, 0x000e, 0x000e, 0x000e, 0x000e, 0x000e,
	0x000e, 0x000e, 0x000e, 0x000e, 0x000e, 0x000e, 0x000e, 0x000e,
	0x000e, 0x000e, 0x000e, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000,
	0x0000
};

#ifndef LEX_EOF
#define LEX_EOF		256
#endif

#define lookup_char(C)	((int)lookup_tab[(C)])
#define is_white(T)	((T) & 0x0001)
#define is_identstart(T)	((T) & 0x0002)
#define is_identbody(T)	((T) & 0x0004)
#define is_builtin(T)	((T) & 0x0008)


/* MAIN PASS ANALYSER */

int
read_token(void)
{
	start: {
	int c0 = read_char(), t0;
	t0 = lookup_char(c0);
	if (is_white(t0)) goto start;
	switch (c0) {
	    case '!': {
		return(LEXER_TOK_IGNORE);
	    }
	    case '#': {
		int c1 = read_char();
		if (c1 == '#') {
		    return(LEXER_TOK_HANDLER_SEP);
		}
		unread_char(c1);
		break;
	    }
	    case '$': {
		return(LEXER_TOK_EMPTY);
	    }
	    case '%': {
		return(read_builtin(c0));
	    }
	    case '&': {
		return(LEXER_TOK_REFERENCE);
	    }
	    case '(': {
		return(LEXER_TOK_OPEN_TUPLE);
	    }
	    case ')': {
		return(LEXER_TOK_CLOSE_TUPLE);
	    }
	    case ',': {
		return(LEXER_TOK_SEPARATOR);
	    }
	    case '-': {
		int c1 = read_char();
		if (c1 == '>') {
		    return(LEXER_TOK_ARROW);
		}
		unread_char(c1);
		break;
	    }
	    case '/': {
		int c1 = read_char();
		if (c1 == '*') {
		    return(skip_bracketed_comment(c0, c1));
		} else if (c1 == '/') {
		    return(skip_singleline_comment(c0, c1));
		}
		unread_char(c1);
		break;
	    }
	    case ':': {
		int c1 = read_char();
		if (c1 == ':') {
		    return(LEXER_TOK_SCOPEMARK);
		}
		unread_char(c1);
		return(LEXER_TOK_TYPEMARK);
	    }
	    case ';': {
		return(LEXER_TOK_TERMINATOR);
	    }
	    case '<': {
		return(LEXER_TOK_BEGIN_ACTION);
	    }
	    case '=': {
		return(LEXER_TOK_DEFINE);
	    }
	    case '>': {
		return(LEXER_TOK_END_ACTION);
	    }
	    case '?': {
		return(LEXER_TOK_PRED_RESULT);
	    }
	    case '[': {
		return(LEXER_TOK_BEGIN_SCOPE);
	    }
	    case ']': {
		return(LEXER_TOK_END_SCOPE);
	    }
	    case '{': {
		return(LEXER_TOK_BEGIN_RULE);
	    }
	    case '|': {
		int c1 = read_char();
		if (c1 == '|') {
		    return(LEXER_TOK_ALT_SEP);
		}
		unread_char(c1);
		break;
	    }
	    case '}': {
		return(LEXER_TOK_END_RULE);
	    }
	}
	if (is_identstart(t0)) {
	    return(read_identifier(c0));
	}
	return(unknown_token(c0));
	}
}
