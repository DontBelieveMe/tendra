/* $Id$ */

/*
 * Copyright 2011, The TenDRA Project.
 * Copyright 1997, United Kingdom Secretary of State for Defence.
 *
 * See doc/copyright/ for the full copyright terms.
 */

%types%

/*
    TYPES

    There are four types, representing booleans, identifiers, input strings
    and strings of character codes.
*/

BOOL ;
IDENTIFIER ;
ZONE;
STRING ;

CMD ;
CMD_LIST ;

TYPETUPLE;

ARG ;
ARGS_LIST ;

%terminals%

/*
    TERMINALS

    These terminals give the various terminals identified by the lexical
    analysis routines.
*/

identifier : () -> ( :IDENTIFIER ) ;
sid-identifier : () -> ( :IDENTIFIER ) ;
string : () -> ( :STRING ) ;

upper : () -> ( :STRING ) ;
lower : () -> ( :STRING ) ;
digit : () -> ( :STRING ) ;

group ;
keyword ;
mapping ;
token ;
white ;
default ;
zone ;

open ;
close ;
open-brace ;
close-brace ;

arrow ;
eof ;
equal ;
plus ;
semicolon ;
colon ;
reference ;
range ;
range-closed-closed ;
range-closed-open ;
comma;
nothing-marker;
!unknown ;

arg-char-string : () -> (:ARG);
arg-char-nb : () -> (:ARG);
arg-nb-of-chars : () -> (:ARG);
arg-return-terminal : () -> (:ARG);
arg-ignore : () -> (:ARG);

action-kw ;
begin-action ; 		// <
end-action ; 		// >


type-kw ;

%productions%


/*
    ACTION DECLARATIONS

    The actions are described in more detail in the action definition
    file.
*/

<string-concat> : ( :STRING, :STRING ) -> ( :STRING ) ;
<make-white> : ( :ZONE, :STRING ) -> () ;
<make-group> : ( :ZONE, :IDENTIFIER, :STRING ) -> () ;
<make-trigraph> : ( :ZONE, :STRING, :STRING ) -> () ;
<make-terminal-inst>  :  ( :IDENTIFIER) -> (:CMD) ;
<make-action-inst> : (:ZONE, :IDENTIFIER, :ARGS_LIST, :ARGS_LIST) -> (:CMD) ;
<make-donothing-inst> : () -> (:CMD) ;
<make-token> : ( :ZONE, :STRING, :CMD_LIST) -> () ;
<make-default> : ( :ZONE, :CMD_LIST ) -> () ;
<make-keyword> : ( :ZONE, :STRING, :CMD ) -> () ;
<true> : () -> ( :BOOL ) ;
<false> : () -> ( :BOOL ) ;

<empty-identifier> : () -> ( :IDENTIFIER );

//<global-zone> : () -> ( :ZONE );
<is-global-zone> : ( :ZONE ) -> ( :BOOL );

<empty-args-list> : () -> ( :ARGS_LIST) ;
<check-args-list> : ( :ARGS_LIST) -> () ;
<args-list-push-front>: ( :ARG , :ARGS_LIST) -> () ;
<append-arg-args-list>: ( :ARGS_LIST, :ARG ) -> () ;
<make_arg_terminal> : (:IDENTIFIER) -> (:ARG);
<make_arg_from_identifier> : (:IDENTIFIER) -> (:ARG);
<make_arg_from_reference> : (:IDENTIFIER) -> (:ARG);
<make_arg_none> : () -> (:ARG);

<empty-inst-list> : () -> ( : CMD_LIST);
<add-inst-to-list> : ( : ZONE, : CMD, : CMD_LIST ) -> ();
<check-inst-list> : (: CMD_LIST ) -> ();


<E_expected_identifier> : () -> (:IDENTIFIER);
<E_expected_begin_action> : () -> ();
<E_expected_end_action> : () -> ();
<E_expected_range> : () -> ();
<E_expected_open> : () -> ();
<E_expected_close> : () -> ();
<E_expected_chars> : () -> (:STRING);

<E_nonglobalzonekeyword> : () -> ();
<E_nonglobalzonetype>    : (:IDENTIFIER) -> ();
<E_expected_colon>	 : () -> ();
<E_expected_semicolon> 	 : () -> ();
<E_expected_arrow> 	 : () -> ();
<E_expected_equal> 	 : () -> ();

<E_sharp_arg_in_lhs> : () -> ();
<E_string_arg_in_lhs> : () -> ();
<E_terminal_in_lhs> :() -> (); 

<E_return_terminal_in_rhs> : () -> ();
<E_string_in_action_rhs> : () -> ();

<is-non-empty> : ( : STRING ) -> ( : BOOL );
<E_empty_character_string> : () -> ();
<E_ignore_in_rhs> : () -> ();

<syntax-error> : () -> () ;

<make-zone> : ( :ZONE, :IDENTIFIER, :STRING, :CMD_LIST, 
	      	:STRING, :CMD_LIST, : BOOL ) -> ( :ZONE );
<update-zone-type> : (:ZONE, :ZONE) -> ();

<make-type>: (:ZONE, :IDENTIFIER) -> ();
<init-tuple>: () -> (:TYPETUPLE);
<append-tuple> : (:ZONE, :TYPETUPLE&,:IDENTIFIER,:IDENTIFIER,:BOOL) -> ();
<make-action> : (:ZONE, :IDENTIFIER, :TYPETUPLE&, :TYPETUPLE&) -> ();

/*
    STRINGS

    This action gives the full definition of a string, including special
    strings and string concatenation.
*/

string-plus : () -> ( s : STRING ) = {
	{
		a = string ;
	    ||	a = upper ;
	    ||	a = lower ;
	    ||	a = digit ;
	} ; 
	{
		s = a ;
	    ||	plus ; b = string-plus ; s = <string-concat> ( a, b ) ;
	} ;
} ;


/*
    CHARACTER STRING
*/

non-empty-chars : () -> (s: STRING) ={
	s = string-plus;
	{
		? = <is-non-empty>(s);
	    ##
		<E_empty_character_string>;
	};
};



/*
    WHITE SPACE DEFINITION

    This action defines the set of white space characters.
*/

white-defn : ( z:ZONE ) -> () = {
	group ; 
	white ; 
	{
		equal ; 
	    ##	
		<E_expected_equal>;
	};
	s = string-plus ; <make-white> ( z, s ) ;
} ;


/*
    CHARACTER GROUP DEFINITION

    This action assigns a name to a group of characters.
*/

group-defn : ( z:ZONE ) -> () = {
        group ; 
	i = identifier ; 
	{
		equal ; 
	    ##
	    	<E_expected_equal>;
	};
	s = non-empty-chars ; 
	<make-group> ( z, i, s ) ;
} ;


/*
    TRIGRAPH DEFINITION

    This action defines a lexical pre-pass mapping (for example, trigraphs
    in ANSI C).
*/

trigraph-defn : ( z:ZONE) -> () = {
	mapping ; s = string-plus ; 
	{
		arrow ; 
	    ##
		<E_expected_arrow>;
	} ;
	t = string-plus ; 
    	<make-trigraph> ( z, s, t ) ;
} ;

/*
	TYPE DEFINITION

	This defines a lexi type
*/
type-defn : (z:ZONE) -> () = {
	type-kw ; s = identifier ;
	{
		?=<is-global-zone> (z) ; 
		<make-type> (z, s) ;
	    ##
		<E_nonglobalzonetype>(s);
	};
} ;



/* 
   List of Type Tuples ;
*/

type-tuple : ( z:ZONE ) -> (a:TYPETUPLE) [
	type-name : (z:ZONE, a:TYPETUPLE&) -> () = {
		{
			name=identifier ;
		    ||	
		    	name=<empty-identifier>;
		};
		colon ;
		type=identifier ;
		{
			isref = <false>;
		    ||
			reference; isref = <true>;
		};
		<append-tuple>(z, &a, name, type, isref);
	} ;
	type-tuple1 : (z:ZONE, a:TYPETUPLE&) -> () = {
		type-name(z, &a) ;
	    ||
		type-name(z, &a) ; comma; type-tuple1(z, &a) ;
	} ; ] = {
	a=<init-tuple> ;
    ||
	a=<init-tuple>;
	type-tuple1(z, &a) ;
};


/* 
   ACTION DEFINITION
*/

action-decl : (z:ZONE) -> () = {
	action-kw;
	{
		begin-action ;
	    ##
		<E_expected_begin_action>;
	};
	i = identifier ;
	{
		end-action ;
	    ##
		<E_expected_end_action>;
	};
	{
		it = <init-tuple>;
		ot = <init-tuple>;
	    ||
		colon ;
		{
			open ;
		    ##
			<E_expected_open>;
		};
		it=type-tuple(z) ;
		{
			close ;
		    ##
			<E_expected_close>;
		};
		{
			arrow ;
		    ##
			<E_expected_arrow> ;
		} ;
		{
			open ;
		    ##
			<E_expected_open>;
		};
		ot=type-tuple(z) ;
		{
			close ;
		    ##
			<E_expected_close>;
		};
	} ;
	<make-action>(z,i,&it,&ot);
} ;

/*
   ACTION CALL 
*/

action-call : (z:ZONE) -> (inst:CMD) [
	lhs-arg : (l:ARGS_LIST) -> () = {
		{
		        b=arg-char-string ; a=<make_arg_none>; <E_sharp_arg_in_lhs>;
		    ||  b=arg-char-nb ; a=<make_arg_none>; <E_sharp_arg_in_lhs>;
		    ||  b=arg-nb-of-chars ; a=<make_arg_none>; <E_sharp_arg_in_lhs>;
		    ||  b=string ; a=<make_arg_none>; <E_string_arg_in_lhs>;
		    ||  i=identifier ; a=<make_arg_from_identifier>(i);
		    ||  reference; i=identifier ; a=<make_arg_from_reference>(i);
		    ||  b=sid-identifier ; a=<make_arg_none>; <E_terminal_in_lhs>; 
		    ||  a=arg-return-terminal ;
		    ||  a=arg-ignore ;
		 };
		<append-arg-args-list>(l, a); 
	};

	lhs-tuple1 : (l:ARGS_LIST) -> () = {
		lhs-arg(l) ; 
	    ||
		lhs-arg(l); comma; lhs-tuple1(l); 

	};
	lhs-tuple : (l:ARGS_LIST) -> () = { 
		{
			lhs-arg(l);  
		    ||
			open;
			lhs-tuple1(l);
			close;
		};
	};
	rhs-arg : () -> ( a : ARG ) = {
	        a=arg-char-string ;
	    ||  a=arg-char-nb ;
	    ||  a=arg-nb-of-chars ;
	    ||  b=sid-identifier ; a=<make_arg_terminal>(b); 
	    ||  b=arg-return-terminal ; a=<make_arg_none>; <E_return_terminal_in_rhs>;
	    ||  b=arg-ignore ; a=<make_arg_none>; <E_ignore_in_rhs>;
	    ||  b=string ; a=<make_arg_none>; <E_string_in_action_rhs>;
	    ||  reference; i=identifier ; a=<make_arg_from_reference>(i);
	    ||	i=identifier ; a=<make_arg_from_identifier>(i);
	} ;
	rhs-tuple1 : () -> (r:ARGS_LIST) = {
		a = rhs-arg ; r=<empty-args-list> ; <args-list-push-front>(a,r); 
	    ||
		a = rhs-arg; comma; r = rhs-tuple1; <args-list-push-front>(a,r);

	};
	rhs-tuple : () -> (r: ARGS_LIST) = {
     		open ;
		{
			r = <empty-args-list> ;
		    ||
			r = rhs-tuple1 ;
		} ;
		close;
	}; ] = {
	l = <empty-args-list> ;
       	{
		$;
	    ||
		lhs-tuple(l) ;
		equal ;
	} ;
	begin-action ;
	i = identifier ;
	<check-args-list>(l);
	end-action ; 
	{
		r=<empty-args-list> ;
	    ||
		r = rhs-tuple;
	};
	inst = <make-action-inst>(z, i, l, r) ;
} ;


/*
  COMMAND LISTS
*/

cmd : (z:ZONE) -> (inst:CMD) = {
	l = <empty-args-list> ;
	i = sid-identifier ; 
	inst = <make-terminal-inst>(i);
    ||	
	l = <empty-args-list> ;
	nothing-marker; 
	inst = <make-donothing-inst>;
    ||	
    	inst = action-call(z) ;
} ;

cmd-list : (z:ZONE) -> (instl:CMD_LIST) = {
	inst=cmd(z);
	instl=<empty-inst-list>;
	<add-inst-to-list>(z, inst, instl);
    ||
	instl=cmd-list(z);
   	comma;
	inst=cmd(z);
	<add-inst-to-list>(z, inst, instl);
} ;

/*
    TOKEN DEFINITION

    This action defines a lexical main-pass mapping (for example, operators
    and keywords).
*/

token-defn : ( z:ZONE ) -> () = {
	token ; s = non-empty-chars ; arrow ;
	inst-list=cmd-list(z);
	<check-inst-list>(inst-list);
	<make-token> ( z, s, inst-list) ;
} ;

default-defn : ( z:ZONE ) -> () = {
        token ; default ; arrow ;
	inst-list=cmd-list(z);
        <make-default> ( z, inst-list) ; 
} ;



/*
    KEYWORD DEFINITION

    This action defines a keyword.
*/

keyword-defn : ( z:ZONE ) -> () = {
	keyword ; s = string ; arrow ;
	inst=cmd(z) ; 
	{
		?=<is-global-zone> (z); 
	    	<make-keyword> ( z, s, inst) ;
	    ##
		<E_nonglobalzonekeyword>;
	};
} ;


/*
    COMMANDS

    These actions define the composite commands derived from the basic
    commands above.
*/

command : (:ZONE) -> () ;

command-list : (z:ZONE) -> () = {
	$ ;
    ||	command(z) ; command-list(z) ;
    ##	<syntax-error> ;
} ;

zone-defn : (z:ZONE) -> ()  = {
	zone; 
	{
		zid = identifier; 
	    ##  
	    	zid=<E_expected_identifier>;
	};
	{
		colon;
	    ##
		<E_expected_colon>;
	};
	{
		b=non-empty-chars; 
	    ##  
	    	b=<E_expected_chars>;
	};
	{
		arrow; 
		entry-instl=cmd-list(z);
	    ||  
		entry-instl=<empty-inst-list>;
	};
	{
		range ; lendclosed =<true> ;
	    ||  
		range-closed-closed ; lendclosed =<true> ;
	    ||  
		range-closed-open ; lendclosed =<false> ;
	    ##
		<E_expected_range>; lendclosed=<false> ;
	};
	{
		e=non-empty-chars; 
	    ##  
	    	e=<E_expected_chars>;
	};
	{
		arrow; 
		leaving-instl=cmd-list(z);
	    ||  
		leaving-instl=<empty-inst-list>;
	};
	new-zone=<make-zone>(z,zid,b,entry-instl,e,leaving-instl,lendclosed);

	open-brace ; command-list(new-zone) ; close-brace ;
	<update-zone-type>(z,new-zone);
} ;

expected_semicolon : () -> () = {
	semicolon ; 
    ##
	<E_expected_semicolon>;
} ;

command : (z:ZONE) -> () = {
	semicolon ;
    ||	white-defn ( z ) ; expected_semicolon ;	
    ||	group-defn ( z ) ; expected_semicolon ;
    ||	trigraph-defn ( z ) ; expected_semicolon ;
    ||	token-defn ( z ) ; expected_semicolon ;
    ||	keyword-defn ( z ) ; expected_semicolon ;
    ||  default-defn ( z ); expected_semicolon ;
    ||  zone-defn ( z ) ;
    ||	open-brace ; command-list( z ) ; close-brace ;
    ||  type-defn ( z ) ; expected_semicolon ;
    ||	action-decl ( z ) ; expected_semicolon ;
} ;


/*
    COMPLETE UNIT

    This action gives the main entry point for the syntax.  A complete
    unit just consists of a list of commands.
*/

unit : (z:ZONE) -> () = {
	command-list ( z ) ;
	{
		eof ;
	    ##	<syntax-error> ;
	} ;
}  ;

%entry% unit ;
