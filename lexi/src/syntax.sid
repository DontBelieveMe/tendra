/*
    		 Crown Copyright (c) 1997
    
    This TenDRA(r) Computer Program is subject to Copyright
    owned by the United Kingdom Secretary of State for Defence
    acting through the Defence Evaluation and Research Agency
    (DERA).  It is made available to Recipients with a
    royalty-free licence for its use, reproduction, transfer
    to other parties and amendment for any purpose not excluding
    product development provided that any such use et cetera
    shall be deemed to be acceptance of the following conditions:-
    
        (1) Its Recipients shall ensure that this Notice is
        reproduced upon any copies or amended versions of it;
    
        (2) Any amended version of it shall be clearly marked to
        show both the nature of and the organisation responsible
        for the relevant amendment or amendments;
    
        (3) Its onward transfer from a recipient to another
        party shall be deemed to be that party's acceptance of
        these conditions;
    
        (4) DERA gives no warranty or assurance as to its
        quality or suitability for any purpose and DERA accepts
        no liability whatsoever in relation to any use to which
        it may be put.
*/


%types%

/*
    TYPES

    There are four types, representing booleans, identifiers, input strings
    and strings of character codes.
*/

BOOL ;
CHARACTERS ;
IDENTIFIER ;
ZONE;
STRING ;

INSTRUCTION ;
INSTRUCTIONS_LIST ;

TYPETUPLE;

ARG ;
ARGS_LIST ;

%terminals%

/*
    TERMINALS

    These terminals give the various terminals identified by the lexical
    analysis routines.
*/

identifier : () -> ( :IDENTIFIER ) ;
sid-identifier : () -> ( :IDENTIFIER ) ;
string : () -> ( :STRING ) ;

upper : () -> ( :STRING ) ;
lower : () -> ( :STRING ) ;
digit : () -> ( :STRING ) ;

copyright;

group ;
keyword ;
mapping ;
token ;
white ;
default ;
zone ;

if ;
else ;

open ;
close ;
open-brace ;
close-brace ;

arrow ;
eof ;
equal ;
plus ;
semicolon ;
colon ;
reference ;
range ;
range-closed-closed ;
range-closed-open ;
comma;
nothing-marker;
!unknown ;

arg-char-list : () -> (:ARG);
arg-char-string : () -> (:ARG);
arg-char-nb : () -> (:ARG);
arg-nb-of-chars : () -> (:ARG);
arg-return-terminal : () -> (:ARG);
arg-ignore : () -> (:ARG);
arg-char-void; //temporary

action-kw ;
begin-action ; 		// <
end-action ; 		// >


type-kw ;

%productions%


/*
    ACTION DECLARATIONS

    The actions are described in more detail in the action definition
    file.
*/

<string-concat> : ( :STRING, :STRING ) -> ( :STRING ) ;
<make-chars> : ( :ZONE, :STRING ) -> ( :CHARACTERS ) ;
<make-white> : ( :ZONE, :CHARACTERS ) -> () ;
<make-group> : ( :ZONE, :IDENTIFIER, :CHARACTERS ) -> () ;
<make-trigraph> : ( :ZONE, :CHARACTERS, :STRING ) -> () ;
<make-inst>  :  ( :IDENTIFIER, :ARGS_LIST) -> (:INSTRUCTION) ;
<make-action-inst> : (:ZONE, :IDENTIFIER, :ARGS_LIST, :ARGS_LIST) -> (:INSTRUCTION) ;
<make-donothing-inst> : () -> (:INSTRUCTION) ;
<make-token> : ( :ZONE, :CHARACTERS, :INSTRUCTIONS_LIST ) -> () ;
<make-default> : ( :ZONE, :INSTRUCTIONS_LIST ) -> () ;
<make-keyword> : ( :ZONE, :STRING, :INSTRUCTION ) -> () ;
<add-condition> : ( :IDENTIFIER ) -> () ;
<compl-condition> : () -> () ;
<get-condition> : () -> ( :IDENTIFIER ) ;
<set-condition> : ( :IDENTIFIER ) -> () ;
<true> : () -> ( :BOOL ) ;
<false> : () -> ( :BOOL ) ;

<empty-identifier> : () -> ( :IDENTIFIER );

//<global-zone> : () -> ( :ZONE );
<is-global-zone> : ( :ZONE ) -> ( :BOOL );

<null-args-list> : () -> ( :ARGS_LIST) ;
<empty-args-list> : () -> ( :ARGS_LIST) ;
<args-list-push-front> : ( :ARG , :ARGS_LIST) -> () ;
<arg-char-list-tmp> :    () -> ( :ARG);
<make_arg_terminal> : (:IDENTIFIER) -> (:ARG);
<make_arg_from_string> : (:STRING) -> (:ARG);
<make_arg_from_identifier> : (:IDENTIFIER) -> (:ARG);
<make_arg_from_reference> : (:IDENTIFIER) -> (:ARG);
<make_arg_none> : () -> (:ARG);

<empty-inst-list> : () -> ( : INSTRUCTIONS_LIST);
<add-inst-to-list> : ( : ZONE, : INSTRUCTION, : INSTRUCTIONS_LIST ) -> ();

<E_expected_identifier> : () -> (:IDENTIFIER);
<E_expected_begin_action> : () -> ();
<E_expected_end_action> : () -> ();
<E_expected_range> : () -> ();
<E_expected_open> : () -> ();
<E_expected_close> : () -> ();
<E_expected_chars> : () -> (:CHARACTERS);

<E_nonglobalzonekeyword> : () -> ();
<E_nonglobalzonetype>    : (:IDENTIFIER) -> ();
<E_nonglobalzonecopyright> : () -> ();
<E_expected_colon>	 : () -> ();
<E_expected_semicolon> 	 : () -> ();
<E_expected_arrow> 	 : () -> ();
<E_expected_equal> 	 : () -> ();

<E_sharp_arg_in_lhs> : () -> ();
<E_string_arg_in_lhs> : () -> ();
<E_terminal_in_lhs> :() -> (); 

<E_return_terminal_in_rhs> : () -> ();
<E_string_in_action_rhs> : () -> ();

<E_terminal_in_function_rhs>;
<E_localname_in_function_rhs>;

<is-non-empty> : ( : CHARACTERS , :ZONE) -> ( : BOOL );
<E_empty_character_string> : () -> ();
<E_ignore_in_rhs> : () -> ();
<E_sharp_list_in_action_rhs> : () -> ();

<syntax-error> : () -> () ;

<make-zone> : ( :ZONE, :IDENTIFIER, :CHARACTERS, :INSTRUCTIONS_LIST, 
	      	:CHARACTERS, :INSTRUCTIONS_LIST, : BOOL ) -> ( :ZONE );

<make-copyright> : ( :STRING ) -> () ;

<make-type>: (:ZONE, :IDENTIFIER) -> ();
<init-tuple>: () -> (:TYPETUPLE);
<append-tuple> : (:ZONE, :TYPETUPLE&,:IDENTIFIER,:IDENTIFIER,:BOOL) -> ();
<make-action> : (:ZONE, :IDENTIFIER, :TYPETUPLE&, :TYPETUPLE&) -> ();

/*
    STRINGS

    This action gives the full definition of a string, including special
    strings and string concatenation.
*/

string-plus : () -> ( s : STRING ) = {
	{
		a = string ;
	    ||	a = upper ;
	    ||	a = lower ;
	    ||	a = digit ;
	} ; 
	{
		s = a ;
	    ||	plus ; b = string-plus ; s = <string-concat> ( a, b ) ;
	} ;
} ;


/*
    CHARACTER STRING

    This action transforms an input string into the internal representation
    of arrays of character codes.
*/

chars : (z:ZONE) -> ( c : CHARACTERS ) = {
	s = string-plus ;
	c = <make-chars> ( z, s ) ;
} ;

non-empty-chars : (z:ZONE) -> (c: CHARACTERS) ={
	c=chars(z);
	{
		?=<is-non-empty>(c,z);
	    ##
		<E_empty_character_string>;
	};
};



copyright-stmt : ( z:ZONE ) -> () = {
	copyright; equal; s = string ;
	{
		?=<is-global-zone> (z) ; 
		<make-copyright> (s) ;
	    ##
		<E_nonglobalzonecopyright>;
	};
}; 


/*
    WHITE SPACE DEFINITION

    This action defines the set of white space characters.
*/

white-defn : ( z:ZONE ) -> () = {
	group ; 
	white ; 
	{
		equal ; 
	    ##	
		<E_expected_equal>;
	};
	s = chars(z) ; <make-white> ( z, s ) ;
} ;


/*
    CHARACTER GROUP DEFINITION

    This action assigns a name to a group of characters.
*/

group-defn : ( z:ZONE ) -> () = {
        group ; 
	i = identifier ; 
	{
		equal ; 
	    ##
	    	<E_expected_equal>;
	};
	s = chars(z) ; 
	<make-group> ( z, i, s ) ;
} ;


/*
    RETURN ARGUMENTS

    This action deals with the optional arguments which may be used in
    a token definition.
*/

single-arg : () -> ( a : ARG ) = {
	a=arg-char-list ;
    ||  a=arg-char-string ;
    ||  a=arg-char-nb ;
    ||  a=arg-nb-of-chars ;
    ||  b=arg-return-terminal ; a=<make_arg_none>; <E_return_terminal_in_rhs>;
    ||  a=arg-ignore ; <E_ignore_in_rhs>;
    ||  b=string ; a=<make_arg_from_string>(b);
    ||  b=sid-identifier ; a=<make_arg_none>; <E_terminal_in_function_rhs>;
    ||  i=identifier ; a = <make_arg_none>; <E_localname_in_function_rhs>;
    ||  reference; i=identifier ; a = <make_arg_from_reference>(i); 
} ;

non-empty-tuple-args : () -> (l: ARGS_LIST) = {
	a=single-arg ; l=<empty-args-list> ; <args-list-push-front>(a,l); 
    ||
	a=single-arg ; comma ; l=non-empty-tuple-args ;
	<args-list-push-front>(a,l);
} ;

tuple-args : () -> (l : ARGS_LIST) = {
	l=<empty-args-list> ;
	tmp=<arg-char-list-tmp>;
	<args-list-push-front>(tmp,l); 
    ||
	arg-char-void; //temporary
	l=<empty-args-list> ;
    ||
	l=non-empty-tuple-args ;  
};

args : () -> ( l : ARGS_LIST ) = {
	l = <null-args-list> ;
    ||	open ; l=tuple-args ; close ;
} ;


/*
    TRIGRAPH DEFINITION

    This action defines a lexical pre-pass mapping (for example, trigraphs
    in ANSI C).
*/

trigraph-defn : ( z:ZONE) -> () = {
	mapping ; s = chars(z) ; 
	{
		arrow ; 
	    ##
		<E_expected_arrow>;
	} ;
	t = string-plus ; 
    	<make-trigraph> ( z, s, t ) ;
} ;

/*
	TYPE DEFINITION

	This defines a lexi type
*/
type-defn : (z:ZONE) -> () = {
	type-kw ; s = identifier ;
	{
		?=<is-global-zone> (z) ; 
		<make-type> (z, s) ;
	    ##
		<E_nonglobalzonetype>(s);
	};
} ;



/* 
   List of Type Tuples ;
*/

type-tuple : ( z:ZONE ) -> (a:TYPETUPLE) [
	type-name : (z:ZONE, a:TYPETUPLE&) -> () = {
		{
			name=identifier ;
		    ||	
		    	name=<empty-identifier>;
		};
		colon ;
		type=identifier ;
		{
			isref = <false>;
		    ||
			reference; isref = <true>;
		};
		<append-tuple>(z, &a, name, type, isref);
	} ;
	type-tuple1 : (z:ZONE, a:TYPETUPLE&) -> () = {
		type-name(z, &a) ;
	    ||
		type-name(z, &a) ; comma; type-tuple1(z, &a) ;
	} ; ] = {
	a=<init-tuple> ;
    ||
	a=<init-tuple>;
	type-tuple1(z, &a) ;
};


/* 
   ACTION DEFINITION
*/

action-decl : (z:ZONE) -> () = {
	action-kw;
	{
		begin-action ;
	    ##
		<E_expected_begin_action>;
	};
	i = identifier ;
	{
		end-action ;
	    ##
		<E_expected_end_action>;
	};
	{
		it = <init-tuple>;
		ot = <init-tuple>;
	    ||
		colon ;
		{
			open ;
		    ##
			<E_expected_open>;
		};
		it=type-tuple(z) ;
		{
			close ;
		    ##
			<E_expected_close>;
		};
		{
			arrow ;
		    ##
			<E_expected_arrow> ;
		} ;
		{
			open ;
		    ##
			<E_expected_open>;
		};
		ot=type-tuple(z) ;
		{
			close ;
		    ##
			<E_expected_close>;
		};
	} ;
	<make-action>(z,i,&it,&ot);
} ;

/*
   ACTION CALL 
*/

action-call : (z:ZONE) -> (inst:INSTRUCTION) [
	lhs-arg : () -> ( a : ARG ) = {
		b=arg-char-list ; a=<make_arg_none>; <E_sharp_arg_in_lhs>;
	    ||  b=arg-char-string ; a=<make_arg_none>; <E_sharp_arg_in_lhs>;
	    ||  b=arg-char-nb ; a=<make_arg_none>; <E_sharp_arg_in_lhs>;
	    ||  b=arg-nb-of-chars ; a=<make_arg_none>; <E_sharp_arg_in_lhs>;
	    ||  b=string ; a=<make_arg_none>; <E_string_arg_in_lhs>;
	    ||  i=identifier ; a=<make_arg_from_identifier>(i);
	    ||  reference; i=identifier ; a=<make_arg_from_reference>(i);
	    ||  b=sid-identifier ; a=<make_arg_none>; <E_terminal_in_lhs>; 
	    ||  a=arg-return-terminal ;
	    ||  a=arg-ignore ;
} ;

	lhs-tuple1 : () -> (l:ARGS_LIST) = {
		a = lhs-arg ; l=<empty-args-list> ; <args-list-push-front>(a,l); 
	    ||
		a = lhs-arg; comma; l = lhs-tuple1; <args-list-push-front>(a,l);

	};
	lhs-tuple : () -> (l:ARGS_LIST) = {
		a=lhs-arg; l=<empty-args-list> ; <args-list-push-front>(a,l); 
	    ||
		open;
		l = lhs-tuple1;
		close;
	};
	rhs-arg : () -> ( a : ARG ) = {
		b=arg-char-list ; a=<make_arg_none>; <E_sharp_list_in_action_rhs>;
	    ||  a=arg-char-string ;
	    ||  a=arg-char-nb ;
	    ||  a=arg-nb-of-chars ;
	    ||  b=sid-identifier ; a=<make_arg_terminal>(b); 
	    ||  b=arg-return-terminal ; a=<make_arg_none>; <E_return_terminal_in_rhs>;
	    ||  b=arg-ignore ; a=<make_arg_none>; <E_ignore_in_rhs>;
	    ||  b=string ; a=<make_arg_none>; <E_string_in_action_rhs>;
	    ||  reference; i=identifier ; a=<make_arg_from_reference>(i);
	    ||	i=identifier ; a=<make_arg_from_identifier>(i);
	} ;
	rhs-tuple1 : () -> (r:ARGS_LIST) = {
		a = rhs-arg ; r=<empty-args-list> ; <args-list-push-front>(a,r); 
	    ||
		a = rhs-arg; comma; r = rhs-tuple1; <args-list-push-front>(a,r);

	};
	rhs-tuple : () -> (r: ARGS_LIST) = {
     		open ;
		{
			r = <empty-args-list> ;
		    ||
			r = rhs-tuple1 ;
		} ;
		close;
	}; ] = {
       	{
	        l = <empty-args-list> ;
	    ||
		l=lhs-tuple ;
		equal ;
	} ;
	begin-action ;
	i = identifier ;
	end-action ; 
	{
		r=<empty-args-list> ;
	    ||
		r = rhs-tuple;
	};
    	inst = <make-action-inst>(z, i, l, r) ;
} ;


/*
  INSTRUCTION LISTS
*/

instruction : (z:ZONE) -> (inst:INSTRUCTION) = {
	{
		i = identifier ; a = args ;
	    ||	
	    	i = sid-identifier ; a = <null-args-list> ;
	} ;
	inst = <make-inst>( i, a);
    ||	
    	{
		nothing-marker; 
		inst = <make-donothing-inst>;
	} ;
    ||	
    	inst = action-call(z) ;
} ;

instructions-list : (z:ZONE) -> (instl:INSTRUCTIONS_LIST) = {
	inst=instruction(z);
	instl=<empty-inst-list>;
	<add-inst-to-list>(z, inst, instl);
    ||
	instl=instructions-list(z);
   	comma;
	inst=instruction(z);
	<add-inst-to-list>(z, inst, instl);
} ;

/*
    TOKEN DEFINITION

    This action defines a lexical main-pass mapping (for example, operators
    and keywords).
*/

token-defn : ( z:ZONE ) -> () = {
	token ; s = non-empty-chars(z) ; arrow ;
	inst-list=instructions-list(z);
	<make-token> ( z, s, inst-list) ;
} ;

default-defn : ( z:ZONE ) -> () = {
        token ; default ; arrow ;
	inst-list=instructions-list(z);
        <make-default> ( z, inst-list) ; 
} ;



/*
    KEYWORD DEFINITION

    This action defines a keyword.
*/

keyword-defn : ( z:ZONE ) -> () = {
	keyword ; s = string ; arrow ;
	inst=instruction(z) ; 
	{
		?=<is-global-zone> (z); 
	    	<make-keyword> ( z, s, inst) ;
	    ##
		<E_nonglobalzonekeyword>;
	};
} ;


/*
    COMMANDS

    These actions define the composite commands derived from the basic
    commands above.
*/

command : (:ZONE) -> () ;

command-list : (z:ZONE) -> () = {
	$ ;
    ||	command(z) ; command-list(z) ;
    ##	<syntax-error> ;
} ;

if-command : (z:ZONE) -> () = {
	if ; open ; i = identifier ; close ;
	j = <get-condition> ;
	<add-condition> ( i ) ;
	command ( z ) ;
	{
		else ; <compl-condition> ; command ( z ) ; <set-condition> ( j ) ;
	    ##	<set-condition> ( j ) ;
	} ;
} ;

zone-defn : (z:ZONE) -> ()  = {
	zone; 
	{
		zid = identifier; 
	    ##  
	    	zid=<E_expected_identifier>;
	};
	{
		colon;
	    ##
		<E_expected_colon>;
	};
	{
		b=non-empty-chars(z); 
	    ##  
	    	b=<E_expected_chars>;
	};
	{
		arrow; 
		entry-instl=instructions-list(z);
	    ||  
		entry-instl=<empty-inst-list>;
	};
	{
		range ; lendclosed =<true> ;
	    ||  
		range-closed-closed ; lendclosed =<true> ;
	    ||  
		range-closed-open ; lendclosed =<false> ;
	    ##
		<E_expected_range>; lendclosed=<false> ;
	};
	{
		e=non-empty-chars(z); 
	    ##  
	    	e=<E_expected_chars>;
	};
	{
		arrow; 
		leaving-instl=instructions-list(z);
	    ||  
		leaving-instl=<empty-inst-list>;
	};
	new-zone=<make-zone>(z,zid,b,entry-instl,e,leaving-instl,lendclosed);

	open-brace ; command-list(new-zone) ; close-brace ;
} ;

expected_semicolon : () -> () = {
	semicolon ; 
    ##
	<E_expected_semicolon>;
} ;

command : (z:ZONE) -> () = {
	semicolon ;
    ||	white-defn ( z ) ; expected_semicolon ;	
    ||	group-defn ( z ) ; expected_semicolon ;
    ||	trigraph-defn ( z ) ; expected_semicolon ;
    ||	token-defn ( z ) ; expected_semicolon ;
    ||	keyword-defn ( z ) ; expected_semicolon ;
    ||  default-defn ( z ); expected_semicolon ;
    ||  zone-defn ( z ) ;
    ||	open-brace ; command-list( z ) ; close-brace ;
    ||	if-command ( z ) ;
    ||  copyright-stmt ( z ) ; expected_semicolon ;
    ||  type-defn ( z ) ; expected_semicolon ;
    ||	action-decl ( z ) ; expected_semicolon ;
} ;


/*
    COMPLETE UNIT

    This action gives the main entry point for the syntax.  A complete
    unit just consists of a list of commands.
*/

unit : (z:ZONE) -> () = {
	command-list ( z ) ;
	{
		eof ;
	    ##	<syntax-error> ;
	} ;
}  ;

%entry% unit ;
