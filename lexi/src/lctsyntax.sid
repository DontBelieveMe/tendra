/*
 * Copyright (c) 2002-2005 The TenDRA Project <http://www.tendra.org/>.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 3. Neither the name of The TenDRA Project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific, prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS
 * IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $Id$
 */

%types%
BOOL;
ENTRYP;
IDENTIFIER ;
BIGSTRING ;
TYPETUPLE;
CCODE;

%terminals%

header-kw ;
trailer-kw ;
map-kw ;
action-kw ;
reference ;	//&
colon;
arrow;
define ;  	//=
semicolon ;	//;
comma ;   	//,

code-start;	//@{
code-end;	//@}
lone-code-at;
code-at;
code-eof;

eof;
identifier : () -> (:IDENTIFIER);
code-identifier : () -> (:IDENTIFIER);
code-reference : () -> (:IDENTIFIER);
code-string : () -> (:BIGSTRING);
!unknown ;

%productions%

<true> : () -> (:BOOL) ;
<false> : () -> (:BOOL) ;

<empty-identifier> : () -> ( : IDENTIFIER);

<set-headers> : (:CCODE &, :CCODE&) -> ();
<set-trailers> : (:CCODE &, :CCODE&) -> ();

<init-tuple> : () -> (:TYPETUPLE);
<append-tuple> : (:TYPETUPLE&, :IDENTIFIER, :IDENTIFIER, :BOOL) -> ();

<make-map> : (:IDENTIFIER, :IDENTIFIER) -> ();

<define-action> : (:ENTRYP, :CCODE&) -> ();
<check-action-tuples> : (:ENTRYP, :TYPETUPLE&, :TYPETUPLE&) -> ();	
<null-entry> : () -> (:ENTRYP);
<get-entry-action> : (:IDENTIFIER) -> (:ENTRYP);


<init-ccode> : () -> (:CCODE);
<append-ccode-string> : (:CCODE&, :BIGSTRING&) -> ();
<append-ccode-identifier> : (:CCODE&, :IDENTIFIER, :ENTRYP, :BOOL) -> ();
<append-ccode-at> : (:CCODE&) -> ();


<E-syntax-error> ;
<E_expected_code_end> ;
<E_expected_code_start> ;
<E_expected_comma> ;
<E_expected_define> ;
<E_expected_arrow> ;
<E_expected_semicolon> ;

<E_unexpected_eof> ;
<E_lone_at_in_code_block>;

code-block : (e:ENTRYP) -> (c:CCODE) [
	code-element : (c:CCODE&, e:ENTRYP) -> () = {
		s = code-string ;
		<append-ccode-string>(&c, &s);
	    ||	
	    	i = code-identifier;
		b = <false>;
		<append-ccode-identifier>(&c, i, e, b);
	    ||
	    	i = code-reference;
		b = <true>;
		<append-ccode-identifier>(&c, i, e, b);
	    ||
		lone-code-at;
		<E_lone_at_in_code_block>;
	    ||
		code-at;
		<append-ccode-at>(&c);
	};

	code-body : (c:CCODE&, e:ENTRYP) -> () = {
		$;
	    ||
		code-element(&c, e);
		code-body(&c, e); 
	};
] = {
	{
		code-start ;
    	##
		<E_expected_code_start> ;
	} ;
	c=<init-ccode>;
	code-body(&c, e);
	{
		$ ;
	    ||
		code-eof ; <E_unexpected_eof> ;
	} ;
	{
		code-end ;
	    ##
		<E_expected_code_end> ;
	} ;
};

header-stmnt : () -> () = {
	header-kw ;
	{
		define ;
	    ##
		<E_expected_define> ;
	} ;
	e=<null-entry>;
	sc=code-block(e);
	{
		comma ;
	    ##
		<E_expected_comma> ;
	};
	sh=code-block(e);
	<set-headers>(&sc,&sh);
	{
		semicolon ;
	    ##
		<E_expected_semicolon> ;
	} ;
};

trailer-stmnt : () -> () = {
	trailer-kw ;
	{
		define ;
	    ##
		<E_expected_define> ;
	} ;
	e=<null-entry>;
	sc = code-block(e);
	{
		comma ;
	    ##
		<E_expected_comma> ;
	};
	sh=code-block(e);
	<set-trailers>(&sc,&sh);
	{
		semicolon ;
	    ##
		<E_expected_semicolon> ;
	} ;
};

map-stmnt : () -> () = {
	map-kw ; lexitype=identifier; 
	{
		arrow; 
	    ##
		<E_expected_arrow>;
	};
	ctype=identifier; 
	<make-map>(lexitype, ctype);
	{
		semicolon ;
	    ##
		<E_expected_semicolon> ;
	} ;
};

action-definition : () -> () [ 
	type-tuple : ( ) -> (a:TYPETUPLE) [
		type-name : (a:TYPETUPLE&) -> () = {
			{
				name=identifier ;
			    ||
				name=<empty-identifier>;
			};
			colon ;
			type=identifier ;
			{
				isref = <false>;
			    ||
				reference; isref = <true>;
			};
			<append-tuple>(&a,name,type,isref);
		} ;
		type-tuple1 : (a:TYPETUPLE&) -> () = {
			type-name(&a) ;
		    ||
			type-name(&a) ; comma; type-tuple1(&a) ;
		} ; ] = {
		a=<init-tuple> ;
	    ||
		a=<init-tuple>;
		type-tuple1(&a) ;
	};
	function-type-defn : () -> (in:TYPETUPLE,out:TYPETUPLE) = {
		in=<init-tuple>;
		out=<init-tuple>;
	    ||
		in=type-tuple;
		{
			arrow;
		    ##
			<E_expected_arrow>;
		};
		out=type-tuple;
	};
	] = {
	action-kw; nm = identifier; 
	(in, out) = function-type-defn ;
	{
		define ; 
	    ##
		<E_expected_define>;
	};

	e = <get-entry-action>(nm);
	<check-action-tuples>(e, &in, &out);
	c = code-block(e);
	<define-action>(e, &c);
	{
		semicolon ;
	    ##
		<E_expected_semicolon> ;
	} ;
};

statement : () -> () = {
	header-stmnt;
    ||
	trailer-stmnt;
    ||
	action-definition;
    ||
	map-stmnt;
};

statement-list : () -> () = {
	$;
    ||
	statement; statement-list;
};

lct-unit : () -> () = {
	statement-list;
	eof;
    ##
	<E-syntax-error> ;
};

%entry% 
lct-unit ;
