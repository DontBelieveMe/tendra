/*
 * Copyright (c) 2002-2005 The TenDRA Project <http://www.tendra.org/>.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 3. Neither the name of The TenDRA Project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific, prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS
 * IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $Id: lex.c 1714 2007-11-25 13:36:15Z kate $
 */

%types%
LETTER ;
IDENTIFIER ;
BIGSTRING ;
TYPETUPLE;

%terminals%

header-kw ;
trailer-kw ;
map-kw;
action-kw;
colon;
arrow;
letter : () -> (:LETTER) ;
define ;  	//=
semicolon ;	//;
comma ;   	//,
code-start;	//@{
code-end;	//@}
eof;
identifier : () -> (:IDENTIFIER);
!unknown ;

%productions%

<init-string> : () -> (:BIGSTRING);
<set-headers> : (:BIGSTRING &, :BIGSTRING&) -> ();
<set-trailers> : (:BIGSTRING &, :BIGSTRING&) -> ();

<init-tuple>: () -> (:TYPETUPLE);
<append-tuple> : (:TYPETUPLE&,:IDENTIFIER,:IDENTIFIER) -> ();

<append-letter> : ( :BIGSTRING & , :LETTER ) -> ();

<define-action> : (:IDENTIFIER&, :TYPETUPLE&,:TYPETUPLE&,:BIGSTRING&) -> ();

<E-syntax-error> ;
<E_expected_code_end> ;
<E_expected_code_start> ;
<E_expected_comma> ;
<E_expected_define> ;
<E_expected_arrow> ;
<E_expected_semicolon> ;
<E_unexpected_eof> ;

letters : ( s:BIGSTRING& ) -> () = {
	$;
    ||
	letters(&s) ; c = letter ; <append-letter>(&s,c);
} ;

grp-of-letters : ( s:BIGSTRING& ) -> () = {
	letters(&s) ;
    	{
		$ ;
	    ||
		eof ; <E_unexpected_eof> ;
	} ;
};

code-block : () -> (s:BIGSTRING) = {
	{
		code-start ;
	    ##
		<E_expected_code_start> ;
	} ;
	s=<init-string>;
	grp-of-letters(&s) ;
	{
		code-end ;
	    ##
		<E_expected_code_end> ;
	} ;
};

header-stmnt : () -> () = {
	header-kw ;
	{
		define ;
	    ##
		<E_expected_define> ;
	} ;
	sc=code-block;
	{
		comma ;
	    ##
		<E_expected_comma> ;
	};
	sh=code-block;
	<set-headers>(&sc,&sh);
	{
		semicolon ;
	    ##
		<E_expected_semicolon> ;
	} ;
};

trailer-stmnt : () -> () = {
	trailer-kw ;
	{
		define ;
	    ##
		<E_expected_define> ;
	} ;
	sc = code-block;
	{
		comma ;
	    ##
		<E_expected_comma> ;
	};
	sh=code-block;
	<set-trailers>(&sc,&sh);
	{
		semicolon ;
	    ##
		<E_expected_semicolon> ;
	} ;
};

map-stmnt : () -> () = {
	map-kw ; lexitype=identifier; 
	{
		arrow; 
	    ##
		<E_expected_arrow>;
	};
	ctype=identifier; 
	{
		semicolon ;
	    ##
		<E_expected_semicolon> ;
	} ;
};

action-definition : () -> () [ 
	type-tuple : ( ) -> (a:TYPETUPLE) [
		type-name : (a:TYPETUPLE) -> () = {
			name=identifier ;
			colon ;
			type=identifier ;
			<append-tuple>(&a,name,type);
		} ;
		type-tuple1 : (a:TYPETUPLE&) -> () = {
			type-name(a) ;
		    ||
			type-name(a) ; type-tuple1(&a) ;
		} ; ] = {
		a=<init-tuple> ;
	    ||
		a=<init-tuple>;
		type-tuple1(&a) ;
	};
	function-type-defn : () -> (in:TYPETUPLE,out:TYPETUPLE) = {
		in=<init-tuple>;
		out=<init-tuple>;
	    ||
		in=type-tuple;
		{
			arrow;
		    ##
			<E_expected_arrow>;
		};
		out=type-tuple;
	};
	] = {
	action-kw; nm= identifier; 
	(in, out) = function-type-defn ;
	{
		define ; 
	    ##
		<E_expected_define>;
	};
	c = code-block ;
	<define-action>(&nm,&in,&out,&c);
	{
		semicolon ;
	    ##
		<E_expected_semicolon> ;
	} ;
};

statement : () -> () = {
	header-stmnt;
    ||
	trailer-stmnt;
    ||
	action-definition;
    ||
	map-stmnt;
};

statement-list : () -> () = {
	$;
    ||
	statement; statement-list;
};

lct-unit : () -> () = {
	statement-list;
	eof;
    ##
	<E-syntax-error> ;
};

%entry% 
lct-unit ;
