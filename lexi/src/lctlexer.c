/* 
 *  Copyright (c) 2002-2008 The TenDRA Project <http://www.tendra.org/>.
 *  All rights reserved.
 * 
 *  Redistribution and use in source and binary forms, with or without
 *  modification, are permitted provided that the following conditions are met:
 * 
 *  1. Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *  2. Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *  3. Neither the name of The TenDRA Project nor the names of its contributors
 *     may be used to endorse or promote products derived from this software
 *     without specific, prior written permission.
 * 
 *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS
 *  IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 *  THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 *  PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR
 *  CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 *  EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 *  PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 *  OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 *  OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 *  ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * $Id$
 * 
 */


/*
 * Automatically generated by lexi version 2.0
 */

#include "lctlexer.h"


#include "lctlexer.h"
#include "lctsyntax.h"
#include "error/error.h"

int crt_lct_token ;
int saved_lct_token ;

char lct_token_buff [2000];
static char *lct_token_end = lct_token_buff + sizeof(lct_token_buff);
static char* lct_token_current;

NStringT lct_token_nstring;

FILE* lct_file;
struct lexi_lct_state lct_lexer_state;

static int 
lexi_lct_getchar() 
{
	int c =fgetc(lct_file);
	if(c == '\n') 
		crt_line_no++;
	if(c == EOF) 
		return LEXI_EOF;
	return c;
}

#include <assert.h>
#include <stdbool.h>
#include <stdint.h>

int lexi_lct_readchar(struct lexi_lct_state *state) {
	if(state->buffer_index) {
		return lexi_lct_pop(state);
	}

	return lexi_lct_getchar();
}
void lexi_lct_push(struct lexi_lct_state *state, const int c) {
	assert(state);
	assert(state->buffer_index < sizeof state->buffer / sizeof *state->buffer);
	state->buffer[state->buffer_index++] = c;
}

int lexi_lct_pop(struct lexi_lct_state *state) {
	assert(state);
	assert(state->buffer_index > 0);
	return state->buffer[--state->buffer_index];
}

void lexi_lct_flush(struct lexi_lct_state *state) {
	state->buffer_index = 0;
}


/* LOOKUP TABLE */

typedef uint8_t lookup_type;
static lookup_type lookup_tab[257] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x40, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
	0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
	0x03, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x03,
	0x00, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
	0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
	0x03, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00
};

bool lexi_lct_group(enum lexi_lct_groups group, int c) {
	return lookup_tab[c] & group;
}


#include <string.h>
int lexi_lct_keyword(const char *identifier, int notfound) {
	if(!strcmp(identifier, "ACTION")) return lct_lex_action_Hkw;
	if(!strcmp(identifier, "HEADERS")) return lct_lex_header_Hkw;
	if(!strcmp(identifier, "MAP")) return lct_lex_map_Hkw;
	if(!strcmp(identifier, "TRAILERS")) return lct_lex_trailer_Hkw;
	return notfound;
}
/* PRE-PASS ANALYSERS */

void lexi_lct_init(struct lexi_lct_state *state) {
	state->zone_function = lexi_lct_read_token;
	state->buffer_index = 0;
}
/* ZONES PASS ANALYSER PROTOTYPES*/

static int lexi_lct_read_token_codereferencezone(struct lexi_lct_state *state);
static int lexi_lct_read_token_codeidentifierzone(struct lexi_lct_state *state);
static int lexi_lct_read_token_code_area(struct lexi_lct_state *state);
static void lexi_lct_read_token_LineComment(struct lexi_lct_state *state);
static void lexi_lct_read_token_Comment(struct lexi_lct_state *state);
static int lexi_lct_read_token_identifierzone(struct lexi_lct_state *state);
/* MAIN PASS ANALYSERS */

/* MAIN PASS ANALYSER for zone codereferencezone*/

static int
lexi_lct_read_token_codereferencezone(struct lexi_lct_state *state)
{
	start: {
		int c0 = lexi_lct_readchar(state);
		if (!lexi_lct_group(lexi_lct_group_alphanum, c0)) {
			lexi_lct_push(state, c0);
			{

       	if(lct_token_current==lct_token_end) {
		error(ERROR_FATAL, "Buffer overflow: trailing 0");
	       *(lct_token_end-1) = 0;		
	} else {
	       *lct_token_current++ = 0;	
	}
			}
			return lct_lex_code_Hreference;
		}
		{

       	if(lct_token_current==lct_token_end-1)
		error(ERROR_FATAL, "Buffer overflow");
	else 
	       *lct_token_current++ = c0;
		}
		goto start;
	}
}
/* MAIN PASS ANALYSER for zone codeidentifierzone*/

static int
lexi_lct_read_token_codeidentifierzone(struct lexi_lct_state *state)
{
	start: {
		int c0 = lexi_lct_readchar(state);
		if (!lexi_lct_group(lexi_lct_group_alphanum, c0)) {
			lexi_lct_push(state, c0);
			{

       	if(lct_token_current==lct_token_end) {
		error(ERROR_FATAL, "Buffer overflow: trailing 0");
	       *(lct_token_end-1) = 0;		
	} else {
	       *lct_token_current++ = 0;	
	}
			}
			return lct_lex_code_Hidentifier;
		}
		{

       	if(lct_token_current==lct_token_end-1)
		error(ERROR_FATAL, "Buffer overflow");
	else 
	       *lct_token_current++ = c0;
		}
		goto start;
	}
}
/* MAIN PASS ANALYSER for zone code_area*/

static int
lexi_lct_read_token_code_area(struct lexi_lct_state *state)
{
	start: {
		int c0 = lexi_lct_readchar(state);
		switch (c0) {
			case '@': {
				int c1 = lexi_lct_readchar(state);
				switch (c1) {
					case '&': {
						int c2 = lexi_lct_readchar(state);
						if (lexi_lct_group(lexi_lct_group_alpha, c2)) {
							{

	lct_token_current=lct_token_buff;
							}
							{

       	if(lct_token_current==lct_token_end-1)
		error(ERROR_FATAL, "Buffer overflow");
	else 
	       *lct_token_current++ = c2;
							}
							return lexi_lct_read_token_codereferencezone(state);
							goto start;
						}
						lexi_lct_push(state, c2);
						break;
					}
					case '@': {
						return lct_lex_code_Hat;
					}
					case '}': {
						state->zone_function = lexi_lct_read_token;
						return lct_lex_code_Hend;
					}
				}
				if (lexi_lct_group(lexi_lct_group_alpha, c1)) {
					{

	lct_token_current=lct_token_buff;
					}
					{

       	if(lct_token_current==lct_token_end-1)
		error(ERROR_FATAL, "Buffer overflow");
	else 
	       *lct_token_current++ = c1;
					}
					return lexi_lct_read_token_codeidentifierzone(state);
					goto start;
				}
				lexi_lct_push(state, c1);
				return lct_lex_lone_Hcode_Hat;
			}
			case LEXI_EOF: {
				return lct_lex_code_Heof;
			}
		}
		{
			int ZT1;

	int c = c0;
	DStringT dstring;
	dstring_init(&dstring);
	do {
		dstring_append_char(&dstring, c) ;
		c = lexi_lct_readchar(&lct_lexer_state);
        } while(c!='@' && c!=LEXI_EOF) ;

	lexi_lct_push(&lct_lexer_state, c);
	
	dstring_to_nstring(&dstring,&lct_token_nstring);
	dstring_destroy(&dstring);
	ZT1 = lct_lex_code_Hstring;
			return ZT1;
		}
	}
}
/* MAIN PASS ANALYSER for zone LineComment*/

static void
lexi_lct_read_token_LineComment(struct lexi_lct_state *state)
{
	start: {
		int c0 = lexi_lct_readchar(state);
		if (c0 == '\n') {
			return;
		}
		goto start;
	}
}
/* MAIN PASS ANALYSER for zone Comment*/

static void
lexi_lct_read_token_Comment(struct lexi_lct_state *state)
{
	start: {
		int c0 = lexi_lct_readchar(state);
		if (c0 == '*') {
			int c1 = lexi_lct_readchar(state);
			if (c1 == '/') {
				return;
			}
			lexi_lct_push(state, c1);
		}
		goto start;
	}
}
/* MAIN PASS ANALYSER for zone identifierzone*/

static int
lexi_lct_read_token_identifierzone(struct lexi_lct_state *state)
{
	start: {
		int c0 = lexi_lct_readchar(state);
		if (!lexi_lct_group(lexi_lct_group_alphanum, c0)) {
			lexi_lct_push(state, c0);
			{

       	if(lct_token_current==lct_token_end) {
		error(ERROR_FATAL, "Buffer overflow: trailing 0");
	       *(lct_token_end-1) = 0;		
	} else {
	       *lct_token_current++ = 0;	
	}
			}
			{
				int ZT1;

	ZT1 = lexi_lct_keyword(lct_token_buff, lct_lex_identifier);
				return ZT1;
			}
		}
		{

       	if(lct_token_current==lct_token_end-1)
		error(ERROR_FATAL, "Buffer overflow");
	else 
	       *lct_token_current++ = c0;
		}
		goto start;
	}
}
/* MAIN PASS ANALYSER for zone global*/

int
lexi_lct_read_token(struct lexi_lct_state *state)
{
	if(state->zone_function != lexi_lct_read_token)
		return (*state->zone_function)(state);
	start: {
		int c0 = lexi_lct_readchar(state);
		if (lexi_lct_group(lexi_lct_group_white, c0)) goto start;
		switch (c0) {
			case '&': {
				return lct_lex_reference;
			}
			case '(': {
				return lct_lex_open;
			}
			case ')': {
				return lct_lex_close;
			}
			case ',': {
				return lct_lex_comma;
			}
			case '-': {
				int c1 = lexi_lct_readchar(state);
				if (c1 == '>') {
					return lct_lex_arrow;
				}
				lexi_lct_push(state, c1);
				break;
			}
			case '/': {
				int c1 = lexi_lct_readchar(state);
				switch (c1) {
					case '*': {
						lexi_lct_read_token_Comment(state);
						goto start;
					}
					case '/': {
						lexi_lct_read_token_LineComment(state);
						goto start;
					}
				}
				lexi_lct_push(state, c1);
				break;
			}
			case ':': {
				return lct_lex_colon;
			}
			case ';': {
				return lct_lex_semicolon;
			}
			case '=': {
				return lct_lex_define;
			}
			case '@': {
				int c1 = lexi_lct_readchar(state);
				if (c1 == '{') {
					state->zone_function = lexi_lct_read_token_code_area;
					return lct_lex_code_Hstart;
				}
				lexi_lct_push(state, c1);
				break;
			}
			case LEXI_EOF: {
				return lct_lex_eof;
			}
		}
		if (lexi_lct_group(lexi_lct_group_alpha, c0)) {
			{

	lct_token_current=lct_token_buff;
			}
			{

       	if(lct_token_current==lct_token_end-1)
		error(ERROR_FATAL, "Buffer overflow");
	else 
	       *lct_token_current++ = c0;
			}
			return lexi_lct_read_token_identifierzone(state);
			goto start;
		}
		return lct_lex_unknown;
	}
}


