
/*
 *  AUTOMATICALLY GENERATED BY lexi VERSION 2.0
 */

#include "lctlexer.h"

#include <assert.h>
#include <stdint.h>

/* LOOKUP TABLE */

typedef uint8_t lookup_type;
static lookup_type lookup_tab[257] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x01, 0x01, 0x00, 0x01, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00
};

/* Push a character to lexi's buffer */
void lexi_lct_push(struct lexi_lct_state *state, const int c) {
	assert(state);
	assert(state->buffer_index < sizeof state->buffer / sizeof *state->buffer);
	state->buffer[state->buffer_index++] = c;
}

/* Pop a character from lexi's buffer */
int lexi_lct_pop(struct lexi_lct_state *state) {
	assert(state);
	assert(state->buffer_index > 0);
	return state->buffer[--state->buffer_index];
}

/* Flush lexi's buffer */
void lexi_lct_flush(struct lexi_lct_state *state) {
	state->buffer_index = 0;
}

/* Read a character */
int lexi_lct_readchar(struct lexi_lct_state *state) {
	if(state->buffer_index) {
		return lexi_lct_pop(state);
	}

	return lexi_lct_getchar();
}

int lexi_lct_group(enum lexi_lct_groups group, int c) {
	return lookup_tab[c] & group;
}



/* KEYWORDS */
#include <string.h>
int lexi_lct_keyword(const char *identifier, int notfound) {
	if(!strcmp(identifier, "HEADER")) return lct_lex_header_Hkw;
	return notfound;
}
/* PRE-PASS ANALYSERS */

void lexi_lct_init(struct lexi_lct_state *state) {
	state->zone_function = &lexi_lct_read_token;
	state->buffer_index = 0;
}
/* ZONES PASS ANALYSER PROTOTYPES*/

static int lexi_lct_read_token_code_area(struct lexi_lct_state *state);
/* MAIN PASS ANALYSERS */

/* MAIN PASS ANALYSER for zone code_area*/

static int
lexi_lct_read_token_code_area(struct lexi_lct_state *state)
{
	start: {
		int c0 = lexi_readchar(state);
		if (lexi_lct_group(lexi_lct_group_white, c0)) goto start;
		if (c0 == ',') {
			return(lct_lex_comma);
		} else if (c0 == '@') {
			int c1 = lexi_readchar(state);
			if (c1 == '}') {
				state->zone_function=&lexi_lct_read_token;
				return(lct_lex_code_Hend);
			}
			lexi_lct_push(state, c1);
		}
		return(lct_lex_letter);
	}
}
/* MAIN PASS ANALYSER for zone global*/

int
lexi_lct_read_token(struct lexi_lct_state *state)
{
	if(state->zone_function!=&lexi_lct_read_token)
		return ((*state->zone_function)(state));
	start: {
		int c0 = lexi_readchar(state);
		if (lexi_lct_group(lexi_lct_group_white, c0)) goto start;
		switch (c0) {
			case '%': {
				int c1 = lexi_readchar(state);
				if (c1 == 'H') {
					int c2 = lexi_readchar(state);
					if (c2 == 'E') {
						int c3 = lexi_readchar(state);
						if (c3 == 'A') {
							int c4 = lexi_readchar(state);
							if (c4 == 'D') {
								int c5 = lexi_readchar(state);
								if (c5 == 'E') {
									int c6 = lexi_readchar(state);
									if (c6 == 'R') {
										int c7 = lexi_readchar(state);
										if (c7 == 'S') {
											int c8 = lexi_readchar(state);
											if (c8 == '%') {
												return(lct_lex_header_Hkw);
											}
											lexi_lct_push(state, c8);
										}
										lexi_lct_push(state, c7);
									}
									lexi_lct_push(state, c6);
								}
								lexi_lct_push(state, c5);
							}
							lexi_lct_push(state, c4);
						}
						lexi_lct_push(state, c3);
					}
					lexi_lct_push(state, c2);
				}
				lexi_lct_push(state, c1);
				break;
			}
			case ',': {
				return(lct_lex_comma);
			}
			case ';': {
				return(lct_lex_semicolon);
			}
			case '=': {
				return(lct_lex_define);
			}
			case '@': {
				int c1 = lexi_readchar(state);
				if (c1 == '{') {
					state->zone_function=&lexi_lct_read_token_code_area;
					return(lct_lex_code_Hstart);
				}
				lexi_lct_push(state, c1);
				break;
			}
			case LEX_EOF: {
				return(lct_lex_eof);
			}
		}
		return(lct_lex_unknown);
	}
}
