/* 
 *     		 Crown Copyright (c) 1997
 *     
 *     This TenDRA(r) Computer Program is subject to Copyright
 *     owned by the United Kingdom Secretary of State for Defence
 *     acting through the Defence Evaluation and Research Agency
 *     (DERA).  It is made available to Recipients with a
 *     royalty-free licence for its use, reproduction, transfer
 *     to other parties and amendment for any purpose not excluding
 *     product development provided that any such use et cetera
 *     shall be deemed to be acceptance of the following conditions:-
 *     
 *         (1) Its Recipients shall ensure that this Notice is
 *         reproduced upon any copies or amended versions of it;
 *     
 *         (2) Any amended version of it shall be clearly marked to
 *         show both the nature of and the organisation responsible
 *         for the relevant amendment or amendments;
 *     
 *         (3) Its onward transfer from a recipient to another
 *         party shall be deemed to be that party's acceptance of
 *         these conditions;
 *     
 *         (4) DERA gives no warranty or assurance as to its
 *         quality or suitability for any purpose and DERA accepts
 *         no liability whatsoever in relation to any use to which
 *         it may be put.
 * 
 */

/*
 *  AUTOMATICALLY GENERATED BY lexi VERSION 2.0
 */

#include "lexer.h"

#include <assert.h>
struct lexer_state_tag {
	int (*zone_function)(struct lexer_state_tag*);
};
/* LOOKUP TABLE */

lexi_lookup_type lookup_tab[257] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x01, 0x01, 0x00, 0x00, 0x01, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,
	0x0c, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
	0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
	0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
	0x0a, 0x0a, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x0a,
	0x00, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
	0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
	0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
	0x0a, 0x0a, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00
};

/*
 * Lexi's buffer is a simple stack. The size is calculated as
 * max(mapping) - 1 + max(token) - 1
 */
static int lexi_buffer[5 - 1];
static int lexi_buffer_index;

/* Push a character to lexi's buffer */
void lexi_push(const int c) {
	assert(lexi_buffer_index < sizeof lexi_buffer / sizeof *lexi_buffer);
	lexi_buffer[lexi_buffer_index++] = c;
}

/* Pop a character from lexi's buffer */
int lexi_pop(void) {
	assert(lexi_buffer_index > 0);
	return lexi_buffer[--lexi_buffer_index];
}

/* Flush lexi's buffer */
void lexi_flush(void) {
	lexi_buffer_index = 0;
}

/* Read a character */
int lexi_readchar(void) {
	if(lexi_buffer_index) {
		return lexi_pop();
	}

	return read_char();
}



/* PRE-PASS ANALYSERS */

lexer_state current_lexer_state_v={&read_token};
lexer_state* current_lexer_state=&current_lexer_state_v;/* ZONES PASS ANALYSER PROTOTYPES*/

static int read_token_line_comment(struct lexer_state_tag* state);
static int read_token_comment(struct lexer_state_tag* state);
/* MAIN PASS ANALYSERS */

/* MAIN PASS ANALYSER for zone line_comment*/

static int
read_token_line_comment(lexer_state* state)
{
	start: {
	int c0 = lexi_readchar(), t0;
	t0 = lookup_char(c0);
	if (is_line_comment_white(t0)) goto start;
	if (c0 == '\n') {
	    state->zone_function=&read_token;
	    return(read_token(state));
	}
	goto start;
	}
}
/* MAIN PASS ANALYSER for zone comment*/

static int
read_token_comment(lexer_state* state)
{
	start: {
	int c0 = lexi_readchar(), t0;
	t0 = lookup_char(c0);
	if (is_comment_white(t0)) goto start;
	if (c0 == '*') {
	    int c1 = lexi_readchar();
	    if (c1 == '/') {
		state->zone_function=&read_token;
		return(read_token(state));
	    }
	    lexi_push(c1);
	}
	goto start;
	}
}
/* MAIN PASS ANALYSER for zone global*/

int
read_token(lexer_state* state)
{
	if(state->zone_function!=&read_token)
		return ((*state->zone_function)(state));
	start: {
	int c0 = lexi_readchar(), t0;
	t0 = lookup_char(c0);
	if (is_white(t0)) goto start;
	switch (c0) {
	    case '"': {
		return(get_string(c0));
	    }
	    case '#': {
		int c1 = lexi_readchar(), t1;
		if (c1 == '#') {
		    return(lex_arg_Hchar_Hlist);
		} else if (c1 == '$') {
		    return(lex_arg_Hchar_Hvoid);
		} else if (c1 == '*') {
		    return(lex_arg_Hchar_Hstring);
		}
		t1 = lookup_char(c1);
		if (is_digit(t1)) {
		    return(read_arg_char_nb(c0, c1));
		}
		lexi_push(c1);
		break;
	    }
	    case '$': {
		int c1 = lexi_readchar(), t1;
		if (c1 == '$') {
		    return(lex_nothing_Hmarker);
		}
		t1 = lookup_char(c1);
		if (is_alpha(t1)) {
		    return(get_sid_ident(c0, c1));
		}
		lexi_push(c1);
		break;
	    }
	    case '(': {
		return(lex_open);
	    }
	    case ')': {
		return(lex_close);
	    }
	    case '+': {
		return(lex_plus);
	    }
	    case ',': {
		return(lex_comma);
	    }
	    case '-': {
		int c1 = lexi_readchar();
		if (c1 == '>') {
		    return(lex_arrow);
		}
		lexi_push(c1);
		break;
	    }
	    case '.': {
		int c1 = lexi_readchar();
		if (c1 == '.') {
		    int c2 = lexi_readchar();
		    if (c2 == '.') {
			return(lex_range);
		    }
		    lexi_push(c2);
		}
		lexi_push(c1);
		break;
	    }
	    case '/': {
		int c1 = lexi_readchar();
		if (c1 == '*') {
		    state->zone_function=&read_token_comment;
		    return(read_token(state));
		} else if (c1 == '/') {
		    state->zone_function=&read_token_line_comment;
		    return(read_token(state));
		}
		lexi_push(c1);
		break;
	    }
	    case ':': {
		return(lex_colon);
	    }
	    case ';': {
		return(lex_semicolon);
	    }
	    case '=': {
		return(lex_equal);
	    }
	    case '{': {
		int c1 = lexi_readchar();
		if (c1 == '0') {
		    int c2 = lexi_readchar();
		    if (c2 == '-') {
			int c3 = lexi_readchar();
			if (c3 == '9') {
			    int c4 = lexi_readchar();
			    if (c4 == '}') {
				return(lex_digit);
			    }
			    lexi_push(c4);
			}
			lexi_push(c3);
		    }
		    lexi_push(c2);
		} else if (c1 == 'A') {
		    int c2 = lexi_readchar();
		    if (c2 == '-') {
			int c3 = lexi_readchar();
			if (c3 == 'Z') {
			    int c4 = lexi_readchar();
			    if (c4 == '}') {
				return(lex_upper);
			    }
			    lexi_push(c4);
			}
			lexi_push(c3);
		    }
		    lexi_push(c2);
		} else if (c1 == 'a') {
		    int c2 = lexi_readchar();
		    if (c2 == '-') {
			int c3 = lexi_readchar();
			if (c3 == 'z') {
			    int c4 = lexi_readchar();
			    if (c4 == '}') {
				return(lex_lower);
			    }
			    lexi_push(c4);
			}
			lexi_push(c3);
		    }
		    lexi_push(c2);
		}
		lexi_push(c1);
		return(lex_open_Hbrace);
	    }
	    case '}': {
		return(lex_close_Hbrace);
	    }
	    case LEX_EOF: {
		return(lex_eof);
	    }
	}
	if (is_alpha(t0)) {
	    return(get_identifier(c0));
	}
	return(unknown_token(c0));
	}
}
