/*
 * Automatically generated by lexi version 2.0
 * Copyright terms for the input source also apply to this generated code.
 */

#include <assert.h>
#include <string.h>

#if defined(__STDC_VERSION__) && (__STDC_VERSION__ - 0L) >= 199901L
#include <stdbool.h>
#include <stdint.h>
#endif



	#include <stdio.h>
	#include <string.h>
	#include <ctype.h>

	#include <shared/error.h>
	#include <shared/string.h>
	#include <shared/xalloc.h>

	#include "lexer.h"
	#include "syntax.h"

	struct lxi_state lxi_state;

	typedef int ZTTERMINAL;

	/*
	 * This buffer is used to hold the values of identifiers and strings.
	 */
	char tokbuf[2000];
	char *token_end = tokbuf + sizeof tokbuf;
	static char *token_current;
	unsigned int numbuf;

	/*
	 * CURRENT TOKEN
	 *
	 * These variables are used by the parser to hold the current and former
	 * lexical tokens.
	 */
	int curr_lex_token;
	int saved_lex_token;

	#define lexi_unknown lxi_unknown

	/*
	 * GET THE NEXT CHARACTER
	 *
	 * This routine reads the next character, either from the pending buffer
	 * or from the input file.
	 */
	static int
	lexi_getchar(struct lxi_state *state)
	{
		int c;

		c = fgetc(state->input);

		if (c == EOF) {
			return LEXI_EOF;
		}

		if (c == '\n') {
			crt_line_no++;
		}

		c &= 0xff; /* XXX: why? */

		return c;
	}

int lxi_readchar(struct lxi_state *state) {
	if (state->buffer_index) {
		return lxi_pop(state);
	}

	return lexi_getchar(state);
}
void lxi_push(struct lxi_state *state, const int c) {
	assert(state);
	assert((size_t) state->buffer_index < sizeof state->buffer / sizeof *state->buffer);
	state->buffer[state->buffer_index++] = c;
}

int lxi_pop(struct lxi_state *state) {
	assert(state);
	assert(state->buffer_index > 0);
	return state->buffer[--state->buffer_index];
}

void lxi_flush(struct lxi_state *state) {
	state->buffer_index = 0;
}


/* LOOKUP TABLE */

#if defined(__STDC_VERSION__) && (__STDC_VERSION__ - 0L) >= 199901L
typedef uint8_t lookup_type;
#else
typedef unsigned char lookup_type;
#endif
static lookup_type lookup_tab[] = {
	   0,    0,    0,    0,    0,    0,    0,    0,    0, 0x10, 0x10,    0, 
	   0, 0x10,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0, 
	   0,    0,    0,    0,    0,    0,    0,    0, 0x10,    0,    0,    0, 
	   0,    0,    0,    0,    0,    0,    0,    0,    0,  0x1,    0,    0, 
	 0x7,  0x7,  0x7,  0x7,  0x7,  0x7,  0x7,  0x7,  0x7,  0x7,    0,    0, 
	   0,    0,    0,    0,    0,  0xb,  0xb,  0xb,  0xb,  0xb,  0xb,  0xb, 
	 0xb,  0xb,  0xb,  0xb,  0xb,  0xb,  0xb,  0xb,  0xb,  0xb,  0xb,  0xb, 
	 0xb,  0xb,  0xb,  0xb,  0xb,  0xb,  0xb,    0,    0,    0,    0,  0xb, 
	   0,  0xb,  0xb,  0xb,  0xb,  0xb,  0xb,  0xb,  0xb,  0xb,  0xb,  0xb, 
	 0xb,  0xb,  0xb,  0xb,  0xb,  0xb,  0xb,  0xb,  0xb,  0xb,  0xb,  0xb, 
	 0xb,  0xb,  0xb,    0,    0,    0,    0,    0,    0,    0,    0,    0, 
	   0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0, 
	   0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0, 
	   0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0, 
	   0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0, 
	   0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0, 
	   0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0, 
	   0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0, 
	   0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0, 
	   0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0, 
	   0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,    0, 
	   0,    0,    0,    0
};

#if defined(__STDC_VERSION__) && (__STDC_VERSION__ - 0L) >= 199901L
bool lxi_group(enum lxi_groups group, int c) {
#else
int lxi_group(enum lxi_groups group, int c) {
#endif
	if (c == LEXI_EOF) {
		return 0;
	}
	return lookup_tab[c] & group;
}


int lxi_keyword(const char *identifier, int notfound) {
	if (streq(identifier, "ACTION")) return lxi_kw_Haction;
	if (streq(identifier, "DEFAULT")) return lxi_default;
	if (streq(identifier, "GROUP")) return lxi_kw_Hgroup;
	if (streq(identifier, "KEYWORD")) return lxi_kw_Hkeyword;
	if (streq(identifier, "MAPPING")) return lxi_kw_Hmapping;
	if (streq(identifier, "TOKEN")) return lxi_kw_Htoken;
	if (streq(identifier, "TYPE")) return lxi_kw_Htype;
	if (streq(identifier, "ZONE")) return lxi_kw_Hzone;
	if (streq(identifier, "white")) return lxi_white;
	return notfound;
}
/* PRE-PASS ANALYSERS */

void lxi_init(struct lxi_state *state, FILE_P input) {
	state->zone = lxi_next;
	state->buffer_index = 0;
	state->input = input;
}
/* ZONES PASS ANALYSER PROTOTYPES */

static int lxi_next_sidident(struct lxi_state *state);
static int lxi_next_ident(struct lxi_state *state);
static int lxi_next_string(struct lxi_state *state);
static void lxi_next_linecomment(struct lxi_state *state);
static void lxi_next_comment(struct lxi_state *state);
static int lxi_next_arg_char_num(struct lxi_state *state);
/* MAIN PASS ANALYSERS */


/* MAIN PASS ANALYSER for sidident */
static int
lxi_next_sidident(struct lxi_state *state)
{
	start: {
		int c0 = lxi_readchar(state);
		if (!lxi_group(lxi_group_alnumhy, c0)) {
			lxi_push(state, c0);
			/* ACTION <fini_tokbuf> */
			{

	if (token_current == token_end) {
		error(ERR_FATAL, "Buffer overflow: trailing 0");
		*(token_end-1) = 0;
	} else {
		*token_current++ = 0;
	}
			}
			/* END ACTION <fini_tokbuf> */
			return lxi_sid_Hident;
		}

		/* DEFAULT */
		/* ACTION <push_tokbuf> */
		{

	if (token_current == token_end - 1) {
		error(ERR_FATAL, "Buffer overflow");
	} else {
		*token_current++ = c0;
	}
		}
		/* END ACTION <push_tokbuf> */
		goto start; /* DEFAULT */
	}
}

/* MAIN PASS ANALYSER for ident */
static int
lxi_next_ident(struct lxi_state *state)
{
	start: {
		int c0 = lxi_readchar(state);
		if (!lxi_group(lxi_group_alnum, c0)) {
			lxi_push(state, c0);
			/* ACTION <fini_tokbuf> */
			{

	if (token_current == token_end) {
		error(ERR_FATAL, "Buffer overflow: trailing 0");
		*(token_end-1) = 0;
	} else {
		*token_current++ = 0;
	}
			}
			/* END ACTION <fini_tokbuf> */
			/* ACTION <keyword> */
			{
				ZTTERMINAL ZT1;

	ZT1 = lxi_keyword(tokbuf, lxi_ident);
				return ZT1;
			}
			/* END ACTION <keyword> */
		}

		/* DEFAULT */
		/* ACTION <push_tokbuf> */
		{

	if (token_current == token_end - 1) {
		error(ERR_FATAL, "Buffer overflow");
	} else {
		*token_current++ = c0;
	}
		}
		/* END ACTION <push_tokbuf> */
		goto start; /* DEFAULT */
	}
}

/* MAIN PASS ANALYSER for string */
static int
lxi_next_string(struct lxi_state *state)
{
	start: {
		int c0 = lxi_readchar(state);
		switch (c0) {
		case '\n': {
				/* ACTION <E_newline_in_string> */
				{

	error(ERR_SERIOUS, "Unexpected newline in string");
				}
				/* END ACTION <E_newline_in_string> */
				goto start; /* leaf */
			}

		case LEXI_EOF: {
				/* ACTION <E_eof_in_string> */
				{

	error(ERR_SERIOUS, "Unexpected eof in string");
				}
				/* END ACTION <E_eof_in_string> */
				goto start; /* leaf */
			}

		case '\\': {
				int c1 = lxi_readchar(state);
				switch (c1) {
				case '\\': {
						/* ACTION <push_tokbuf> */
						{

	if (token_current == token_end - 1) {
		error(ERR_FATAL, "Buffer overflow");
	} else {
		*token_current++ = c0;
	}
						}
						/* END ACTION <push_tokbuf> */
						/* ACTION <push_tokbuf> */
						{

	if (token_current == token_end - 1) {
		error(ERR_FATAL, "Buffer overflow");
	} else {
		*token_current++ = c0;
	}
						}
						/* END ACTION <push_tokbuf> */
						goto start; /* leaf */
					}

				case '"': {
						/* ACTION <push_tokbuf> */
						{

	if (token_current == token_end - 1) {
		error(ERR_FATAL, "Buffer overflow");
	} else {
		*token_current++ = c1;
	}
						}
						/* END ACTION <push_tokbuf> */
						goto start; /* leaf */
					}

				}
				lxi_push(state, c1);
			}
			break;

		case '"': {
				/* ACTION <fini_tokbuf> */
				{

	if (token_current == token_end) {
		error(ERR_FATAL, "Buffer overflow: trailing 0");
		*(token_end-1) = 0;
	} else {
		*token_current++ = 0;
	}
				}
				/* END ACTION <fini_tokbuf> */
				return lxi_string;
			}

		}

		/* DEFAULT */
		/* ACTION <push_tokbuf> */
		{

	if (token_current == token_end - 1) {
		error(ERR_FATAL, "Buffer overflow");
	} else {
		*token_current++ = c0;
	}
		}
		/* END ACTION <push_tokbuf> */
		goto start; /* DEFAULT */
	}
}

/* MAIN PASS ANALYSER for linecomment */
static void
lxi_next_linecomment(struct lxi_state *state)
{
	start: {
		int c0 = lxi_readchar(state);
		if (c0 == '\n') {
			return;
		}

		/* DEFAULT */
		goto start; /* DEFAULT */
	}
}

/* MAIN PASS ANALYSER for comment */
static void
lxi_next_comment(struct lxi_state *state)
{
	start: {
		int c0 = lxi_readchar(state);
		if (c0 == '*') {
			int c1 = lxi_readchar(state);
			if (c1 == '/') {
				return;
			}
			lxi_push(state, c1);
		}

		/* DEFAULT */
		goto start; /* DEFAULT */
	}
}

/* MAIN PASS ANALYSER for arg_char_num */
static int
lxi_next_arg_char_num(struct lxi_state *state)
{
	start: {
		int c0 = lxi_readchar(state);
		if (lxi_group(lxi_group_white, c0)) goto start;
		if (!lxi_group(lxi_group_digit, c0)) {
			lxi_push(state, c0);
			return lxi_arg_Hchar_Hnum;
		}

		/* DEFAULT */
		/* ACTION <numbuf_push_digit> */
		{

	numbuf *= 10;
	numbuf += c0 - '0';
		}
		/* END ACTION <numbuf_push_digit> */
		goto start; /* DEFAULT */
	}
}

/* MAIN PASS ANALYSER for global zone */
int
lxi_next(struct lxi_state *state)
{
	if (state->zone != lxi_next)
		return state->zone(state);
	start: {
		int c0 = lxi_readchar(state);
		if (lxi_group(lxi_group_white, c0)) goto start;
		switch (c0) {
		case '"': {
				/* ACTION <init_tokbuf> */
				{

	token_current=tokbuf;
				}
				/* END ACTION <init_tokbuf> */
				return lxi_next_string(state);
			}

		case '/': {
				int c1 = lxi_readchar(state);
				switch (c1) {
				case '/': {
						lxi_next_linecomment(state);
						goto start;	/* pure function */
					}

				case '*': {
						lxi_next_comment(state);
						goto start;	/* pure function */
					}

				}
				lxi_push(state, c1);
			}
			break;

		case '!': {
				return lxi_arg_Hignore;
			}

		case '#': {
				int c1 = lxi_readchar(state);
				switch (c1) {
				case '*': {
						return lxi_arg_Hchar_Hstring;
					}

				case 'n': {
						return lxi_arg_Hchar_Hcount;
					}

				}
				if (lxi_group(lxi_group_digit, c1)) {
					/* ACTION <numbuf_init> */
					{

	numbuf = 0;
					}
					/* END ACTION <numbuf_init> */
					/* ACTION <numbuf_push_digit> */
					{

	numbuf *= 10;
	numbuf += c1 - '0';
					}
					/* END ACTION <numbuf_push_digit> */
					return lxi_next_arg_char_num(state);
				}
				lxi_push(state, c1);
			}
			break;

		case '[': {
				int c1 = lxi_readchar(state);
				if (c1 == '.') {
					int c2 = lxi_readchar(state);
					if (c2 == '.') {
						int c3 = lxi_readchar(state);
						if (c3 == '.') {
							int c4 = lxi_readchar(state);
							switch (c4) {
							case ')': {
									return lxi_range_Hclosed_Hopen;
								}

							case ']': {
									return lxi_range_Hclosed_Hclosed;
								}

							}
							lxi_push(state, c4);
						}
						lxi_push(state, c3);
					}
					lxi_push(state, c2);
				}
				lxi_push(state, c1);
			}
			break;

		case '.': {
				int c1 = lxi_readchar(state);
				if (c1 == '.') {
					int c2 = lxi_readchar(state);
					if (c2 == '.') {
						return lxi_range;
					}
					lxi_push(state, c2);
				}
				lxi_push(state, c1);
			}
			break;

		case LEXI_EOF: {
				return lxi_eof;
			}

		case ',': {
				return lxi_comma;
			}

		case '$': {
				int c1 = lxi_readchar(state);
				if (c1 == '$') {
					return lxi_discard;
				}
				if (lxi_group(lxi_group_alpha, c1)) {
					/* ACTION <init_tokbuf> */
					{

	token_current=tokbuf;
					}
					/* END ACTION <init_tokbuf> */
					/* ACTION <push_tokbuf> */
					{

	if (token_current == token_end - 1) {
		error(ERR_FATAL, "Buffer overflow");
	} else {
		*token_current++ = c1;
	}
					}
					/* END ACTION <push_tokbuf> */
					return lxi_next_sidident(state);
				}
				lxi_push(state, c1);
				return lxi_arg_Hreturn;
			}

		case '+': {
				return lxi_plus;
			}

		case '=': {
				return lxi_equal;
			}

		case ';': {
				return lxi_semicolon;
			}

		case '&': {
				return lxi_ref;
			}

		case ':': {
				return lxi_colon;
			}

		case '-': {
				int c1 = lxi_readchar(state);
				if (c1 == '>') {
					return lxi_arrow;
				}
				lxi_push(state, c1);
			}
			break;

		case '}': {
				return lxi_close_Hbrace;
			}

		case '{': {
				int c1 = lxi_readchar(state);
				switch (c1) {
				case '0': {
						int c2 = lxi_readchar(state);
						if (c2 == '-') {
							int c3 = lxi_readchar(state);
							if (c3 == '9') {
								int c4 = lxi_readchar(state);
								if (c4 == '}') {
									return lxi_digit;
								}
								lxi_push(state, c4);
							}
							lxi_push(state, c3);
						}
						lxi_push(state, c2);
					}
					break;

				case 'a': {
						int c2 = lxi_readchar(state);
						if (c2 == '-') {
							int c3 = lxi_readchar(state);
							if (c3 == 'z') {
								int c4 = lxi_readchar(state);
								if (c4 == '}') {
									return lxi_lower;
								}
								lxi_push(state, c4);
							}
							lxi_push(state, c3);
						}
						lxi_push(state, c2);
					}
					break;

				case 'A': {
						int c2 = lxi_readchar(state);
						if (c2 == '-') {
							int c3 = lxi_readchar(state);
							if (c3 == 'Z') {
								int c4 = lxi_readchar(state);
								if (c4 == '}') {
									return lxi_upper;
								}
								lxi_push(state, c4);
							}
							lxi_push(state, c3);
						}
						lxi_push(state, c2);
					}
					break;

				}
				lxi_push(state, c1);
				return lxi_open_Hbrace;
			}

		case '>': {
				return lxi_end_Haction;
			}

		case '<': {
				return lxi_begin_Haction;
			}

		case ')': {
				return lxi_close;
			}

		case '(': {
				return lxi_open;
			}

		}
		if (lxi_group(lxi_group_alpha, c0)) {
			/* ACTION <init_tokbuf> */
			{

	token_current=tokbuf;
			}
			/* END ACTION <init_tokbuf> */
			/* ACTION <push_tokbuf> */
			{

	if (token_current == token_end - 1) {
		error(ERR_FATAL, "Buffer overflow");
	} else {
		*token_current++ = c0;
	}
			}
			/* END ACTION <push_tokbuf> */
			return lxi_next_ident(state);
		}

		/* DEFAULT */
		return lexi_unknown;
	}
}


