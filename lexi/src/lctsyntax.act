%prefixes%

terminal = lct_lex_ ;

%maps%

/*
	ENTRY POINT
*/

lct-unit -> read_lct_unit ;

/* 
	TYPE MAPPINGS
*/

BOOL -> bool;
CCODE -> CcodeT; 
BIGSTRING -> NStringT;
IDENTIFIER -> NStringT;
TYPETUPLE -> TypeTupleT;
ENTRYP -> EntryP;

%header% @{
/*
 * Copyright (c) 2002-2005 The TenDRA Project <http://www.tendra.org/>.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 3. Neither the name of The TenDRA Project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific, prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS
 * IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $Id$
 */
 

#include <stdbool.h>

#include "lctsyntax.h"
#include "lctlexer.h"
#include "ccode.h"
#include "adt.h"
#include "error/error.h"
#include "exds/common.h"
#include "exds/exception.h"
#include "exds/dalloc.h"
#include "exds/dstring.h"
#include "exds/cstring.h"

#include "adt/tree.h"

#define ADVANCE_LEXER ADVANCE_LCT_LEXER
#define CURRENT_TERMINAL CURRENT_LCT_TERMINAL 
#define SAVE_LEXER SAVE_LCT_LEXER
#define RESTORE_LEXER RESTORE_LCT_LEXER

typedef EntryT* EntryP;



void init_lct_parse_tree (lct_parse_tree* a) 
{
	a->headersdefined = 0;
	a->trailersdefined = 0;
	ccode_init(&(a->hfileheader)) ;
	ccode_init(&(a->cfileheader)) ;
	ccode_init(&(a->hfiletrailer)) ;
	ccode_init(&(a->cfiletrailer)) ;
}

lexer_parse_tree* lxi_top_level;
lct_parse_tree global_lct_parse_tree ;

@}, @{
/*
 * Copyright (c) 2002-2005 The TenDRA Project <http://www.tendra.org/>.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 3. Neither the name of The TenDRA Project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific, prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS
 * IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $Id$
 */
 #ifndef LCT_SYNTAX_HEADER_INCLUDED
 #define LCT_SYNTAX_HEADER_INCLUDED

#include "ccode.h"
#include "adt.h"

#include "adt/tree.h"

typedef struct lct_parse_tree_tag {
	int headersdefined;
	int trailersdefined;
	CcodeT hfileheader;
	CcodeT cfileheader;
	CcodeT hfiletrailer;
	CcodeT cfiletrailer;
} lct_parse_tree;

extern lexer_parse_tree* lxi_top_level;
extern lct_parse_tree global_lct_parse_tree ;

extern void init_lct_parse_tree(lct_parse_tree*);
@};

%assignments%

IDENTIFIER : (a) -> (b) = @{
	nstring_assign(&@b,@a);
@};

BIGSTRING : (a) -> (b) = @{
	nstring_assign(&@b,@a);
@};

%parameter-assignments%

IDENTIFIER : (a) -> (b) = @{
	nstring_assign(&@b,@a);
@};

BIGSTRING : (a) -> (b) = @{
	nstring_assign(&@b,@a);
@};

%result-assignments%

IDENTIFIER : (a) -> (b) = @{
	nstring_assign(@b,@&a);
@};

BIGSTRING : (a) -> (b) = @{
	nstring_assign(@b,@&a);
@};

%terminals%

identifier : () -> (i:IDENTIFIER) = @{
	nstring_copy_cstring(&@i,lct_token_buff);
@};

code-identifier : () -> (i:IDENTIFIER) = @{
	nstring_copy_cstring(&@i,lct_token_buff);
@};

code-reference : () -> (i:IDENTIFIER) = @{
	nstring_copy_cstring(&@i,lct_token_buff);
@};

code-string : () -> (s:BIGSTRING) = @{
	nstring_assign(&@s, &lct_token_nstring);
@};



%actions%

/*
    BOOLEANS

    These actions give the booleans true and false.
*/

<true> : () -> ( b : BOOL ) =	@{ @b = true ; @} ;
<false> : () -> ( b : BOOL ) =	@{ @b = false ; @} ;

/*
	STRINGS
*/

<empty-identifier> : () -> ( s: IDENTIFIER) = @{ nstring_init(&@s); @};

/*
	C CODE MANIPULATION
*/

<init-ccode> : () -> (c:CCODE) = @{
	ccode_init(&@c);
@};

<append-ccode-at> : (c:CCODE&) -> () = @{
	ccode_append_at(&@c);
@};

<append-ccode-string> : (c:CCODE&, s:BIGSTRING&) -> () = @{
	ccode_append_string(@&c,@&s);
@};

<append-ccode-identifier> : (c:CCODE&, i:IDENTIFIER, e:ENTRYP, b:BOOL) -> () = @{
	if(@e) {
		ActionT* action = entry_get_action(@e);
		TypeTupleEntryT *p, *q;
	 	if ((p = typetuple_name_is_in(action_get_inputs(action),@&i)) || 
	       	    (q = typetuple_name_is_in(action_get_outputs(action),@&i))) {
		   	if(!@b) {
				ccode_append_identifier(@&c,@&i);
			} else {
				if(p && p->is_reference) {
					ccode_append_reference(@&c,@&i);
				} else {
					error(ERROR_SERIOUS, "In code block the \'@@&\' can only be used for input parameters that are references");
				}
			}
		} else {
			char* pi = nstring_to_cstring(@&i);
			nstring_destroy(@&i);
			char* pe =  nstring_to_cstring(entry_key(@e));
			error(ERROR_SERIOUS, "Identifier @@%s is neither an input nor an output " 
					     "parameter of action %s", pi, pe );
			DEALLOCATE(pi);
			DEALLOCATE(pe);
		}
	} else {
		error(ERROR_SERIOUS, "The @@ code identifiers are not allowed in headers or trailers");
		nstring_destroy(@&i);
	}
@};


<set-headers> : (sc:CCODE &,sh:CCODE&) -> () = @{
	if(!global_lct_parse_tree.trailersdefined) {
		global_lct_parse_tree.headersdefined = 1;
		ccode_assign(&(global_lct_parse_tree.hfileheader),@&sh) ;
		ccode_assign(&(global_lct_parse_tree.cfileheader),@&sc) ;
	} else {
		error(ERROR_SERIOUS, "Headers may not be redefined");
		ccode_destroy(@&sc);
		ccode_destroy(@&sh);
	}
@} ;

<set-trailers> : (sc:CCODE &,sh:CCODE&) -> () = @{
	if(!(global_lct_parse_tree.trailersdefined)) {
		global_lct_parse_tree.trailersdefined = 1;
		ccode_assign(&(global_lct_parse_tree.hfiletrailer),@&sh) ;
		ccode_assign(&(global_lct_parse_tree.cfiletrailer),@&sc) ;
	} else {
		error(ERROR_SERIOUS, "Trailers may not be redefined");
		ccode_destroy(@&sc);
		ccode_destroy(@&sh);
	}
@} ;


/*
	Initializing an empty type tuple
*/

<init-tuple> : () -> (a:TYPETUPLE) = @{
	typetuple_init(&@a);
@};

<append-tuple> : (a:TYPETUPLE&, id:IDENTIFIER, type:IDENTIFIER, isref:BOOL) -> () =@{
	EntryT* entry = table_get_entry(lxi_top_level->table,@&type);
	if(entry == NULL) {
		 char* pt = nstring_to_cstring(@&type);
		 error(ERROR_SERIOUS, "Unknown type %s", pt);
		 DEALLOCATE(pt);
		 nstring_destroy(@&id);
		 nstring_destroy(@&type);
	}
	else if(!entry_is_type(entry)) {
		error(ERROR_SERIOUS, "%s is not a type", @&type);
		nstring_destroy(@&type);
	}
	else {
		typetuple_append(@&a,typetupleentry_create(@&id,entry, @isref));
		nstring_destroy(@&type);
	}
@} ;

<make-map> : (lexitype:IDENTIFIER, ctype:IDENTIFIER) -> () = @{
	EntryT* entry= table_get_entry(lxi_top_level->table,@&lexitype);
	if(entry !=NULL) {
		if(entry_is_type(entry)) {
			TypeT* type = entry_get_type(entry);
			type_map(type, @&ctype);
		} else {
			error(ERROR_SERIOUS, "Name in maps section is not a type");
			nstring_destroy(@&ctype);
		}
	} else {
		error(ERROR_SERIOUS, "Unknown type in mapping");
		nstring_destroy(@&ctype);
	}
	nstring_destroy(@&lexitype);
@};


<get-entry-action> : (i:IDENTIFIER) -> (e:ENTRYP) = @{
	@e=table_get_entry(lxi_top_level->table,@&i);
	if(@e) {
		if(!entry_is_action(@e)) {
			@e=NULL; /*TODO skip to end of action */
			char* pi = nstring_to_cstring(@&i);
			error(ERROR_SERIOUS,"%s is not an action", pi);
			DEALLOCATE(pi);
		}
	} else {
		char* pi = nstring_to_cstring(@&i);		
		error(ERROR_SERIOUS,"Defining an undeclared action: %s", pi);
		DEALLOCATE(pi);
	}
	nstring_destroy(@&i);
@};

<null-entry> : () -> (e:ENTRYP) = @{
	@e=NULL;
@};

<check-action-tuples> : (e:ENTRYP, in:TYPETUPLE&, out:TYPETUPLE&) -> () = @{
	if(@e) {
		/*TODO assert (entry_is_action(@e)); */	       
		/* TODO check that the same name does not appear twice in the input and output tuple */
		ActionT* action = entry_get_action(@e);
		if(typetuple_length(action_get_inputs(action))!=typetuple_length(@&in)) {
			char* pe=nstring_to_cstring(entry_key(@e));
			error(ERROR_SERIOUS,"Action %s declared with an incompatible number of inputs", pe);
			DEALLOCATE(pe);
		} else if(!typetuple_match(action_get_inputs(action),@&in)) {
			char* pe=nstring_to_cstring(entry_key(@e));
			error(ERROR_SERIOUS, "params do not match for action %s",pe);
			DEALLOCATE(pe);
		} else {
			int allhavenames = typetuple_assign_names(action_get_inputs(action),@&in);
			if(!allhavenames) {
				error(ERROR_SERIOUS,"outputs tuples in action definition should have names");
			}
		}
		if(typetuple_length(action_get_outputs(action))!=typetuple_length(@&out)) {
			char* pe=nstring_to_cstring(entry_key(@e));
			error(ERROR_SERIOUS,"Action %s declared with an incompatible number of outputs", pe);
			DEALLOCATE(pe);
		} else if (!typetuple_match(action_get_outputs(action),@&out)) {
			char* pe=nstring_to_cstring(entry_key(@e));
			error(ERROR_SERIOUS, "results do not match for action %s",pe);
			DEALLOCATE(pe);
		} else {				
			int allhavenames = typetuple_assign_names(action_get_outputs(action),@&out);
			if(!allhavenames) {
				char* pe=nstring_to_cstring(entry_key(@e));
				error(ERROR_SERIOUS,"outputs tuples in the definition of action %s should have names",pe);
			DEALLOCATE(pe);
			}
		}
	}
	typetuple_destroy(@&in);
	typetuple_destroy(@&out);
@};	


<define-action> : (e:ENTRYP, c:CCODE&) -> () = @{
	if(@e) {
	       /*TODO assert entry_is_action */	       
	        ActionT* action = entry_get_action(@e);
			if(!action_is_defined(action)) {
				action_set_define(action);
				action_set_code(action, @&c);
			} else {
				char* pe=nstring_to_cstring(entry_key(@e));
				error(ERROR_SERIOUS,"Action %s has already been defined", pe);
				DEALLOCATE(pe);
			}
	} else {
		ccode_destroy(@&c);
	}
@};

<E-syntax-error> = @{
	    error ( ERROR_SERIOUS, "Syntax error" ) ;
@} ;

<E_expected_code_end> = @{
	    error( ERROR_SERIOUS, "Syntax error: expected  '@@}'") ;
@};

<E_expected_identifier> = @{
	    error( ERROR_SERIOUS, "Syntax error: expected  identifier") ;
@};

<E_expected_code_start> = @{
	    error( ERROR_SERIOUS, "Syntax error: expected  '@@{'") ;
@} ;

<E_expected_comma> = @{
	    error( ERROR_SERIOUS, "Syntax error: expected ','") ;
@} ;

<E_expected_define> = @{
	    error( ERROR_SERIOUS, "Syntax error: expected '='") ;

@} ;

<E_expected_arrow> = @{
	    error( ERROR_SERIOUS, "Syntax error: expected '->'") ;
@} ;

<E_expected_semicolon> = @{
	    error( ERROR_SERIOUS, "Syntax error: expected ';'") ;
@} ;


<E_unexpected_eof> = @{
	    error( ERROR_SERIOUS, "Unexpected End of File inside @@{ @@} block") ;
@};

<E_lone_at_in_code_block> = @{
	    error( ERROR_SERIOUS, "Lone @@ inside @@{ @@} block") ;
@};



%trailer% @{

@}, @{
#endif
@};
