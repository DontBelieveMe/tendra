/* $Id$ */

/*
 * Copyright 2011, The TenDRA Project.
 *
 * See doc/copyright/ for the full copyright terms.
 */

%prefixes%

	terminal = lct_lex_;

%maps%

	lct-unit -> read_lct_unit;

	BOOL       -> bool;
	CODE       -> codeP;
	BIGSTRING  -> NStringT;
	IDENT      -> NStringT;
	PARAM_LIST -> paramP;
	ENTRYP     -> entryP;

%header% @{

	#include <stdbool.h>

	#include <shared/xalloc.h>
	#include <shared/error.h>

	#include <exds/common.h>
	#include <exds/exception.h>
	#include <exds/dalloc.h>
	#include <exds/dstring.h>
	#include <exds/cstring.h>

	#include <adt/action.h>
	#include <adt/entry.h>
	#include <adt/param.h>

	#include "lctsyntax.h"
	#include "lctlexer.h"
	#include "code.h"
	#include "ast.h"

	#define ADVANCE_LEXER    ADVANCE_LCT_LEXER
	#define CURRENT_TERMINAL CURRENT_LCT_TERMINAL
	#define SAVE_LEXER       SAVE_LCT_LEXER
	#define RESTORE_LEXER    RESTORE_LCT_LEXER

	typedef struct code *  codeP;
	typedef struct entry * entryP;
	typedef struct param * paramP;

	void
	init_lct_ast(struct lct_ast* a)
	{
		a->headersdefined  = 0;
		a->trailersdefined = 0;

		a->hfileheader  = NULL;
		a->cfileheader  = NULL;
		a->hfiletrailer = NULL;
		a->cfiletrailer = NULL;

		a->arg_head = NULL;
		a->arg_tail = &a->arg_head;
	}

	struct ast *lxi_ast;
	struct lct_ast lct_ast;

@}, @{

	#ifndef LCT_SYNTAX_H
	#define LCT_SYNTAX_H

	#include "code.h"
	#include "ast.h"

	struct lxi_additional_argument {
		char *name;
		char *ctype;

		struct lxi_additional_argument *next;
	};

	struct lct_ast {
		int headersdefined;
		int trailersdefined;

		struct code *hfileheader;
		struct code *cfileheader;
		struct code *hfiletrailer;
		struct code *cfiletrailer;

		struct lxi_additional_argument* arg_head;
		struct lxi_additional_argument** arg_tail;
	};

	extern struct ast *lxi_ast;
	extern struct lct_ast lct_ast;

	extern void init_lct_ast(struct lct_ast*);

@};

%assignments%

	IDENT: (a) -> (b) = @{
		nstring_assign(&@b, @a);
	@};

	BIGSTRING: (a) -> (b) = @{
		nstring_assign(&@b, @a);
	@};

%parameter-assignments%

	IDENT: (a) -> (b) = @{
		nstring_assign(&@b, @a);
	@};

	BIGSTRING : (a) -> (b) = @{
		nstring_assign(&@b, @a);
	@};

%result-assignments%

	IDENT: (a) -> (b) = @{
		nstring_assign(@b, @&a);
	@};

	BIGSTRING: (a) -> (b) = @{
		nstring_assign(@b, @&a);
	@};

%terminals%

	ident: () -> (i :IDENT) = @{
		nstring_copy_cstring(&@i, lct_tokbuf);
	@};

	code-ident: () -> (i :IDENT) = @{
		nstring_copy_cstring(&@i, lct_tokbuf);
	@};

	code-ref: () -> (i :IDENT) = @{
		nstring_copy_cstring(&@i, lct_tokbuf);
	@};

	code-string: () -> (s :BIGSTRING) = @{
		nstring_assign(&@s, &lct_token_nstring);
	@};

%actions%

	<true>:  () -> ( b :BOOL ) = @{ @b = true;  @};
	<false>: () -> ( b :BOOL ) = @{ @b = false; @};

	<empty-ident>: () -> (s :IDENT) = @{
		nstring_init(&@s);
	@};

	<init-code>: () -> (c :CODE) = @{
		@c = NULL;
	@};

	<append-code-at>: (c :CODE &) -> () = @{
		code_append_at(@&c);
	@};

	<append-code-string>: (c :CODE &, s :BIGSTRING &) -> () = @{
		code_append_string(@&c, @&s);
	@};

	<append-code-ident>: (c :CODE &, i :IDENT, e :ENTRYP, b :BOOL) -> () = @{
		if (@e) {
			struct action* act = entry_get_action(@e);
			struct param *p, *q;
			if ((p = param_name_is_in(action_get_inputs(act), @&i)) ||
					(q = param_name_is_in(action_get_outputs(act), @&i))) {
				if (!@b) {
					code_append_ident(@&c, @&i);
				} else {
					if (p && p->is_ref) {
						code_append_ref(@&c, @&i);
					} else {
						error(ERROR_SERIOUS, "In code block the \'@@&\' can only be used for input parameters that are references");
					}
				}
			} else {
				char *pi;
				char *pe;
				pi = nstring_to_cstring(@&i);
				nstring_destroy(@&i);
				pe = nstring_to_cstring(entry_key(@e));
				error(ERROR_SERIOUS, "Identifier @@%s is neither an input nor an output "
							 "parameter of action %s", pi, pe );
				xfree(pi);
				xfree(pe);
			}
		} else {
			error(ERROR_SERIOUS, "The @@ code identifiers are not allowed in headers or trailers");
			nstring_destroy(@&i);
		}
	@};

	<define-additional-argument>: (name :IDENT, ctype :IDENT) -> () = @{
		if (nstring_length(@&name) > 0 && nstring_length(@&ctype) > 0) {
			struct lxi_additional_argument *p;

			p = xmalloc(sizeof *p);
			p->name  = nstring_to_cstring(@&name);
			p->ctype = nstring_to_cstring(@&ctype);
			p->next  = NULL;

			*lct_ast.arg_tail = p;
			lct_ast.arg_tail = &p->next;
		}
		nstring_destroy(@&name);
		nstring_destroy(@&ctype);
	@};

	<set-headers>: (sc :CODE, sh :CODE) -> () = @{
		if (!lct_ast.trailersdefined) {
			lct_ast.headersdefined = 1;
			lct_ast.hfileheader = @sh;
			lct_ast.cfileheader = @sc;
		} else {
			error(ERROR_SERIOUS, "Headers may not be redefined");
			code_destroy(@sc);
			code_destroy(@sh);
		}
	@};

	<set-trailers>: (sc :CODE, sh :CODE) -> () = @{
		if (!lct_ast.trailersdefined) {
			lct_ast.trailersdefined = 1;
			lct_ast.hfiletrailer = @sh;
			lct_ast.cfiletrailer = @sc;
		} else {
			error(ERROR_SERIOUS, "Trailers may not be redefined");
			code_destroy(@sc);
			code_destroy(@sh);
		}
	@};

	<init-param>: () -> (a :PARAM_LIST) = @{
		@a = NULL;
	@};

	<append-param>: (a :PARAM_LIST &, id :IDENT, type :IDENT, isref :BOOL) -> () =@{
		struct entry *et = table_get_entry(tree_get_table(lxi_ast), @&type);
		if (et == NULL) {
			char *pt;

			pt = nstring_to_cstring(@&type);
			error(ERROR_SERIOUS, "Unknown type %s", pt);
			xfree(pt);

			nstring_destroy(@&id);
			nstring_destroy(@&type);
		} else if (!entry_is_type(et)) {
			error(ERROR_SERIOUS, "%s is not a type", @&type);
			nstring_destroy(@&type);
		} else {
			param_append(@&a, @&id, et, @isref);
			nstring_destroy(@&type);
		}
	@};

	<get-entry-action>: (i :IDENT) -> (ea :ENTRYP) = @{
		@ea = table_get_entry(tree_get_table(lxi_ast), @&i);
		if (@ea) {
			if (!entry_is_action(@ea)) {
				char *pi;

				@ea = NULL; /* TODO: skip to end of action */
				pi = nstring_to_cstring(@&i);
				error(ERROR_SERIOUS, "%s is not an action", pi);
				xfree(pi);
			}
		} else {
			char *pi = nstring_to_cstring(@&i);
			error(ERROR_SERIOUS, "Defining an undeclared action: %s", pi);
			xfree(pi);
		}
		nstring_destroy(@&i);
	@};

	<null-entry>: () -> (e :ENTRYP) = @{
		@e = NULL;
	@};

	<check-action-params>: (e :ENTRYP, in :PARAM_LIST, out :PARAM_LIST) -> () = @{
		if (@e) {
			/* TODO: assert (entry_is_action(@e)); */
			/* TODO: check that the same name does not appear twice in the input and output tuple */
			struct action *act = entry_get_action(@e);

			if (param_length(action_get_inputs(act)) != param_length(@in)) {
				char *pe = nstring_to_cstring(entry_key(@e));
				error(ERROR_SERIOUS, "Action %s declared with an incompatible number of inputs", pe);
				xfree(pe);
			} else if (!param_match(action_get_inputs(act), @in)) {
				char *pe = nstring_to_cstring(entry_key(@e));
				error(ERROR_SERIOUS, "params do not match for action %s", pe);
				xfree(pe);
			} else {
				int allhavenames = param_assign_names(action_get_inputs(act), @in);
				if (!allhavenames) {
					error(ERROR_SERIOUS, "outputs tuples in action definition should have names");
				}
			}

			if (param_length(action_get_outputs(act)) != param_length(@out)) {
				char *pe = nstring_to_cstring(entry_key(@e));
				error(ERROR_SERIOUS, "Action %s declared with an incompatible number of outputs", pe);
				xfree(pe);
			} else if (!param_match(action_get_outputs(act), @out)) {
				char *pe = nstring_to_cstring(entry_key(@e));
				error(ERROR_SERIOUS, "results do not match for action %s", pe);
				xfree(pe);
			} else {
				int allhavenames = param_assign_names(action_get_outputs(act), @out);
				if (!allhavenames) {
					char *pe = nstring_to_cstring(entry_key(@e));
					error(ERROR_SERIOUS, "outputs tuples in the definition of action %s should have names", pe);
					xfree(pe);
				}
			}
		}

		param_destroy(@in);
		param_destroy(@out);
	@};

	<define-action>: (ea :ENTRYP, c :CODE) -> () = @{
		if (@ea) {
			/* TODO: assert entry_is_action */
			struct action *act = entry_get_action(@ea);
			if (!action_is_defined(act)) {
				action_set_define(act);
				action_set_code(act, @c);
			} else {
				char *pe = nstring_to_cstring(entry_key(@ea));
				error(ERROR_SERIOUS, "Action %s has already been defined", pe);
				xfree(pe);
			}
		} else {
			code_destroy(@c);
		}
	@};

	<E-syntax-error> = @{
		error(ERROR_SERIOUS, "Syntax error");
	@};

	<E_expected_code_end> = @{
		error(ERROR_SERIOUS, "Syntax error: expected  '@@}'");
	@};

	<E_expected_ident> = @{
		error(ERROR_SERIOUS, "Syntax error: expected  identifier");
	@};

	<E_expected_code_start> = @{
		error(ERROR_SERIOUS, "Syntax error: expected  '@@{'");
	@};

	<E_expected_comma> = @{
		error(ERROR_SERIOUS, "Syntax error: expected ','");
	@};

	<E_expected_define> = @{
		error(ERROR_SERIOUS, "Syntax error: expected '='");

	@};

	<E_expected_arrow> = @{
		error(ERROR_SERIOUS, "Syntax error: expected '->'");
	@};

	<E_expected_semicolon> = @{
		error(ERROR_SERIOUS, "Syntax error: expected ';'");
	@};

	<E_expected_colon> = @{
		error(ERROR_SERIOUS, "Syntax error: expected ':'");
	@};

	<E_unexpected_eof> = @{
		error(ERROR_SERIOUS, "Unexpected End of File inside @@{ @@} block");
	@};

	<E_lone_at_in_code_block> = @{
		error(ERROR_SERIOUS, "Lone @@ inside @@{ @@} block");
	@};

%trailer% @{

@}, @{

	#endif

@};

