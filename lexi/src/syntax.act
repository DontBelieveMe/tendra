/* $Id$ */

/*
 * Copyright 2011, The TenDRA Project.
 * Copyright 1997, United Kingdom Secretary of State for Defence.
 *
 * See doc/copyright/ for the full copyright terms.
 */

%prefixes%
terminal = lex_ ;


%maps%


/*
    ENTRY POINT

    The main entry point for the grammar is given by unit.
*/

unit -> read_lex ;


/*
    TYPE MAPPINGS

    These mappings give the correspondences between syntax types and
    C types.
*/

BOOL -> int ;
IDENTIFIER -> SID_STRING ;
ZONE -> zoneP ;
STRING -> SID_STRING ;
INSTRUCTION -> instructionP ;
INSTRUCTIONS_LIST -> instructions_listP ;
ARG -> argP;
ARGS_LIST -> args_listP;
TYPETUPLE -> TypeTupleT;

%header% @{

/* $Id$ */

/*
 * Copyright 2011, The TenDRA Project.
 * Copyright 1997, United Kingdom Secretary of State for Defence.
 *
 * See doc/copyright/ for the full copyright terms.
 */

#include <string.h>
#include <stdio.h>

#include <exds/common.h>
#include <exds/exception.h>
#include <exds/dalloc.h>
#include <exds/dstring.h>

#include <shared/error.h>
#include <shared/xalloc.h>
#include <shared/check.h>
#include <shared/string.h>

#include "adt/action.h"
#include "adt/entry.h"
#include "adt/instruction.h"
#include "adt/keyword.h"
#include "adt/zone.h"
#include "adt/tree.h"
#include "adt/char.h"

#include "adt.h"
#include "lexer.h"
#include "syntax.h"
#include "options.h"


#define ADVANCE_LEXER ADVANCE_LXI_LEXER
#define CURRENT_TERMINAL CURRENT_LXI_TERMINAL 
#define SAVE_LEXER SAVE_LXI_LEXER
#define RESTORE_LEXER RESTORE_LXI_LEXER



/*
    PARSER TYPES

    These types give the implementation of the types used in the syntax.
*/

typedef char *SID_STRING ;
typedef char *SID_CHARS ;
/*typedef zone* zoneP; Done in syntax.h */
typedef instruction* instructionP ;
typedef instructions_list* instructions_listP ;
typedef arg* argP;
typedef args_list* args_listP;

/*
    SID IDENTIFIER PREFIX

    This string is added to the start of each sid identifier.
*/

char *token_prefix = "lex_" ;


/*
    COMPILATION MODE

    We allow unreached code in the automatically generated sections.
*/

#if FS_TENDRA
#pragma TenDRA begin
#ifndef OLD_PRODUCER
#pragma TenDRA unreachable code allow
#endif
#endif


@}, @{

/* $Id$ */

/*
 * Copyright 2011, The TenDRA Project.
 * Copyright 1997, United Kingdom Secretary of State for Defence.
 *
 * See doc/copyright/ for the full copyright terms.
 */

#ifndef SYNTAX_INCLUDED
#define SYNTAX_INCLUDED

#include "adt/zone.h"

extern char *token_prefix ;
typedef zone* zoneP;

@};


%assignments%

TYPETUPLE : (a) -> (b) = @{
	typetuple_assign(&@b,@&a);
@};

%parameter-assignments%

TYPETUPLE : (a) -> (b) = @{
	typetuple_assign(&@b,@a);
@};

%result-assignments%

TYPETUPLE : (a) -> (b) = @{
	typetuple_assign(@b, @&a);
@};


%terminals%


/*
    IDENTIFIER TERMINAL

    This action gives the terminal for identifiers.  The identifier text
    is built up in token_buff by the lexical routines.
*/

identifier : () -> ( i : IDENTIFIER ) = @{
    @i = xstrdup ( token_buff ) ;
@} ;


/*
    SID IDENTIFIER TERMINAL

    This action gives the terminal for sid-style identifiers.  The
    identifier text is built up in token_buff by the lexical routines.
*/

sid-identifier : () -> ( i : IDENTIFIER ) = @{
    int n ;
    char *s ;
    char buff [1000] ;
    strcpy ( buff, token_prefix ) ;
    n = ( int ) strlen ( buff ) ;
    for ( s = token_buff ; *s ; s++ ) {
	if ( *s == '-' ) {
	    buff [ n++ ] = '_' ;
	    buff [ n++ ] = 'H' ;
	} else if ( *s == '_' ) {
	    buff [ n++ ] = '_' ;
	    buff [ n++ ] = '_' ;
	} else {
	    buff [ n++ ] = *s ;
	}
	if ( n >= 900 ) {
	    error ( ERROR_SERIOUS, "Identifier too long" ) ;
	    break ;
	}
    }
    buff [n] = 0 ;
    @i = xstrdup ( buff ) ;
@} ;


/*
    STRING TERMINAL

    This action gives the terminal for strings.  The string text is built
    up in token_buff by the lexical routines.
*/

string : () -> ( s : STRING ) = @{
    @s = xstrdup ( token_buff ) ;
@} ;


/*
    SPECIAL STRING TERMINALS

    These actions give a number of special strings.
*/

upper : () -> ( s : STRING ) =	@{ @s = "ABCDEFGHIJKLMNOPQRSTUVWXYZ" ; @} ;
lower : () -> ( s : STRING ) =	@{ @s = "abcdefghijklmnopqrstuvwxyz" ; @} ;
digit : () -> ( s : STRING ) =	@{ @s = "0123456789" ; @} ;

arg-char-string : () ->(a:ARG) = @{
      @a=add_arg(arg_charP,0);
@};

arg-char-nb : () ->(a:ARG) = @{
      @a=add_arg(arg_char_nb,number_buffer);
@};

arg-nb-of-chars : () ->(a:ARG) = @{
      @a=add_arg(arg_nb_of_chars,0);
@};

arg-return-terminal : () -> (a:ARG) = @{
      @a=add_arg(arg_return_terminal,0);
@};

arg-ignore : () -> (a:ARG) = @{
      @a=add_arg(arg_ignore,0);
@};

%actions%


/*
    CONCATENATE TWO STRINGS

    This action concatenates two strings.
*/

<string-concat> : ( a : STRING, b : STRING ) -> ( s : STRING ) = @{
    @s = xstrcat ( @a, @b ) ;
@} ;

/*
    CREATE AN EMPTY IDENTIFIER

    This action creates a NULL IDENTIFIER
*/

<empty-identifier> : () -> ( i : IDENTIFIER ) = @{
    @i = xstrdup("");
@} ;


/*
    SET WHITE SPACE VARIABLE

    This action sets the white space variable to the given array of
    characters.  There is a check to make sure that it has not already
    been set.
*/

<make-white> : ( z : ZONE, s : STRING ) -> () = @{
    if ( @z->white_space) {
	error ( ERROR_SERIOUS, "White space group already defined" ) ;
    }
    @z->white_space= make_group(@z,"white",@s) ;
@} ;


/*
    CREATE A CHARACTER GROUP

    This action defines the character group i to be s.
*/

<make-group> : ( z : ZONE, i : IDENTIFIER, s : STRING ) -> () = @{
    make_group ( @z, @i, @s ) ;
@} ;


/*
    CREATE A PRE-PASS MAPPING

    This action creates a pre-pass mapping from s to t.
*/

<make-trigraph> : ( z : ZONE, s : STRING, t : STRING ) -> () = @{
	assert(@z != NULL);
	assert(@s != NULL);
	assert(@t != NULL);

	add_prepass(@z, @s, @t);
@} ;



/* 
   CREATE AN INSTRUCTION 
*/
<make-terminal-inst>  :  ( i : IDENTIFIER ) -> ( inst : INSTRUCTION ) = @{
        @inst=add_instruction_return_terminal(@i);
@};

<make-donothing-inst> : () -> ( inst : INSTRUCTION ) = @{
	@inst=add_instruction_donothing();
@};

<make-action-inst> : ( z: ZONE, i:IDENTIFIER, l:ARGS_LIST, r:ARGS_LIST) -> (inst:INSTRUCTION)  = @{
	NStringT key;
	struct EntryT* entry;
	nstring_copy_cstring(&key, @i);
	entry = table_get_entry(tree_get_table(@z->top_level), &key);
	if(entry) {
		if(entry_is_action(entry)) {
			/* TODO: Inefficient code follows: */
			/* Checking that a name does not appear twice in an lhs*/
			arg* p, *q;
			for(p=@l->head;p!=NULL;p=p->next) {
				if(p->type==arg_identifier) {
					for(q=p->next; q!=NULL;q=q->next) {
						if(q->type==arg_identifier && !strcmp(p->u.literal, q->u.literal)) {
							char* s = nstring_to_cstring(entry_key(entry));
							error(ERROR_SERIOUS, "In call to action %s, the left hand side contain multiple reference to %s",s, p->u.literal);
							break;		   
						}
					}
				}
			}
			@inst=add_instruction_action(entry,@l,@r);
		 /* END Inefficient code*/
		} else {
			@inst=NULL;
			error(ERROR_SERIOUS, "Name %s is not an action", @i);
		}
	} else {
		@inst=NULL;
		error(ERROR_SERIOUS, "Unknown action %s", @i);
	}
	xfree(@i);
@};

/*
    ADD ARGS to ARGS LIST
*/
<append-arg-args-list> : ( l:ARGS_LIST, a:ARG ) -> () = @{
    *@l->tail=@a;
    @l->tail=&@a->next;
    if(@a->type==arg_return_terminal)
	@l->nb_return_terminal++;
@};

<args-list-push-front> : ( a:ARG , l:ARGS_LIST ) -> () = @{
    @a->next=@l->head;
    @l->head=@a;
    if(@a->type==arg_return_terminal)
	@l->nb_return_terminal++;
@};

<check-args-list> : ( l:ARGS_LIST) -> () = @{
    if(@l->nb_return_terminal>1)
	error(ERROR_SERIOUS, "There can only be one return terminal argument per action lhs");
@};


/*
   CREATES AN EMPTY ARGS LIST
*/
<empty-args-list> : () -> ( l:ARGS_LIST) = @{
    @l=add_args_list();
@};

/*
    ADD INSTRUCTION to INSTRUCTION LIST 
*/
<add-inst-to-list> : ( z : ZONE, i : INSTRUCTION, il : INSTRUCTIONS_LIST ) -> () = @{
	if(@i!=NULL) { /* if @i == NULL, an error has already been issued.*/
		LocalNamesT* locals = instructionslist_localnames(@il);
/*		if((@il->head !=NULL) && (@i->type==return_terminal || @i->type==do_nothing)) {
			error(ERROR_SERIOUS, "A $sid-identifier or a $$ can only appear at the end of an instruction-list"); Does not work anymore since we append and do not prepend anymore. No pb as this will be unecessary due to the upcoming removal of direct function calls.
		}*/
		if(@il->nb_return_terminal>0 && @i->type!=do_nothing)
			error(ERROR_SERIOUS, "No instruction may follow an instruction that returns a terminal");
		if(@i->type == return_terminal) {
			++(@il->nb_return_terminal);
		}
		if(@i->type == action_call) {
			args_list* rhs;
			args_list* lhs;
			struct EntryT* entryaction;
			ActionT* action;
			arg* p;
			TypeTupleEntryT* q;

			@il->nb_return_terminal+=@i->u.act.lhs->nb_return_terminal;
			if(@il->nb_return_terminal>1)
				error(ERROR_SERIOUS, "Only one terminal may be returned per token");
			entryaction = @i->u.act.called_act;
			action = entry_get_action(entryaction);
			rhs = @i->u.act.rhs;
			lhs = @i->u.act.lhs;

			/* CHECKING RHS COMPATIBILITY */ 
			for ( p = rhs->head, q = action->inputs.head; p!=NULL && q!=NULL; p=p->next, q=q->next) {
			      	struct EntryT* entrytype = NULL;
				NStringT str;
			      	switch (p->type) {
				case arg_identifier: 
				     	nstring_copy_cstring(&str, p->u.literal);
					entrytype=localnames_get_type(locals, &str);
					nstring_destroy(&str);
					if(!entrytype) {
						struct EntryT* tableentry = table_get_entry(tree_get_table(@z->top_level), &str);
						if(!tableentry) {
							error(ERROR_SERIOUS, "local name %s has not been defined yet", p->u.literal);
							entrytype = NULL;
						} else if (entry_is_localname(tableentry)) {
							error(ERROR_SERIOUS, "local name %s has been defined but not in this scope", p->u.literal);
							entrytype = NULL;
						} else if (entry_is_action(tableentry)) {
							error(ERROR_SERIOUS, "%s is not a local name but an action which is not allowed", p->u.literal);
							entrytype = NULL;
						} else if (entry_is_type(tableentry)) {
							error(ERROR_SERIOUS, "%s is not a local name but a type which is not allowed", p->u.literal);
							entrytype = NULL;
						} else {
							UNREACHED;
						}
					}
					break;
				case arg_charP:
					/* TODO assert(lexer_string_type(top_level)) */
					entrytype = lexer_string_type(@z->top_level);
		 			break;
				case arg_char_nb:
					/* TODO assert(lexer_char_type(top_level)) */
					entrytype = lexer_char_type(@z->top_level);
			 		break;
				case arg_terminal:
					/* TODO assert(lexer_terminal_type(top_level)) */
					entrytype = lexer_terminal_type(@z->top_level);
					break;
				case arg_nb_of_chars:
					/* TODO assert(lexer_terminal_type(top_level)) */
					entrytype = lexer_int_type(@z->top_level);
		 			break;
				case arg_none:
					break; /* Error already detected, do nothing and leave p->lexitype = NULL */
				case arg_ignore:
				case arg_return_terminal:
					UNREACHED;
				break;
			default:
				UNREACHED;
				break;
			}
			if(entrytype) {
				if( q->type!=entrytype || p->is_reference!=q->is_reference) {
						char* s1 = nstring_to_cstring(entry_key(entryaction));
						char* s2 = nstring_to_cstring(entry_key(entrytype));
						char* s3 = p->is_reference ? "&" : "";
						char* s4 = nstring_to_cstring(entry_key(q->type));
						char* s5 = q->is_reference ? "&" : "";
						char* s6 = "unknown";
						char* s7 = "unknown";
						switch(p->type) {
						case arg_terminal:
							s6 = "$"; 
							s7 = p->u.literal;
							break;
						case arg_identifier:
							s7 = p->u.literal;
							break;
						case arg_nb_of_chars:
							s6 = "#n";
							break;
						case arg_char_nb:
							s6 = "#[number]";
							/* TODO s7=p->u.digit */;
							break;
						case arg_charP:
							s6 = "#*";
							break;
						}
						error(ERROR_SERIOUS, "In call to action %s, argument \'%s%s\' has type \'%s%s\' when it should have type %s", s1, s6, s7, s2, s3, s4, s5);
						DEALLOCATE(s1);
						DEALLOCATE(s2);
						DEALLOCATE(s4);
					}
				}
			}
			if(p!=NULL) {
				char* s = nstring_to_cstring(entry_key(entryaction));
				error(ERROR_SERIOUS, "In call to action %s, too many arguments", s);
				DEALLOCATE(s);
			}
			if(q!=NULL) {
				char* s = nstring_to_cstring(entry_key(entryaction));
				error(ERROR_SERIOUS, "In call to action %s, not enough arguments", s);
				DEALLOCATE(s);
			}

			for ( p = lhs->head, q = action->outputs.head; p!=NULL && q!=NULL; p=p->next, q=q->next) {
			      	struct EntryT* entrytype;
				switch (p->type) {
				case arg_identifier: 
					{
						NStringT str;
						nstring_copy_cstring(&str, p->u.literal);
						entrytype = localnames_get_type(locals, &str);
						if(!entrytype) {
							struct EntryT* entry = table_get_entry(tree_get_table(@z->top_level), &str);
							localnames_add_nstring(locals, &str, q->type);
							if(entry) {
								nstring_destroy(&str);
								if (entry_is_action(entry)) {
									error(ERROR_SERIOUS, "In action lhs. Name %s is an action. Hiding globals by local names is not allowed", p->u.literal);
								} else if (entry_is_type(entry)) {
									error(ERROR_SERIOUS, "In action lhs. Name %s is a type. Hiding globals by local names is not allowed", p->u.literal);									
								}
							} else {
								table_add_local_name(tree_get_table(@z->top_level), &str);
							}
							if(p->is_reference) {
								char* s = nstring_to_cstring(entry_key(entryaction));
								error(ERROR_SERIOUS, "In action call %s, you can only use references %s for preexisting variables", s, p->u.literal);
								DEALLOCATE(s);
							} 
						} else {
							nstring_destroy(&str);
							if(!p->is_reference) {
								char* s = nstring_to_cstring(entry_key(entryaction));
								error(ERROR_SERIOUS, "In action call %s, name %s already declared. Use references to change the value of an already existing variable", s, p->u.literal);
								entrytype=q->type; /* To avoid outputting that error more than once*/
								DEALLOCATE(s);
							}
						}
					}
					break;
				case arg_return_terminal:
					entrytype = lexer_terminal_type(@z->top_level);
					q->is_reference = false;
					/* TODO assert(q->is_reference == false) */
					break;
				case arg_ignore:
					/*always acceptable */
					entrytype=q->type;
					p->is_reference=q->is_reference;
					break;
				case arg_none:
					break;
					/* TODO asserting errored is already set */
					/* Error has already been detected */
				case arg_charP:
				case arg_char_nb:
				case arg_terminal:
				case arg_nb_of_chars:
					break; /* UNREACHABLE */
				default:
					break; /* UNREACHABLE */
				}
				if(p->is_reference != q->is_reference) {
					/* XXX: state which action */
					if(p->is_reference)
						error(ERROR_SERIOUS, "In call to action, %s should not be a reference", p->u.literal);
					else
						error(ERROR_SERIOUS, "In call to action, %s should not be a reference", p->u.literal);
				}
			}
			if(p!=NULL) {
				char* s = nstring_to_cstring(entry_key(entryaction));
				error(ERROR_SERIOUS, "In call to action %s, too many results", s);
				DEALLOCATE(s);
			}
			if(q!=NULL) {
				char* s = nstring_to_cstring(entry_key(entryaction));
				error(ERROR_SERIOUS, "In call to action %s, not enough results", s);
				DEALLOCATE(s);
			}
		}
		/* TODO only append if no error */
		*@il->tail=@i;
		@il->tail=&@i->next;
		++(@il->size);
	}
@};

<check-inst-list> : (il: INSTRUCTIONS_LIST ) -> () = @{
	if(@il->nb_return_terminal>1)
		error(ERROR_SERIOUS, "At most one return terminal may be specified per instruction list");
@};


/*
    EMPTY INSTRUCTION LIST
*/

<empty-inst-list> : () -> (i:INSTRUCTIONS_LIST) = @{
    @i=add_instructions_list();
@};


/*
    CREATE A MAIN-PASS MAPPING

    This action creates a main-pass mapping from s to the lexical token i.
*/

<make-token> : ( z : ZONE, s : STRING, il : INSTRUCTIONS_LIST) -> () = @{
	add_mainpass(@z, @s, @il);
	if(@il->nb_return_terminal)
		@z->type=typezone_general_zone;
@} ;

<is-non-empty> : ( s : STRING ) -> ( b : BOOL ) = @{
	@b = strlen(@s) > 0;
@};

<E_empty_character_string> : () -> () = @{
        error(ERROR_SERIOUS, "Empty character string is not allowed here, try using DEFAULT instead");	
@};  

/*
    CREATE A MAIN-PASS MAPPING

    This action creates a main-pass default from s to the lexical token i.
*/
<make-default> : ( z : ZONE, i : INSTRUCTIONS_LIST ) -> () = @{
    @z->default_instructions=@i;
	if(@i->nb_return_terminal)
		@z->type=typezone_general_zone;
@} ;


/*
    CREATE A KEYWORD

    This action creates a keyword called s.

*/

<make-keyword> : ( z: ZONE, s : STRING, i : INSTRUCTION ) -> () = @{
    switch(@i->type) {
    case return_terminal: 
    /* Fallback is intentional */
      add_keyword ( @z, @s, @i ) ;
    break;
    default:
      error(ERROR_SERIOUS, "Syntax error: only a function or a token might be returned for a keyword");
  }
@} ;


/*
    BOOLEANS

    These actions give the booleans true and false.
*/

<true> : () -> ( b : BOOL ) =	@{ @b = 1 ; @} ;
<false> : () -> ( b : BOOL ) =	@{ @b = 0 ; @} ;

/* 
   ZONES 

*/

/* 
   ADDING A NEW ZONE

   This action adds a a new zone
*/
<make-zone> : ( z : ZONE , i : IDENTIFIER, b : STRING, 
	      	binst : INSTRUCTIONS_LIST, e : STRING, 
		einst : INSTRUCTIONS_LIST, endmarkerclosed : BOOL ) 
		      		-> ( nz : ZONE) = 
@{
    instruction* inst;
    instructions_list* inst_list;
    @nz=add_zone(@z,@i,@e, @endmarkerclosed );

    @nz->leaving_instructions=@einst;
    if(@nz->leaving_instructions->nb_return_terminal)
	@nz->type= typezone_pseudo_token;
    @nz->entering_instructions=@binst;
    if(@nz->entering_instructions->nb_return_terminal)
	@nz->type=typezone_general_zone;
    inst=add_instruction_pushzone(@nz);
    inst_list=add_instructions_list();
    *(inst_list->tail)=inst;
    inst_list->tail=&(inst->next);
	add_mainpass(@z, @b, inst_list);
@};

<update-zone-type> : (zparent:ZONE, zchild:ZONE) -> () = @{
	switch(@zchild->type) {
		case typezone_pseudo_token:
		case typezone_general_zone:
			@zparent->type = typezone_general_zone;
			break;
		case typezone_pure_function:
			break; /* do nothing */

	}
@};


<make_arg_from_identifier> : (i:IDENTIFIER) -> (a:ARG) = @{
	@a = add_identifier_arg (@i);
@};

<make_arg_from_reference> : (i:IDENTIFIER) -> (a:ARG) = @{
	@a = add_reference_arg (@i);
@};

<make_arg_terminal> : (i:IDENTIFIER) -> (a:ARG) = @{
	@a = add_terminal_arg (@i);
@};


<make_arg_none> : () -> (a:ARG) = @{
	@a = add_none_arg();
@};

/* 
   IS THE ZONE GLOBAL

   This action report if the zone z is the global zone 
*/
<is-global-zone> : ( z : ZONE ) -> ( b : BOOL ) = @{
   @b = tree_zoneisglobal(@z->top_level, @z);
@};

<make-type> : ( z:ZONE, i:IDENTIFIER ) -> () = @{
	NStringT str;
	struct EntryT* entry;
	nstring_copy_cstring(&str,@i);
	xfree(@i);
	entry=table_get_entry(tree_get_table(@z->top_level), &str);
	if(entry != NULL) {
		nstring_destroy(&str);
		/* TODO switch ? */
		if(entry_is_type(entry))
			error(ERROR_SERIOUS, "Type %s already exists",@i);
		else if(entry_is_localname(entry))
			error(ERROR_SERIOUS, "Can't create type %s, %s has been previously used as a local name. We do not allow retroactive hiding.",@i,@i);
		else if(entry_is_action(entry))
			error(ERROR_SERIOUS, "Can't create type %s, %s has already been declared as an action",@i, @i);
		else
			UNREACHED;
	} else {
		table_add_type(tree_get_table(@z->top_level), &str, false);
	}
@};

<make-action> : ( z:ZONE, i:IDENTIFIER, params:TYPETUPLE&, results:TYPETUPLE&) -> () = @{
	NStringT str;
	struct EntryT* entry;
	nstring_copy_cstring(&str, @i);
	entry=table_get_entry(tree_get_table(@z->top_level), &str);
	if(entry != NULL) {
		nstring_destroy(&str);
		/* TODO switch ? */
	   	if(entry_is_action(entry))
			error(ERROR_SERIOUS, "Action %s already exists",@i);
		else if(entry_is_localname(entry))
			error(ERROR_SERIOUS, "Can't create type %s, %s has been previously used as a local name. We do not allow retroactive hiding.",@i,@i);
		else if(entry_is_type(entry))
			error(ERROR_SERIOUS, "Can't create action %s, %s has already been declared as a type",@i, @i);
		else
			UNREACHED;
	} else {
		table_add_action(tree_get_table(@z->top_level), &str , @&params, @&results);
	}
	xfree(@i);
@};

/*
	Initializing an empty type tuple
*/

<init-tuple> : () -> (a:TYPETUPLE) = @{
	typetuple_init(&@a);
@};

<append-tuple> : (z:ZONE, a:TYPETUPLE&, id:IDENTIFIER, type:IDENTIFIER, isref:BOOL) -> () =@{
	struct EntryT* entry;
	NStringT tstr, istr;
	nstring_copy_cstring(&tstr,@type);
	nstring_copy_cstring(&istr,@id);
	entry = table_get_entry(tree_get_table(@z->top_level), &tstr);
	if(entry == NULL) {
		 error(ERROR_SERIOUS, "Unknown type %s", @type);
		 nstring_destroy(&istr);
	}
	else if(!entry_is_type(entry)) {
		 error(ERROR_SERIOUS, "%s is not a type", @type);
		 nstring_destroy(&istr);
	}
	else {
		typetuple_append(@&a,typetupleentry_create(&istr,entry,@isref));
	}
	nstring_destroy(&tstr);
	xfree(@type);
	xfree(@id);
@} ;

/* 
   These actions reports errors if non global zones contains
   definitions that should only be in zones.
*/

<E_nonglobalzonekeyword> : () -> () = @{
    error( ERROR_SERIOUS, "Keywords not yet implemented in a non global zone ") ;

@};

<E_nonglobalzonetype>    : (i:IDENTIFIER) -> () = @{
    error( ERROR_SERIOUS, "Syntax error: type %s should not be declared inside a zone",@i) ;
@};


/*
    SYNTAX ERROR

    This action reports a syntax error.
*/

<E_expected_identifier> : () -> (i:IDENTIFIER) = @{
	@i="";
	error(ERROR_SERIOUS, "Syntax error: expected identifier");
@};

<E_expected_range> : () -> () = @{
	error(ERROR_SERIOUS, "Syntax error: expected range");
@};

<E_expected_open> : () -> () = @{
	error(ERROR_SERIOUS, "Syntax error: expected open \'(\'");
@};

<E_expected_close> : () -> () = @{
	error(ERROR_SERIOUS, "Syntax error: expected close \')\'");
@};

<E_expected_chars> : () -> (s:STRING) = @{
        @s = NULL ;
	error(ERROR_SERIOUS, "Syntax error: expected characters");
@};

<E_expected_colon>	 : () -> () = @{
	error(ERROR_SERIOUS, "Syntax error: expected colon \':\'");
@};

<E_expected_semicolon> 	 : () -> () = @{
	error(ERROR_SERIOUS, "Syntax error: expected semicolon \';\'");
@};

<E_expected_arrow> 	 : () -> () = @{
	error(ERROR_SERIOUS, "Syntax error: expected arrow \'->\'");
@};

<E_expected_equal> 	 : () -> () = @{
	error(ERROR_SERIOUS, "Syntax error: expected equal \'=\'");
@};

<E_expected_begin_action> 	 : () -> () = @{
	error(ERROR_SERIOUS, "Syntax error: expected begin action \'<\'");
@};

<E_expected_end_action> 	 : () -> () = @{
	error(ERROR_SERIOUS, "Syntax error: expected end action \'>\'");
@};


<syntax-error> : () -> () = @{
	error ( ERROR_SERIOUS, "Syntax error" ) ;
@} ;

<E_sharp_arg_in_lhs> : () -> () = @{
	error(ERROR_SERIOUS, "Argument of style # are rvalues and should not appear on a left handside");
@} ;

<E_string_arg_in_lhs> : () -> () = @{
	error(ERROR_SERIOUS, "Argument of type "" are rvalues and should not appear on a left handside");
@} ;

<E_return_terminal_in_rhs> : () -> () = @{
	error(ERROR_SERIOUS, "Return terminal argument in right handside");
@};

<E_string_in_action_rhs> : () -> () = @{
	error(ERROR_SERIOUS, "String argument in right handside of action call: purposefuly not implemented to avoid confusions. Will be implemented with an alternate meaning once direct function calls are removed from lexi");
@};



<E_ignore_in_rhs> : () -> () = @{
	error(ERROR_SERIOUS, "Ignore argument in right handside");
@};

<E_terminal_in_lhs> : () -> () = @{
	error(ERROR_SERIOUS, "Terminal argument in left handside");
@};

%trailer% @{
@}, @{
#endif
@} ;
