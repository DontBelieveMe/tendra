<?xml version="1.0" standalone="no"?>
<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">

<!--
  $Id$
-->

<chapter id="commands">
	<title>Commands</title>	<!-- TODO term -->

	<para>Lexical analysers are described to <application>Lexi</application> by a
		sequence of commands. This section provides an explanation of
		each possible command, and explains their respective
		intended uses.</para>

	<section id="prepassmappings">
		<title>Pre-pass mappings</title>

		<para>The lexical analysis runs in two passes. The first pass,
			or <quote>pre-pass</quote> stage permits replacements to be substituted
			before the main pass, under which tokenisation takes place.
			This gives a convenient mechanism for expressing trigraph-like
			substitutions as found in C. The syntax to define pre-pass
			replacements is:</para>

		<!-- TODO not real BNF! -->
		<programlisting language="BNF">MAPPING sequence + "->" + char ;</programlisting>

		<para>The string on the right (i.e. the value with which the
			matched string is replaced) may only contain one character,
			or an escape sequence which yields one character.</para>

		<para>For example, to replace the trigraph <literal>??=</literal>
			with a single <literal>#</literal>:</para>

		<programlisting language="Lexi">MAPPING "??=" -> "#" ;</programlisting>

		<para>This would replace instances of <literal>??=</literal>
			with <literal>#</literal> before
			any tokenisation takes place. So the input
			<literal>a??=b</literal> would
			match the token definition:</para>

		<programlisting language="Lexi">TOKEN "a#b" -> a ;</programlisting>

		<para>(and so would simply <literal>a#b</literal>, as usual).</para>

		<para>A group may be included in the character sequence to
			be replaced. For example:</para>

		<programlisting language="Lexi">MAPPING "[alpha]" -> " " ;</programlisting>

		<para>will replace any alphabetic character by a blank,
			assuming the <quote>alpha</quote> group is suitablly
			defined at that point.
			See the <xref linkend="groupinclusion" endterm="groupinclusion"/>
			rules for details of including groups in sequences.</para>

		<para>Mappings are substituted repeatedly until no further
			mappings match. The order of replacement for mappings
			matching strings of equal length is undefined,
			and so it is an error to define a mapping which produces
			a character used at the start of any mapping, including
			itself. For example:</para>

		<programlisting language="Lexi">MAPPING "???" -> "?" ;</programlisting>

		<para>is illegal. To see why, consider the input
			<quote><literal>aab</literal></quote> for
			the (illegal) mappings:</para>

		<programlisting language="Lexi">MAPPING "aa" -> "x" ;
MAPPING "xb" -> y ;</programlisting>

		<para>Since the order of substitution for mappings matching
			strings of equal length is undefined, it is
			unclear if this will result in <quote>xb</quote> or
			<quote>y</quote>. Notice that
			C does not demand a <quote>???</quote> trigraph
			- perhaps for this very reason (or perhaps simply
			because it is redundant).
			This restriction applies no matter how the string
			defining the characters to be mapped is formed: for
			example, it is also illegal to define a mapping which maps
			to a character present in a group included at the start
			of another mapping.</para>

		<para>Mappings bind from left to right. For example:</para>

		<programlisting language="Lexi">MAPPING "ab" -> "d" ;
MAPPING "bc" -> "d" ;</programlisting>

		<para>For the input <quote>abc</quote> will produce
			<quote>db</quote>, not <quote>ad</quote>.</para>

		<para>Mappings matching sequences of longer lengths
			are replaced with higher precedance than mappings
			matching shorter lengths of the same values
			beginning the longer sequences. For example:</para>

		<programlisting language="Lexi">MAPPING "abcdef" -> "x" ;
MAPPING "abcd" -> "y" ;</programlisting>

		<para>for the input <quote><literal>abcdef</literal></quote>
			will produce <quote><literal>x</literal></quote>,
			not <quote><literal>yef</literal></quote>.</para>
		<!-- TODO ditto tokens? -->
	</section>

	<section id="groupdefinitions">
		<title id="groupdefinitions.title">Character group definitions</title>

		<para>A group is an unordered sets of characters; groups
			name these sets for use in <!-- TODO which strings? -->
			strings <!-- TODO think up a name for group inclusions -->.
			The syntax of a group definition is:</para>

		<programlisting language="BNF">group-defn := "GROUP" + identifier + "=" + chars ;</programlisting>
		<!-- TODO not identifier, but name (we don't want to include
			sid-identifiers!) -->

		<para>The <code>identifier</code> specified is the name
			by which the group may be referenced.</para>

		<para>For example, the following are valid group definitions:</para>

		<programlisting language="Lexi">GROUP alpha    = {A-Z} + {a-z} + "_" ;
GROUP digit    = {0-9} ;
GROUP odds     = "13579" ;
GROUP even     = "02468" ;
GROUP vowels   = "aeiou" ;
GROUP anything = "atrf" + "HGMP" + {0-9} ;</programlisting>

		<para>Groups may include the sets of previously-defined
			groups. Any character in the referenced set will be
			included into the group definition. For example:</para>

		<programlisting language="Lexi">GROUP hexdigit = "[digit]ABCDEFabcdef" ;
GROUP alphanum = "[alpha]" + {0-9}</programlisting>

		<para>assuming the groups <literal>alpha</literal> and
			<literal>digit</literal> have already
			been defined at that point.
			See <xref linkend="charactersetssequences"
			endterm="charactersetssequences.title"/> for details of the
			syntax for the chars production.</para>

		<para>Groups may not contain characters which are present
			in other groups (i.e. they may not overlap). See the
			<xref linkend="tokendefinitions"
			endterm="tokendefinitions.title"/> section for further
			discussion of why this is so.</para>
		<!-- TODO NEW UNDEFINED BEHAVIOUR -->

		<para>Macros to test if a character belongs to a group
			are provided in the generated code, of the form
			<code>is_groupname()</code>. These must be
			passed the index into the look-up table containing
			the given character, obtained by <code>lookup_char(c)</code>.
			For example:</para>

		<programlisting language="C">is_alpha(lookup_char('a'))</programlisting>
		<!-- TODO repetiion: this is in Interface -->

		<para>would yield true, assuming the group <literal>alpha</literal>
			is suitablly defined.</para>

		<!-- TODO explain what groups are legal, undefined, etc.
			Overlapping, for example? -->

		<para>The group name <quote>white</quote> may not be used for groups other
			than the whitespace definition; see
			<xref linkend="whitespacedefinitions"/> for details.</para>

		<para>A group name is unique amongst groups; groups may
			only be defined once.</para>
		<!-- TODO unique amongst what else? Think in terms of namespaces;
			somewhere we should explain namespaces for identifiers -->
	</section>

	<section id="whitespacedefinitions">
		<title id="whitespacedefinitions.title">Whitespace definition</title>

		<para>Consecuitive whitespace characters outside of tokens
			<!-- TODO is this right? --> are skipped by
			the lexical analyser <emphasis>before</emphasis> each token
			is recognised.
			Whitespace is treated with the semantics of a
			single token delimiter. <application>Lexi</application> specifies
			whitespace by the special group name <code>white</code>,
			which may not be used as an identifier to name other
			groups.</para>

		<para>For special cases where whitespace has significance (a common
			example is inside string literals), token definitions may call
			user-defined functions which purposefully circumvent the
			whitespace-skipping features of
			<application>Lexi</application>.</para>

		<para>The syntax is the same as for any
			<xref linkend="groupdefinitions"
			endterm="groupdefinitions.title"/>, but with the
			special group name <code>white</code>:</para>

		<programlisting language="BNF">white-defn := "GROUP" + "white" + "=" + chars ;</programlisting>

		<para>The whitespace definition may be omitted, in which case
			it defaults to space, horizontal tabulation and
			newline. Therfore it is always present, even if the
			declaration is implicit. As with any group, it may not
			be defined multiple times.</para>

		<para>For example:</para>

		<programlisting language="Lexi">GROUP white = " \t\n\r";</programlisting>

		<para>Aside from the additional semantics explained above,
			the whitespace group is present as any other group:
			it is present in the API as <code>is_white()</code>,
			and may be included in <xref linkend="groupinclusion"
			endterm="groupinclusion"/> as <code>[white]</code>.</para>

		<!-- TODO NEW UNDEFINED BEHAVIOUR -->
		<!-- if white contains the same characters as other tokens,
			it has precidence. however we call that illegal -->
		<para>It is illegal to define the whitespace group to
			contains characters which are present in token
			definitions, including groups which those tokens use.</para>
		<!-- TODO rather, we should also say it's illegal to define
			tokens which use whitespace characters. -->
	</section>

	<section id="tokendefinitions">
		<title id="tokendefinitions.title">Token definitions</title>

		<para>Tokens are sequences of characters read by the lexical analyser
			and produced as output. Each token as a unique identifier,
			which is passed to code calling <application>Lexi</application>,
			along with the characters read which form the token's
			spelling.<!-- TODO not true: you need to store the spelling
			yourself --></para>

		<para>Tokens are usually the main component of a lexical analyser.
			In <application>Lexi</application>'s case, the only sitution in
			which there would be no token declarations is if the lexical
			analyser is to exclusivley perform pre-pass mappings. The
			effect of specifying neither tokens nor pre-pass mappings
			is undefined.</para>

		<para>The syntax for specifiying tokens is:</para>

		<programlisting language="BNF">token-defn := "TOKEN" + chars + "->" + either-identifier ;</programlisting>
		<!-- TODO right? -->

		<para>Each action associated with a token is either a
			<application>Sid</application> identifier or a call to
			a user-defined function. An example of these two forms:

			<programlisting language="Lexi">TOKEN "token1" -> $sid-identifier ;
TOKEN "token2" -> get_identifier () ;</programlisting>

			The first form of token definition states that upon
			encountering <quote>token1</quote> the lexer should return
			the terminal corresponding <quote>sid-identifier</quote>.
			See <xref linkend="interface_terminals"/> for the C
			representation of the terminals returned by
			<code>read_token()</code>.</para>

		<para>The second form states that the lexer should return the result
			of the call to the given function identifier. See
			<xref linkend="interface_functions"/> for details of the
			function call made in C.</para>

		<para><!-- TODO simple examples here --></para>

		<para>In more complex cases (most notably where tokens need include
			whitespace), tokens are mapped to user-defined functions.
			For example, for comments in a C-style language, the lexical
			analyser is expected to discard characters until the end
			of the comment is found. In <application>Lexi</application>,
			this is specified as:</para>

		<programlisting language="Lexi">TOKEN "/*" -> get_comment() ;</programlisting>
		<!-- TODO right? -->

		<para>Where <code>get_comment()</code> is an externally defined
			function which simply reads characters until the corresponding
			<code>*/</code> is found. See the <!-- TODO -->functions
			section for futher details of calling functions.</para>

		<para>In most languages, keywords are usually a subset of
			identifiers. In order to handle these and simplify the
			user-defined <code>read_identifier()</code> function
			(or equivalent), <application>Lexi</application> provides
			the keywords mechanism discussed in
			<xref linkend="keyworddefinitions"/>.</para>
		<!-- TODO mention that most keywords are usually a subset of identifiers -->

		<para>Note that this example does not illustrating storing the
			characters read. A real-world case would usually store
			spellings in order to be useful to a later stage, such
			as parsing.</para>

		<!-- TODO only defined once: even in IFs?  -->

		<para>Unlike many lexical analysers, tokens in
			<application>Lexi</application> are not specified by regular
			expressions. However, as sequences of characters may contain
			references to groups (which are treated as sets), similar
			effects may be achieved for simple cases. For example:

			<programlisting language="Lexi">TOKEN "[alpha]" ->  get_identifier ();
TOKEN "$[alpha]" -> get_sid_identifier ();</programlisting>

			assuming the group <quote>alpha</quote> is defined. Another
			example:

			<programlisting language="Lexi">TOKEN "A[digit]" -> $papersize ;</programlisting>

			would match paper sizes such as such as <quote>A3</quote>,
			<quote>A4</quote> and so on. A token may only be defined once,
			but different tokens may share the same terminal or call the
			same function. So to extend our (rather lax) implementation of
			<acronym>ISO</acronym> 216 paper sizes:

			<programlisting language="Lexi">TOKEN "A[digit]" -> $papersize ;
TOKEN "A10" -> $papersize ;
TOKEN "C[digit]" -> $envelopesize ;
TOKEN "B[digit]" -> $envelopesize ;
TOKEN "DL" -> $envelopesize ;	/* BS 4264 specifies a transparent window for DL */
TOKEN "ID-[digit]" -> $identificationcardsize ;</programlisting>
			<!-- TODO extend as "C[{0-3}]" in the future -->

			Note that <quote>A10</quote> codes for the same lexeme as
			single-digit <quote>A</quote> sizes. See
			<xref linkend="functioncalls"/> for further examples of
			multiple tokens sharing one function, and the <!-- TODO sets -->
			for further examples of using sets within sequences.</para>

		<para>Using groups in this way is especially useful in combination
			with functions for reading variable-length tokens. For example:

			<programlisting language="Lexi">TOKEN "[alpha]" ->  get_identifier() ;
TOKEN "$[alpha]" -> get_sid_identifier() ;</programlisting>
			</para>


		<para><!-- TODO state ranges are undefined --></para>

		<para><!-- TODO kevin says:
       Remember,  individual  characters  have  priority over groups. But lexi
       doesn't handle subset analysis for groups. So

            GROUP alpha     =  {A-Z}+{a-z} ;
            GROUP lower     =  {a-z} ;
            TOKEN "[alpha]" -> get_identifier ()
            TOKEN "[lower]"  -> get_low_identifier () ;

       may not work correctly. lexi doesn't look  for  ambiguities  if  groups
       overlap.
		TODO we defined overlap as illegal in the groups section;
			this is just explaining rationalle -->


<!-- TODO stated as undefined behaviour in Strings section
		<para>TODO kevin says:
       An empty string can be a token,
            TOKEN "" -> $default ;
       It really means that if no other token match, then the  lexer  will  eat
       one  character  and  return  $default.   If  this  token is not present
       lex_unknown would have been returned.
		</para>

TODO we should make a sequence of undefined behaviours and check
if anybody uses them (or indeed if anybody uses lexi...)
-->

	</para>

	</section>

	<section id="keyworddefinitions">
		<title>Keyword definitions</title>

		<para>The  syntax of keywords resembles the syntax
			used for tokens:</para>

		<programlisting language="BNF">keyword-defn := "KEYWORD" + string + "->" + either-identifier ;</programlisting>

		<para>For example:</para>

		<programlisting language="Lexi">KEYWORD "keyword" -> $key ;
KEYWORD "special" -> get_special () ;</programlisting>

		<para>Usually  keywords are simply identifiers with a special
			meaning.  Using the main pass to identify keyword
			with the token constructs is possible but awkward
			since the spelling of keywords is usually a subset of the
			much bigger set of identifiers. The keyword construct
			facilitates the identification of keywords after
			a token has been found; they have effect only for
			the <option>-k</option> and are otherwise not present
			in the output generated by <application>Lexi</application>.
			Therfore the only difference between keywords and
			tokens (and indeed their purpose) is the programatic
			interface that they provide.<!-- TODO and overlap! --></para>

		<para>Code generated by <application>Lexi</application> under
			the <option>-k</option> option consists of a succession
			of calls to define each keyword, one per <code>KEYWORD</code>
			statement:</para>

		<programlisting language="Lexi">MAKE_KEYWORD ( "keyword", "lex_key" )
MAKE_KEYWORD ( "special", "get_special ()" )</programlisting>

		<para>where the identifier has been transformed according
			to the rules for <application>Sid</application>
			identifiers<!-- TODO link -->.
			It is then left to the user to implement
			<code>MAKE_KEYWORD</code>,
			usually by way of a macro. The generated keyword
			code is intended to be included with a
			<code>#include</code> directive. Suppose
			that keyword.h contains the keyword code then
			building on existing token definitions, the
			intended use for keywords is as follows (for example with
			a lexer required to identify variable names):</para>

<!-- TODO use read_identifier from above -->
		<programlisting language="Lexi">KEYWORD "if" -> keyword_if ;
KEYWORD "else" -> keyword_else ;
TOKEN "[alpha]" -> get_variable() ;</programlisting>

		<para>Where and <code>get_variable()</code> checks to
			see if the given token is actually a keyword like so:</para>

		<programlisting language="C">&lt;type&gt; get_variable(int c) {
char *token;
/* token is pointed to the characters read */
...
#define MAKE_KEYWORD(A, B)\
	if (!strcmp(token, (A))) return(B);
#include "keyword.h"
	return(lex_variable);
...
}
</programlisting>

		<para>Here <filename>keyword.h</filename> was generated by
			<application>Lexi</application>'s <option>-k</option>. If the
			variable name read by <code>get_variable()</code> and
			pointed at by <code>char *token</code> is a keyword,
			<filename>keyword.h</filename>'s calls to <code>MAKE_KEYWORD()</code>
			will result in the string comparisons of <code>token</code>
			to each possible keyword in turn (that is, <code>token</code>
			is compared to <code>"if"</code> and <code>"else"</code>.
			If either of these match, the identifiers <code>keyword_if</code>
			and <code>keyword_else</code> are returned, respectivley.
			Otherwise, if no keywords match, the token is known to
			be a variable name, and so <code>get_variable()</code>
			falls through to return the <code>lex_variable</code>
			identifier.</para>

		<note>
			<para>This historic interface is expected to change
				drastically for the next version of
				<application>Lexi</application>.</para>
		</note>

		<para>Unlike functions associated with tokens, functions
			associated with keywords are generated to be called
			with no arguments passed:</para>

		<programlisting language="Lexi">KEYWORD "sx" -> fx() ;</programlisting>

		<para>Results in the generated call:</para>

		<programlisting language="C">MAKE_KEYWORD("sx", fx());</programlisting>

		<para>And so <code>f()</code> should be declared to
			accept no parameters, that is of prototype:</para>

		<programlisting language="C">&lt;type&gt; f(void);</programlisting>

	<!-- TODO does mapping a keyword to a function have a use-case? if not,
		can we disallow it? Perhaps good for fortran style unreserved keywords?
		(the function could check to see if the symbol table holds that
		identifier; if it dosen't, then we know its a keyword) -->

	<!-- TODO talk about read_char_aux() used for MAPPNG. unread_char()
		needs to deal with that :(
		read_char_aux() is called in place of read_char().
		But as this happens in a seperate pass, the buffer need only
		be max(token, trigraph) (not including '\0')
	-->

<!--
<kevin2993> And I believe I was wrong at one point in the manpage saying that one 
            could replace a KEYWORD with aTOKEN and get an equivalent program 
            with a different interface
<kevin2993> The difference is the beginning of 
            keywordwithoutaseparatingwhitespace will be recognized as a token but 
            not as keyword if keyword is a keyword
-->
	</section>

<!--
	<section>
		<title>Blocks</title>

		<para>TODO. what're these even for? just IFs, I think. if so,
			merge them - we have no scope etc, so there's no other purpose</para>
	</section>
-->

	<section id="conditionalcommands">
		<title>Conditional commands</title>

		<para><!-- Runtime or compiletime? TODO check --></para>

		<para>The identifier specified is passed through to the generated code
			as-is - it is expected to be resolved to a symbol provided by the
			user's program. Expressions are not supported, though may be provided
			by definining a macro which provides a simple identifier:</para>

		<para><!-- The command given may be in a block? TODO --></para>

		<para><!-- TODO kevin says:
       It is possible to use IF ELSE constructs around mappings,  keyword  and
       token. Groups ignore them. The general syntax is
TODO then define groups inside a block as undefined, and adjust the grammar
TODO or we can have groups inside IFs as silently creating multiple groups, so for example:
IF (x) { GROUP "x" ...; } ELSE { GROUP "x" ...; } would make two groups, not one.
TODO for the moment, we can not permit them and decide that later. NEW UNDEFINED BEHAVIOUR

            IF (identifier) {
                 commands ....
            } ELSE {
                  commands ....
            }
		-->
		</para>

		<para>Conditions affect constructs in the following ways:

			<variablelist>
				<varlistentry>
					<term>Tokens</term>
					<listitem>
						<para>
	<!-- TODO kevin says:
        For tokens, it seems to
       mean that if the condition is fulfilled, upon finding  the  token,  the
       corresponding terminal is returned.  If that is not the case, the token
       is read and skipped. 
	-->
						</para>
					</listitem>
				</varlistentry>

				<varlistentry>
					<term>Keywords</term>
					<listitem>
						<para>
	<!--
	For keywords, the MAKE_KEYWORD call  is  enclosed
       by  the condition in the resulting C code.
	-->
						</para>
					</listitem>
				</varlistentry>

				<varlistentry>
					<term>Pre-pass mappings</term>
					<listitem>
						<para>
	<!--
	For mappings, if the condi-
       tion doesn't hold, the replacement doesn't occur.
	-->
						</para>
					</listitem>
				</varlistentry>
			</variablelist>
		</para>

		<para>The conditional constructs are not a particularly powerful
			mechanism as the braces do not introduce scope.
			So, for example, they do not provide a means to have
			multiple definitions of tokens. In particular, having one
			spelling map to different lexemes is not permitted:

			<programlisting language="Lexi">IF (xxx) {
TOKEN "a" -> $aaa;
} ELSE {
TOKEN "a" -> $bbb;
}</programlisting>

			As the token <quote>a</quote> is defined twice, both definitions are in
			the same scope and are therefore mutually illegal.</para>
			<!-- make it valid? introduce scope for this purpose? -->

		<para><!-- TODO kevin says: IF constructs can nest. --></para>
	</section>
</chapter>

