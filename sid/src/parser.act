%prefixes%

%maps%

AltP			-> AltP;
BoolT			-> BoolT;
EntryP			-> EntryP;
ItemP			-> ItemP;
RuleP			-> RuleP;
StringT			-> NStringT;
sid-parse-grammar	-> sid_parse_grammar;

%header% @{
/*
 * Copyright (c) 2002-2005 The TenDRA Project <http://www.tendra.org/>.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 *    this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 * 3. Neither the name of The TenDRA Project nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific, prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS
 * IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
 * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
 * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT HOLDERS OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * $Id$
 */
/*
    		 Crown Copyright (c) 1997
    
    This TenDRA(r) Computer Program is subject to Copyright
    owned by the United Kingdom Secretary of State for Defence
    acting through the Defence Evaluation and Research Agency
    (DERA).  It is made available to Recipients with a
    royalty-free licence for its use, reproduction, transfer
    to other parties and amendment for any purpose not excluding
    product development provided that any such use et cetera
    shall be deemed to be acceptance of the following conditions:-
    
        (1) Its Recipients shall ensure that this Notice is
        reproduced upon any copies or amended versions of it;
    
        (2) Any amended version of it shall be clearly marked to
        show both the nature of and the organisation responsible
        for the relevant amendment or amendments;
    
        (3) Its onward transfer from a recipient to another
        party shall be deemed to be that party's acceptance of
        these conditions;
    
        (4) DERA gives no warranty or assurance as to its
        quality or suitability for any purpose and DERA accepts
        no liability whatsoever in relation to any use to which
        it may be put.
*/

#include <limits.h>
#include <assert.h>

#include "parser.h"
#include "action.h"
#include "basic.h"
#include "bitvec.h"
#include "dalloc.h"
#include "dstring.h"
#include "gen-errors.h"
#include "grammar.h"
#include "lexer.h"
#include "non-local.h"
#include "rules/rule.h"
#include "scope.h"
#include "table.h"
#include "types.h"

#define CURRENT_TERMINAL lexer_get_terminal (sid_current_stream)
#define ADVANCE_LEXER lexer_next_token (sid_current_stream)
#define SAVE_LEXER(x) (lexer_save_terminal (sid_current_stream, (LexerTokenT) (x)))
#define RESTORE_LEXER (lexer_restore_terminal (sid_current_stream))
#define ALT_LIMIT (UINT_MAX - 1)

LexerStreamP		sid_current_stream;
GrammarP		sid_current_grammar;

static TableP		sid_current_table;
static EntryListP	sid_current_entry_list;
static ScopeStackT	sid_scope_stack;
static ScopeStackT	sid_global_scope;
static ScopeStackP	sid_current_scope;
static EntryP		sid_current_entry;
static RuleP		sid_enclosing_rule;
static union {
    BasicP		basic;
    ActionP		action;
    RuleP		rule;
} sid_current;
static BoolT		sid_redefining_entry;
static NStringT		sid_maximum_scope;
static TypeTupleT	sid_saved_type;
static TypeTupleT	sid_current_type;
static EntryP		sid_saved_pred_id;
static EntryP		sid_current_pred_id;
static EntryP		sid_unique_pred_id = NULL;
static EntryP		sid_predicate_type = NULL;
static AltP		sid_current_alt;
static ItemP		sid_current_item;
static unsigned		sid_alternative;
static BoolT            sid_internal_rule;
static EntryP		sid_external_rule;
static unsigned		sid_num_alternatives = 0;
static NonLocalEntryP	sid_non_local;
static BoolT		sid_propagating_error = FALSE;
static BoolT		sid_finished_terminals = FALSE;
@}, @{
/*
    		 Crown Copyright (c) 1997
    
    This TenDRA(r) Computer Program is subject to Copyright
    owned by the United Kingdom Secretary of State for Defence
    acting through the Defence Evaluation and Research Agency
    (DERA).  It is made available to Recipients with a
    royalty-free licence for its use, reproduction, transfer
    to other parties and amendment for any purpose not excluding
    product development provided that any such use et cetera
    shall be deemed to be acceptance of the following conditions:-
    
        (1) Its Recipients shall ensure that this Notice is
        reproduced upon any copies or amended versions of it;
    
        (2) Any amended version of it shall be clearly marked to
        show both the nature of and the organisation responsible
        for the relevant amendment or amendments;
    
        (3) Its onward transfer from a recipient to another
        party shall be deemed to be that party's acceptance of
        these conditions;
    
        (4) DERA gives no warranty or assurance as to its
        quality or suitability for any purpose and DERA accepts
        no liability whatsoever in relation to any use to which
        it may be put.
*/


@};

%assignments%

StringT: (a) -> (b) = @{
    nstring_assign (&@b, @&a);
@};

%parameter-assignments%

StringT: (a) -> (b) = @{
    nstring_assign (&@b, @a);
@};

%result-assignments%

StringT: (a) -> (b) = @{
    nstring_assign (@b, @&a);
@};

%terminals%

identifier: () -> (i) = @{
    nstring_assign (&@i, lexer_string_value (sid_current_stream));
@};

%actions%

<init> = @{
sid_current_table      = grammar_table (sid_current_grammar);
sid_current_entry_list = grammar_entry_list (sid_current_grammar);
scope_stack_init (&sid_scope_stack);
scope_stack_init (&sid_global_scope);
@};

// Type section actions:

<add-type>: (string) -> () = @{
    if (table_add_type (sid_current_table, &@=string) == NULL) {
	E_duplicate_type (@&string);
	nstring_destroy (&@=string);
    }
@};

// Terminals section actions:

<terminal>: (string) -> () = @{
    sid_current_entry = table_add_basic (sid_current_table, &@=string,
					 sid_current_grammar, FALSE);
    if (sid_current_entry == NULL) {
	E_duplicate_basic (@&string);
	nstring_destroy (&@=string);
    } else {
	sid_current.basic = entry_get_basic (sid_current_entry);
    }
@};

<i-terminal>: (string) -> () = @{
    sid_current_entry = table_add_basic (sid_current_table, &@=string,
					 sid_current_grammar, TRUE);
    if (sid_current_entry == NULL) {
	E_duplicate_basic (@&string);
	nstring_destroy (&@=string);
    } else {
	sid_current.basic = entry_get_basic (sid_current_entry);
    }
@};

<x-terminal> = @{
    if (sid_current_entry) {
	KeyP key = entry_key (sid_current_entry);

	if (types_contains_names (&sid_saved_type)) {
	    E_basic_param_has_names (key, &sid_saved_type);
	}
	if (types_contains_names (&sid_current_type)) {
	    E_basic_result_has_names (key, &sid_current_type);
	}
	if (types_contains_references (&sid_current_type)) {
	    E_basic_result_has_refs (key, &sid_current_type);
	}
	if (!types_equal_zero_tuple (&sid_saved_type)) {
	    E_basic_param_mismatch (key, &sid_saved_type);
	}
	types_assign (basic_result (sid_current.basic), &sid_current_type);
    } else {
	types_destroy (&sid_current_type);
    }
    types_destroy (&sid_saved_type);
@};

<x-terminals> = @{
    unsigned max_terminal = grammar_max_terminal (sid_current_grammar);

    bitvec_set_size (max_terminal);
    sid_finished_terminals = TRUE;
@};

// Tuple manipulation actions:

<save-tuple> = @{
    types_assign (&sid_saved_type, &sid_current_type);
    sid_saved_pred_id = sid_current_pred_id;
@};

<null-type> = @{
    types_init (&sid_saved_type);
    types_init (&sid_current_type);
    sid_saved_pred_id   = NULL;
    sid_current_pred_id = NULL;
@};

<init-tuple> = @{
    types_init (&sid_current_type);
    sid_current_pred_id = NULL;
@};

<tuple-name>: (name, type) -> () = @{
    if (!types_add_typed_name (&sid_current_type, sid_current_table, &@=name,
			       @&type, FALSE)) {
	E_unknown_type (@&type);
    }
    nstring_destroy (&@=type);
@};

<tuple-ref-name>: (name, type) -> () = @{
    if (!types_add_typed_name (&sid_current_type, sid_current_table, &@=name,
			       @&type, TRUE)) {
	E_unknown_type (@&type);
    }
    nstring_destroy (&@=type);
@};

<tuple-type>: (type) -> () = @{
    if (!types_add_type (&sid_current_type, sid_current_table, @&type,
			 FALSE)) {
	E_unknown_type (@&type);
    }
    nstring_destroy (&@=type);
@};

<tuple-ref-type>: (type) -> () = @{
    if (!types_add_type (&sid_current_type, sid_current_table, @&type, TRUE)) {
	E_unknown_type (@&type);
    }
    nstring_destroy (&@=type);
@};

<add-name>: (name) -> () = @{
    NStringT scope;
    EntryP   non_local_entry = scope_stack_get_non_local (&sid_scope_stack,
							  sid_current_table,
							  @&name, &scope);
    EntryP   name_entry      = table_get_entry (sid_current_table, @&name);

    if (name_entry) {
	if ((sid_current_entry) && (sid_current_alt)) {
	    if ((!types_contains (alt_names (sid_current_alt), name_entry)) &&
		(!types_contains (rule_param (sid_current.rule),
				  name_entry))) {
		name_entry = NULL;
	    }
	} else {
	    name_entry = NULL;
	}
    }
    if (name_entry) {
	types_add_name_and_type (&sid_current_type, name_entry, NULL,
				 FALSE);
	if (non_local_entry) {
	    nstring_destroy (&scope);
	}
	nstring_destroy (&@=name);
    } else if (non_local_entry) {
	types_add_name_and_type (&sid_current_type, non_local_entry,
				 NULL, FALSE);
	if (nstring_length (&scope) > nstring_length (&sid_maximum_scope)) {
	    nstring_destroy (&sid_maximum_scope);
	    nstring_assign (&sid_maximum_scope, &scope);
	} else {
	    nstring_destroy (&scope);
	}
	nstring_destroy (&@=name);
    } else {
	types_add_name (&sid_current_type, sid_current_table, &@=name, FALSE);
    }
@};

<add-ref-name>: (name) -> () = @{
    NStringT scope;
    EntryP   non_local_entry = scope_stack_get_non_local (&sid_scope_stack,
							  sid_current_table,
							  @&name, &scope);
    EntryP   name_entry      = table_get_entry (sid_current_table, @&name);

    if (name_entry) {
	if ((sid_current_entry) && (sid_current_alt)) {
	    if ((!types_contains (alt_names (sid_current_alt), name_entry)) &&
		(!types_contains (rule_param (sid_current.rule),
				  name_entry))) {
		name_entry = NULL;
	    }
	} else {
	    name_entry = NULL;
	}
    }
    if (name_entry) {
	types_add_name_and_type (&sid_current_type, name_entry, NULL,
				 TRUE);
	if (non_local_entry) {
	    nstring_destroy (&scope);
	}
	nstring_destroy (&@=name);
    } else if (non_local_entry) {
	types_add_name_and_type (&sid_current_type, non_local_entry,
				 NULL, TRUE);
	if (nstring_length (&scope) > nstring_length (&sid_maximum_scope)) {
	    nstring_destroy (&sid_maximum_scope);
	    nstring_assign (&sid_maximum_scope, &scope);
	} else {
	    nstring_destroy (&scope);
	}
	nstring_destroy (&@=name);
    } else {
	types_add_name (&sid_current_type, sid_current_table, &@=name, TRUE);
    }
@};

<add-var>: (name) -> () = @{
    NStringT scope;
    EntryP   non_local_entry = scope_stack_get_non_local (&sid_scope_stack,
							  sid_current_table,
							  @&name, &scope);
    EntryP   name_entry      = table_get_entry (sid_current_table, @&name);

    if (name_entry) {
	if ((sid_current_entry) && (sid_current_alt)) {
	    if ((!types_contains (alt_names (sid_current_alt), name_entry)) &&
		(!types_contains (rule_param (sid_current.rule),
				  name_entry))) {
		name_entry = NULL;
	    }
	} else {
	    name_entry = NULL;
	}
    }
    if (name_entry) {
	types_add_name_and_type_var (&sid_current_type, name_entry,
				     NULL);
	if (non_local_entry) {
	    nstring_destroy (&scope);
	}
	nstring_destroy (&@=name);
    } else if (non_local_entry) {
	types_add_name_and_type_var (&sid_current_type, non_local_entry,
				     NULL);
	if (nstring_length (&scope) > nstring_length (&sid_maximum_scope)) {
	    nstring_destroy (&sid_maximum_scope);
	    nstring_assign (&sid_maximum_scope, &scope);
	} else {
	    nstring_destroy (&scope);
	}
	nstring_destroy (&@=name);
    } else {
	E_undefined_assignment (@&name);
	types_add_name (&sid_current_type, sid_current_table, &@=name, FALSE);
    }
@};

<add-pred> = @{
    if (sid_current_pred_id) {
	E_multi_predicate_return ();
    } else if (sid_unique_pred_id == NULL) {
	sid_unique_pred_id = grammar_get_predicate_id (sid_current_grammar);
    }
    sid_current_pred_id = sid_unique_pred_id;
    types_add_name_entry (&sid_current_type, sid_current_pred_id);
@};

<add-void> = @{
    EntryP entry = table_add_generated_name (sid_current_table);

    types_add_name_entry (&sid_current_type, entry);
@};

// Productions section actions:

<use-global> = @{
    sid_current_scope = &sid_global_scope;
@};

<use-local> = @{
    sid_current_scope = &sid_scope_stack;
@};

<action>: (string) -> () = @{
    sid_current_entry = scope_stack_add_action (sid_current_scope,
						sid_current_table, &@=string,
						sid_enclosing_rule,
						&sid_redefining_entry);
    if (sid_current_entry) {
	sid_current.action = entry_get_action (sid_current_entry);
    } else {
	E_duplicate_action (@&string);
	nstring_destroy (&@=string);
    }
@};

<x-action> = @{
    if (sid_current_entry) {
	KeyP       key     = entry_key (sid_current_entry);
	TypeTupleP param   = action_param (sid_current.action);
	TypeTupleP result  = action_result (sid_current.action);
	BoolT      errored = FALSE;

	if (types_contains_names (&sid_saved_type)) {
	    E_action_param_has_names (key, &sid_saved_type);
	    errored = TRUE;
	}
	if (sid_redefining_entry) {
	    if (!types_equal (param, &sid_saved_type)) {
		E_action_param_mismatch (key, param, &sid_saved_type);
		errored = TRUE;
	    }
	}
	if (types_contains_names (&sid_current_type)) {
	    E_action_result_has_names (key, &sid_current_type);
	    errored = TRUE;
	}
	if (types_contains_references (&sid_current_type)) {
	    E_action_result_has_refs (key, &sid_current_type);
	    errored = TRUE;
	}
	if (sid_redefining_entry) {
	    if (!types_equal (result, &sid_current_type)) {
		E_action_result_mismatch (key, result, &sid_current_type);
		errored = TRUE;
	    }
	}
	if (errored || sid_redefining_entry) {
	    types_destroy (&sid_saved_type);
	    types_destroy (&sid_current_type);
	} else {
	    types_assign (param, &sid_saved_type);
	    types_assign (result, &sid_current_type);
	}
    } else {
	types_destroy (&sid_saved_type);
	types_destroy (&sid_current_type);
    }
@};

<non-local>: (id, type_id) -> () = @{
    sid_non_local = NULL;
    if ((sid_enclosing_rule == NULL) ||
	(sid_current_scope == &sid_global_scope)) {
	E_global_scope_non_local (@&id);
	nstring_destroy (&@=id);
    } else {
	EntryP type = table_get_type (sid_current_table, @&type_id);

	if (type == NULL) {
	    E_unknown_type (@&type_id);
	    nstring_destroy (&@=id);
	} else {
	    EntryP name = scope_stack_add_non_local (sid_current_scope,
						     sid_current_table,
						     &@=id, type,
						     sid_enclosing_rule);

	    if (name) {
		NonLocalListP non_locals = rule_non_locals (sid_enclosing_rule);
		sid_non_local = non_local_list_add (non_locals, name, type);
	    } else {
		E_duplicate_non_local (@&id);
		nstring_destroy (&@=id);
	    }
	}
    }
    nstring_destroy (&@=type_id);
@};

<non-local-init>: (action_id) -> () = @{
    EntryP entry = scope_stack_get_action (&sid_scope_stack, sid_current_table,
					   @&action_id);

    if (entry == NULL) {
	E_unknown_action (@&action_id);
    } else if (sid_non_local) {
	EntryP     type   = non_local_entry_get_type (sid_non_local);
	KeyP       name   = entry_key (non_local_entry_get_name (sid_non_local));
	ActionP    action = entry_get_action (entry);
	TypeTupleP param  = action_param (action);
	TypeTupleP result = action_result (action);
	TypeTupleT tuple;
	TypeTupleT ref_tuple;

	types_init (&tuple);
	types_init (&ref_tuple);
	types_add_type_entry (&tuple, type, FALSE);
	types_add_type_entry (&ref_tuple, type, TRUE);
	if ((!types_equal (param, &tuple)) &&
	    (!types_equal (param, &ref_tuple)) &&
	    (!types_equal_zero_tuple (param))) {
	    E_initialiser_param_mismatch (name, &tuple, &ref_tuple, param);
	}
	if (!types_equal (result, &tuple)) {
	    E_initialiser_result_mismatch (name, &tuple, result);
	}
	types_destroy (&ref_tuple);
	types_destroy (&tuple);
	non_local_entry_set_initialiser (sid_non_local, entry);
    }
    nstring_destroy (&@=action_id);
@};

<rule>: (string) -> () = @{
    sid_current_entry = scope_stack_add_rule (sid_current_scope,
					      sid_current_table, &@=string,
					      sid_enclosing_rule,
					      &sid_redefining_entry);
    if (sid_current_entry) {
	sid_current.rule = entry_get_rule (sid_current_entry);
    } else {
	E_duplicate_rule (@&string);
	nstring_destroy (&@=string);
    }
@};

<x-rule> = @{
    if (sid_current_entry) {
	KeyP       key     = entry_key (sid_current_entry);
	TypeTupleP param   = rule_param (sid_current.rule);
	TypeTupleP result  = rule_result (sid_current.rule);
	BoolT      errored = FALSE;

	if (types_contains_names (&sid_saved_type)) {
	    E_rule_param_has_names (key, &sid_saved_type);
	    errored = TRUE;
	}
	if (sid_redefining_entry) {
	    if (!types_equal (param, &sid_saved_type)) {
		E_rule_param_mismatch (key, param, &sid_saved_type);
		errored = TRUE;
	    }
	}
	if (types_contains_names (&sid_current_type)) {
	    E_rule_result_has_names (key, &sid_current_type);
	    errored = TRUE;
	}
	if (types_contains_references (&sid_current_type)) {
	    E_rule_result_has_refs (key, &sid_current_type);
	    errored = TRUE;
	}
	if (sid_redefining_entry) {
	    if (!types_equal (result, &sid_current_type)) {
		E_rule_result_mismatch (key, result, &sid_current_type);
		errored = TRUE;
	    }
	}
	if (errored || sid_redefining_entry) {
	    types_destroy (&sid_saved_type);
	    types_destroy (&sid_current_type);
	} else {
	    types_assign (param, &sid_saved_type);
	    types_assign (result, &sid_current_type);
	}
    } else {
	types_destroy (&sid_saved_type);
	types_destroy (&sid_current_type);
    }
@};

<prod> = @{
    if (sid_current_entry) {
	KeyP key = entry_key (sid_current_entry);

	if (rule_is_defined (sid_current.rule)) {
	    E_rule_already_defined (key);
	    sid_current_entry = NULL;
	    types_destroy (&sid_saved_type);
	    types_destroy (&sid_current_type);
	} else {
	    TypeTupleP param   = rule_param (sid_current.rule);
	    TypeTupleP result  = rule_result (sid_current.rule);
	    BoolT      errored = FALSE;

	    rule_defined (sid_current.rule);
	    if (!types_disjoint_names (&sid_saved_type)) {
		E_rule_param_clash (key, &sid_saved_type);
		errored = TRUE;
	    }
	    if (types_check_shadowing (&sid_saved_type, &sid_scope_stack,
				       sid_current.rule)) {
		errored = TRUE;
	    }
	    if (sid_redefining_entry) {
		if (!types_fillin_names (param, &sid_saved_type)) {
		    E_rule_param_mismatch (key, param, &sid_saved_type);
		    errored = TRUE;
		}
		types_destroy (&sid_saved_type);
	    } else {
		types_assign (param, &sid_saved_type);
	    }
	    if (!types_disjoint_names (&sid_current_type)) {
		E_rule_result_clash (key, &sid_current_type);
		errored = TRUE;
	    }
	    if (types_check_shadowing (&sid_current_type, &sid_scope_stack,
				       sid_current.rule)) {
		errored = TRUE;
	    }
	    if (types_contains_references (&sid_current_type)) {
		E_rule_result_has_refs (key, &sid_current_type);
		errored = TRUE;
	    }
	    if (sid_redefining_entry) {
		if (!types_fillin_names (result, &sid_current_type)) {
		    E_rule_result_mismatch (key, result, &sid_current_type);
		    errored = TRUE;
		}
		types_destroy (&sid_current_type);
	    } else {
		types_assign (result, &sid_current_type);
	    }
	    if (errored) {
		sid_current_entry = NULL;
	    } else {
		if (types_intersect (param, result)) {
		    E_rule_formal_clash (key, param, result);
		    sid_current_entry = NULL;
		}
	    }
	}
    } else {
	types_destroy (&sid_saved_type);
	types_destroy (&sid_current_type);
    }
    sid_alternative   = 0;
    sid_internal_rule = FALSE;
    sid_external_rule = sid_current_entry;
    nstring_init (&sid_maximum_scope);
@};

<x-prod> = @{
    if (sid_current_entry) {
	nstring_assign (rule_maximum_scope (sid_current.rule),
			&sid_maximum_scope);
    } else {
	nstring_destroy (&sid_maximum_scope);
    }
@};

<push-scope> = @{
    if (sid_current_entry) {
	KeyP     key   = entry_key (sid_current_entry);
	NStringP scope = key_get_string (key);

	scope_stack_push (&sid_scope_stack, scope);
    }
@};

<pop-scope> = @{
    if (sid_current_entry) {
	scope_stack_pop (&sid_scope_stack);
    }
@};

<save-scope>: () -> (saved_entry, saved_rule) = @{
    @saved_entry       = sid_current_entry;
    @saved_rule        = sid_enclosing_rule;

    sid_enclosing_rule = sid_current.rule;
@};

<restore-scope>: (saved_entry, saved_rule) -> () = @{
    sid_current_entry  = @saved_entry;
    sid_current.rule   = sid_enclosing_rule;
    sid_enclosing_rule = @saved_rule;
    sid_alternative    = 0;
    sid_internal_rule  = FALSE;
    sid_external_rule  = sid_current_entry;
    nstring_init (&sid_maximum_scope);
@};

<empty-alt> = @{
    if ((++ sid_num_alternatives) == ALT_LIMIT) {
	E_too_many_alternatives ();
	UNREACHED;
    }
    if (!sid_internal_rule) {
	sid_alternative ++;
    }
    if (sid_current_entry) {
	if (rule_has_empty_alt (sid_current.rule)) {
	    E_multiple_empty_alts (entry_key (sid_external_rule));
	} else if (!types_equal_zero_tuple (rule_result (sid_current.rule))) {
	    E_alt_result_mismatch (entry_key (sid_external_rule),
				   sid_alternative);
	} else {
	    rule_add_empty_alt (sid_current.rule);
	}
    }
@};

<non-empty-alt> = @{
    if ((++ sid_num_alternatives) == ALT_LIMIT) {
	E_too_many_alternatives ();
	UNREACHED;
    }
    if (!sid_internal_rule) {
	sid_alternative ++;
    }
    if (sid_current_entry) {
	sid_current_alt = alt_create ();
    }
@};

<x-non-empty-alt> = @{
    if ((sid_current_entry) && (sid_current_alt)) {
	if (types_check_names (rule_result (sid_current.rule),
			       alt_names (sid_current_alt))) {
	    TypeTupleT used;

	    types_copy (&used, rule_result (sid_current.rule));
	    item_compute_minimal_dataflow (alt_item_head (sid_current_alt),
					   &used);
	    types_destroy (&used);
	    rule_add_alt (sid_current.rule, sid_current_alt);
	} else {
	    (void) alt_deallocate (sid_current_alt);
	    E_alt_result_mismatch (entry_key (sid_external_rule),
				   sid_alternative);
	}
    }
@};

<handler> = @{
    if (sid_current_entry) {
	sid_current_alt = alt_create ();
    }
@};

<x-handler> = @{
    if ((sid_current_entry) && (sid_current_alt)) {
	if (types_check_names (rule_result (sid_current.rule),
			       alt_names (sid_current_alt))) {
	    TypeTupleT used;

	    types_copy (&used, rule_result (sid_current.rule));
	    item_compute_minimal_dataflow (alt_item_head (sid_current_alt),
					   &used);
	    types_destroy (&used);
	    rule_set_handler (sid_current.rule, sid_current_alt);
	} else {
	    (void) alt_deallocate (sid_current_alt);
	    E_handler_result_mismatch (entry_key (sid_external_rule));
	}
    }
@};

<save>: () -> (saved_entry, saved_rule, saved_alt, saved_internal, item) = @{
    @saved_entry      = sid_current_entry;
    @saved_rule       = sid_current.rule;
    @saved_alt        = sid_current_alt;
    @saved_internal   = sid_internal_rule;
    @item             = NULL;
    sid_internal_rule = TRUE;
    if ((sid_current_entry) && (sid_current_alt)) {
	sid_current_entry = table_add_generated_rule (sid_current_table,
						      FALSE);
	sid_current.rule  = entry_get_rule (sid_current_entry);
	@item             = item_create (sid_current_entry);
	rule_defined (sid_current.rule);
	item_inlinable (@item);
	types_copy (item_param (@item), rule_param (@saved_rule));
	types_append_copy (item_param (@item), alt_names (@saved_alt));
	types_copy (rule_param (sid_current.rule), item_param (@item));
	types_make_references (rule_param (sid_current.rule),
			       item_param (@item));
	alt_add_item (@saved_alt, @item);
    } else {
	sid_current_entry = NULL;
    }
@};

<restore>:
    (saved_entry, saved_rule, saved_alt, saved_internal, item) -> () = @{
    if ((@saved_entry) && (@saved_alt)) {
	rule_compute_result_intersect (sid_current.rule);
	types_copy (item_result (@item), rule_result (sid_current.rule));
	types_add_new_names (alt_names (@saved_alt), item_result (@item),
			     sid_unique_pred_id);
    }
    sid_internal_rule = @saved_internal;
    sid_current_alt   = @saved_alt;
    sid_current.rule  = @saved_rule;
    sid_current_entry = @saved_entry;
@};

<prod-action>: (string) -> () = @{
    if ((sid_current_entry) && (sid_current_alt)) {
	EntryP entry = scope_stack_get_action (&sid_scope_stack,
					       sid_current_table, @&string);

	if (entry) {
	    sid_current_item = item_create (entry);
	} else {
	    E_unknown_action (@&string);
	    sid_current_item = NULL;
	    (void) alt_deallocate (sid_current_alt);
	    sid_current_alt  = NULL;
	}
    } else {
	sid_current_item = NULL;
    }
    nstring_destroy (&@=string);
@};

<x-prod-action> = @{
    if (sid_current_item) {
	BoolT   errored = FALSE;
	EntryP  entry   = item_entry (sid_current_item);
	ActionP action  = entry_get_action (entry);

	if (types_resolve (&sid_current_type, rule_param (sid_current.rule),
			   alt_names (sid_current_alt), E_undefined_name,
			   entry_key (sid_external_rule), sid_alternative)) {
	    if (types_equal (&sid_current_type, action_param (action))) {
		item_add_param (sid_current_item, &sid_current_type);
	    } else {
		E_action_param_call_mismatch (entry_key (entry),
					      action_param (action),
					      &sid_current_type);
		types_destroy (&sid_current_type);
		errored = TRUE;
	    }
	} else {
	    types_destroy (&sid_current_type);
	    errored = TRUE;
	}
	if (types_disjoint_names (&sid_saved_type)) {
	    if (types_check_undefined (&sid_saved_type,
				       rule_param (sid_current.rule),
				       alt_names (sid_current_alt),
				       E_redefined_name,
				       entry_key (sid_external_rule),
				       sid_alternative)) {
		if (types_fillin_types (&sid_saved_type,
					action_result (action))) {
		    types_add_new_names (alt_names (sid_current_alt),
					 &sid_saved_type, sid_unique_pred_id);
		    if (sid_saved_pred_id) {
			BoolT  reference;
			EntryP type = types_find_name_type (&sid_saved_type,
							    sid_saved_pred_id,
							    &reference);

			assert((type != NULL) && (!reference));
			if (sid_predicate_type) {
			    if (type != sid_predicate_type) {
				E_predicate_type (sid_predicate_type, type);
			    }
			} else {
			    grammar_set_predicate_type (sid_current_grammar,
							type);
			    sid_predicate_type = type;
			}
			item_to_predicate (sid_current_item);
		    }
		    item_add_result (sid_current_item, &sid_saved_type);
		} else {
		    E_action_result_call_mismatch (entry_key (entry),
						   action_result (action),
						   &sid_saved_type);
		    types_destroy (&sid_saved_type);
		    errored = TRUE;
		}
	    } else {
		types_destroy (&sid_saved_type);
		errored = TRUE;
	    }
	} else {
	    E_action_result_call_clash (entry_key (entry), &sid_saved_type);
	    types_destroy (&sid_saved_type);
	    errored = TRUE;
	}
	if (errored) {
	    (void) item_deallocate (sid_current_item);
	    sid_current_item = NULL;
	    (void) alt_deallocate (sid_current_alt);
	    sid_current_alt  = NULL;
	} else {
	    alt_add_item (sid_current_alt, sid_current_item);
	}
    } else {
	types_destroy (&sid_saved_type);
	types_destroy (&sid_current_type);
    }
@};

<x-identity> = @{
    if ((sid_current_entry) && (sid_current_alt)) {
	EntryP entry = table_add_rename (sid_current_table);

	if (types_resolve (&sid_current_type, rule_param (sid_current.rule),
			   alt_names (sid_current_alt), E_undefined_name,
			   entry_key (sid_external_rule), sid_alternative)) {
	    if (types_contains_references (&sid_current_type)) {
		E_identity_param_has_refs (&sid_current_type,
					   entry_key (sid_external_rule),
					   sid_alternative);
		types_destroy (&sid_current_type);
		sid_current_item = NULL;
	    } else {
		sid_current_item = item_create (entry);
		item_add_param (sid_current_item, &sid_current_type);
	    }
	} else {
	    types_destroy (&sid_current_type);
	    sid_current_item = NULL;
	}
	if (types_disjoint_names (&sid_saved_type)) {
	    if (types_check_undefined (&sid_saved_type,
				       rule_param (sid_current.rule),
				       alt_names (sid_current_alt),
				       E_redefined_name,
				       entry_key (sid_external_rule),
				       sid_alternative)) {
		if (sid_current_item) {
		    if (types_fillin_types (&sid_saved_type,
					    item_param (sid_current_item))) {
			types_add_new_names (alt_names (sid_current_alt),
					     &sid_saved_type,
					     sid_unique_pred_id);
			if (sid_saved_pred_id) {
			    E_predicate ();
			}
			item_add_result (sid_current_item, &sid_saved_type);
			alt_add_item (sid_current_alt, sid_current_item);
		    } else {
			E_identity_mismatch (item_param (sid_current_item),
					     &sid_saved_type);
			types_destroy (&sid_saved_type);
			(void) item_deallocate (sid_current_item);
			sid_current_item = NULL;
		    }
		}
	    } else {
		types_destroy (&sid_saved_type);
		if (sid_current_item) {
		    (void) item_deallocate (sid_current_item);
		    sid_current_item = NULL;
		}
	    }
	} else {
	    E_identity_result_clash (&sid_saved_type);
	    types_destroy (&sid_saved_type);
	    if (sid_current_item) {
		(void) item_deallocate (sid_current_item);
		sid_current_item = NULL;
	    }
	}
	if (sid_current_item == NULL) {
	    (void) alt_deallocate (sid_current_alt);
	    sid_current_alt = NULL;
	}
    } else {
	types_destroy (&sid_saved_type);
	types_destroy (&sid_current_type);
    }
@};

<x-prod-rule>: (string) -> () = @{
    TypeTupleP param  = NULL;
    TypeTupleP result = NULL;
    EntryP     entry  = NULL;
    RuleP      rule;
    BasicP     basic;

    if ((sid_current_entry) && (sid_current_alt)) {
	entry = scope_stack_get_rule (&sid_scope_stack, sid_current_table,
				      @&string);
	if (entry) {
	    sid_current_item = item_create (entry);
	    rule             = entry_get_rule (entry);
	    param            = rule_param (rule);
	    result           = rule_result (rule);
	} else {
	    entry = table_get_basic (sid_current_table, @&string);
	    if (entry) {
		sid_current_item = item_create (entry);
		basic            = entry_get_basic (entry);
		param            = NULL;
		result           = basic_result (basic);
		if (basic_get_ignored (basic)) {
		    E_ignored_basic_call (@&string);
		}
	    } else {
		E_unknown_rule_or_basic (@&string);
		sid_current_item = NULL;
	    }
	}
    } else {
	sid_current_item = NULL;
    }
    nstring_destroy (&@=string);
    if (sid_current_item) {
	BoolT errored = FALSE;
	KeyP  key     = entry_key (entry);

	if (types_resolve (&sid_current_type, rule_param (sid_current.rule),
			   alt_names (sid_current_alt), E_undefined_name,
			   entry_key (sid_external_rule), sid_alternative)) {
	    if (param) {
		if (types_equal (&sid_current_type, param)) {
		    item_add_param (sid_current_item, &sid_current_type);
		} else {
		    E_rule_param_call_mismatch (key, param, &sid_current_type);
		    types_destroy (&sid_current_type);
		    errored = TRUE;
		}
	    } else {
		if (!types_equal_zero_tuple (&sid_current_type)) {
		    E_basic_param_call_mismatch (key, &sid_current_type);
		    types_destroy (&sid_current_type);
		    errored = TRUE;
		}
	    }
	} else {
	    types_destroy (&sid_current_type);
	    errored = TRUE;
	}
	if (types_disjoint_names (&sid_saved_type)) {
	    if (types_check_undefined (&sid_saved_type,
				       rule_param (sid_current.rule),
				       alt_names (sid_current_alt),
				       E_redefined_name,
				       entry_key (sid_external_rule),
				       sid_alternative)) {
		if (types_fillin_types (&sid_saved_type, result)) {
		    types_add_new_names (alt_names (sid_current_alt),
					 &sid_saved_type, sid_unique_pred_id);
		    if (sid_saved_pred_id) {
			E_predicate ();
		    }
		    item_add_result (sid_current_item, &sid_saved_type);
		} else {
		    if (param) {
			E_rule_result_call_mismatch (key, result,
						     &sid_saved_type);
		    } else {
			E_basic_result_call_mismatch (key, result,
						      &sid_saved_type);
		    }
		    types_destroy (&sid_saved_type);
		    errored = TRUE;
		}
	    } else {
		types_destroy (&sid_saved_type);
		errored = TRUE;
	    }
	} else {
	    if (param) {
		E_rule_result_call_clash (key, &sid_saved_type);
	    } else {
		E_basic_result_call_clash (key, &sid_saved_type);
	    }
	    types_destroy (&sid_saved_type);
	    errored = TRUE;
	}
	if (errored) {
	    (void) item_deallocate (sid_current_item);
	    sid_current_item = NULL;
	    (void) alt_deallocate (sid_current_alt);
	    sid_current_alt  = NULL;
	} else {
	    alt_add_item (sid_current_alt, sid_current_item);
	}
    } else {
	if (sid_current_alt) {
	    (void) alt_deallocate (sid_current_alt);
	    sid_current_alt = NULL;
	}
	types_destroy (&sid_saved_type);
	types_destroy (&sid_current_type);
    }
@};

<x-prod-rule-or-identity>: (string) -> () = @{
    EntryP     name_entry = table_get_entry (sid_current_table, @&string);
    EntryP     entry      = NULL;
    TypeTupleP param      = NULL;
    TypeTupleP result     = NULL;
    RuleP      rule;
    BasicP     basic;

    if ((sid_current_entry) && (sid_current_alt)) {
	if ((name_entry != NULL) &&
	    (!types_contains (alt_names (sid_current_alt), name_entry)) &&
	    (!types_contains (rule_param (sid_current.rule), name_entry))) {
	    name_entry = NULL;
	}
	entry = scope_stack_get_rule (&sid_scope_stack, sid_current_table,
				      @&string);
	if (entry) {
	    sid_current_item = item_create (entry);
	    rule             = entry_get_rule (entry);
	    param            = rule_param (rule);
	    result           = rule_result (rule);
	} else {
	    entry = table_get_basic (sid_current_table, @&string);
	    if (entry) {
		sid_current_item = item_create (entry);
		basic            = entry_get_basic (entry);
		param            = NULL;
		result           = basic_result (basic);
		if ((name_entry == NULL) &&
		    basic_get_ignored (basic)) {
		    E_ignored_basic_call (@&string);
		}
	    }
	}
	if ((entry == NULL) && (name_entry == NULL)) {
	    NStringT scope;

	    name_entry = scope_stack_get_non_local (&sid_scope_stack,
						    sid_current_table,
						    @&string, &scope);
	    if (name_entry) {
		if (nstring_length (&scope) >
		    nstring_length (&sid_maximum_scope)) {
		    nstring_destroy (&sid_maximum_scope);
		    nstring_assign (&sid_maximum_scope, &scope);
		} else {
		    nstring_destroy (&scope);
		}
	    } else {
		E_unknown_rule_or_basic (@&string);
	    }
	} else if ((entry != NULL) && (name_entry != NULL)) {
	    E_ambiguous_call (@&string);
	    entry      = NULL;
	    name_entry = NULL;
	}
    } else {
	name_entry = NULL;
    }
    nstring_destroy (&@=string);
    if (entry) {
	BoolT errored = FALSE;
	KeyP  key     = entry_key (entry);

	if (types_resolve (&sid_current_type, rule_param (sid_current.rule),
			   alt_names (sid_current_alt), E_undefined_name,
			   entry_key (sid_external_rule), sid_alternative)) {
	    if (param) {
		if (types_equal (&sid_current_type, param)) {
		    item_add_param (sid_current_item, &sid_current_type);
		} else {
		    E_rule_param_call_mismatch (key, param, &sid_current_type);
		    types_destroy (&sid_current_type);
		    errored = TRUE;
		}
	    } else {
		if (!types_equal_zero_tuple (&sid_current_type)) {
		    E_basic_param_call_mismatch (key, &sid_current_type);
		    types_destroy (&sid_current_type);
		    errored = TRUE;
		}
	    }
	} else {
	    types_destroy (&sid_current_type);
	    errored = TRUE;
	}
	if (types_disjoint_names (&sid_saved_type)) {
	    if (types_check_undefined (&sid_saved_type,
				       rule_param (sid_current.rule),
				       alt_names (sid_current_alt),
				       E_redefined_name,
				       entry_key (sid_external_rule),
				       sid_alternative)) {
		if (types_fillin_types (&sid_saved_type, result)) {
		    types_add_new_names (alt_names (sid_current_alt),
					 &sid_saved_type, sid_unique_pred_id);
		    if (sid_saved_pred_id) {
			E_predicate ();
		    }
		    item_add_result (sid_current_item, &sid_saved_type);
		} else {
		    if (param) {
			E_rule_result_call_mismatch (key, result,
						     &sid_saved_type);
		    } else {
			E_basic_result_call_mismatch (key, result,
						      &sid_saved_type);
		    }
		    types_destroy (&sid_saved_type);
		    errored = TRUE;
		}
	    } else {
		types_destroy (&sid_saved_type);
		errored = TRUE;
	    }
	} else {
	    if (param) {
		E_rule_result_call_clash (key, &sid_saved_type);
	    } else {
		E_basic_result_call_clash (key, &sid_saved_type);
	    }
	    types_destroy (&sid_saved_type);
	    errored = TRUE;
	}
	if (errored) {
	    (void) item_deallocate (sid_current_item);
	    sid_current_item = NULL;
	    (void) alt_deallocate (sid_current_alt);
	    sid_current_alt  = NULL;
	} else {
	    alt_add_item (sid_current_alt, sid_current_item);
	}
    } else if (name_entry) {
	types_add_name_entry (&sid_current_type, name_entry);
	entry = table_add_rename (sid_current_table);
	if (types_resolve (&sid_current_type, rule_param (sid_current.rule),
			   alt_names (sid_current_alt), E_undefined_name,
			   entry_key (sid_external_rule), sid_alternative)) {
	    if (types_contains_references (&sid_current_type)) {
		E_identity_param_has_refs (&sid_current_type,
					   entry_key (sid_external_rule),
					   sid_alternative);
		types_destroy (&sid_current_type);
		sid_current_item = NULL;
	    } else {
		sid_current_item = item_create (entry);
		item_add_param (sid_current_item, &sid_current_type);
	    }
	} else {
	    types_destroy (&sid_current_type);
	    sid_current_item = NULL;
	}
	if (types_disjoint_names (&sid_saved_type)) {
	    if (types_check_undefined (&sid_saved_type,
				       rule_param (sid_current.rule),
				       alt_names (sid_current_alt),
				       E_redefined_name,
				       entry_key (sid_external_rule),
				       sid_alternative)) {
		if (sid_current_item) {
		    if (types_fillin_types (&sid_saved_type,
					    item_param (sid_current_item))) {
			types_add_new_names (alt_names (sid_current_alt),
					     &sid_saved_type,
					     sid_unique_pred_id);
			if (sid_saved_pred_id) {
			    E_predicate ();
			}
			item_add_result (sid_current_item, &sid_saved_type);
			alt_add_item (sid_current_alt, sid_current_item);
		    } else {
			E_identity_mismatch (item_param (sid_current_item),
					     &sid_saved_type);
			types_destroy (&sid_saved_type);
			(void) item_deallocate (sid_current_item);
			sid_current_item = NULL;
		    }
		}
	    } else {
		types_destroy (&sid_saved_type);
		if (sid_current_item) {
		    (void) item_deallocate (sid_current_item);
		    sid_current_item = NULL;
		}
	    }
	} else {
	    E_identity_result_clash (&sid_saved_type);
	    types_destroy (&sid_saved_type);
	    if (sid_current_item) {
		(void) item_deallocate (sid_current_item);
		sid_current_item = NULL;
	    }
	}
	if (sid_current_item == NULL) {
	    (void) alt_deallocate (sid_current_alt);
	    sid_current_alt = NULL;
	}
    } else {
	if (sid_current_alt) {
	    (void) alt_deallocate (sid_current_alt);
	    sid_current_alt = NULL;
	}
	types_destroy (&sid_saved_type);
	types_destroy (&sid_current_type);
    }
@};

<add-entry>: (string) -> () = @{
    EntryP entry = table_get_rule (sid_current_table, @&string);

    if (entry) {
	if (entry_list_contains (sid_current_entry_list, entry)) {
	    E_mult_entry (entry_key (entry));
	} else {
	    entry_list_add (sid_current_entry_list, entry);
	    rule_required (entry_get_rule (entry));
	}
    } else {
	E_unknown_rule (@&string);
    }
    nstring_destroy (&@=string);
@};

// Error recovery stuff:

<unhandled-syntax-error> = @{
    UNREACHED;
@};

<expected-typemark> = @{
    if (!sid_propagating_error) {
	E_expected_typemark ();
    }
@};

<expected-identifier> = @{
    if (!sid_propagating_error) {
	E_expected_identifier ();
    }
@};

<expected-tuple-defn> = @{
    if (!sid_propagating_error) {
	E_expected_tuple_defn ();
    }
@};

<expected-terminal-decn> = @{
    if (!sid_propagating_error) {
	E_expected_terminal_decn ();
    }
@};

<expected-separator> = @{
    if (!sid_propagating_error) {
	E_expected_separator ();
    }
@};

<expected-open-tuple> = @{
    if (!sid_propagating_error) {
	E_expected_open_tuple ();
    }
@};

<expected-close-tuple> = @{
    if (!sid_propagating_error) {
	E_expected_close_tuple ();
    }
@};

<expected-arrow> = @{
    if (!sid_propagating_error) {
	E_expected_arrow ();
    }
@};

<expected-terminator> = @{
    if (!sid_propagating_error) {
	E_expected_terminator ();
    }
@};

<expected-lhs-name> = @{
    if (!sid_propagating_error) {
	E_expected_lhs_name ();
    }
@};

<expected-rhs-name> = @{
    if (!sid_propagating_error) {
	E_expected_rhs_name ();
    }
@};

<expected-begin-action> = @{
    if (!sid_propagating_error) {
	E_expected_begin_action ();
    }
@};

<expected-end-action> = @{
    if (!sid_propagating_error) {
	E_expected_end_action ();
    }
@};

<expected-end-scope> = @{
    if (!sid_propagating_error) {
	E_expected_end_scope ();
    }
@};

<expected-tuple-or-terminator> = @{
    if (!sid_propagating_error) {
	E_expected_tuple_or_term ();
    }
@};

<expected-item-rhs> = @{
    if (!sid_propagating_error) {
	E_expected_item_rhs ();
    }
@};

<expected-define> = @{
    if (!sid_propagating_error) {
	E_expected_define ();
    }
@};

<expected-tuple-or-define-or-terminator> = @{
    if (!sid_propagating_error) {
	E_expected_tuple_def_or_term ();
    }
@};

<expected-begin-rule> = @{
    if (!sid_propagating_error) {
	E_expected_begin_rule ();
    }
@};

<expected-end-rule> = @{
    if (!sid_propagating_error) {
	E_expected_end_rule ();
    }
@};

<expected-item> = @{
    if (!sid_propagating_error) {
	E_expected_item ();
    }
@};

<expected-alternative> = @{
    if (!sid_propagating_error) {
	E_expected_alternative ();
    }
@};

<expected-other-defn> = @{
    if (!sid_propagating_error) {
	E_expected_other_defn ();
    }
@};

<expected-production-defn> = @{
    if (!sid_propagating_error) {
	E_expected_production_defn ();
    }
@};

<expected-blt-types> = @{
    if (!sid_propagating_error) {
	E_expected_blt_types ();
    }
@};

<expected-blt-terminals> = @{
    if (!sid_propagating_error) {
	E_expected_blt_terminals ();
    }
@};

<expected-blt-productions> = @{
    if (!sid_propagating_error) {
	E_expected_blt_productions ();
    }
@};

<expected-blt-entry> = @{
    if (!sid_propagating_error) {
	E_expected_blt_entry ();
    }
@};

<expected-eof> = @{
    if (!sid_propagating_error) {
	E_expected_eof ();
    }
@};

<expected-terminator-or-define> = @{
    if (!sid_propagating_error) {
	E_expected_terminator_or_define ();
    }
@};

<destroy-string>: (string) -> () = @{
    nstring_destroy (&@=string);
@};

<skip-to-end-of-tuple-defn> = @{
    if (sid_finished_terminals) {
	while ((@. != LEXER_TOK_EOF) &&
	       (@. != LEXER_TOK_DEFINE) &&
	       (@. != LEXER_TOK_BEGIN_SCOPE) &&
	       (@. != LEXER_TOK_BEGIN_RULE) &&
	       (@. != LEXER_TOK_SEPARATOR) &&
	       (@. != LEXER_TOK_CLOSE_TUPLE) &&
	       (@. != LEXER_TOK_TERMINATOR) &&
	       (@. != LEXER_TOK_BLT_ENTRY)) {
	    if (@. == LEXER_TOK_IDENTIFIER) {
		nstring_destroy (lexer_string_value (sid_current_stream));
	    }
	    @>;
	}
	if (@. == LEXER_TOK_IDENTIFIER) {
	    nstring_destroy (lexer_string_value (sid_current_stream));
	}
	if (@. != LEXER_TOK_EOF) {
	    @>;
	}
    } else {
	while ((@. != LEXER_TOK_EOF) &&
	       (@. != LEXER_TOK_SEPARATOR) &&
	       (@. != LEXER_TOK_CLOSE_TUPLE) &&
	       (@. != LEXER_TOK_TERMINATOR) &&
	       (@. != LEXER_TOK_BLT_PRODUCTIONS) &&
	       (@. != LEXER_TOK_BLT_ENTRY)) {
	    if (@. == LEXER_TOK_IDENTIFIER) {
		nstring_destroy (lexer_string_value (sid_current_stream));
	    }
	    @>;
	}
	if (@. == LEXER_TOK_IDENTIFIER) {
	    nstring_destroy (lexer_string_value (sid_current_stream));
	}
	if (@. != LEXER_TOK_EOF) {
	    @>;
	}
    }
    sid_propagating_error = TRUE;
@};

<skip-to-end-of-terminal-decn> = @{
    while ((@. != LEXER_TOK_EOF) &&
	   (@. != LEXER_TOK_TERMINATOR) &&
	   (@. != LEXER_TOK_BLT_PRODUCTIONS) &&
	   (@. != LEXER_TOK_BLT_ENTRY)) {
	if (@. == LEXER_TOK_IDENTIFIER) {
	    nstring_destroy (lexer_string_value (sid_current_stream));
	}
	@>;
    }
    if (@. == LEXER_TOK_IDENTIFIER) {
	nstring_destroy (lexer_string_value (sid_current_stream));
    }
    if (@. != LEXER_TOK_EOF) {
	@>;
    }
    sid_propagating_error = TRUE;
@};

<skip-to-end-of-lhs-name> = @{
    while ((@. != LEXER_TOK_EOF) &&
	   (@. != LEXER_TOK_TERMINATOR) &&
	   (@. != LEXER_TOK_BLT_PRODUCTIONS) &&
	   (@. != LEXER_TOK_BLT_ENTRY)) {
	if (@. == LEXER_TOK_IDENTIFIER) {
	    nstring_destroy (lexer_string_value (sid_current_stream));
	}
	@>;
    }
    if (@. == LEXER_TOK_IDENTIFIER) {
	nstring_destroy (lexer_string_value (sid_current_stream));
    }
    if (@. != LEXER_TOK_EOF) {
	@>;
    }
    sid_propagating_error = TRUE;
@};

<skip-to-end-of-rhs-name> = @{
    while ((@. != LEXER_TOK_EOF) &&
	   (@. != LEXER_TOK_TERMINATOR) &&
	   (@. != LEXER_TOK_BLT_PRODUCTIONS) &&
	   (@. != LEXER_TOK_BLT_ENTRY)) {
	if (@. == LEXER_TOK_IDENTIFIER) {
	    nstring_destroy (lexer_string_value (sid_current_stream));
	}
	@>;
    }
    if (@. == LEXER_TOK_IDENTIFIER) {
	nstring_destroy (lexer_string_value (sid_current_stream));
    }
    if (@. != LEXER_TOK_EOF) {
	@>;
    }
    sid_propagating_error = TRUE;
@};

<skip-to-end-of-action-decn> = @{
    while ((@. != LEXER_TOK_EOF) &&
	   (@. != LEXER_TOK_TERMINATOR) &&
	   (@. != LEXER_TOK_END_SCOPE) &&
	   (@. != LEXER_TOK_BLT_PRODUCTIONS) &&
	   (@. != LEXER_TOK_BLT_ENTRY)) {
	if (@. == LEXER_TOK_IDENTIFIER) {
	    nstring_destroy (lexer_string_value (sid_current_stream));
	}
	@>;
    }
    if (@. == LEXER_TOK_IDENTIFIER) {
	nstring_destroy (lexer_string_value (sid_current_stream));
    }
    if (@. != LEXER_TOK_EOF) {
	@>;
    }
    sid_propagating_error = TRUE;
@};

<skip-to-end-of-item> = @{
    while ((@. != LEXER_TOK_EOF) &&
	   (@. != LEXER_TOK_TERMINATOR) &&
	   (@. != LEXER_TOK_ALT_SEP) &&
	   (@. != LEXER_TOK_HANDLER_SEP) &&
	   (@. != LEXER_TOK_BEGIN_RULE) &&
	   (@. != LEXER_TOK_END_RULE) &&
	   (@. != LEXER_TOK_END_SCOPE) &&
	   (@. != LEXER_TOK_BLT_PRODUCTIONS) &&
	   (@. != LEXER_TOK_BLT_ENTRY)) {
	if (@. == LEXER_TOK_IDENTIFIER) {
	    nstring_destroy (lexer_string_value (sid_current_stream));
	}
	@>;
    }
    if (@. == LEXER_TOK_IDENTIFIER) {
	nstring_destroy (lexer_string_value (sid_current_stream));
    }
    if (@. != LEXER_TOK_EOF) {
	@>;
    }
    sid_propagating_error = TRUE;
@};

<skip-to-end-of-alternative> = @{
    while ((@. != LEXER_TOK_EOF) &&
	   (@. != LEXER_TOK_ALT_SEP) &&
	   (@. != LEXER_TOK_HANDLER_SEP) &&
	   (@. != LEXER_TOK_END_RULE) &&
	   (@. != LEXER_TOK_END_SCOPE) &&
	   (@. != LEXER_TOK_BLT_PRODUCTIONS) &&
	   (@. != LEXER_TOK_BLT_ENTRY)) {
	if (@. == LEXER_TOK_IDENTIFIER) {
	    nstring_destroy (lexer_string_value (sid_current_stream));
	}
	@>;
    }
    if (@. == LEXER_TOK_IDENTIFIER) {
	nstring_destroy (lexer_string_value (sid_current_stream));
    }
    if (@. != LEXER_TOK_EOF) {
	@>;
    }
    sid_propagating_error = TRUE;
@};

<skip-to-end-of-other-defn> = @{
    while ((@. != LEXER_TOK_EOF) &&
	   (@. != LEXER_TOK_TERMINATOR) &&
	   (@. != LEXER_TOK_END_SCOPE) &&
	   (@. != LEXER_TOK_END_RULE) &&
	   (@. != LEXER_TOK_BLT_PRODUCTIONS) &&
	   (@. != LEXER_TOK_BLT_ENTRY)) {
	if (@. == LEXER_TOK_IDENTIFIER) {
	    nstring_destroy (lexer_string_value (sid_current_stream));
	}
	@>;
    }
    if (@. == LEXER_TOK_IDENTIFIER) {
	nstring_destroy (lexer_string_value (sid_current_stream));
    }
    if (@. != LEXER_TOK_EOF) {
	@>;
    }
    sid_propagating_error = TRUE;
@};

<skip-to-end-of-production-defn> = @{
    while ((@. != LEXER_TOK_EOF) &&
	   (@. != LEXER_TOK_TERMINATOR) &&
	   (@. != LEXER_TOK_END_SCOPE) &&
	   (@. != LEXER_TOK_END_RULE) &&
	   (@. != LEXER_TOK_BLT_PRODUCTIONS) &&
	   (@. != LEXER_TOK_BLT_ENTRY)) {
	if (@. == LEXER_TOK_IDENTIFIER) {
	    nstring_destroy (lexer_string_value (sid_current_stream));
	}
	@>;
    }
    if (@. == LEXER_TOK_IDENTIFIER) {
	nstring_destroy (lexer_string_value (sid_current_stream));
    }
    if (@. != LEXER_TOK_EOF) {
	@>;
    }
    sid_propagating_error = TRUE;
@};

<skip-to-end-of-entry-list> = @{
    while ((@. != LEXER_TOK_EOF) &&
	   (@. != LEXER_TOK_TERMINATOR) &&
	   (@. != LEXER_TOK_SEPARATOR)) {
	if (@. == LEXER_TOK_IDENTIFIER) {
	    nstring_destroy (lexer_string_value (sid_current_stream));
	}
	@>;
    }
    if (@. == LEXER_TOK_IDENTIFIER) {
	nstring_destroy (lexer_string_value (sid_current_stream));
    }
    if (@. != LEXER_TOK_EOF) {
	@>;
    }
    sid_propagating_error = TRUE;
@};

<skip-recover> = @{
    sid_propagating_error = FALSE;
@};

<is-blt-entry-or-end-scope-or-eof>: () -> (predicate) = @{
    @predicate = ((@. == LEXER_TOK_EOF) ||
		  (@. == LEXER_TOK_END_SCOPE) ||
		  (@. == LEXER_TOK_BLT_ENTRY));
@};

<is-close-tuple-or-skipped-or-eof>: () -> (predicate) = @{
    @predicate = ((@. == LEXER_TOK_CLOSE_TUPLE) ||
		  (@. == LEXER_TOK_EOF) ||
		  (sid_propagating_error));
@};

<is-terminator>: () -> (predicate) = @{
    @predicate = (@. == LEXER_TOK_TERMINATOR);
@};

<is-not-separator>: () -> (predicate) = @{
    @predicate = (@. != LEXER_TOK_SEPARATOR);
@};

%trailer% @{
@}, @{
@};
