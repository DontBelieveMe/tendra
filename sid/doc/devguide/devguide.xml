<?xml version="1.0" standalone="no"?>
<!DOCTYPE book SYSTEM "minidocbook.dtd">

<!-- $Id$ -->

<book>

  <bookinfo>
    <title>The SID Developers' Guide</title>

	<authorgroup>
	    <author>
			<firstname>Kevin</firstname>
			<!-- surname elided -->
			<affiliation><orgname>The TenDRA Project</orgname></affiliation>
	    </author>

		<editor>
			<firstname>Katherine</firstname>
			<surname>Flavel</surname>
			<affiliation><orgname>The TenDRA Project</orgname></affiliation>
		</editor>
	</authorgroup>

    <pubdate>2007</pubdate>

    <copyright>
		<year>2008</year>
		<year>2007</year>
		<holder>The TenDRA Project</holder>
    </copyright>

	<revhistory>
		<revision role="docs">
			<date>04-02-2008</date>
			<authorinitials>kate</authorinitials>
			<revdescription>
				<para>Moved out much of the datastructure
					comments to the code itself.</para>

				<para>This reverse engineering better serves its purpose kept
					with the code, so that it may evolve as the code changes.
					The developer guide (now slightly spartan) can grow anew
					giving structual and organisational information
					rather than a field-by-field analysis.</para>
			</revdescription>
		</revision>

		<revision role="docs">
			<date>09-07-2007</date>
			<authorinitials>kate</authorinitials>
			<revdescription>
				<para>Initial import (and conversion from LaTeX)
					of the SID Developer Guide,
					researched and written by Kevin.</para>
			</revdescription>
		</revision>
	</revhistory>
  </bookinfo>

  <preface id="introduction">
	<title>Introduction</title>

	<para>&sid; is an LL(1) parser. It reads a grammar specification
		(documented in the &sid;
		users' guide) then outputs a parser.</para>

		<para>In this documentation, we explain &sid;'s
			internal representation
			of grammars. It was reverse engineered from the code itself and 
			the accompanying comments. Most of the reverse engineering was done reading 
			&sid;'s own grammar file and most notably the actions in 
			the <filename>parser.act</filename> file. This document does not explain
			in detail how &sid;
			parses the <filename>.sid</filename>
			and the <filename>.act</filename> files.</para>

		<para>[TODO this guide has been gutted; what remains gives a skeletal outline which
			will serve as a tour of the use and contents of the internal structures,
			without concerning itself with the implementation minuate. (Comments by the
			structures and API routines serve more accurately there, and will not fall out
			of sync with the code so easily). Here we can state how they all fit together,
			and what one might do with the data. dumping implementation to graphviz
			would be great, too.]</para>

		<section>
			<title>Prerequisites</title>

			<para>Before reading this guide, you should have read the
			&sid; users' guide
				and be able to use &sid;
				to output a simple parser.</para>
		</section>

		<section>
			<title>Who Should Read This Document?</title>

			<para>Anyone interested in the post-processing steps
				&sid; does
				to a grammar after having parsed the <filename>.sid</filename>
				and the <filename>.act</filename> files.
				In particular, if you want to work on the grammar transforms
				and improve them you need to know &sid;'s
				internal representations 
				of grammars or at least know the interface to the internal 
				representation. You may not want to reverse engineer 
				this representation yourself.</para>
		</section>
	</preface>

	<chapter>
		<title>&sid;'s Organisation</title>

		<para>When you call &sid;, the main
			operations it performs are</para>

		<orderedlist>
			<listitem>
				<para>Reads the grammar <filename>.sid</filename>
					file and stores its internal representation.</para>
			</listitem>

			<listitem>
				<para>Reads the grammar output language specific .act file and complete the
					representation of the grammars with the action code.
					(After this step, &sid;
					only works on the internal representation.)</para>
			</listitem>

			<listitem>
				<para>Transforms and Optimises the Grammar. Most notably, it removes left
					recursion and tries to transform the context free grammar provided 
					in an equivalent LL(1) grammar.</para>
			</listitem>

			<listitem>
				<para>Outputs the parser.</para>
			</listitem>
		</orderedlist>

		<section>
			<title>The <code>main</code> Function</title>

			<para>Let's look at some parts of the code in main.c.
				In <code>main</code>, you can see <code>HANDLE</code> and 
				<code>WITH</code>: these are macros that emulate an exception
				mechanism in C. These come from <application>libexds</application>.</para>

			<para>The function <code>main</code> itself doesn't do much:
				it initializes some structures, calls <code>main_init</code>
				to process the command line options then calls <code>main_1</code>
				to do all the interesting work.
				Now look at the function
				<code>main_1</code>,  it calls in order (forgetting about
				all the initialisation stuff and the error handling stuff)</para>

			<variablelist>
				<varlistentry>
					<term><code>sid_parse_grammar()</code></term>

					<listitem>
						<para>parses the <filename>.sid</filename>
							file and converts it into
							an internal representation.</para>
					</listitem>
				</varlistentry>

				<varlistentry>
					<term><code>grammar_check_complete(&amp;grammar)</code></term>

					<listitem>
						<para>verifies that all rules are accessible.</para>
					</listitem>
				</varlistentry>

				<varlistentry>
					<term><code>(*(main_language->input_proc))(output_closure, &amp;grammar)</code></term>

					<listitem>
						<para>parses the action file and completes the internal representation
							of the grammar.</para>
					</listitem>
				</varlistentry>

				<varlistentry>
					<term><code>grammar_remove_left_recursion(&amp;grammar)</code></term>

					<listitem>
						<para>TODO</para>
					</listitem>
				</varlistentry>

				<varlistentry>
					<term><code>grammar_compute_first_set(&amp;grammar)</code></term>

					<listitem>
						<para>computes the first set of each rule in the grammar.</para>
					</listitem>
				</varlistentry>

				<varlistentry>
					<term><code>grammar_factor(&amp;grammar)</code></term>

					<listitem>
						<para>TODO</para>
					</listitem>
				</varlistentry>

				<varlistentry>
					<term><code>grammar_simplify(&amp;grammar)</code></term>

					<listitem>
						<para>TODO</para>
					</listitem>
				</varlistentry>

				<varlistentry>
					<term><code>grammar_compute_inlining(&amp;grammar)</code></term>

					<listitem>
						<para>TODO</para>
					</listitem>
				</varlistentry>

				<varlistentry>
					<term><code>grammar_check_collisions(&amp;grammar)</code></term>

					<listitem>
						<para>TODO</para>
					</listitem>
				</varlistentry>

				<varlistentry>
					<term><code>grammar_recompute_alt_names(&amp;grammar)</code></term>

					<listitem>
						<para>TODO</para>
					</listitem>
				</varlistentry>

				<varlistentry>
					<term><code>(*(main_language->output_proc))(output_closure, &amp;grammar)</code></term>

					<listitem>
						<para>outputs the parser in the chosen language.</para>
					</listitem>
				</varlistentry>
			</variablelist>

			<para>You may wonder what <code>main_language</code> is. We explain it in the
				next section.</para>
		</section>

		<section>
			<title>Adding a New Output Language: <code>main_language_list</code></title>

			<para>The global variable <code>main_language</code>
				allows us to easily modify the output language.
				It's a pointer to a structure called <code>LangListT</code>.
				This pointer will always point to an element in the
				table <code>main_language_list</code>, which contains callbacks
				for the various stages of processing.</para>

			<!-- TODO reword by name, not numerically -->
			<para>The first member indicates the option name. The second one
				is a pointer to the initialisation function. The third one
				contains a pointer to the top input routine for the action file.
				The fourth one is an integer indicating the number of
				input file (2 for outputting C, 1 for test). Then we have 
				the top output language specific output function and finally
				the number of outputted file. Don't remove the last line: it serves as a guard.
				To add a new output language, add a line to <code>main_language_list</code>
				and implement the new top level functions.</para>

			<!-- TODO explain that languages may have language-specific options -->
		</section>

		<section>
			<title>Code Organisation and Conventions</title>

			<para>If you read this guide, it is probably because
				you want to modify &sid;.
				In this section, we say
				how &sid;
				is organised and how one should modify the
				code to keep the code readable.</para>

			<para>&sid;
				defines many types for the internal representation of a grammar.
				These types are defined in the header files, begins with a
				majuscule and ends with T, e.g. <code>RuleT</code>. If a type, 
				<code>MytypeT</code> is declared in <filename>myfile.h</filename>,
				then any function 
				that directly touches the members of <code>MytypeT</code> begins
				with <code>mytype_</code> and is defined in <filename>file.c</filename>.
				No other 
				function should touch <code>MytypeT</code> directly. If you
				want to access an object of a certain type, do not
				access its members directly. Instead, use the interface
				declared in the header (the same header where the type is declared).</para>
				<!-- TODO when we generate API documentation, add link to it here -->
		</section>
	</chapter>

	<chapter>
		<title>The Internal Representation of a Grammar</title>

		<para>We present the internal representation in a top down 
			structure. Many functions are provided that hides 
			the implementation; all access to these structures is performed through
			their respective <acronym>API</acronym>s. Those interfaces are not
			documented here; rather, a brief functional tour of content is given
			instead.</para>

		<para>The implementation details behind the interfaces are documented in
			their respective datastructures; see the various header files for
			details per-field. Virtually all of these are stored in the adt
			directory.</para>

		<section>
			<title>The <code>GrammarT</code> Type and Structure</title>

			<para>&sid;
				stores grammars in a structure called <code>GrammarT</code>.</para>

			<para>It contains a <code>TableT</code> hash map containing elements of type
				<code>EntryT</code>. We'll talk about <code>EntryT</code> later. For the
				moment remember that an <code>EntryT</code> is a structure
				that can be used to store either an action, a rule, a type, 
				a terminal, or a nonlocal.</para>

			<para>Please note that in the code terminals are referred as basics in the
				code, probably for historical reasons.<!-- TODO so rename them --></para>
		</section>

		<!-- TODO maintain kevin's ordering of things as a tour of interesting types -->

		<section>
			<title>The <code>TableT</code> Type</title>

			<para>It holds most of the information about a grammar, rules, actions,
				terminals, non-local names, types and local names along 
				with their scopes. <!-- TODO Have to write somewhere that
				rules, actions may be scoped, non-locals must be scoped, 
				while types and terminals
				are never scoped and are always global.--></para>

			<para>Its definition is very simple, containing only a
				hash table of <code>EntryT</code>.</para>
		</section>

		<section>
			<title>Internal Representation of Actions</title>

			<para>Actions are stored in a <code>ActionT</code>. More exactly, they are
				stored in an <code>EntryT</code> whose union member is an <code>ActionT</code>.</para>
		</section>

		<section>
			<title>Internal Representation of Rules</title>

			<para>Look at an extremely simple &sid; rule:</para>

			<programlisting language="sid">basic-arithmetic = {
        number;plus;number;
    ||  number;minus;number;
};</programlisting>

			<para>It has two alternatives, each one holding three items.
				Alternatives have their special type: <code>AltT</code>.</para>

			<para>It also contains a list of <code>ItemT</code>. In our previous example,
				the list of items of the first alternate would be
				<code>number</code>, <code>plus</code> and <code>number</code>.</para>

			<para>An <code>ItemT</code>
				is therefore a rule, an action call, a terminal or TODO(rename, name)
				already declared in table.</para>

			<para>And now the <code>RuleT</code> type; this structure is very long.</para>
		</section>

		<section>
			<title>Internal Representation of Non-Locals</title>

			<para>A non-local is an <code>EntryT</code> whose type is <code>ET_NON_LOCAL</code>
				and whose member <code>u</code>
				is also an <code>EntryT*</code>: the target of this pointer
				is a type giving the type of the non-local. The <code>key</code>
				member is of course the name of the non-local but also contains 
				its scope. IE, non-locals are accessible to all rules
				contained in the rule for which the non-local is defined.
				The scope is indicated in the <code>key</code> string by 
				<code>outer-enclosing-rule::inner-enclosing-rule::name-of-non-local</code>.</para>
		</section>
	</chapter>

	<chapter>
		<title>The Representation of an Action Code</title>

		<para>This depends on the output language but as only C
			is supported at the moment, we'll describe how the body
			of an action is represented.</para>

		<section>
			<title>The <code>CCodeT</code> Type</title>

			<para>To represent the body of an action when the output language is
				C, &sid; uses the type <code>CCodeT</code></para>
		</section>
	</chapter>

	<chapter>
		<title>The Scope System</title>

		<para>The scope system is only used when reading the grammar definition
			file (the <filename>.sid</filename> file). The only
			trace of it once the scope system has 
			been deleted are the key members of the scoped rules and
			the always scope non-locals that begins with 
			<code>outer-enclosing-rule1::inner-enclosing-rule</code>.</para>
	</chapter>

	<chapter>
		<title><acronym>API</acronym> Organisation</title>

		<para>[TODO we'll automatically generate this using Puredocs]</para>

		<para>Most of the implementation is hidden to
			the user. One should only use the following
			functions to access everything.</para>

		<section>
			<title>Interface to TableT</title>

			<para>As a general rule, you add entries to a TableT
				by using the functions listed in <filename>adt/table.h</filename>.</para>
		</section>

		<section>
			<title>Interface to EntryT</title>

			<para>TODO</para>
		</section>

		<section>
			<title>Interface to RuleT</title>

			<para>TODO</para>
		</section>

		<section>
			<title>Interface to BasicT</title>

			<para>TODO</para>
		</section>

		<section>
			<title>Interface to ActionT</title>

			<para>TODO</para>
		</section>

		<section>
			<title>Interface to NonLocalT</title>

			<para>TODO</para>
		</section>

	</chapter>

</book>

