<?xml version="1.0" standalone="no"?>
<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd">

<!--
  $Id$
-->

<book>
  <bookinfo>
    <title>The <application><acronym>SID</acronym></application> Developers' Guide</title>

    <author>
      <firstname>Kevin</firstname>
      <!-- surname elided -->
      <affiliation><orgname>The TenDRA Project</orgname></affiliation>
    </author>

	<editor>
		<firstname>Katherine</firstname>
		<surname>Flavel</surname>
		<affiliation><orgname>The TenDRA Project</orgname></affiliation>
	</editor>

    <pubdate>2007</pubdate>

    <copyright>
      <year>2007</year>

      <holder>The TenDRA Project</holder>
    </copyright>

	<abstract>
		<para>In this documentation, we explain <application><acronym>SID</acronym></application>'s
			internal representation
			of grammars. It was reverse engineered from the code itself and 
			the accompanying comments. Most of the reverse engineering was done reading 
			<application><acronym>SID</acronym></application>'s own grammar file and most notably the actions in 
			the <filename>parser.act</filename> file. This document does not explain
			in detail how <application><acronym>SID</acronym></application>
			parses the <filename class="extension">sid</filename>
			and the <filename class="extension">act</filename> files.</para>
	</abstract>
  </bookinfo>

  <chapter id="introduction">
	<title>Introduction</title>

	<para><application><acronym>SID</acronym></application> is an LL(1) parser. It reads a grammar specification
		(documented in the <application><acronym>SID</acronym></application>
		users' guide) then outputs a parser.</para>

		<section>
			<title>Prerequisites</title>

			<para>Before reading this guide, you should have read the
			<application><acronym>SID</acronym></application> users' guide
				and be able to use <application><acronym>SID</acronym></application>
				to output a simple parser.</para>
		</section>

		<section>
			<title>Who Should Read This Document?</title>

			<para>Anyone interested in the post-processing steps
				<application><acronym>SID</acronym></application> does
				to a grammar after having parsed the <filename class="extension">sid</filename>
				and the <filename class="extension">act</filename> files.
				In particular, if you want to work on the grammar transforms
				and improve them you need to know <application><acronym>SID</acronym></application>'s
				internal representations 
				of grammars or at least know the interface to the internal 
				representation. You may not want to reverse engineer 
				this representation yourself.</para>
		</section>
	</chapter>

	<chapter>
		<title><application><acronym>SID</acronym></application>'s Organisation</title>

		<para>When you call <application><acronym>SID</acronym></application>, the main
			operations it performs are

			<orderedlist>
				<listitem>
					<para>Reads the grammar <filename class="extension">sid</filename>
						file and stores its internal representation.</para>
				</listitem>

				<listitem>
					<para>Reads the grammar output language specific .act file and complete the
						representation of the grammars with the action code.
						(After this step, <application><acronym>SID</acronym></application>
						only works on the internal representation.)</para>
				</listitem>

				<listitem>
					<para>Transforms and Optimises the Grammar. Most notably, it removes left
						recursion and tries to transform the context free grammar provided 
						in an equivalent LL(1) grammar.</para>
				</listitem>

				<listitem>
					<para>Outputs the parser.</para>
				</listitem>
			</orderedlist>
		</para>

		<section>
			<title>The <code>main</code> Function</title>

			<para>Let's look at some parts of the code in main.c.
				In <code>main</code>, you can see <code>HANDLE</code> and 
				<code>WITH</code>: these are macros that emulate an exception
				mechanism in C. 
				The function <code>main</code> itself doesn't do much:
				it initialise some structures, call <code>main_init</code>
				to process the command line options then calls <code>main_1</code>
				to do all the interesting work.
				Now look at the function
				<code>main_1</code>,  it calls in order (forgetting about
				all the initialisation stuff and the error handling stuff)</para>

			<variablelist>
				<varlistentry>
					<term><code>sid_parse_grammar()</code></term>

					<listitem>
						<para>parses the <filename class="extension">sid</filename>
							file and convert it in
							an internal representation.</para>
					</listitem>
				</varlistentry>

				<varlistentry>
					<term><code>grammar_check_complete(&amp;grammar)</code></term>

					<listitem>
						<para>verify that all rules are accessible.</para>
					</listitem>
				</varlistentry>

				<varlistentry>
					<term><code>(*(main_language->input_proc))(output_closure, &amp;grammar)</code></term>

					<listitem>
						<para>parses the action file and completes the internal representation
							of the grammar.</para>
					</listitem>
				</varlistentry>

				<varlistentry>
					<term><code>grammar_remove_left_recursion(&amp;grammar)</code></term>
				</varlistentry>

				<varlistentry>
					<term><code>grammar_compute_first_set(&amp;grammar)</code></term>

					<listitem>
						<para>computes the first set of each rule in the grammar.</para>
					</listitem>
				</varlistentry>

				<varlistentry>
					<term><code>grammar_factor(&amp;grammar)</code></term>
				</varlistentry>

				<varlistentry>
					<term><code>grammar_simplify(&amp;grammar)</code></term>
				</varlistentry>

				<varlistentry>
					<term><code>grammar_compute_inlining(&amp;grammar)</code></term>
				</varlistentry>

				<varlistentry>
					<term><code>grammar_check_collisions(&amp;grammar)</code></term>
				</varlistentry>

				<varlistentry>
					<term><code>grammar_recompute_alt_names(&amp;grammar)</code></term>
				</varlistentry>

				<varlistentry>
					<term><code>(*(main_language->output_proc))(output_closure, &amp;grammar)</code></term>

					<listitem>
						<para>outputs the parser in the chosen language.</para>
					</listitem>
				</varlistentry>

				<varlistentry>
					<term><code></code></term>
				</varlistentry>
			</variablelist>

			<para>You may wonder what <code>main_language</code> is. We explain it in the
				next section.</para>
		</section>

		<section>
			<title>Adding a New Output Language: <code>main_language_list</code></title>

			<para>The global variable <code>main_language</code>
				allows us to easily modify the output language. Right now only
				C is supported. It's a pointer to a structure
				called <code>LangListT</code>. This pointer will always
				point to an element in the table <code>main_language_list</code>:

				<programlisting language="C">static LangListT main_language_list[] = {
    {"ansi-c", main_init_ansi_c, main_input_c, 2, main_output_c, 2},
    {"pre-ansi-c", main_init_pre_ansi_c, main_input_c, 2, main_output_c, 2},
    {"iso-c", main_init_ansi_c, main_input_c, 2, main_output_c, 2},
    {"pre-iso-c", main_init_pre_ansi_c, main_input_c, 2, main_output_c, 2},
    {"test", main_init_test, main_input_test, 1, main_output_test, 0},
    {NULL, NULL, NULL, 0, NULL, 0}
};</programlisting>

				The first member indicates the option name. The second one
				is a pointer to the initialisation function. The third one
				contains a pointer to the top input routine for the action file.
				The fourth one is an integer indicating the number of
				input file (2 for outputting C, 1 for test). Then we have 
				the top output language specific output function and finally
				the number of outputted file. Don't remove the last line: it serves as a guard.
				To add a new output language, add a line to <code>main_language_list</code>
				and implement the new top level functions.</para>
		</section>

		<section>
			<title>Code Organisation and Conventions</title>

			<para>If you read this guide, it is probably because
				you want to modify <application><acronym>SID</acronym></application>.
				In this section, we say
				how <application><acronym>SID</acronym></application>
				is organised and how one should modify the
				code to keep the code readable.</para>

			<para><application><acronym>SID</acronym></application>
				defines many types for the internal representation of a grammar.
				These types are defined in the header files, begins with a
				majuscule and ends with T, e.g. <code>RuleT</code>. If a type, 
				<code>MytypeT</code> is declared in <filename>myfile.h</filename>,
				then any function 
				that directly touches the members of <code>MytypeT</code> begins
				with <code>mytype_</code> and is defined in <filename>file.c</filename>.
				No other 
				function should touch <code>MytypeT</code> directly. If you
				want to access an object of a certain type, do not
				access its members directly. Instead, use the interface
				declared in the header (the same header where the type is declared).</para>
				<!-- TODO when we generate API documentation, add link to it here -->
		</section>
	</chapter>

	<chapter>
		<title>The Internal Representation of a Grammar</title>

		<para>We present the internal representation in a top down 
			structure. Many functions are provided that hides 
			the implementation.</para>

		<section>
			<title>The <code>GrammarT</code> Type and Structure</title>

			<para><application><acronym>SID</acronym></application>
				stores grammars in a structure called <code>GrammarT</code>:

				<programlisting language="C">typedef struct GrammarT {
    TableT                      table;
    EntryListT                  entry_list;
    unsigned                    terminal;
    EntryT *                    predicate_type;
    EntryT *                    predicate_id;
} GrammarT;</programlisting>

				<variablelist>
					<varlistentry>
						<term><code>table</code></term>

						<listitem>
							<para>is the first and most important member.
								<code>table</code> holds the information about

								<itemizedlist>
									<listitem>
										<para>the types in the <code>%types%</code>
											section of the <filename class="extension">sid</filename>
											file.</para>
									</listitem>

									<listitem>
										<para>the terminals existing in the <code>%terminals%</code> section
											of the <filename class="extension">sid</filename> file.</para>
									</listitem>

									<listitem>
										<para>the rules defined in the <code>%productions%</code>
											section of <filename class="extension">sid</filename> file</para>
									</listitem>

									<listitem>
										<para>the actions declared in the <code>%production%</code>
											section of the <filename class="extension">sid</filename> file
											and defined in the <filename class="extension">act</filename>
											file.</para>
									</listitem>

									<listitem>
										<para>The local variables in a rule. This contains
											scope information</para>
									</listitem>

									<listitem>
										<para>the non locals variables<!-- TODO reread code as I
											forgot everything about them). --></para>
									</listitem>
								</itemizedlist>
							</para>

							<para>A <code>TableT</code> is a hash map containing elements of type 
								<code>EntryT</code>. We'll talk
								about <code>EntryT</code> later. For the moment remember that an 
								<code>EntryT</code> is a structure
								that can be used to store either an action, a rule, a type, 
								a terminal, or a nonlocal.</para>
						</listitem>
					</varlistentry>

					<varlistentry>
						<term><code>entry_list</code></term>

						<listitem>
							<para>holds the starting
  								points (yes, it's plural) of the grammar.</para>
						</listitem>
					</varlistentry>

					<varlistentry>
						<term><code>terminal</code></term>

						<listitem>
							<para>holds the number of terminals.
								Terminals are numbered from <code>0</code> to
								<code>grammar-&gt;terminal - 1</code>.  The value of
								<code>GrammarT.terminal</code>
								is primarily (only?) used while parsing the
								<filename class="extension">sid</filename> file to tell 
								each new constructed terminal which number it should hold.
								See the <code>BasicT</code> type.</para>
						</listitem>
					</varlistentry>

					<varlistentry>
						<term><code>predicate_type</code></term>

						<listitem>
							<para>holds a pointer to 
								an <code>EntryT</code> preexisting in <code>table</code>. This  
								<code>EntryT</code> indicates the boolean type. 
								There can only be one boolean type. It is set
								when <application><acronym>SID</acronym></application> first encounters
								a predicate function.</para>
						</listitem>
					</varlistentry>

					<varlistentry>
						<term><code>predicate_id</code></term>

						<listitem>
							<para>points to an automatically generated 
								entry in table. You may skip the explanation for the moment
								as it is not primordial to know what it is used for.
								It is used to internally represents the predicate 
								indicator <code>?</code> in a left hand side name
								tuple in the <filename class="extension">sid</filename> grammar file. 
								E.g.  in a <filename class="extension">sid</filename> file

								<programlisting language="SID Grammar">    a=&lt;non-predicate&gt;
    ?=&lt;predicate-function&gt;</programlisting>

								There must be a representation of <code>a</code> and  
								<code>?</code>.  <code>a</code> is a local or non-local name
								represented by an <code>EntryT</code> in <code>table</code>, 
								and <code>?</code> must also have an <code>EntryT</code>
								in <code>table</code>. This <code>EntryT</code>
								is pointed by <code>predicate_id</code>.</para>
						</listitem>
					</varlistentry>
				</variablelist>
			</para>

			<para>Please note that in the code terminals are referred as basics in the
				code, probably for historical reasons.<!-- TODO so rename them --></para>
		</section>

		<section>
			<title>The <code>TableT</code> Type</title>

			<para>It holds most of the information about a grammar, rules, actions,
				terminals, non-local names, types and local names along 
				with their scopes. <!-- TODO Have to write somewhere that
				rules, actions may be scoped, non-locals must be scoped, 
				while types and terminals
				are never scoped and are always global.--></para>

			<para>Its definition is very simple

				<programlisting language="C">typedef struct TableT {
    EntryT *                    contents[TABLE_SIZE];
} TableT;</programlisting>

				This is a hash table of <code>EntryT</code>. <code>TABLE_SIZE</code>
				is currently 127.</para>

			<section>
				<title>The <code>EntryT</code> Type</title>

				<para>An <code>EntryT</code> is a structure designed to go in a hash map that contains
					one of the following: a rule, a type, an action, 
					a terminal, a non-local, a local or base name, or a rename instruction.
					In the two latter case the <code>EntryT</code> contains almost 
					no information in itself.
					It is defined as

					<programlisting language="C">typedef struct EntryT {
    struct EntryT              *next; 
    KeyT                        key; 
    BoolT                       mapped;
    NStringT                    mapping;
    EntryTypeT                  type; 
    BoolT                       traced;
    union {
        struct BasicT          *basic;
        struct RuleT           *rule;
        struct ActionT         *action;
        struct TypeT           *type;
        struct EntryT          *non_local;
    } u;
    struct NameT               *name;
} EntryT;</programlisting></para>

				<variablelist>
					<varlistentry>
						<term><code>next</code></term>

						<listitem>
							<para>contains a pointer to the next EntryT
								in the table. It is <code>NULL</code> if there are no next entry. 
								By <quote>next</quote>, we mean that if two or more 
								<code>EntryT</code> share the same hash
								then they are stored as a singly linked list, so it is next in the
								sense of the hash table.</para>
						</listitem>
					</varlistentry>

					<varlistentry>
						<term><code>key</code></term>

						<listitem>
							<para>contains either
								a string (the name of a rule, action, type or terminal) 
								or a number (the number of an anonymous rule e.g.). 
								Rules may be scoped: <code>key</code> begins with <code>scope::</code>.
								Non-locals must be scoped.</para>
						</listitem>
					</varlistentry>

					<varlistentry>
						<term><code>mapped</code></term>

						<listitem>
							<para>is a boolean 
								that is set to true if this entry is mapped in the <code>%maps%</code>
								section of the .act file. It is only valid
								for types, terminals and rules.</para>
						</listitem>
					</varlistentry>

					<varlistentry>
						<term><code>mapping</code></term>

						<listitem>
							<para>contains the value of
								the C identifier to which the entry must be mapped in the outputted code.
								It corresponds to the value found in the <code>%maps%</code> sections of the 
								<filename class="extension">act</filename> file.</para>
						</listitem>
					</varlistentry>

					<varlistentry>
						<term><code>type</code></term>

						<listitem>
							<para>is of type <code>EntryTypeT</code>
								which is an enum:

								<programlisting language="C">typedef enum { ET_TYPE, ET_BASIC, ET_RULE, ET_ACTION, ET_NAME,
  ET_RENAME, ET_PREDICATE, ET_NON_LOCAL } EntryTypeT;</programlisting>

								Member <code>type</code> holds the type to which the pointer
								stored in the sixth member refers. 
								<code>ET_TYPE</code>, <code>ET_BASIC</code>, <code>ET_RULE</code>,
								<code>ET_ACTION</code> and <code>ET_NON_LOCAL</code> are self explanatory.
								Value <code>ET_PREDICATE</code> is an invalid value for an
								<code>EntryT</code>.</para>

							<para>Value <code>ET_RENAME</code> indicates an identity in the
								<filename class="extension">sid</filename> file, 
								e.g. <code>(a,b)=(c,d)</code>: we'll talk about it later
								when we explain the <code>ItemT</code> type.</para>

							<para>Value <code>ET_NAME</code>
								only indicates a local name that has been declared somewhere
								with <code>key</code> containing the name of the local name.
								They may indicate something else: a scoped rule, scoped action
								or scoped non-local (the latters are always scoped)
								have their base name (without the scope) declare as an
								<code>ET_NAME</code> in <code>table</code>. Whether the local name is 
								used in a rule or in an identity is stored in the rule.
								is stored in the rule itself (more exactly in each alternate of the
								rule). As we can see an <code>EntryT</code>s with values <code>ET_NAME</code>
								or <code>ET_RENAME</code> contain very few information in themselves: nothing
								for <code>ET_RENAME</code>, only the name of the local variable (or of a
								rule, action, non-local base name) in <code>ET_NAME</code>.</para>
						</listitem>
					</varlistentry>

					<varlistentry>
						<term><code>traced</code></term>

						<para>serves to iterates on entries.
							It marks the entries from which we have already decided to iterate on the 
							child to avoid infinite recursion. For example, beginning with the
							starting points (entry points)
							of the grammar, we can iterate on all the called rules and
							verify that there are no unused rule by checking that all rules
							have been traced. This is done by <code>grammar_check_complete</code>
							in grammar.c.  Just after <application><acronym>SID</acronym></application>
							has parsed the <filename class="extension">sid</filename> file, all
							<code>traced</code> are set to false. To use <code>traced</code>, you must
							first untrace everything. This is done with the
							function <code>table_untrace (TableT*)</code>. To see how 
							<code>traced</code> can be used, just grep for <code>table_untrace</code>.</para>
					</varlistentry>

					<varlistentry>
						<term><code>u</code></term>

						<para><code>u</code> is an anonymous union holding a pointer 
							to either an action, a rule, a basic (a terminal), a type
							or a non local variable as indicated by <code>type</code>.</para>
					</varlistentry>

					<varlistentry>
						<term><code>name</code></term>

						<para>is of type NameT which is defined in name.h as

							<programlisting language="C">typedef struct NameT {
    BoolT                       clash;
    BoolT                       used;
    BoolT                       labelled;
    unsigned                    label;
} NameT;</programlisting>

							<remark>I haven't succeeded yet in understanding what
								<code>NameT</code> is used for but it is only used in
								c-code.c and types.c.</remark></para>
					</varlistentry>
				</variablelist>
			</section>

			<section>
				<title>Internal Representation of Actions</title>

				<para>Actions are stored in a <code>ActionT</code>. More exactly, they are
					stored in an <code>EntryT</code> whose union member is an <code>ActionT</code>.

					<programlisting language="C">typedef struct ActionT {
    TypeTupleT                  param;
    TypeTupleT                  result;
    void *                      code;
} ActionT;</programlisting>

					The first and second members: <code>param</code> and <code>result</code>
					hold respectively the input parameters and output parameters 
					of the action. A <code>TypeTupleT</code> is a structure 
					containing a list of pairs of (name,type). 
					The third member code contains the body of the action.
					The type of <code>code</code> is a <code>void *</code> that hides
					the true type: it depends on the output language specific type for
					code.</para>
			</section>
		</section>

		<section>
			<title>Internal Representations of Types</title>

			<para>Types are stored in an <code>EntryT</code> whose anonymous
				union holds a <code>TypeT</code>

				<programlisting language="C">typedef struct TypeT {
    void *                      assign_code;
    void *                      param_assign_code;
    void *                      result_assign_code;
} TypeT;</programlisting>

				This type contains the assignment code
				defined in the <code>%assignment%</code>, <code>%param-assignment%</code>
				and <code>%result-assignment%</code> section of the action file.
				The exact type should depend on the output language, e.g. for
				C, the <code>void *</code> will be cast to a <code>CCodeT *</code>.</para>

			<section>
				<title>Internal Representation of Terminals</title>

				<para>A terminal is represented by a <code>BasicT</code>.
					The term basic used to refer to terminals
					in previous versions of <application><acronym>SID</acronym></application>.

					<programlisting language="C">typedef struct BasicT {
    unsigned                    terminal;
    TypeTupleT                  result;
    void *                      result_code;
    BoolT                       ignored;
} BasicT;</programlisting>

					The first member <code>terminal</code> is an unsigned integer
					that is used to generate the token definition 
					when outputting the parser. The second member <code>result</code>
					contains the tuple of types e.g. for a terminal declared by, 

					<programlisting language="C"> identifier : () -&gt; (:StringT);</programlisting>

					result contains a tuple of one element that indicates
					the only result is a <code>StringT</code>. The third member,
					<code>result_code</code> contains the code given in the 
					<code>%terminals%</code> extraction section of the action information file (the
					.act file). This is stored as a <code>void *</code> because the true
					type will depend on the output language used.
					The boolean <code>ignored</code> indicates if the terminal
					is ignored or not, i.e. declared with a preceding <code>!</code>
					in the grammar information file (the <filename class="extension">sid</filename>
					file).</para>
			</section>

			<section>
				<title>Internal Representation of Rules</title>

				<para>Look at an extremely simple <application><acronym>SID</acronym></application> rule:

					<programlisting language="SID Grammar">basic-arithmetic = {
        number;plus;number;
    ||  number;minus;number;
};</programlisting>

					It has two alternatives, each one holding three items.
					Alternatives have their special type: <code>AltT</code>.
					Let's look at its implementation

					<programlisting language="C">typedef struct AltT {
    struct AltT                *next;
    TypeTupleT                  names;
    BitVecT                     first_set;
    ItemT *                     item_head;
    ItemT *                    *item_tail;
} AltT;</programlisting>

					The rule type <code>RuleT</code> must contain a list of alternatives.
					Therefore <code>next</code> refers to the next alternate in the list
					held by a <code>RuleT</code>.
					It also contains a list of <code>ItemT</code>. In our previous example,
					the list of items of the first alternate would be
					<code>number</code>, <code>plus</code> and <code>number</code>. An <code>ItemT</code>
					is therefore a rule, an action call, a terminal or TODO(rename, name)
					already declared in table. The other members are <code>names</code>
					which contains a list of all local variables 
					that appears as a left hand side in an item of the alternate
					including (I'm not sure but I believe) the non locals (if they appear
					on the left hand side of an identity).</para>

				<para>Let's look at the <code>ItemT</code> definition

					<programlisting language="C">typedef struct ItemT {
    struct ItemT               *next;
    TypeTupleT                  param;
    TypeTupleT                  result;
    EntryTypeT                  type;
    EntryT *                    entry;
    BoolT                       inlinable;
    BoolT                       tail_call;
} ItemT;</programlisting>

					It contains a pointer <code>next</code> to the next item in the list
					held by an alternate, tuples of types containing 
					the list of input (<code>param</code>) and output parameters
					(<code>result</code>). 
					An <code>EntryTypeT</code> and an <code>EntryT*</code> pointing to the 
					<code>ItemT</code> definition
					(terminal, rule, action, identity ) already declared and stored 
					in the hash map <code>table</code>. If the item is just an identity,
					then <code>*entry-&gt;type</code> is <code>ET_RENAME</code> and <code>*entry</code>
					contains no other useful information<footnote>I cannot guarantee this
					but this is what I deduced from reading and greping the code</footnote>.
					<!-- TODO Explain inlinable, tail_call and type -->.</para>

				<para>And now the <code>RuleT</code> type:

					<programlisting language="C">typedef struct RuleT {
    EntryT *                    entry;
    TypeTupleT                  param;
    TypeTupleT                  result;
    NonLocalListT               non_locals;
    NStringT                    maximum_scope;
    BoolT                       defined;
    BoolT                       has_empty_alt;
    BoolT                       required;
    EntryListT                  reverse_list;
    DFSStateT                   dfs_state;
    struct RuleT               *next_in_root_list;
    struct RuleT               *next_in_dfs;
    struct RuleT               *next_in_reverse_dfs;
    BoolT                       no_cycles;
    unsigned                    cycle_index;
    BoolT                       computed_first_set;
    BoolT                       computing_first_set;
    BitVecT                     first_set;
    EntryListT                  predicate_first;
    BoolT                       see_through;
    unsigned                    priority;
    BoolT                       factored;
    struct RuleT               *tail_group;
    BoolT                       being_inlined;
    BoolT                       checked_for_inlining;
    EntryListT                  call_list;
    struct RuleT               *next_in_table;
    BitVecT                     follow_set;
    EntryListT                  predicate_follow;
    BoolT                       started_follows;
    AltT *                      see_through_alt;
    BoolT                       needs_function;
    BoolT                       all_basics;
    SaveRStackT                 rstack_state;
    SaveRStackT                 non_local_state;
    BoolT                       being_output;
    unsigned                    start_label;
    unsigned                    call_count;
    unsigned                    end_label;
    BoolT                       used_end_label;
    unsigned                    next_label;
    unsigned                    handler_label;
    BoolT                       used_handler_label;
    AltT *                      handler;
    AltT *                      alt_head;
    AltT *                     *alt_tail;
} RuleT;</programlisting>

					The structure is very long.</para>

				<variablelist>
					<varlistentry>
						<term><code>entry</code></term>

						<listitem>
							<para>points to the <code>EntryT</code> in the
								hash table that hold the <code>RuleT</code>.
								<remark>I don't know why <code>entry</code> is necessary</remark>
							</para>
						</listitem>
					</varlistentry>

					<varlistentry>
						<term><code>alt_head, alt_tail</code></term>

						<listitem>
							<para>holds the list of the alternatives except
								the empty alternate (epsilon rule)
								marked as <code>$;</code> in the <filename class="extension">sid</filename>
								file.</para>
						</listitem>
					</varlistentry>

					<varlistentry>
						<term><code>has_empty_alt</code></term>

						<listitem>
							<para>is set to true if the rule has an empty alternate.</para>
						</listitem>
					</varlistentry>

					<varlistentry>
						<term><code>alt_handler</code></term>

						<listitem>
							<para>points to the exception handler alternate. There can only be one 
								for each rule and corresponds to the alternate
								one can find after <code>##</code>.</para>
						</listitem>
					</varlistentry>

					<varlistentry>
						<term><code>param</code></term>
						<term><code>result</code></term>

						<listitem>
							<para>hold respectively the type specification of the input and 
								output parameters of a rule.</para>
						</listitem>
					</varlistentry>

					<varlistentry>
						<term><code>defined</code></term>

						<listitem>
							<para>is set to true is the rule has been defined, to
								false if it hasn't been defined
								yet. This is necessary to verify that all declared
								rules have been defined.</para>
						</listitem>
					</varlistentry>

					<varlistentry>
						<term><code>required</code></term>

						<listitem>
							<para>This boolean is set to true for all
								rule in the <code>%entry%</code> section
								of the <filename class="extension">sid</filename>
								file. It is used only in <filename>rule-simp.c</filename>. 
								Surprisingly, this is not used to check that all rules 
								are accessible.<!-- TODO so we should? --></para>
						</listitem>
					</varlistentry>

					<varlistentry>
						<term><code>first_set</code></term>

						<listitem>
							<para>This is a bitfield designed to contain
								what terminals are part of the first set of the rule.
								For a description of what the first set is, you may 
								want to read a book on LL(1) parsing. Please note that after parsing,
								the first set has not been computed yet. In the program,
								the computation is done at the top level by 
								<code>grammar_compute_first_set</code>.</para>
						</listitem>
					</varlistentry>

					<varlistentry>
						<term><code>computed_first_set</code></term>

						<listitem>
							<para>indicates if the first set has already
								been computed.</para>
						</listitem>
					</varlistentry>

					<varlistentry>
						<term><code>computing_first_set</code></term>

						<listitem>
							<para>indicates that we are currently computing
								the first set. It is currently not set back to false once the
								computation has terminated.</para>
						</listitem>
					</varlistentry>

					<varlistentry>
						<term><code>non-locals</code></term>

						<listitem>
							<para>is a type tuple  of all the non-locals
								declared in the rule. It does not include the non-locals
								declared in an enclosing rules<footnote>This should be checked 
								once again</footnote>.</para>
						</listitem>
					</varlistentry>
				</variablelist>
			</section>

			<section>
				<title>Internal Representation of Non-Locals</title>

				<para>A non-local is an <code>EntryT</code> whose type is <code>ET_NON_LOCAL</code>
					and whose member <code>u</code>
					is also an <code>EntryT*</code>: the target of this pointer
					is a type giving the type of the non-local. The <code>key</code>
					member is of course the name of the non-local but also contains 
					its scope. IE, non-locals are accessible to all rules
					contained in the rule for which the non-local is defined.
					The scope is indicated in the <code>key</code> string by 
					<code>outer-enclosing-rule::inner-enclosing-rule::name-of-non-local</code>.</para>
			</section>
		</section>

		<section>
			<title>The Representation of an Action Code</title>

			<para>This depends on the output language but as only C
				is supported at the moment, we'll describe how the body
				of an action is represented.</para>
		</section>

		<section>
			<title>The <code>CCodeT</code> Type</title>

			<para>To represent the body of an action when the output language is
				C, <application><acronym>SID</acronym></application> uses the type <code>CCodeT</code></para>

		<programlisting language="C">typedef enum {
    CCT_STRING,
    CCT_LABEL,
    CCT_IDENT,
    CCT_MOD_IDENT,
    CCT_REF_IDENT,
    CCT_EXCEPTION,
    CCT_ADVANCE,
    CCT_TERMINAL
} CCodeItemTypeT;

typedef struct CCodeItemT {
    struct CCodeItemT	       *next;
    CCodeItemTypeT		type;
    union {
	NStringT		string;
	EntryT *			ident;
    } u;
} CCodeItemT;

typedef struct CCodeT {
    CCodeItemT *			head;
    CCodeItemT *		       *tail;
    unsigned			line;
    char *			file;
    TypeTupleT			param;
    TypeTupleT			result;
} CCodeT;</programlisting>
		</section>
	</chapter>

	<chapter>
		<title>The Scope System</title>

		<para>The scope system is only used when reading the grammar definition
			file (the <filename class="extension">sid</filename> file). The only
			trace of it once the scope system has 
			been deleted are the key members of the scoped rules and
			the always scope non-locals that begins with 
			<code>outer-enclosing-rule1::inner-enclosing-rule</code>.</para>
	</chapter>

<!--
TODO we'll automatically generate this using Puredocs
	<appendix>
		<title>Interface list</title>

		<para>
Most of the implementation is hidden to
the user. One could only use the following 
functions to access everything.
\marginpar{This might be unecessary, people can 
read the header files themselves}
		</para>

		<section>
			<title>Interface to TableT</title>
As a general rule, you add entries to a TableT
by using the functions listed in ``adt/table.h''.
		<programlisting language="C">void     table_init(TableT *);
EntryT * table_add_type(TableT *, NStringT *);
EntryT * table_add_basic(TableT *, NStringT *, struct GrammarT *, BoolT);
EntryT * table_add_action(TableT *, NStringT *);
EntryT * table_add_rule(TableT *, NStringT *);
EntryT * table_add_generated_rule(TableT *, BoolT);
EntryT * table_add_name(TableT *, NStringT *);
EntryT * table_add_generated_name(TableT *);
EntryT * table_add_rename(TableT *);
EntryT * table_add_non_local(TableT *, NStringT *, EntryT *);
EntryT * table_get_entry(TableT *, NStringT *);
EntryT * table_get_type(TableT *, NStringT *);
EntryT * table_get_basic(TableT *, NStringT *);
EntryT * table_get_basic_by_number(TableT *, unsigned);
EntryT * table_get_action(TableT *, NStringT *);
EntryT * table_get_rule(TableT *, NStringT *);
void     table_iter(TableT *, void(*)(EntryT *, void *), void *);
void     table_untrace(TableT *);
void     table_unlink_untraced_rules(TableT *);</programlisting>
		</section>

		<section>
			<title>Interface to EntryT</title>
		</section>

		<section>
			<title>Interface to RuleT</title>
		<programlisting language="C">RuleT *		rule_create(EntryT *);
void		rule_reinit(RuleT *);
EntryT *	rule_entry(RuleT *);
TypeTupleT *	rule_param(RuleT *);
TypeTupleT *	rule_result(RuleT *);
NonLocalListT *	rule_non_locals(RuleT *);
NStringT *	rule_maximum_scope(RuleT *);
BoolT		rule_is_defined(RuleT *);
void		rule_defined(RuleT *);
void		rule_add_alt(RuleT *, AltT *);
BoolT		rule_has_empty_alt(RuleT *);
void		rule_add_empty_alt(RuleT *);
BoolT		rule_has_one_alt(RuleT *);
void		rule_compute_result_intersect(RuleT *);
void		rule_compute_minimal_dataflow(RuleT *, TypeTupleT *);
BoolT		rule_is_required(RuleT *);
void		rule_required(RuleT *);
void		rule_compute_reverse_list(RuleT *, CycleTypeT);
void		rule_reinit_reverse_list(RuleT *);
EntryListT *	rule_reverse_list(RuleT *);
void		rule_set_dfs_state(RuleT *, DFSStateT);
RuleT *		rule_next_in_root_list(RuleT *);
void		rule_build_root_list(EntryT *, void *);
RuleT *		rule_get_next_in_dfs(RuleT *);
void		rule_compute_dfs(RuleT *, CycleTypeT, RuleT * *);
RuleT *		rule_get_next_in_reverse_dfs(RuleT *);
RuleT *	       *rule_next_in_reverse_dfs_ref(RuleT *);
void		rule_compute_reverse_dfs(RuleT *, RuleT *, RuleT * *);
BoolT		rule_has_no_cycles(RuleT *);
void		rule_no_cycles(RuleT *);
unsigned	rule_get_cycle_index(RuleT *);
void		rule_set_cycle_index(RuleT *, unsigned);
void		rule_reset_cycle_index(RuleT *);
BoolT		rule_has_computed_first_set(RuleT *);
void		rule_computed_first_set(RuleT *);
BoolT		rule_is_computing_first_set(RuleT *);
void		rule_computing_first_set(RuleT *);
BitVecT *		rule_first_set(RuleT *);
EntryListT *	rule_predicate_first(RuleT *);
BoolT		rule_is_see_through(RuleT *);
void		rule_see_through(RuleT *);
unsigned	rule_get_priority(RuleT *);
void		rule_set_priority(RuleT *, unsigned);
BoolT		rule_is_factored(RuleT *);
void		rule_factored(RuleT *);
RuleT *		rule_get_tail_group(RuleT *);
void		rule_set_tail_group(RuleT *, RuleT *);
BoolT		rule_is_being_inlined(RuleT *);
void		rule_being_inlined(RuleT *);
BoolT		rule_is_checked_for_inlining(RuleT *);
void		rule_checked_for_inlining(RuleT *);
EntryListT *	rule_call_list(RuleT *);
RuleT *		rule_get_next_in_table(RuleT *);
RuleT *	       *rule_get_next_in_table_ref(RuleT *);
void		rule_set_next_in_table(RuleT *, RuleT *);
BitVecT *	rule_follow_set(RuleT *);
EntryListT *	rule_predicate_follow(RuleT *);
BoolT		rule_has_started_follows(RuleT *);
void		rule_started_follows(RuleT *);
void		rule_set_see_through_alt(RuleT *, AltT *);
AltT *		rule_see_through_alt(RuleT *);
BoolT		rule_needs_function(RuleT *);
void		rule_will_need_function(RuleT *);
BoolT		rule_is_all_basics(RuleT *);
void		rule_all_basics(RuleT *);
SaveRStackT *	rule_rstack_state(RuleT *);
SaveRStackT *	rule_non_local_state(RuleT *);
BoolT		rule_is_being_output(RuleT *);
void		rule_being_output(RuleT *);
void		rule_not_being_output(RuleT *);
unsigned	rule_get_start_label(RuleT *);
void		rule_set_start_label(RuleT *, unsigned);
unsigned	rule_get_call_count(RuleT *);
void		rule_inc_call_count(RuleT *);
unsigned	rule_get_end_label(RuleT *);
void		rule_set_end_label(RuleT *, unsigned);
BoolT		rule_used_end_label(RuleT *);
unsigned	rule_get_next_label(RuleT *);
void		rule_set_next_label(RuleT *, unsigned);
unsigned	rule_get_handler_label(RuleT *);
void		rule_set_handler_label(RuleT *, unsigned);
BoolT		rule_used_handler_label(RuleT *);
AltT *		rule_get_handler(RuleT *);
void		rule_set_handler(RuleT *, AltT *);
AltT *		rule_alt_head(RuleT *);
void		rule_renumber(RuleT *, BoolT, EntryT *);
void		rule_iter_for_table(RuleT *, BoolT,
					    void(*)(EntryT *, void *),
					    void *);
void		rule_deallocate(RuleT *);

void		write_rule_lhs(OStreamT *, RuleT *);
void		write_rule(OStreamT *, RuleT *);

void		rule_list_init(RuleListT *);
void		rule_list_append (RuleListT *, RuleT *, RuleT * *);
void		rule_list_terminate(RuleListT *);
RuleT *		rule_list_head(RuleListT *);</programlisting>
		</section>

		<section>
			<title>Interface to BasicT</title>
		</section>

		<section>
			<title>Interface to ActionT</title>
		</section>

		<section>
			<title>Interface to NonLocalT</title>
		</section>
	</appendix>
-->
</book>

